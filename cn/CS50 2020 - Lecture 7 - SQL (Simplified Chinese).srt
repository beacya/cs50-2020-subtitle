1
00:00:00,000 --> 00:00:03,492
[音乐响起--字幕精校中--By Persisan]
[MUSIC PLAYING]

2
00:00:49,356 --> 00:00:50,439
DAVID J. MALAN：好的。
DAVID J. MALAN: All right.

3
00:00:50,439 --> 00:00:53,259
这是CS50，这是第7周。
This is CS50, and this is week 7.

4
00:00:53,259 --> 00:00:56,206
而今天的焦点将完全集中在数据上
And today's focus is going to be entirely on data--

5
00:00:56,207 --> 00:00:58,540
收集过程，存储过程，
the process of collecting it, the process of storing it,

6
00:00:58,539 --> 00:01:00,609
搜索过程等等。
the process of searching it, and so much more.

7
00:01:00,609 --> 00:01:03,279
您会记得，上周我们开始玩耍
You'll recall that last week we started off by playing around

8
00:01:03,280 --> 00:01:04,750
相对较小的数据集。
with the relatively small data set.

9
00:01:04,750 --> 00:01:08,629
我们询问了每个人在霍格沃茨的偏爱之屋可能是什么。
We asked everyone for what their preferred house at Hogwarts might be.

10
00:01:08,629 --> 00:01:12,399
然后我们继续使用一些Python分析该数据
And then we proceeded to analyze that data a little bit using some Python

11
00:01:12,400 --> 00:01:15,730
算出有多少人想要格兰芬多，斯莱特林或其他人，
and counting up how many people wanted Gryffindor or Slytherin or the others,

12
00:01:15,730 --> 00:01:16,423
也一样
as well.

13
00:01:16,423 --> 00:01:19,090
最终，我们通过使用Google表单进行了收集。
And we ultimately did that by using a Google form to collect it.

14
00:01:19,090 --> 00:01:21,923
然后我们将所有数据存储在Google电子表格中，然后
And we stored all of the data in a Google spreadsheet, which we then

15
00:01:21,923 --> 00:01:24,350
导出为CSV文件。
exported, of course, as a CSV file.

16
00:01:24,349 --> 00:01:26,739
因此，本周，我们认为我们将收集更多数据
So this week, we thought we'd collect a little more data

17
00:01:26,739 --> 00:01:28,779
看看什么时候出现什么问题
and see what kinds of problems arise when

18
00:01:28,780 --> 00:01:32,350
我们开始仅使用电子表格或CSV文件
we start using only a spreadsheet or, in turn, a CSV file

19
00:01:32,349 --> 00:01:34,219
存储我们关心的数据。
to store the data that we care about.

20
00:01:34,219 --> 00:01:37,929
因此，事实上，如果您可以继续浏览此网址，您会看到，
So in fact, if you could go ahead and go to this URL here that you see,

21
00:01:37,930 --> 00:01:41,230
您应该会看到另一张Google表单，该表单会询问您
you should see another Google form, this one asking you

22
00:01:41,230 --> 00:01:42,730
一些不同的问题。
some different questions.

23
00:01:42,730 --> 00:01:46,540
现在，我们所有人可能比以往任何时候都拥有一些喜欢的电视节目。
All of us probably have some preferred TV shows, now more than ever, perhaps.

24
00:01:46,540 --> 00:01:49,150
我们想做的就是请大家输入
And what we'd like to do is ask everyone to input

25
00:01:49,150 --> 00:01:53,590
变成他们最喜欢的电视节目，然后是流派
into that form their favorite TV show followed by the genre

26
00:01:53,590 --> 00:01:58,190
或特定电视节目所属的流派。
or genres into which that particular TV show falls.

27
00:01:58,189 --> 00:02:00,679
因此，花点时间来做。
So go ahead and take a moment to do that.

28
00:02:00,680 --> 00:02:03,820
如果您无法在家中跟随，人们正在看什么
And if you're unable to follow along at home, what folks are looking at

29
00:02:03,819 --> 00:02:07,359
是一种很像这里的表格，我们只是问他们
is a form quite like this one here, whereby we're just asking them

30
00:02:07,359 --> 00:02:11,349
他们喜欢的电视节目的标题和类型
for the title of their preferred TV show and the genre

31
00:02:11,349 --> 00:02:15,769
或特定电视节目的类型。
or genres of that specific TV show.

32
00:02:15,770 --> 00:02:16,270
好的。
All right.

33
00:02:16,270 --> 00:02:19,270
因此，让我们继续来看一下其中的一些数据。
So let's go ahead and start to look at some of this data that's come in.

34
00:02:19,270 --> 00:02:23,043
这是Google表单为我们创建的结果Google电子表格。
Here is the resulting Google spreadsheet that Google Forms has created for us.

35
00:02:23,043 --> 00:02:25,960
而且您会注意到，默认情况下，Google表单，此特定工具，
And you'll notice that by default, Google Forms, this particular tool,

36
00:02:25,960 --> 00:02:28,180
至少在此表单中具有三个不同的列。
has three different columns, at least for this form.

37
00:02:28,180 --> 00:02:30,070
一个是时间戳记，Google会自动
One is a timestamp, and Google automatically

38
00:02:30,069 --> 00:02:33,339
根据每个人在哪个日期和时间嗡嗡作响，向我们提供信息
gives us that based on what day and time everyone was buzzing in

39
00:02:33,340 --> 00:02:34,390
与回应。
with the responses.

40
00:02:34,389 --> 00:02:38,769
然后，他们的标题行超出了标题和流派。
Then they have a header row beyond that for title and genres.

41
00:02:38,770 --> 00:02:42,100
为了使它脱颖而出，我已经对其进行了手动粗体标记。
I've manually boldfaced it in advance just to make it stand out.

42
00:02:42,099 --> 00:02:45,579
但您会注意到这里的标题，标题和流派，
But you'll notice that the headings here, Title and Genres,

43
00:02:45,580 --> 00:02:48,790
与我们在Google表单中提出的问题完全匹配。
perfectly matches the question that we asked in the Google form.

44
00:02:48,789 --> 00:02:53,019
因此，我们可以将您的回答与我们的问题保持一致。
That allows us to therefore line up your responses with our questions.

45
00:02:53,020 --> 00:02:56,410
您可以在这里看到Punisher是第一部最喜欢的电视
And you can see here Punisher was the first favorite TV

46
00:02:56,409 --> 00:03:00,039
待输入的节目，接着是The Office，Breaking Bad，New Girl，Archer，
show to be inputted followed by The Office, Breaking Bad, New Girl, Archer,

47
00:03:00,039 --> 00:03:02,269
另一个办公室，依此类推。
another Office, and so forth.

48
00:03:02,270 --> 00:03:04,660
在第三栏的“类型”下，您将
And in the third column, under Genres, you'll

49
00:03:04,659 --> 00:03:06,519
看到这里有些奇怪。
see that there's something curious here.

50
00:03:06,520 --> 00:03:08,230
虽然某些单元格-
While some of the cells--

51
00:03:08,229 --> 00:03:10,329
也就是说，一小盒文字-
that is, the little boxes of text--

52
00:03:10,330 --> 00:03:12,970
只有一个单词，例如“喜剧”或“戏剧”，
have just single words like "comedy" or "drama,"

53
00:03:12,969 --> 00:03:15,549
您会注意到其中有些列表以逗号分隔。
you'll notice that some of them have a comma-separated list.

54
00:03:15,550 --> 00:03:19,150
这个逗号分隔的列表是因为你们中的一些人尽可能地检查了一下，
And that comma-separated list is because some of you checked, as you could,

55
00:03:19,150 --> 00:03:24,730
多个复选框以表明Breaking Bad是犯罪类型
multiple check boxes to indicate that Breaking Bad is a crime genre

56
00:03:24,729 --> 00:03:26,829
戏剧和惊悚片。
drama and also thriller.

57
00:03:26,830 --> 00:03:31,240
因此，在某种意义上，Google表单处理此问题的方式有点偷偷摸摸
And so the way Google Forms handles this is a bit sleazily in the sense

58
00:03:31,240 --> 00:03:35,350
他们只是将所有这些值作为逗号分隔的列表
that they just drop all of those values as a comma-separated list

59
00:03:35,349 --> 00:03:37,852
在电子表格本身中。
inside of the spreadsheet itself.

60
00:03:37,853 --> 00:03:40,270
如果我们最终下载，那将是一个潜在的问题
And that's potentially a problem if we ultimately download

61
00:03:40,270 --> 00:03:43,570
此为CSV文件，逗号分隔的值，
this as a CSV file, comma-separated values,

62
00:03:43,569 --> 00:03:47,499
因为现在您在逗号之间有逗号。
because now you have commas in between the commas.

63
00:03:47,500 --> 00:03:50,479
幸运的是，我们最终将看到一个解决方案。
Fortunately, there's a solution to that that we'll ultimately see.

64
00:03:50,479 --> 00:03:52,159
因此，这里有大量数据。
So we've got a good amount of data here.

65
00:03:52,159 --> 00:03:55,299
实际上，如果我继续向下滚动，我们现在将看到数百个响应。
In fact, if I keep scrolling down, we'll see a few hundred responses now.

66
00:03:55,300 --> 00:03:58,120
并以某种方式分析这些数据将是很好的
And it would be nice to analyze this data in some way

67
00:03:58,120 --> 00:04:02,410
找出最流行的电视节目是什么，也许搜索新节目
and figure out what the most popular TV show is, maybe search for new shows

68
00:04:02,409 --> 00:04:04,142
我可能喜欢通过他们的类型。
I might like via their genre.

69
00:04:04,143 --> 00:04:06,310
因此，您可以想象一些查询可以
So you can imagine some number of queries that could

70
00:04:06,310 --> 00:04:08,620
通过此数据集进行回答。
be answered by way of this data set.

71
00:04:08,620 --> 00:04:12,340
但首先让我们考虑保留此数据的局限性
But let's first consider the limitations of leaving this data

72
00:04:12,340 --> 00:04:14,980
在这样的电子表格中。
in just a spreadsheet like this.

73
00:04:14,979 --> 00:04:17,439
我们所有人都可能养成偶尔使用的习惯
All of us are probably in the habit of using occasionally

74
00:04:17,439 --> 00:04:22,489
Google Spreadsheets，Apple Numbers，Microsoft Excel或其他工具。
Google Spreadsheets, Apple Numbers, Microsoft Excel, or some other tool.

75
00:04:22,490 --> 00:04:27,220
因此，让我们考虑一下哪些电子表格擅长，哪些擅长。
So let's consider what spreadsheets are good at and what they are bad at.

76
00:04:27,220 --> 00:04:30,370
有人愿意自愿回答第一个问题吗？
Would anyone like to volunteer an answer to the first of those?

77
00:04:30,370 --> 00:04:34,030
电子表格的优点是什么？
What is a spreadsheet good at or good for?

78
00:04:34,029 --> 00:04:35,079
是的，安德鲁？
Yeah, Andrew?

79
00:04:35,079 --> 00:04:36,759
您对电子表格有何想法？
What's your thinking on spreadsheets?

80
00:04:36,759 --> 00:04:39,796
观众：[听不清]
AUDIENCE: [INAUDIBLE]

81
00:04:39,797 --> 00:04:41,880
DAVID J. MALAN：好的，非常适合快速排序。
DAVID J. MALAN: OK, very good for quickly sorting.

82
00:04:41,879 --> 00:04:42,299
我喜欢。
I like that.

83
00:04:42,300 --> 00:04:44,758
例如，我可以单击“标题”列的顶部，
I could click on the top of the Title column, for instance,

84
00:04:44,757 --> 00:04:48,449
然后立即按字母顺序对所有这些标题进行排序。
and immediately sort all of those titles by alphabetically.

85
00:04:48,449 --> 00:04:49,139
我喜欢。
I like that.

86
00:04:49,139 --> 00:04:53,369
使用电子表格的其他原因-它们可以解决什么问题？
Other reasons to use a spreadsheet-- what problems do they solve?

87
00:04:53,370 --> 00:04:55,050
他们擅长什么？
What are they good at?

88
00:04:55,050 --> 00:04:56,670
有关电子表格的其他想法。
Other thoughts on spreadsheets.

89
00:04:56,670 --> 00:04:58,530
是的，彼得呢？
Yeah, how about Peter?

90
00:04:58,529 --> 00:05:01,946
听众：存储大量数据，以便以后进行分析。
AUDIENCE: Storing large amounts of data that you can later analyze.

91
00:05:01,947 --> 00:05:03,780
DAVID J. MALAN：好的，所以要大量存储
DAVID J. MALAN: OK, so storing large amounts

92
00:05:03,779 --> 00:05:05,699
您以后可以分析的数据。
of data that you can later analyze.

93
00:05:05,699 --> 00:05:09,209
可以这么说，这是一种用于存储大量数据行的好模型。
It's kind of a nice model for storing lots of rows of data, so to speak.

94
00:05:09,209 --> 00:05:11,309
我会说实际上是有限制的。
I will say that there actually is a limit.

95
00:05:11,310 --> 00:05:13,890
实际上，回想过去，这是什么限制。
And in fact, back in the day, I learned what this limit is.

96
00:05:13,889 --> 00:05:16,514
长话短说，在研究生院，我正在使用电子表格
Long story short, in graduate school, I was using a spreadsheet

97
00:05:16,514 --> 00:05:17,939
分析一些研究数据。
to analyze some research data.

98
00:05:17,939 --> 00:05:23,369
有一次，我的数据比Excel支持的行多。
And at one point, I had more data than Excel supported rows for.

99
00:05:23,370 --> 00:05:28,110
具体来说，我有65,536行，
Specifically, I had some 65,536 rows, which

100
00:05:28,110 --> 00:05:30,360
当时对于Excel来说太多了，
was too many at that point for Excel at the time,

101
00:05:30,360 --> 00:05:33,870
因为长话短说，如果您从电子表格程序中回想起
because, long story short, if you recall from a spreadsheet program

102
00:05:33,870 --> 00:05:37,328
像Google Spreadsheets一样，每一行都从1开始编号。
like Google Spreadsheets, every row is numbered from 1 on up.

103
00:05:37,327 --> 00:05:39,119
好吧，不幸的是，在当时，微软
Well, unfortunately, at the time, Microsoft

104
00:05:39,120 --> 00:05:43,170
使用了16位整数，16位或2个字节，
had used a 16-bit integer, 16 bits or 2 bytes,

105
00:05:43,170 --> 00:05:45,150
代表每个数字。
to represent each of those numbers.

106
00:05:45,149 --> 00:05:49,319
结果表明2到16的幂大约为65,000。
And it turns out the 2 to the 16th power is roughly 65,000.

107
00:05:49,319 --> 00:05:51,999
因此，在那一点上，我使行的总数最大化。
So at that point, I maxed out the total number of rows.

108
00:05:52,000 --> 00:05:54,827
现在，以Peter的观点来说，最近几年他们已经增加了这一点。
Now, to Peter's point, they've increased that in recent years.

109
00:05:54,827 --> 00:05:56,619
实际上，您可以存储更多数据。
And you can actually store a lot more data.

110
00:05:56,620 --> 00:05:58,870
因此，电子表格确实擅长于此。
So spreadsheets are indeed good at that.

111
00:05:58,870 --> 00:06:02,580
但是他们不一定在所有方面都擅长，因为在某些时候，
But they're not necessarily good at everything, because at some point,

112
00:06:02,579 --> 00:06:05,309
您将在电子表格中拥有更多数据
you're going to have more data potentially in a spreadsheet

113
00:06:05,310 --> 00:06:07,860
超出Mac或PC所能承受的范围。
than your Mac or PC can handle.

114
00:06:07,860 --> 00:06:10,860
实际上，如果您实际上是在尝试构建应用程序，
In fact, if you're actually trying to build an application, whether it's

115
00:06:10,860 --> 00:06:14,490
Twitter，Instagram或Facebook或任何规模的东西，
Twitter, Instagram, or Facebook or anything of that scale,

116
00:06:14,490 --> 00:06:17,490
这些公司肯定没有存储他们的数据，可以这样说：
those companies are certainly not storing their data, suffice it to say,

117
00:06:17,490 --> 00:06:20,700
在电子表格中，因为只会有太多的数据要使用。
in a spreadsheet, because there would just be way too much data to use.

118
00:06:20,699 --> 00:06:23,049
而且没有人能从他们的计算机上真正打开它。
And no one could literally open it on their computer.

119
00:06:23,050 --> 00:06:25,830
因此，我们需要解决规模问题的方法。
So we'll need a solution to that problem of scale.

120
00:06:25,829 --> 00:06:29,949
但是我认为我们不需要抛弃那些对电子表格有效的方法。
But I don't think we need to throw out what works well about spreadsheets.

121
00:06:29,949 --> 00:06:33,509
因此，您确实可以以行形式存储大量数据。
So you can store indeed a lot of data in row form.

122
00:06:33,509 --> 00:06:36,929
但是似乎您也可以以列的形式存储大量数据。
But it would seem that you can also store a lot of data in column form.

123
00:06:36,930 --> 00:06:39,567
即使我只显示A，B和C列，
And even though I'm only showing columns A, B, and C,

124
00:06:39,567 --> 00:06:41,400
当然，您可能已经使用过电子表格
of course, you've probably used spreadsheets

125
00:06:41,399 --> 00:06:42,569
在其中添加更多列-
where you add more columns--

126
00:06:42,569 --> 00:06:44,679
D，E，F等。
D, E, F, and so forth.

127
00:06:44,680 --> 00:06:48,540
那么如何思考行的正确心智模型是什么
So what's the right mental model for how to think about rows

128
00:06:48,540 --> 00:06:51,540
与电子表格中的列？
versus columns in a spreadsheet?

129
00:06:51,540 --> 00:06:57,840
我觉得我们可能在概念上以某种不同的方式使用它们。
I feel like we probably use them in a somewhat different way conceptually.

130
00:06:57,839 --> 00:07:00,549
我们可能会有所不同。
We might think about them a little differently.

131
00:07:00,550 --> 00:07:04,440
电子表格中的行和列有什么区别？
What's the difference between rows and columns in a spreadsheet?

132
00:07:04,439 --> 00:07:06,569
苏菲亚。
Sofia.

133
00:07:06,569 --> 00:07:07,889
听众：添加更多条目。
AUDIENCE: Adding more entries.

134
00:07:07,889 --> 00:07:09,419
添加更多数据是-
Adding more data is--

135
00:07:09,420 --> 00:07:12,720
这些在行内，但随后是实际属性或特征
those are within the rows, but then the actual attributes or characteristics

136
00:07:12,720 --> 00:07:14,240
的数据应在列中。
of the data should be in columns.

137
00:07:14,240 --> 00:07:15,240
戴维·J·马兰（David J. MALAN）：好的。
DAVID J. MALAN: Exactly.

138
00:07:15,240 --> 00:07:17,220
当您向电子表格中添加更多数据时，
When you add more data to the spreadsheet,

139
00:07:17,220 --> 00:07:19,620
您真的应该添加到它的底部，
you should really be adding to the bottom of it,

140
00:07:19,620 --> 00:07:21,310
添加越来越多的行。
adding more and more rows.

141
00:07:21,310 --> 00:07:24,300
所以这些事情在垂直方向上是增长的，尽管那当然是
So these things sort of grow vertically, even though of course that's

142
00:07:24,300 --> 00:07:25,920
只是人类对它的感知。
just a human's perception of it.

143
00:07:25,920 --> 00:07:28,740
它们通过添加越来越多的行从上到下增长。
They grow from top to bottom by adding more and more rows.

144
00:07:28,740 --> 00:07:31,560
但就索非亚而言，您的专栏代表
But to Sofia's point, your columns represent

145
00:07:31,560 --> 00:07:37,920
我们可以称之为属性或字段或其他任何此类特征的东西
what we might call attributes or fields or any other such characteristic that

146
00:07:37,920 --> 00:07:40,030
是您要存储的一种数据。
is a type of data that you're storing.

147
00:07:40,029 --> 00:07:42,929
因此，在我们的表格中，时间戳是第一列。
So in this case of our form, Timestamp is the first column.

148
00:07:42,930 --> 00:07:44,460
标题是第二列。
Title is the second column.

149
00:07:44,459 --> 00:07:45,929
类别是第三列。
Genres is the third column.

150
00:07:45,930 --> 00:07:49,980
那些列确实可以被认为是字段或属性，属性
And those columns can indeed be thought of as fields or attributes, properties

151
00:07:49,980 --> 00:07:50,697
您的数据。
of your data.

152
00:07:50,697 --> 00:07:54,030
这些是您真正应该事先决定的属性
And those are properties that you should really decide on in advance when you're

153
00:07:54,029 --> 00:07:56,969
在我们的情况下，或者在您手动创建表单时，首先创建表单
first creating the form, in our case, or when you're manually creating

154
00:07:56,970 --> 00:07:59,430
在另一种情况下，电子表格。
the spreadsheet in another case.

155
00:07:59,430 --> 00:08:01,320
你不应该真正养成习惯
You should not really be in the habit, when

156
00:08:01,319 --> 00:08:05,429
使用电子表格，从左侧添加数据
using spreadsheets, of adding data from left

157
00:08:05,430 --> 00:08:08,370
在右边，添加越来越多的列，除非您
to right, adding more and more columns, unless you

158
00:08:08,370 --> 00:08:11,740
决定收集更多类型的数据。
decide to collect more types of data.

159
00:08:11,740 --> 00:08:15,873
因此，仅因为有人将新的喜爱的电视节目添加到您的数据集中，
So just because someone adds a new favorite TV show to your data set,

160
00:08:15,872 --> 00:08:18,539
您不应该在新列中从左到右添加该内容。
you shouldn't be adding that from left to right in a new column.

161
00:08:18,540 --> 00:08:21,040
您确实应该从上至下添加它。
You should indeed be adding it from top to bottom.

162
00:08:21,040 --> 00:08:24,780
但是，假设我们实际上决定从每个人那里收集更多信息。
But suppose that we actually decided to collect more information from everyone.

163
00:08:24,779 --> 00:08:28,649
可能是该表格要求您输入姓名或电子邮件地址
Maybe that form had instead asked you for your name or your email address

164
00:08:28,649 --> 00:08:30,119
或其他任何问题。
or any other questions.

165
00:08:30,120 --> 00:08:34,480
这些属性，属性或字段将属于新列。
Those properties or attributes or fields would belong as new columns.

166
00:08:34,480 --> 00:08:38,309
这就是说我们通常决定数据的布局，
So this is to say we generally decide on the layout of our data,

167
00:08:38,308 --> 00:08:41,129
预先显示我们的数据模式。
the schema of our data, in advance.

168
00:08:41,129 --> 00:08:45,419
然后从那开始，我们继续添加，添加，添加更多行，而不是
And then from there on out, we proceed to add, add, add more rows, not

169
00:08:45,419 --> 00:08:47,669
专栏，除非我们改变主意并需要改变
columns, unless we change our mind and need to change

170
00:08:47,669 --> 00:08:50,229
我们特定数据的架构。
the schema of our particular data.

171
00:08:50,230 --> 00:08:53,850
事实证明，电子表格确实非常有用，
So it turns out that spreadsheets are indeed wonderfully useful,

172
00:08:53,850 --> 00:08:56,700
到彼得的观点，无论是大的还是相当大的
to Peter's point, for large or reasonably large

173
00:08:56,700 --> 00:08:59,610
我们可能收集的数据集。
data sets that we might collect.

174
00:08:59,610 --> 00:09:04,500
当然，我们可以每个星期将这些数据集导出为CSV文件。
And we can, of course, per last week, export those data sets as CSV files.

175
00:09:04,500 --> 00:09:07,290
这样我们就可以从电子表格转到简单文本
And so we can go from a spreadsheet to a simple text

176
00:09:07,289 --> 00:09:11,369
通常，以ASCII或Unicode格式存储在您自己的硬盘上的文件
file stored in ASCII or Unicode, more generally, on your own hard drive

177
00:09:11,370 --> 00:09:12,660
或云中的某个地方。
or somewhere in the cloud.

178
00:09:12,659 --> 00:09:16,349
您实际上可以想到该文件，.CSV文件，
And you can actually think of that file, that .CSV file,

179
00:09:16,350 --> 00:09:19,540
就像我们所说的平面文件数据库一样。
as what we might call a flat-file database.

180
00:09:19,539 --> 00:09:22,979
一般来说，数据库是存储数据的文件。
A database is, generally speaking, a file that stores data.

181
00:09:22,980 --> 00:09:25,997
或它是一个为您存储数据的程序。
Or it's a program that stores data for you.

182
00:09:25,996 --> 00:09:29,079
而且我们所有人都可能在某种意义上考虑或使用过数据库。
And all of us have probably thought about or used databases in some sense.

183
00:09:29,080 --> 00:09:31,560
您可能熟悉以下事实：
You're probably familiar with the fact that all

184
00:09:31,559 --> 00:09:35,309
那些大型网站（例如Google，Twitter和Facebook等）使用
of those same big websites, Google and Twitter and Facebook and others, use

185
00:09:35,309 --> 00:09:37,016
数据库来存储我们的数据。
databases to store our data.

186
00:09:37,017 --> 00:09:38,850
好吧，那些数据库或者只是
Well, those databases are either just really

187
00:09:38,850 --> 00:09:42,120
包含大量数据或特殊程序的大文件
big files containing lots of data or special programs

188
00:09:42,120 --> 00:09:44,130
正在为我们存储数据。
that are storing our data for us.

189
00:09:44,129 --> 00:09:46,349
平面文件只是指事实
And a flat file is just referring to the fact

190
00:09:46,350 --> 00:09:48,580
这确实是一个非常简单的设计。
that it really is a very simple design.

191
00:09:48,580 --> 00:09:51,510
实际上，几年前，几十年前，人类决定
In fact, years ago, decades ago, humans decided

192
00:09:51,509 --> 00:09:54,779
当将数据存储在简单的文本文件中时，如果
when storing data in simple text files that if you

193
00:09:54,779 --> 00:09:57,539
想要存储不同类型的数据，例如，索非亚
want to store different types of data, like, to Sofia's point,

194
00:09:57,539 --> 00:10:00,339
不同的属性或属性，让我们保持简单。
different properties or attributes, well, let's keep it simple.

195
00:10:00,340 --> 00:10:03,780
让我们用逗号分隔这些列
Let's just separate those columns with commas

196
00:10:03,779 --> 00:10:06,449
在我们的平面文件数据库中
in our flat-file database, a.k.a.

197
00:10:06,450 --> 00:10:07,118
CSV。
a CSV.

198
00:10:07,118 --> 00:10:08,160
您可以使用其他东西。
You can use other things.

199
00:10:08,159 --> 00:10:09,429
您可以使用标签。
You can use tabs.

200
00:10:09,429 --> 00:10:12,569
对于制表符分隔的值，有一种称为TSV的东西。
There's things called TSVs, for Tab-Separated Values.

201
00:10:12,570 --> 00:10:14,760
坦白说，您可以使用任何您想要的东西。
And frankly, you can use anything you want.

202
00:10:14,759 --> 00:10:16,049
但是有一个极端的情况。
But there is a corner case.

203
00:10:16,049 --> 00:10:17,979
而且我们已经看到了它的预览。
And we've already seen a preview of it.

204
00:10:17,980 --> 00:10:21,190
如果您的实际数据中包含逗号怎么办？
What if your actual data has a comma in it?

205
00:10:21,190 --> 00:10:23,820
如果您喜欢的电视节目的标题带有逗号怎么办？
What if the title of your favorite TV show has a comma?

206
00:10:23,820 --> 00:10:27,660
如果Google假设将类型存储为以逗号分隔的列表怎么办？
What if Google is presuming to store genres as a comma-separated list?

207
00:10:27,659 --> 00:10:32,339
如果将CSV用作平面文件数据库，可能会发生不好的事情。
Bad things can happen if using a CSV as your flat-file database.

208
00:10:32,340 --> 00:10:33,760
但是有解决方案。
But there are solutions to that.

209
00:10:33,759 --> 00:10:35,579
实际上，世界通常会做什么
And in fact, what the world typically does

210
00:10:35,580 --> 00:10:39,640
每当您在CSV文件中包含逗号时，
is whenever you have commas inside of your CSV file,

211
00:10:39,639 --> 00:10:42,299
您只需确保整个字符串是双精度的
you just make sure that the whole string is double

212
00:10:42,299 --> 00:10:44,459
在最左边和最右边引用。
quoted on the far left and far right.

213
00:10:44,460 --> 00:10:46,860
而且双引号内的任何内容都不是
And anything inside of double quotes is not

214
00:10:46,860 --> 00:10:50,790
此后被误认为是描绘一列
mistaken thereafter as delineating a column

215
00:10:50,789 --> 00:10:53,219
就像文件中的其他逗号一样。
as the other commas in the file might.

216
00:10:53,220 --> 00:10:55,590
这就是平面文件数据库的全部含义。
So that's all that's meant by a flat-file database.

217
00:10:55,590 --> 00:10:58,860
CSV可能是最常见，最常见的格式之一
And CSV is perhaps one of the most common, the most common, formats

218
00:10:58,860 --> 00:11:01,240
如果仅仅是因为所有这些程序，
thereof, if only because all of these programs,

219
00:11:01,240 --> 00:11:03,420
例如Google Spreadsheets和Excel and Numbers，
like Google Spreadsheets and Excel and Numbers,

220
00:11:03,419 --> 00:11:07,136
允许您将文件另存为CSV。
allow you to save your files as CSVs.

221
00:11:07,136 --> 00:11:08,969
长话短说，现在
Now, long story short, those of you who have

222
00:11:08,970 --> 00:11:12,570
电子表格的高级功能，例如内置函数和公式
used fancier features of spreadsheets like built-in functions and formulas

223
00:11:12,570 --> 00:11:14,850
那些东西，那些是内置的
and those kinds of things, those are built in

224
00:11:14,850 --> 00:11:19,120
并且是Google Spreadsheets，Excel和Numbers专有的。
and proprietary to Google Spreadsheets and Excel and Numbers.

225
00:11:19,120 --> 00:11:24,900
您不能在CSV文件或TSV文件或平面文件数据库中使用公式，
You cannot use formulas in a CSV file or a TSV file or in a flat-file database,

226
00:11:24,899 --> 00:11:25,869
更普遍。
more generally.

227
00:11:25,870 --> 00:11:27,990
您只能存储静态-
You can only store static--

228
00:11:27,990 --> 00:11:30,090
也就是说，不变的价值观。
that is, unchanging-- values.

229
00:11:30,090 --> 00:11:33,490
因此，当您导出数据时，所见即所得。
So when you export the data, what you see is what you get.

230
00:11:33,490 --> 00:11:35,242
这就是为什么人们使用更高级的程序
And that's why people use fancier programs

231
00:11:35,241 --> 00:11:37,199
例如Excel，Numbers和Google Spreadsheets，
like Excel and Numbers and Google Spreadsheets,

232
00:11:37,200 --> 00:11:38,658
因为您可以获得更多功能。
because you get more functionality.

233
00:11:38,658 --> 00:11:41,100
但是，如果要导出数据，则只能
But if you want to export the data, you can only

234
00:11:41,100 --> 00:11:44,190
确实从中获取原始文本数据。
get indeed the raw textual data out of it.

235
00:11:44,190 --> 00:11:45,690
但是我敢说那会没事的。
But I daresay that's going to be OK.

236
00:11:45,690 --> 00:11:47,398
其实，布莱恩，你介意我继续吗
In fact, Brian, do you mind if I go ahead

237
00:11:47,398 --> 00:11:50,160
并立即以CSV文件格式下载此电子表格？
and download this spreadsheet as a CSV file now?

238
00:11:50,159 --> 00:11:51,509
布莱恩·于：是的，继续。
BRIAN YU: Yep, go ahead.

239
00:11:51,509 --> 00:11:51,809
DAVID J. MALAN：好的。
DAVID J. MALAN: All right.

240
00:11:51,809 --> 00:11:54,889
我将继续使用Google Spreadsheets，然后转到“文件，下载”。
I'm going to go ahead in Google Spreadsheets and go to File, Download.

241
00:11:54,889 --> 00:11:56,639
您会看到很多选择-
And you can see a whole bunch of options--

242
00:11:56,639 --> 00:12:01,849
PDF，网页，逗号分隔值，这是我想要的值。
PDF, Web Page, Comma-Separated Values, which is the one I want.

243
00:12:01,850 --> 00:12:04,320
所以我确实要继续选择CSV
So I'm going to indeed go ahead and choose CSV

244
00:12:04,320 --> 00:12:06,510
从电子表格中的此下拉菜单中。
from this dropdown in spreadsheets.

245
00:12:06,509 --> 00:12:08,409
那当然是为我下载了该文件。
That, of course, downloaded that file for me.

246
00:12:08,409 --> 00:12:11,076
现在，我将继续进入我们熟悉的CS50 IDE。
And now I'm going to go ahead and go into our familiar CS50 IDE.

247
00:12:11,076 --> 00:12:14,599
您会记得，上周我能够将文件上传到IDE。
You'll recall that last week I was able to upload a file into the IDE.

248
00:12:14,600 --> 00:12:17,350
我也将继续在本周在这里进行相同的操作。
And I'm going to go ahead and do the same here this week, as well.

249
00:12:17,350 --> 00:12:20,730
我将继续获取我的文件，该文件最终在我的下载中
I'm going to go ahead and grab my file, which ended up in my Downloads

250
00:12:20,730 --> 00:12:22,830
我的特定计算机上的文件夹。
folder on my particular computer here.

251
00:12:22,830 --> 00:12:27,840
我将继续将其拖放到IDE中
And I'm going to go ahead and drag and drop this into the IDE

252
00:12:27,840 --> 00:12:31,790
这样它就可以存储在我的主目录中。
such that it ends up in my home directory, so to speak.

253
00:12:31,789 --> 00:12:34,409
所以现在我有了这个文件，“我的最爱电视节目表”。
So now I have this file, Favorite TV Shows Forms.

254
00:12:34,409 --> 00:12:36,749
实际上，如果我在IDE中双击它，
And in fact, if I double click this within the IDE,

255
00:12:36,750 --> 00:12:38,879
您现在将看到熟悉的数据。
you'll see familiar data now.

256
00:12:38,879 --> 00:12:42,949
时间戳逗号标题逗号流派是我们的标题行
Timestamp comma title comma genres is our header row

257
00:12:42,950 --> 00:12:46,830
包含此文件中属性或属性的名称。
that contains the names of the properties or attributes in this file.

258
00:12:46,830 --> 00:12:51,390
然后我们得到了时间戳记逗号最喜欢的标题逗号，然后
Then we've got our timestamps comma favorite title comma and then

259
00:12:51,389 --> 00:12:53,309
以逗号分隔的流派列表。
a comma-separated list of genres.

260
00:12:53,309 --> 00:12:56,099
确实在这里，请注意Google小心了
And here indeed, notice that Google took care

261
00:12:56,100 --> 00:13:00,030
对自己有逗号的任何值使用双引号。
to use double quotes around any values that themselves had commas.

262
00:13:00,029 --> 00:13:02,129
因此，这是一种相对简单的文件格式。
So it's a relatively simple file format.

263
00:13:02,129 --> 00:13:04,559
我当然可以略过这件事，
And I could certainly just kind of skim through this,

264
00:13:04,559 --> 00:13:07,919
找出谁喜欢办公室，谁喜欢Breaking Bad或其他节目。
figuring out who likes The Office, who likes Breaking Bad, or other shows.

265
00:13:07,919 --> 00:13:11,039
但是上周，我们现在有了一种非常有用的编程语言
But per last week, we now have a pretty useful programming language

266
00:13:11,039 --> 00:13:14,219
我们可以使用Python，这可以让我们开始进行操作
at our disposal, Python, that could allow us to start manipulating

267
00:13:14,220 --> 00:13:16,860
并更容易地分析这些数据。
and analyzing this data more readily.

268
00:13:16,860 --> 00:13:20,100
上周，我要讲的是使用正确的工具完成这项工作，
And here to my point last week about using the right tool for the job,

269
00:13:20,100 --> 00:13:24,860
您绝对可以在CS50之前的所有星期中完成我们将要做的所有事情。
you could absolutely do everything we're about to do in all weeks prior of CS50.

270
00:13:24,860 --> 00:13:27,720
我们本来可以用C做的。
We could have used C for what we're about to do.

271
00:13:27,720 --> 00:13:31,350
但是，正如您可能会发现的那样，C在某些方面往往会很痛苦，
But as you can probably glean, C tends to be painful for certain things,

272
00:13:31,350 --> 00:13:34,290
就像涉及字符串操作的任何事物一样，
like anything involving string manipulation,

273
00:13:34,289 --> 00:13:36,659
更改字符串，分析字符串。
changing strings, analyzing strings.

274
00:13:36,659 --> 00:13:38,289
真是痛苦，对吧？
It's just a real pain, right?

275
00:13:38,289 --> 00:13:42,329
上帝禁止您必须将此CSV文件并将其全部加载到内存中，而不是
God forbid you had to take this CSV file and load it all into memory, not

276
00:13:42,330 --> 00:13:43,470
不像您的拼写检查器。
unlike your spell checker.

277
00:13:43,470 --> 00:13:46,950
您将不得不在各处使用malloc或重新分配等。
You would have to be using malloc all over the place or realloc or the like.

278
00:13:46,950 --> 00:13:50,640
仅分析文本文件就涉及很多繁重的工作。
There's just a lot of heavy lifting involved in just analyzing a text file.

279
00:13:50,639 --> 00:13:53,759
因此，Python仅通过给我们提供了所有这些功能
So Python does all of that for us by just giving us

280
00:13:53,759 --> 00:13:56,129
我们可以使用更多功能
more functions at our disposal with which

281
00:13:56,129 --> 00:13:59,469
开始分析和打开数据。
to start analyzing and opening data.

282
00:13:59,470 --> 00:14:01,570
因此，让我继续关闭该文件。
So let me go ahead and close this file.

283
00:14:01,570 --> 00:14:05,082
让我继续创建一个新的文件夹，收藏夹。
And let me go ahead and create a new one called favorites.py,

284
00:14:05,081 --> 00:14:07,289
其中我将开始使用该数据集
wherein I'm going to start playing with this data set

285
00:14:07,289 --> 00:14:09,899
看看我们是否无法开始回答一些有关它的问题。
and see if we can't start answering some questions about it.

286
00:14:09,899 --> 00:14:12,569
坦白说，直到今天，学习了20多年
And frankly, to this day, 20-plus years after learning how

287
00:14:12,570 --> 00:14:14,670
第一次编程，我自己是
to program for the first time, I myself am

288
00:14:14,669 --> 00:14:17,999
编写刚开始的新程序时非常习惯
very much in the habit when writing a new program of just starting simple

289
00:14:18,000 --> 00:14:22,320
并没有解决我最终想要解决的问题，只是简单一些
and not solving the problem I ultimately want to but something simpler just

290
00:14:22,320 --> 00:14:24,270
作为一种概念证明，以确保
as a sort of proof of concept to make sure

291
00:14:24,269 --> 00:14:26,509
我有正确的管道。
I have the right plumbing in place.

292
00:14:26,509 --> 00:14:27,509
因此，我的意思是这个。
So by that, I mean this.

293
00:14:27,509 --> 00:14:32,549
让我们继续编写一个简单的程序，简单地打开该文件CSV
Let's go ahead and write a quick program that simply opens up this file, the CSV

294
00:14:32,549 --> 00:14:37,119
文件，从上到下对其进行迭代，然后仅打印出每个标题，
file, iterates over it top to bottom, and just prints out each of the titles,

295
00:14:37,120 --> 00:14:39,430
就像快速的理智检查一样，我知道我在做什么
just as a quick sanity check that I know what I'm doing

296
00:14:39,429 --> 00:14:41,459
并且我可以访问其中的数据。
and I have access to the data therein.

297
00:14:41,460 --> 00:14:43,740
因此，让我继续导入CSV。
So let me go ahead and import CSV.

298
00:14:43,740 --> 00:14:45,840
然后，我可以通过几种不同的方式来做到这一点。
And then I can do this in a few different ways.

299
00:14:45,840 --> 00:14:48,030
但是到现在为止，您可能已经看到或记住了
But by now, you've probably seen or remembered

300
00:14:48,029 --> 00:14:50,489
我使用诸如open命令和
my using something like the open command and the

301
00:14:50,490 --> 00:14:55,260
用关键字打开，并最终自动为我关闭此文件。
with keyword to open and eventually automatically close this file for me.

302
00:14:55,259 --> 00:14:59,709
此文件称为“喜爱的电视节目-表单响应1.csv”。
This file is called Favorite TV Shows - Form Responses 1.csv.

303
00:15:02,399 --> 00:15:04,559
我将以读取模式打开它。
And I'm going to open this up in read mode.

304
00:15:04,559 --> 00:15:06,999
严格来说，r不是必需的。
Strictly speaking, the r is not required.

305
00:15:07,000 --> 00:15:09,330
您可能会在网上看到一些不包含示例的示例。
You might see examples online not including it.

306
00:15:09,330 --> 00:15:13,140
那是因为read是默认的。但是为了与C和fopen保持一致，
That's because read is the default. But for parity with C and fopen,

307
00:15:13,139 --> 00:15:15,899
我将明确指出并实际执行“ r”。
I'm going to be explicit and actually do "r."

308
00:15:15,899 --> 00:15:18,669
我将继续给这个文件起一个可变的名称。
And I'm going to go ahead and give this a variable name of file.

309
00:15:18,669 --> 00:15:23,819
因此，此处的第3行具有以只读模式打开该CSV文件的效果
So this line 3 here has the effect of opening that CSV file in read-only mode

310
00:15:23,820 --> 00:15:27,532
并创建一个名为file的变量，我可以通过该变量引用它。
and creating a variable called file via which I can reference it.

311
00:15:27,532 --> 00:15:30,240
现在，我将继续使用一些CSV功能。
Now I'm going to go ahead and use some of that CSV functionality.

312
00:15:30,240 --> 00:15:32,790
我要给自己，我们一直在称呼读者，
I'm going to give myself what we keep calling a reader, which

313
00:15:32,789 --> 00:15:34,649
我可以称它为xyz，还有其他任何东西。
I could call it xyz, anything else.

314
00:15:34,649 --> 00:15:37,739
但是“阅读器”类型描述了此变量将要执行的操作。
But "reader" kind of describes what this variable is going to do.

315
00:15:37,740 --> 00:15:42,930
这将是在该文件上调用csv.reader的返回值。
And it's going to be the return value of calling csv.reader on that file.

316
00:15:42,929 --> 00:15:46,739
因此，从本质上讲，上周的CSV库
And so essentially, the CSV library, per last week,

317
00:15:46,740 --> 00:15:48,360
具有很多内置的精美功能。
has a lot of fancy features built in.

318
00:15:48,360 --> 00:15:52,470
输入所需的只是一个已打开的文本文件。
And all it needs as input is an already opened text file.

319
00:15:52,470 --> 00:15:55,120
然后它将包装该文件，可以这么说，
And then it will then wrap that file, so to speak,

320
00:15:55,120 --> 00:15:57,270
还有很多更有用的功能，
with a whole bunch of more useful functionality,

321
00:15:57,269 --> 00:16:01,749
喜欢一次读取列和行的功能。
like the ability to read it column and row at a time.

322
00:16:01,750 --> 00:16:02,250
好的。
All right.

323
00:16:02,250 --> 00:16:05,169
现在，我要继续前进，您知道吗，就目前而言，
Now I'm going to go ahead and, you know what, just for now,

324
00:16:05,169 --> 00:16:08,189
我将跳过第一行。
I'm going to skip the first row.

325
00:16:08,190 --> 00:16:11,310
我将跳过第一行，因为第一行有我的标题-
I'm going to skip the first row, because the first row has my headings--

326
00:16:11,309 --> 00:16:13,529
时间戳，标题和类型。
Timestamp, Title, and Genres.

327
00:16:13,529 --> 00:16:17,691
而且我知道我的专栏是什么，所以我现在暂时忽略该行。
And I know what my columns are, so I'm just going to ignore that line for now.

328
00:16:17,692 --> 00:16:18,900
现在，我要执行此操作。
And now I'm going to do this.

329
00:16:18,899 --> 00:16:24,569
对于排入阅读器，让我继续并简单地打印出排。
For row in reader, let me go ahead and print out, quite simply, row.

330
00:16:24,570 --> 00:16:28,890
我只想要标题，所以我想如果是从左到右的三列，
And I only want title, so I think if it's three columns from left to right,

331
00:16:28,889 --> 00:16:30,329
它是0、1、2
it's 0, 1, 2.

332
00:16:30,330 --> 00:16:33,480
所以我想打印出列支架1
So I want to print out column bracket 1, which

333
00:16:33,480 --> 00:16:35,680
将成为第二列零索引。
is going to be the second column zero indexed.

334
00:16:35,679 --> 00:16:36,179
好的。
All right.

335
00:16:36,179 --> 00:16:39,239
让我继续保存，下至我的终端窗口，
Let me go ahead and save that, go down to my terminal window,

336
00:16:39,240 --> 00:16:42,850
并运行“ favourites.py”的python，然后用手指交叉。
and run python of favorites.py and cross my fingers.

337
00:16:42,850 --> 00:16:43,500
好的。
OK.

338
00:16:43,500 --> 00:16:44,919
瞧。
Voila.

339
00:16:44,919 --> 00:16:46,739
它飞得很快。
It flew by super fast.

340
00:16:46,740 --> 00:16:49,530
但是看起来，确实，这些都是电视
But it looks like, indeed, these are all of the TV

341
00:16:49,529 --> 00:16:51,149
表明人们已经输入了。
shows that folks have inputted.

342
00:16:51,149 --> 00:16:53,369
确实，如果我继续向上滚动，会有几百个。
Indeed, there's a few hundred if I keep scrolling up.

343
00:16:53,370 --> 00:16:55,740
因此，看来我的程序正在运行。
So it looks like my program is working.

344
00:16:55,740 --> 00:16:57,850
但是，让我们对其进行一些改进。
But let's improve it just a little bit.

345
00:16:57,850 --> 00:17:02,490
原来，使用csv.reader并不一定
It turns out that using the csv.reader isn't necessarily

346
00:17:02,490 --> 00:17:04,050
Python中最好的方法。
the best approach in Python.

347
00:17:04,049 --> 00:17:07,588
你们中的许多人已经发现DictReader，字典阅读器，
Many of you have already discovered a DictReader, a dictionary reader,

348
00:17:07,588 --> 00:17:10,739
很好，因为这样您就不必知道或重复检查
which is nice, because then you don't have to know or keep double checking

349
00:17:10,740 --> 00:17:13,230
您的数据在哪个数字列中。
what number column your data is in.

350
00:17:13,230 --> 00:17:17,520
您可以改为通过标头本身来引用它，因此可以通过“标题”来引用它
You can instead refer it to by the header itself, so by "title"

351
00:17:17,519 --> 00:17:18,659
或按“类型”。
or by "genres."

352
00:17:18,660 --> 00:17:21,052
这也很好，因为如果您或您的同事
This is also good, because if you or maybe a colleague

353
00:17:21,051 --> 00:17:23,009
被电子表格弄得乱七八糟
are sort of messing around with the spreadsheet

354
00:17:23,009 --> 00:17:26,338
他们通过向左或向右拖动来重新排列列，
and they rearrange the columns by dragging them left or right,

355
00:17:26,338 --> 00:17:30,119
您在代码中使用的任何数字，0、1、2及以上，
any numbers you have used in your code, 0, 1, 2 on up,

356
00:17:30,119 --> 00:17:34,389
如果您的同事重新排序了这些列，则可能突然不正确。
could suddenly be incorrect if your colleague has reordered those columns.

357
00:17:34,390 --> 00:17:37,590
因此，使用字典阅读器往往会更健壮，因为它
So using a dictionary reader tends to be a little more robust, because it

358
00:17:37,589 --> 00:17:40,479
使用标题，而不是单纯的数字。
uses the titles, not the mere numbers.

359
00:17:40,480 --> 00:17:43,230
如果有人，您自己或其他人仍然会犯错误，
It's still fallible if someone, yourself or someone else,

360
00:17:43,230 --> 00:17:47,978
更改第一行中的值，并重命名标题或体裁。
changes the values in that very first row and renames titles or genres.

361
00:17:47,978 --> 00:17:49,270
然后事情会破裂。
Then things are going to break.

362
00:17:49,269 --> 00:17:51,269
但在那一点上，我们一定要怪你
But at that point, we kind of have to blame you

363
00:17:51,269 --> 00:17:53,729
因为没有跟踪您的代码和数据。
for not having kept track of your code versus your data.

364
00:17:53,730 --> 00:17:55,020
但是仍然有风险。
But still a risk.

365
00:17:55,019 --> 00:17:58,444
因此，我将在这里将其更改为字典阅读器或DictReader。
So I'm going to change this to dictionary reader or DictReader here.

366
00:17:58,444 --> 00:18:00,569
几乎我其余的代码可以相同
And pretty much the rest of my code can be the same

367
00:18:00,569 --> 00:18:02,969
除非我在第5行上不需要此hack。
except I don't need this hack here on line 5.

368
00:18:02,970 --> 00:18:06,750
我不需要一开始就跳到下一行，
I don't need to just skip over to the next row from the get-go,

369
00:18:06,750 --> 00:18:10,889
因为我现在希望字典阅读器处理阅读过程
because I now want the dictionary reader to handle the process of reading

370
00:18:10,890 --> 00:18:11,985
我的第一行。
that first row for me.

371
00:18:11,984 --> 00:18:13,859
但是否则，其他所有东西都保持不变
But otherwise, everything else stays the same

372
00:18:13,859 --> 00:18:15,692
除了最后一行，我现在认为
except for this last line, where now I think

373
00:18:15,692 --> 00:18:21,299
我现在可以将row用作字典，而不能用作列表本身，
I can now use row as a dictionary, not as a list per se,

374
00:18:21,299 --> 00:18:24,879
并从每个给定的行中专门打印出标题。
and print out specifically the title from each given row.

375
00:18:24,880 --> 00:18:27,690
因此，让我继续运行，再次运行python of favorite.py。
So let me go ahead and run python of favorites.py again.

376
00:18:27,690 --> 00:18:31,480
瞧，我得到了相同的结果，其中有数百个。
And voila, it looks like I got the same result, several hundred of them.

377
00:18:31,480 --> 00:18:34,260
但我要指出的是，如果我们实际上
But let me stipulate that it's doing the same thing if we actually

378
00:18:34,259 --> 00:18:36,489
并排比较了两者。
compared both of those side-by-side.

379
00:18:36,490 --> 00:18:36,990
好的。
All right.

380
00:18:36,990 --> 00:18:39,180
在我继续前进之前，先进行实际的扩充
Before I forge ahead now to actually augment this

381
00:18:39,180 --> 00:18:44,610
新功能，对此Python脚本有任何疑问或困惑
with new functionality, any questions or confusion on this Python script

382
00:18:44,609 --> 00:18:49,529
我们只是写了一个打开文件的文件，用阅读器或DictReader包装它，
we just wrote to open a file, wrap it with a reader or DictReader,

383
00:18:49,529 --> 00:18:54,509
然后一次遍历行，打印标题？
and then iterate over the rows one at a time, printing the titles?

384
00:18:54,509 --> 00:18:56,509
有任何疑问，对语法完全困惑吗？
Any questions, confusion on syntax at all?

385
00:18:56,509 --> 00:18:57,009
没关系。
It's OK.

386
00:18:57,009 --> 00:18:59,369
我们只认识或见过Python一个星期。
We've only known or seen Python for a week.

387
00:18:59,369 --> 00:19:01,379
如果还很新，那很好。
It's fine if it's still quite new.

388
00:19:01,380 --> 00:19:04,115
什么，布莱恩，我们应该解决？
Anything, Brian, we should address?

389
00:19:04,115 --> 00:19:04,740
布莱恩·于：是的。
BRIAN YU: Yeah.

390
00:19:04,740 --> 00:19:08,800
那么为什么不需要使用语法关闭文件呢？
So why is it that you don't need to close the file using the syntax

391
00:19:08,799 --> 00:19:10,189
您正在这里使用吗？
that you're using right here?

392
00:19:10,190 --> 00:19:11,732
DAVID J. MALAN：很好的问题。
DAVID J. MALAN: Really good question.

393
00:19:11,731 --> 00:19:15,249
上周，我更自学地使用了open。
Last week, I more pedantically used open on its own.

394
00:19:15,250 --> 00:19:19,209
然后我后来使用了与文件关联的关闭函数
And then I later used a close function that was associated with the file

395
00:19:19,210 --> 00:19:20,470
我刚打开的。
that I had just opened.

396
00:19:20,470 --> 00:19:23,800
现在，如果您愿意，可以使用更Python化的方式来做事，
Now, the more Pythonic way to do things, if you will,

397
00:19:23,799 --> 00:19:27,369
实际上是将它与关键字一起使用，这在C语言中是不存在的。
is actually to use this with keyword, which didn't exist in C.

398
00:19:27,369 --> 00:19:29,829
而且它只是在Python中往往是有用的功能
And it just tends to be a useful feature in Python

399
00:19:29,829 --> 00:19:35,469
这样，如果您以打开的句点表示，它将为您打开文件。
whereby if you say with open, dot dot dot, it will open the file for you.

400
00:19:35,470 --> 00:19:39,280
然后，只要您的代码缩进其中，它就会保持打开状态
Then it will remain open so long as your code is indented inside

401
00:19:39,279 --> 00:19:41,409
与关键字块。
of that with keywords block.

402
00:19:41,410 --> 00:19:43,780
程序结束后，
And as soon as you get to the end of your program,

403
00:19:43,779 --> 00:19:45,731
它将自动为您关闭。
it will automatically be closed for you.

404
00:19:45,731 --> 00:19:48,189
因此，这是Python在某种意义上的其中一项功能
So this is one of these features where Python in some sense

405
00:19:48,190 --> 00:19:50,770
试图保护我们免受自己的伤害。
is trying to protect us from ourselves.

406
00:19:50,769 --> 00:19:52,899
对于我本人来说，这可能很常见
It's probably pretty common for humans, myself

407
00:19:52,900 --> 00:19:55,000
包括，忘记关闭文件。
included, to forget to close your file.

408
00:19:55,000 --> 00:19:57,580
这可能会带来永久保存问题。
That can create problems with saving things permanently.

409
00:19:57,579 --> 00:19:59,989
正如我们从C中了解到的那样，它可能导致内存泄漏。
It can create memory leaks, as we know from C.

410
00:19:59,990 --> 00:20:02,740
所以with关键字只是假设我不会成为白痴
So the with keyword just assumes that I'm not going to be an idiot

411
00:20:02,740 --> 00:20:04,150
忘记关闭文件了。
and forget to close the file.

412
00:20:04,150 --> 00:20:08,050
Python会自动为我完成此操作。
Python is going to do it for me automatically.

413
00:20:08,049 --> 00:20:10,869
其他问题或困惑，布莱恩？
Other questions or confusions, Brian?

414
00:20:10,869 --> 00:20:13,689
布莱恩·于（Brian Yu）：DictReader如何知道该标题
BRIAN YU: How does DictReader know that Title

415
00:20:13,690 --> 00:20:16,270
里面的键名是什么？
is the name of the key inside of the dictionary?

416
00:20:16,269 --> 00:20:18,019
DAVID J. MALAN：真的是一个很好的问题。
DAVID J. MALAN: Really good question, too.

417
00:20:18,019 --> 00:20:22,089
因此它是由Python语言的作者设计的
So it is designed by the authors of the Python language

418
00:20:22,089 --> 00:20:25,449
看文件的第一行，
to look at the very first row in the file,

419
00:20:25,450 --> 00:20:29,380
在第一行的逗号中将其拆分，
split it on the commas in that very first row,

420
00:20:29,380 --> 00:20:34,090
并假设第一个逗号之前的第一个单词或短语
and just assume that the first word or phrase before the first comma

421
00:20:34,089 --> 00:20:37,269
是第一列的名称，第二个单词
is the name of the first column, that the second word

422
00:20:37,269 --> 00:20:42,469
第一个逗号之后的词组或短语是第二列的名称，
or phrase after the first comma is the name of the second column,

423
00:20:42,470 --> 00:20:43,310
等等。
and so forth.

424
00:20:43,309 --> 00:20:47,499
因此，就像CSV的惯例一样，DictReader只是一种假设，
So a DictReader just presumes, as is the convention with CSVs,

425
00:20:47,500 --> 00:20:51,279
您的第一行将包含您的标题
that your first row is going to contain the headings that you

426
00:20:51,279 --> 00:20:53,289
想使用来引用那些列。
want to use to refer to those columns.

427
00:20:53,289 --> 00:20:56,859
如果您的CSV恰好没有这样的标题，
If your CSV happens not to have such a heading whereby it just

428
00:20:56,859 --> 00:20:59,049
在第一行跳到真实数据，
jumps right in on the first row to real data,

429
00:20:59,049 --> 00:21:02,139
那么至少您将无法正确使用DictReader
then you're not going to be able to use a DictReader correctly, at least

430
00:21:02,140 --> 00:21:04,670
并非没有一些手动配置。
not without some manual configuration.

431
00:21:04,670 --> 00:21:05,170
好的。
All right.

432
00:21:05,170 --> 00:21:06,840
所以，让我们继续-
So let's go ahead and--

433
00:21:06,839 --> 00:21:08,589
现在我觉得这里真是一团糟。
now I feel like there's a whole mess here.

434
00:21:08,589 --> 00:21:10,561
其中一些节目非常受欢迎。
And some of these shows are pretty popular.

435
00:21:10,561 --> 00:21:13,269
当我浏览此内容时，我肯定会看到一些重复。
And as I'm glancing over this, I definitely see some duplication.

436
00:21:13,269 --> 00:21:15,009
一大群人喜欢The Office。
A whole bunch of you like The Office.

437
00:21:15,009 --> 00:21:17,529
你们所有人都喜欢《绝命毒师》，《权力的游戏》，
A whole bunch of you like Breaking Bad, Game of Thrones,

438
00:21:17,529 --> 00:21:19,279
还有很多其他节目
and a whole bunch of other shows, as well.

439
00:21:19,279 --> 00:21:21,249
我想，如果我们做些更好的话，那会更好
So it would be nicer, I think, if we kind of

440
00:21:21,250 --> 00:21:25,480
仅查看唯一值即可缩小我们查看此数据的范围。
narrow the scope of our look at this data by just looking at unique values.

441
00:21:25,480 --> 00:21:26,807
您正在寻找独特的价值。
You're looking at unique value.

442
00:21:26,807 --> 00:21:29,140
因此，不只是从头到尾遍历文件，
So rather than just iterate over the file top to bottom,

443
00:21:29,140 --> 00:21:31,690
逐个打印一个标题，为什么
printing out one title after another, why

444
00:21:31,690 --> 00:21:34,330
我们不继续收集所有这些数据
don't we go ahead and sort of accumulate all of this data

445
00:21:34,329 --> 00:21:38,799
在某种数据结构中，这样我们就可以丢弃重复的值
in some kind of data structure so that we can throw away duplicate values

446
00:21:38,799 --> 00:21:42,909
然后只打印出我们累积的唯一标题？
and then only print out the unique titles that we've accumulated?

447
00:21:42,910 --> 00:21:44,630
所以我敢打赌，我们可以通过几种方式做到这一点。
So I bet we can do this in a few ways.

448
00:21:44,630 --> 00:21:47,650
但是，如果我们回想一下上周对字典的演示，
But if we think back to last week's demonstration of our dictionary,

449
00:21:47,650 --> 00:21:50,388
您会记得我使用了所谓的集合。
you'll recall that I used what was called a set.

450
00:21:50,387 --> 00:21:52,929
我将继续创建一个名为title的变量
And I'm going to go ahead and create a variable called titles

451
00:21:52,930 --> 00:21:55,180
并将其设置为等于“ set”的值。
and set it equal to something called set.

452
00:21:55,180 --> 00:21:57,310
集合只是价值的集合。
And a set is just a collection of values.

453
00:21:57,309 --> 00:21:58,539
有点像清单。
It's kind of like a list.

454
00:21:58,539 --> 00:22:00,579
但这为我消除了重复。
But it eliminates duplicates for me.

455
00:22:00,579 --> 00:22:02,859
这似乎恰好是特征
And that would seem to be exactly the characteristic

456
00:22:02,859 --> 00:22:04,869
我想要这个程序。
that I want for this program.

457
00:22:04,869 --> 00:22:08,559
现在，而不是打印每个标题，现在为时过早
Now, instead of printing each title, which is now premature

458
00:22:08,559 --> 00:22:10,479
如果我想先过滤掉重复项，
if I want to first filter out duplicates,

459
00:22:10,480 --> 00:22:11,990
我将继续执行此操作。
I'm going to go ahead and do this.

460
00:22:11,990 --> 00:22:17,290
我将继续使用添加功能将其添加到标题集中
I'm going to go ahead and add to the titles set using the add function

461
00:22:17,289 --> 00:22:19,569
当前行的标题。
the current row's title.

462
00:22:19,569 --> 00:22:21,249
再说一次，我现在不打印它。
So again, I'm not printing it now.

463
00:22:21,250 --> 00:22:25,509
我改为在标题集中添加该特定标题。
I'm instead adding to the title set that particular title.

464
00:22:25,509 --> 00:22:27,189
如果已经存在，没什么大不了的。
And if it's there already, no big deal.

465
00:22:27,190 --> 00:22:29,260
Python中的设置数据结构正在发展
The set data structure in Python is going

466
00:22:29,259 --> 00:22:30,999
为我扔掉重复的东西。
to throw away the duplicates for me.

467
00:22:31,000 --> 00:22:33,310
而且只会继续保持唯一性。
And it's only going to go ahead and keep the uniques.

468
00:22:33,309 --> 00:22:37,329
现在，诚然，在文件的底部，我需要做更多的工作。
Now, at the bottom of my file, I need to do a little more work, admittedly.

469
00:22:37,329 --> 00:22:40,989
现在，我必须遍历该集合以仅打印那些唯一的标题。
Now I have to iterate over the set to print out only those unique titles.

470
00:22:40,990 --> 00:22:41,740
因此，让我这样做。
So let me do this.

471
00:22:41,740 --> 00:22:46,555
对于标题中的标题，请继续并打印标题。
For title in titles, go ahead and print out title.

472
00:22:46,555 --> 00:22:49,180
这就是Python真正变得易于使用的地方了吧？
And this is where Python just gets really user-friendly, right?

473
00:22:49,180 --> 00:22:53,050
你不必做int我得到0，我小于n，或其他。
You don't have to do int i get 0, i less than n, or whatever.

474
00:22:53,049 --> 00:22:55,539
您只能在标题中说出标题。
You can just say for title in titles.

475
00:22:55,539 --> 00:22:59,199
如果标题的变量是数据结构的类型
And if the title's variable is the type of data structure

476
00:22:59,200 --> 00:23:04,690
您可以遍历的列表（如果是列表或集合）
that you can iterate over, which it will be if it's a list or if it's a set

477
00:23:04,690 --> 00:23:06,940
甚至是字典，也可以是另一种数据结构
or even if it's a dictionary, another data structure

478
00:23:06,940 --> 00:23:11,180
我们上周在Python中看到过，Python中的for循环只会知道该怎么做。
we saw last week in Python, the for loop in Python will just know what to do.

479
00:23:11,180 --> 00:23:15,880
这将遍历标题集中的所有标题。
This will loop over all of the titles in the titles set.

480
00:23:15,880 --> 00:23:18,700
因此，让我继续保存该文件并立即进行
So let me go ahead and save this file and go ahead now

481
00:23:18,700 --> 00:23:20,920
并运行“ favourites.py”的python。
and run python of favorites.py.

482
00:23:20,920 --> 00:23:25,240
看起来，列表在某些方面有所不同。
And it looks like, yeah, the list is different in some way.

483
00:23:25,240 --> 00:23:29,463
但是我向上滚动时看到的结果更少，肯定比以前少，
But I'm seeing fewer results as I scroll up, definitely fewer than before,

484
00:23:29,462 --> 00:23:31,629
因为我的滚动条没有跳得那么远。
because my scrollbar didn't jump nearly as far down.

485
00:23:31,630 --> 00:23:33,260
但老实说，这有点混乱。
But honestly, this is kind of a mess.

486
00:23:33,259 --> 00:23:34,659
让我们继续进行排序。
Let's go ahead and sort this.

487
00:23:34,660 --> 00:23:37,502
现在，在C语言中，对事物进行排序会有些痛苦。
Now, in C, it would have been kind of a pain to sort things.

488
00:23:37,501 --> 00:23:39,459
我们可能必须清除伪代码，
We'd have to whip out the pseudocode, probably,

489
00:23:39,460 --> 00:23:41,460
对于气泡排序，选择排序，或者，上帝禁止，
for bubble sort, selection sort, or, god forbid,

490
00:23:41,460 --> 00:23:43,270
合并排序，然后自己实现。
merge sort and then implement it ourselves.

491
00:23:43,269 --> 00:23:47,209
但是，没有，Python确实带来了众所周知的厨房功能库。
But no, with Python comes, really, the proverbial kitchen sink of functions.

492
00:23:47,210 --> 00:23:49,510
因此，如果您想对这个集合进行排序，您知道吗？
So if you want to sort this set, you know what?

493
00:23:49,509 --> 00:23:50,949
只是说您想对它进行排序。
Just say you want it sorted.

494
00:23:50,950 --> 00:23:53,890
Python中有一个称为sorted的函数
There is a function in Python called sorted

495
00:23:53,890 --> 00:23:57,257
它将使用那些更好的算法之一-也许是合并排序。
that will use one of those better algorithms-- maybe it's merge sort.

496
00:23:57,257 --> 00:23:58,840
也许这就是所谓的quicksort。
Maybe it's something called quicksort.

497
00:23:58,839 --> 00:24:00,349
也许完全是另外一回事。
Maybe it's something else altogether.

498
00:24:00,349 --> 00:24:02,379
它不会使用n平方大的O。
It's not going to use a big O of n squared sort.

499
00:24:02,380 --> 00:24:06,940
Python的某个人可能已经花了一些时间为我们实现更好的排序。
Someone at Python probably has spent the time implementing a better sort for us.

500
00:24:06,940 --> 00:24:08,817
但是它将继续进行，并为我整理场景。
But it will go ahead and sort the set for me.

501
00:24:08,817 --> 00:24:10,400
现在，让我继续并再次执行此操作。
Now let me go ahead and do this again.

502
00:24:10,400 --> 00:24:13,360
让我增加终端窗口的大小并重新运行python
Let me increase the size of my terminal window and rerun python

503
00:24:13,359 --> 00:24:15,069
的收藏夹。
of favorites.py.

504
00:24:15,069 --> 00:24:15,639
好的。
OK.

505
00:24:15,640 --> 00:24:19,330
现在我们有一个有趣的分类
And now we have an interesting assortment

506
00:24:19,329 --> 00:24:22,569
对我来说，更容易让我的想法包罗万象，
of shows that's easier for me to wrap my mind around,

507
00:24:22,569 --> 00:24:25,742
因为我现在把它整理在这里了。
because I have it now sorted here.

508
00:24:25,742 --> 00:24:28,659
确实，如果我一直向上滚动，我们应该看所有的节目
And indeed, if I scroll all the way up, we should see all of the shows

509
00:24:28,660 --> 00:24:32,257
以数字或句号开头，
beginning with numbers or a period, which

510
00:24:32,257 --> 00:24:34,090
可能只是有人在玩耍，
might have just been someone playing around,

511
00:24:34,089 --> 00:24:36,289
其次是A字，B字，依此类推。
followed by the A words, the B words, and so forth.

512
00:24:36,289 --> 00:24:38,706
因此，现在我们可以更轻松地将精力集中在这一点上了。
So now it's a little easier to wrap our minds around this.

513
00:24:38,707 --> 00:24:39,760
但是出事了。
But something's up.

514
00:24:39,759 --> 00:24:44,109
我觉得你们很多人都喜欢《阿凡达：最后的气宗》。
I feel like a lot of you like Avatar: The Last Airbender.

515
00:24:44,109 --> 00:24:47,979
但是我确实看到了四个不同的时间。
And yet I'm seeing it, indeed, four different times.

516
00:24:47,980 --> 00:24:49,720
但我认为我们正在对此进行过滤
But I thought we were filtering this down

517
00:24:49,720 --> 00:24:53,350
通过使用该set结构来获得唯一性。
to uniques by using that set structure.

518
00:24:53,349 --> 00:24:54,339
发生什么了？
So what's going on?

519
00:24:54,339 --> 00:24:56,199
实际上，如果我继续滚动，我会很漂亮
And in fact, if I keep scrolling, I'm pretty

520
00:24:56,200 --> 00:24:59,080
我肯定在这里看到了更多的重复。
sure I saw more duplicates in here.

521
00:24:59,079 --> 00:25:01,839
BoJack骑士，坏蛋，坏蛋，
BoJack Horseman, Breaking Bad, Breaking Bad,

522
00:25:01,839 --> 00:25:07,809
布鲁克林九号，布鲁克林九号，CS50有几种不同的口味。
Brooklyn Nine-Nine, Brooklyn Nine-Nine, CS50 in several different flavors.

523
00:25:07,809 --> 00:25:10,209
是的，它一直在继续。
And yes, it keeps going.

524
00:25:10,210 --> 00:25:11,110
朋友们。
Friends.

525
00:25:11,109 --> 00:25:13,049
因此，我看到了很多重复的值。
So I see a lot of duplicate values.

526
00:25:13,049 --> 00:25:14,979
发生什么了？
So what's going on?

527
00:25:14,980 --> 00:25:17,960
是的， [？加达纳？ ？]
Yeah, [? Gadana? ?]

528
00:25:17,960 --> 00:25:22,480
听众：是的，所以您当前的排序方式不区分大小写-抱歉，
AUDIENCE: Yeah, so your current sort is case insensitive-- sorry,

529
00:25:22,480 --> 00:25:26,680
区分大小写，这意味着如果有人用大写字母拼写了化身
is case sensitive, meaning that if someone spells avatar with capital

530
00:25:26,680 --> 00:25:30,800
A在某些地方，那么每次都会得到不同的结果。
A's in some places, then it's going to be a different result each time.

531
00:25:30,799 --> 00:25:32,049
DAVID J. MALAN：好的，是的。
DAVID J. MALAN: Yeah, exactly.

532
00:25:32,049 --> 00:25:35,529
在大写方面，你们中有些人并不勤奋。
Some of you weren't quite diligent when it came to capitalization.

533
00:25:35,529 --> 00:25:38,047
因此，实际上，现实是[[？加达纳（Gadana？）笔记，
And so in fact, the reality is, as [? Gadana ?] notes,

534
00:25:38,048 --> 00:25:39,840
大写字母存在差异。
that there's differences in capitalization.

535
00:25:39,839 --> 00:25:41,089
现在，我们已经解决了这个问题。
Now, we've addressed this before.

536
00:25:41,089 --> 00:25:43,229
实际上，当您实施拼写检查器时，
In fact, when you implemented your spell checker,

537
00:25:43,230 --> 00:25:44,980
当你当你已经要解决这个问题的时候
you had to deal with this already when you

538
00:25:44,980 --> 00:25:46,780
拼写检查任意文本。
were spell checking an arbitrary text.

539
00:25:46,779 --> 00:25:48,159
有些词可能大写。
Some words might be capitalized.

540
00:25:48,160 --> 00:25:50,300
有些可能全部为小写，全部为大写。
Some might be all lowercase, all uppercase.

541
00:25:50,299 --> 00:25:52,809
您想容忍不同的机壳。
And you wanted to tolerate different casings.

542
00:25:52,809 --> 00:25:55,839
因此，我们可能通过强制执行所有操作来解决此问题
And so we probably solved this by just forcing everything

543
00:25:55,839 --> 00:25:58,539
大写或小写的所有东西，
to uppercase or everything to lowercase and doing things,

544
00:25:58,539 --> 00:26:00,499
因此，不区分大小写。
therefore, case insensitively.

545
00:26:00,500 --> 00:26:01,750
所以在这里给我一点时间。
So give me just a moment here.

546
00:26:01,750 --> 00:26:06,006
我将继续在这里快速更改我的表单。
And I'm going to go ahead and make a quick change to my form here.

547
00:26:06,007 --> 00:26:07,840
让我们继续以这种方式更改它
Let's go ahead and change this in such a way

548
00:26:07,839 --> 00:26:11,019
实际上我们将所有内容都强制为大写或小写。
that we actually force everything to uppercase or lowercase.

549
00:26:11,019 --> 00:26:13,759
哪一个都没关系，但是我们需要规范化事情，
Doesn't really matter which, but we need to canonicalize things,

550
00:26:13,759 --> 00:26:14,859
可以这么说。
so to speak, in some way.

551
00:26:14,859 --> 00:26:18,789
规范化事物只是意味着格式化所有数据
And to canonicalize things just means to format all of your data

552
00:26:18,789 --> 00:26:20,019
以某种标准的方式。
in some standard way.

553
00:26:20,019 --> 00:26:22,389
所以[加达纳（Gadana）的观点，让我们标准化
So to [? Gadana's ?] point, let's just standardize

554
00:26:22,390 --> 00:26:23,920
事物的大写。
the capitalization of things.

555
00:26:23,920 --> 00:26:25,600
也许全部大写，全部小写。
Maybe all uppercase, all lowercase.

556
00:26:25,599 --> 00:26:27,259
我们只需要作出判断即可。
We just need to make a judgment call.

557
00:26:27,259 --> 00:26:29,426
因此，我将继续进行一些调整。
So I'm going to go ahead and make a few tweaks here.

558
00:26:29,426 --> 00:26:30,669
我仍然要使用一套。
I'm still going to use a set.

559
00:26:30,670 --> 00:26:33,190
我仍将像以前一样阅读CSV。
I'm still going to read the CSV as before.

560
00:26:33,190 --> 00:26:37,270
但是，不只是添加带有行括号标题的标题，
But instead of just adding the title with row bracket title,

561
00:26:37,269 --> 00:26:40,179
我将继续将其强制为大写，只是
I'm going to go ahead and force it to uppercase, just

562
00:26:40,180 --> 00:26:42,850
只是为了统一起见，是任意的。
arbitrarily, just for the sake of uniformity.

563
00:26:42,849 --> 00:26:45,609
然后，让我们继续检查此处到底发生了什么。
And then let's go ahead and check what exactly has happened here.

564
00:26:45,609 --> 00:26:47,049
我不会更改任何其他内容。
I'm not going to change anything else.

565
00:26:47,049 --> 00:26:49,382
但是，让我继续前进，增加终端的大小
But let me go ahead and increase the size of my terminal

566
00:26:49,383 --> 00:26:52,600
窗口中，重新运行“ favourites.py”的python。
window, rerun python of favorites.py.

567
00:26:52,599 --> 00:26:53,516
和瞧。
And voila.

568
00:26:53,517 --> 00:26:55,600
只是因为我不懂，所以阅读起来有点困难
It's a little harder to read, just because I'm not

569
00:26:55,599 --> 00:26:56,769
习惯于阅读所有大写字母。
used to reading all caps.

570
00:26:56,769 --> 00:26:58,686
有点像我们在大喊大叫。
Kind of looks like we're yelling at ourselves.

571
00:26:58,686 --> 00:27:01,599
但我看不到-等一下。
But I don't see-- wait a minute.

572
00:27:01,599 --> 00:27:05,559
我仍然在这里两次看到办公室。
I still see The Office over here twice.

573
00:27:05,559 --> 00:27:11,919
如果我一直在这里滚动，那么到目前为止，我会看到“陌生人事物”和“ Strainger Things”。
If I keep scrolling here, so far, I see Stranger Things and Strainger Things.

574
00:27:11,920 --> 00:27:13,570
看起来像是一个错字。
That just looks like a typo.

575
00:27:13,569 --> 00:27:15,679
不过，我看到了两个夏洛克。
I see two Sherlocks, though.

576
00:27:15,680 --> 00:27:17,380
这有点可疑。
This is a little suspicious.

577
00:27:17,380 --> 00:27:21,730
所以 [？加达纳，？]您和我似乎还没有完全解决问题。
So [? Gadana, ?] you and I don't seem to have solved things fully.

578
00:27:21,730 --> 00:27:24,220
而且这个还有些微妙。
And this one's a little more subtle.

579
00:27:24,220 --> 00:27:30,970
我可能还要对我的数据做些什么以确保我们删除重复项？
What more should I perhaps do to my data to ensure we get duplicates removed?

580
00:27:30,970 --> 00:27:32,200
奥利维亚？
Olivia?

581
00:27:32,200 --> 00:27:34,407
听众：可能在边缘处修剪。
AUDIENCE: Maybe trim around the edges.

582
00:27:34,406 --> 00:27:35,989
DAVID J. MALAN：修剪边缘。
DAVID J. MALAN: Trim around the edges.

583
00:27:35,990 --> 00:27:37,480
我喜欢这样的声音，但是你是什么意思呢？
I like the sound of that, but what do you mean?

584
00:27:37,480 --> 00:27:38,320
那是做什么的？
What does that do?

585
00:27:38,319 --> 00:27:40,861
听众：哦，像这样，剪掉多余的空间，以防有人
AUDIENCE: Oh, like, trim off the extra spaces in case someone

586
00:27:40,862 --> 00:27:42,940
在单词之前或之后放置一个空格。
put a space before or after the words.

587
00:27:42,940 --> 00:27:44,230
DAVID J. MALAN：好的，是的。
DAVID J. MALAN: Yeah, exactly.

588
00:27:44,230 --> 00:27:47,140
对于人类而言，有意或无意间，
It's pretty common for humans, intentionally or accidentally,

589
00:27:47,140 --> 00:27:48,920
打他们不应该去的空格键。
to hit the Space bar where they shouldn't.

590
00:27:48,920 --> 00:27:51,790
实际上，我有点推断我打赌一个或多个
And in fact, I'm kind of inferring that I bet one or more

591
00:27:51,789 --> 00:27:55,142
你们中的人不小心输入了Sherlock，空格键，然后决定，
of you accidentally typed Sherlock, space, and then decided,

592
00:27:55,143 --> 00:27:55,810
不，就是这样。
nope, that's it.

593
00:27:55,809 --> 00:27:57,039
我没有输入其他任何内容。
I'm not typing anything else.

594
00:27:57,039 --> 00:28:00,739
但是，即使我们不能很清楚地看到它，该空间还是存在的。
But that space, even though we can't quite see it obviously, is there.

595
00:28:00,740 --> 00:28:04,060
当我们进行字符串比较或设置数据结构进行字符串比较时，
And when we do a string comparison or when the set data structure does that,

596
00:28:04,059 --> 00:28:08,109
在进行这些比较时实际上会注意到它。
it's actually going to be noticed when doing those comparisons.

597
00:28:08,109 --> 00:28:10,091
因此，它们将不会是相同的。
And therefore they're not going to be the same.

598
00:28:10,092 --> 00:28:11,800
因此，我可以通过几种不同的方式来做到这一点。
So I can do this in a few different ways.

599
00:28:11,799 --> 00:28:15,079
但是事实证明，在Python中，您可以将函数链接在一起，
But it turns out, in Python, you can chain functions together,

600
00:28:15,079 --> 00:28:17,389
这也是一种花哨的功能。
which is also, too, kind of a fancy feature.

601
00:28:17,390 --> 00:28:18,650
注意我在这里做什么。
Notice what I'm doing here.

602
00:28:18,650 --> 00:28:21,070
我仍在访问标题集。
I'm still accessing the titles set.

603
00:28:21,069 --> 00:28:23,709
我正在为其添加以下值。
I'm adding the following value to it.

604
00:28:23,710 --> 00:28:27,610
我要添加值行括号标题，但不完全是。
I'm adding the value row bracket title, but not quite.

605
00:28:27,609 --> 00:28:30,879
用Python来说，这是一个字符串或一个str。
That is a string or an str, in Python speak.

606
00:28:30,880 --> 00:28:33,130
我要去掉它，
I'm going to go ahead and strip it, which

607
00:28:33,130 --> 00:28:36,340
意味着，如果我们查看此功能的文档，就Olivia而言，
means if we look up the documentation for this function, to Olivia's point,

608
00:28:36,339 --> 00:28:39,129
它会剥离或修剪所有空白区域
it's going to strip off or trim all of the white space

609
00:28:39,130 --> 00:28:41,200
左边，右边的所有空白，
to the left, all of the white space to the right,

610
00:28:41,200 --> 00:28:43,840
是空格键还是Enter键
whether that's the Space bar or the Enter key

611
00:28:43,839 --> 00:28:46,869
或Tab字符或其他一些东西。
or the Tab character or a few other things, as well.

612
00:28:46,869 --> 00:28:50,199
它只是要摆脱前导和尾随的空白。
It's just going to get rid of leading and trailing white space.

613
00:28:50,200 --> 00:28:53,650
然后，剩下的东西，我将继续执行，并强制执行所有操作
And then whatever's left over, I'm going to go ahead and force everything

614
00:28:53,650 --> 00:28:56,810
以[？加达纳（Gadana）的建议。
to uppercase in the spirit of [? Gadana's ?] suggestion, too.

615
00:28:56,809 --> 00:29:00,469
因此，我们现在结合了两个好主意，以对数据进行真正的处理，
So we're sort of combining two good ideas now to really massage the data,

616
00:29:00,470 --> 00:29:02,470
如果可以的话，将其转换为更干净的格式。
if you will, into a cleaner format.

617
00:29:02,470 --> 00:29:04,780
这是一个现实世界的现实。
And this is such a real-world reality.

618
00:29:04,779 --> 00:29:09,587
不能相信您和我的人类以我们应有的方式输入数据。
Humans, you and I, cannot be trusted to input data the way we are supposed to.

619
00:29:09,587 --> 00:29:11,379
有时候都是小写，因为我们
Sometimes it's all lowercase, because we're

620
00:29:11,380 --> 00:29:13,463
有点懒惰或像社交媒体一样，
being a little lazy or a little social media-like,

621
00:29:13,462 --> 00:29:16,119
即使我们正在从亚马逊退房并尝试
even if we're checking out from Amazon and trying

622
00:29:16,119 --> 00:29:18,309
输入有效的邮政地址。
to input a valid postal address.

623
00:29:18,309 --> 00:29:22,126
有时都是首都，因为我可以想到一生中的一些人
Sometimes it's all capitals, because I can think of a few people in my life

624
00:29:22,126 --> 00:29:24,459
那些还不太了解Caps Lock的人。
who don't quite understand the Caps Lock thing just yet.

625
00:29:24,460 --> 00:29:26,710
因此，事情可能全部全部大写了。
And so things might be all capitalized instead.

626
00:29:26,710 --> 00:29:30,580
这对要求精度的计算机系统不利，
This is not good for computer systems that require precision,

627
00:29:30,579 --> 00:29:32,439
我们在第0周的重点。
to our emphasis in week 0.

628
00:29:32,440 --> 00:29:35,140
因此，按摩数据意味着要清理数据，
And so massaging data means cleaning it up,

629
00:29:35,140 --> 00:29:38,500
做一些不会真正改变数据含义的变异
doing some mutations that don't really change the meaning of the data

630
00:29:38,500 --> 00:29:41,740
但将其规范化，标准化，以便您
but canonicalize it, standardize it, so that you're

631
00:29:41,740 --> 00:29:44,950
比较苹果和苹果，可以这么说，不是苹果和橙子。
comparing apples and apples, so to speak, not apples and oranges.

632
00:29:44,950 --> 00:29:47,950
好吧，让我继续在更大的终端上再次运行
Well, let me go ahead and run this again in my bigger terminal

633
00:29:47,950 --> 00:29:50,140
窗口，favourites.py的python。
window, python of favorites.py.

634
00:29:50,140 --> 00:29:50,710
瞧。
Voila.

635
00:29:50,710 --> 00:29:55,220
在向上滚动，向上滚动，向上滚动时，我认为我们处于一个更好的位置。
In scrolling up, up, up, I think we're in a better place.

636
00:29:55,220 --> 00:29:57,520
我现在只看到一个办公室。
I only see one Office now.

637
00:29:57,519 --> 00:30:01,509
如果我不断向上滚动，我仍然看到错别字，
And if I keep scrolling up and up and up, I'm seeing typos still,

638
00:30:01,509 --> 00:30:03,909
但与空白无关。
but nothing related to white space.

639
00:30:03,910 --> 00:30:08,340
而且我认为目前我们拥有更清晰的唯一标题列表。
And I think we have a much cleaner unique list of titles at this point.

640
00:30:08,339 --> 00:30:10,799
当然，如果我们向上滚动，我将不得不
Of course, if we scroll up, I would have to be

641
00:30:10,799 --> 00:30:14,969
如果我想检测印刷错误，那就聪明多了。
a lot more clever if I want to detect things like typographical errors.

642
00:30:14,970 --> 00:30:19,870
你们中的一位似乎非常努力地把FRI
It looks like one of you was very diligent about putting F.R.I.

643
00:30:19,869 --> 00:30:22,969
依此类推，但最后却感到无聊，而在最后一个时期就不再做。
and so forth but then got bored at the end and left off the last period.

644
00:30:22,970 --> 00:30:25,470
但这将在您接受用户输入时发生。
But that's going to happen when you're taking in user input.

645
00:30:25,470 --> 00:30:28,140
我们当然拥有CS50的所有这些变体。
We've, of course, got all these variants of CS50.

646
00:30:28,140 --> 00:30:30,570
这将是一团糟清理，因为现在你
That's going to be a mess to clean up, because now you

647
00:30:30,569 --> 00:30:35,129
可以想象必须添加一大堆if条件，else和else ifs
can imagine having to add a whole bunch of if conditions and elses and else ifs

648
00:30:35,130 --> 00:30:38,160
如果我们想规范化，请清理所有这些
to clean all of that up if we do want to canonicalize

649
00:30:38,160 --> 00:30:41,920
将CS50的所有不同口味都引用为“ CS50”。
all different flavors of CS50 as, quote unquote, "CS50."

650
00:30:41,920 --> 00:30:43,890
因此，这是一个非常湿滑的斜坡。
So this is a very slippery slope.

651
00:30:43,890 --> 00:30:47,010
您和我可能会开始编写大量数据以清除此问题。
You and I could start writing a huge amount of data just to clean this up.

652
00:30:47,009 --> 00:30:50,939
但这是处理现实世界数据时的现实。
But that's the reality when dealing with real-world data.

653
00:30:50,940 --> 00:30:55,140
好吧，让我们现在继续并进一步改进该程序，
Well, let's go ahead now and improve this program further,

654
00:30:55,140 --> 00:30:57,810
做一些更奇特的事情，因为我现在
do something a little fancier, because I now

655
00:30:57,809 --> 00:31:00,089
可以相信我的数据已经规范化
can trust that my data has been canonicalized

656
00:31:00,089 --> 00:31:03,899
除了实际的错别字或CS50之类的怪异变体。
except for the actual typos or the weird variants of CS50 and the like.

657
00:31:03,900 --> 00:31:07,470
让我们继续前进，找出最受欢迎的电视
Let's go ahead and figure out what's the most popular favorite TV

658
00:31:07,470 --> 00:31:10,510
在这里的观众中展示。
show among the audience here.

659
00:31:10,509 --> 00:31:12,299
所以我要从以前的地方开始
So I'm going to start where I have before,

660
00:31:12,299 --> 00:31:14,132
用我当前的代码，因为我认为我有
with my current code, because I think I have

661
00:31:14,133 --> 00:31:16,143
大部分构建块都已就位。
most of the building blocks in place.

662
00:31:16,143 --> 00:31:18,810
我将继续在这里清理我的代码。
I'm going to go ahead and clean up my code a little bit in here.

663
00:31:18,809 --> 00:31:22,049
我要继续给自己一个单独的变量，现在称为title
I'm going to go ahead and give myself a separate variable now called title

664
00:31:22,049 --> 00:31:26,039
只是为了让我可以更有条理地思考事情。
just so that I can think about things in a little more orderly fashion.

665
00:31:26,039 --> 00:31:29,199
但我不会再开始在此集合中添加内容。
But I'm not going to start adding things to this set anymore.

666
00:31:29,200 --> 00:31:32,220
实际上，我认为没有一套
In fact, a set, I don't think, is really going

667
00:31:32,220 --> 00:31:35,880
足以跟踪电视节目的受欢迎程度，
to be sufficient to keep track of the popularity of TV shows,

668
00:31:35,880 --> 00:31:38,820
因为根据定义，该集合会丢弃重复项。
because by definition, the set is throwing away duplicates.

669
00:31:38,819 --> 00:31:40,679
但是现在的目标是相反的。
But the goal now is kind of the opposite.

670
00:31:40,680 --> 00:31:45,240
我想知道哪些是重复的，以便我可以告诉你
I want to know which are the duplicates so that I can tell you

671
00:31:45,240 --> 00:31:46,860
这么多人喜欢The Office。
that this many people like The Office.

672
00:31:46,859 --> 00:31:50,529
这很多人都喜欢Breaking Bad等。
This many people like Breaking Bad and the like.

673
00:31:50,529 --> 00:31:56,009
那么我们在Python的工具包中拥有哪些工具，我们可以通过这些工具来积累
So what tools do we have in Python's toolkit via which we could accumulate

674
00:31:56,009 --> 00:31:59,319
或找出该信息？
or figure out that information?

675
00:31:59,319 --> 00:32:02,739
关于什么数据结构的任何想法都可以在这里帮助我们
Any thoughts on what data structure might help us here

676
00:32:02,740 --> 00:32:07,870
如果我们想弄清楚节目，受欢迎程度，节目，受欢迎程度？
if we want to figure out show, popularity, show, popularity?

677
00:32:07,869 --> 00:32:11,949
在流行度上，我只是指的是CSV文件中它的出现频率。
And by popularity, I just mean the frequency of it in the CSV file.

678
00:32:11,950 --> 00:32:13,720
圣地亚哥？
Santiago?

679
00:32:13,720 --> 00:32:17,110
听众：我猜一个选择是使用词典
AUDIENCE: I guess one option could be to use dictionaries

680
00:32:17,109 --> 00:32:20,409
这样你就可以拥有The Office，我不知道，
so that you can have The Office, I don't know,

681
00:32:20,410 --> 00:32:23,110
20票，然后是《权力的游戏》，另一票，
20 votes, and then Game of Thrones, another one,

682
00:32:23,109 --> 00:32:27,022
这样一本字典就可以真正帮助您形象地看到它。
so that a dictionary could really help you visualize that.

683
00:32:27,022 --> 00:32:28,689
DAVID J. MALAN：是的，完美的直觉。
DAVID J. MALAN: Yeah, perfect instincts.

684
00:32:28,690 --> 00:32:31,660
回想一下，无论如何，一本字典在一天结束时
Recall that a dictionary, at the end of the day, no matter how

685
00:32:31,660 --> 00:32:34,450
它是在引擎盖下实现的
sophisticated it's implemented underneath the hood,

686
00:32:34,450 --> 00:32:35,680
就像您的拼写检查器一样-
like your spell checker--

687
00:32:35,680 --> 00:32:38,240
它只是键值对的集合。
It's just a collection of key value pairs.

688
00:32:38,240 --> 00:32:42,790
实际上，它可能是任何语言中最有用的数据结构之一，
And indeed, it's maybe one of the most useful data structures in any language,

689
00:32:42,789 --> 00:32:45,819
因为这种将一个数据与另一个数据关联的能力
because this ability to associate one piece of data with another

690
00:32:45,819 --> 00:32:49,149
仅仅是解决问题的通用解决方案。
is just a very general purpose solution to problems.

691
00:32:49,150 --> 00:32:51,730
确实，就圣地亚哥而言，如果眼前的问题
And indeed, to Santiago's point, if the problem at hand

692
00:32:51,730 --> 00:32:53,650
是为了找出节目的受欢迎程度，
is to figure out the popularity of shows,

693
00:32:53,650 --> 00:32:58,510
好吧，让我们将按键命名为节目的标题及其频率-
well, let's make the keys the titles of our shows and the frequencies thereof--

694
00:32:58,509 --> 00:32:59,829
选票，可以这么说-
the votes, so to speak--

695
00:32:59,829 --> 00:33:01,809
这些键的值。
the values of those keys.

696
00:33:01,809 --> 00:33:06,449
我们将标题映射为投票，标题映射为投票，标题映射为等等。
We're going to map title to votes, title to vote, title to vote, and so forth.

697
00:33:06,450 --> 00:33:08,145
因此，字典就是这样。
So a dictionary is exactly that.

698
00:33:08,144 --> 00:33:09,519
因此，让我继续向上滚动。
So let me go ahead and scroll up.

699
00:33:09,519 --> 00:33:10,977
我可以在这里进行一些调整。
And I can make a little tweak here.

700
00:33:10,978 --> 00:33:14,260
而不是一组，我可以说字典并给我自己
Instead of a set, I can instead say dict and give myself

701
00:33:14,259 --> 00:33:15,597
只是一个空字典。
just an empty dictionary.

702
00:33:15,597 --> 00:33:18,639
实际上，有一种简写形式，这种说法更为普遍。
There's actually shorthand notation for that that's a little more common.

703
00:33:18,640 --> 00:33:20,830
因此，您使用两个空的花括号。
So you use two empty curly braces.

704
00:33:20,829 --> 00:33:22,809
那只意味着完全相同的事情。
That just means the exact same thing.

705
00:33:22,809 --> 00:33:25,269
给我一本最初是空的字典。
Give me a dictionary that's initially empty.

706
00:33:25,269 --> 00:33:27,399
一套没有花哨的捷径。
There's no fancy shortcut for a set.

707
00:33:27,400 --> 00:33:30,370
您必须逐字输入SET，打开paren和关闭paren。
You have to literally type out S-E-T, open paren and closed paren.

708
00:33:30,369 --> 00:33:34,219
但是字典是如此普遍，如此流行，如此强大，
But dictionaries are so common, so popular, so powerful,

709
00:33:34,220 --> 00:33:38,350
他们只有两个花括号，这是语法上的小捷径，
they have this little syntactic shortcut of just two curly braces,

710
00:33:38,349 --> 00:33:39,559
打开和关闭。
open and closed.

711
00:33:39,559 --> 00:33:42,699
现在我有了，让我继续进行。
So now that I have that, let me go ahead and do this.

712
00:33:42,700 --> 00:33:45,580
在我的for循环中，而不是打印
Inside of my for loop, instead of printing

713
00:33:45,579 --> 00:33:48,879
标题，我不想做，而不是将其添加到集合中，
the title, which I don't want to do, and instead of adding it to the set,

714
00:33:48,880 --> 00:33:50,770
我现在要将其添加到字典中。
I now want to add it to the dictionary.

715
00:33:50,769 --> 00:33:51,859
那我该怎么做呢？
So how do I do that?

716
00:33:51,859 --> 00:33:55,479
好吧，如果我的字典叫做书名，我想我基本上可以做点什么
Well, if my dictionary is called titles, I think I can essentially do something

717
00:33:55,480 --> 00:34:02,710
像这样，标题括号title =或+ = 1。
like this, titles bracket title = or maybe += 1.

718
00:34:02,710 --> 00:34:07,120
也许我可以将字典用作一些备忘单
Maybe I can kind of use the dictionary as just a little cheat sheet

719
00:34:07,119 --> 00:34:12,049
的计数，数字从0开始，然后仅加1，在2处加3。
of counts, numbers, that start at 0 and then just add 1, at 2, add 3.

720
00:34:12,050 --> 00:34:17,860
因此，每当我看到办公室，办公室，办公室时，都会+ = 1，+ = 1。
So every time I see The Office, The Office, The Office, do += 1, += 1.

721
00:34:17,860 --> 00:34:20,199
我们不能做++，因为在Python中这不是问题。
We can't do ++, because that's not a thing in Python.

722
00:34:20,199 --> 00:34:24,580
它仅存在于C中。但这似乎进入了名为
It only exists in C. But this would seem to go into the dictionary called

723
00:34:24,579 --> 00:34:29,259
标题，查找与该特定标题匹配的键，
titles, look up the key that matches this specific title,

724
00:34:29,260 --> 00:34:34,340
然后将其中的任何值加1。
and then increment whatever value is there by 1.

725
00:34:34,340 --> 00:34:37,380
但是，我将继续在这里天真地运行它。
But I'm going to go ahead and run this a little naively here.

726
00:34:37,380 --> 00:34:40,280
让我继续运行python的收藏夹.py。
Let me go ahead and run python of favorites.py.

727
00:34:40,280 --> 00:34:43,400
哇，它已经在第9行破裂了。
And wow, it broke already on line 9.

728
00:34:43,400 --> 00:34:47,389
因此，首先要选择合适的节目，
So sort of an apt choice of show to begin with,

729
00:34:47,389 --> 00:34:49,530
我们在Punisher中遇到了一个关键错误。
we have a key error with Punisher.

730
00:34:49,530 --> 00:34:50,917
所以惩罚者是坏的。
So Punisher is bad.

731
00:34:50,916 --> 00:34:52,249
刚刚发生了一件坏事。
Something bad has just happened.

732
00:34:52,250 --> 00:34:53,250
但是，这是什么意思？
But what does that mean?

733
00:34:53,250 --> 00:34:55,428
一个关键错误是指我
A key error is referring to the fact that I

734
00:34:55,429 --> 00:34:59,407
试图访问字典中的无效键。
tried to access an invalid key in a dictionary.

735
00:34:59,407 --> 00:35:01,490
这就是说在这行代码中
This is saying that literally in this line of code

736
00:35:01,489 --> 00:35:04,609
在这里，即使标题是一本字典，甚至
here, even though titles is a dictionary and even

737
00:35:04,610 --> 00:35:07,130
虽然title的值是单引号
though the value of title, singular, is, quote

738
00:35:07,130 --> 00:35:09,560
取消引号“ PUNISHER”，我收到一个关键错误，
unquote, "PUNISHER," I'm getting a key error,

739
00:35:09,559 --> 00:35:13,229
因为该标题尚不存在。
because that title does not yet exist.

740
00:35:13,230 --> 00:35:17,060
因此，即使您不确定用于解决此问题的Python语法，
So even if you're not sure of the Python syntax for fixing this problem,

741
00:35:17,059 --> 00:35:21,529
这里有什么直观的解决方案？
what's the intuitive solution here?

742
00:35:21,530 --> 00:35:25,610
我不能增加惩罚者的频率，
I cannot increment the frequency of the Punisher,

743
00:35:25,610 --> 00:35:28,130
因为惩罚者不在字典中。
because Punisher is not in the dictionary.

744
00:35:28,130 --> 00:35:29,986
几乎感觉像是一个22。
It almost feels like a catch-22.

745
00:35:29,985 --> 00:35:31,889
[？格雷格？ ？]
[? Greg? ?]

746
00:35:31,889 --> 00:35:35,899
听众：我认为您首先需要创建一个for循环
AUDIENCE: I think that you need, first of all, to create a for loop

747
00:35:35,900 --> 00:35:40,520
并可能为字典中的所有内容分配一个值。
and maybe assign a value to everything in the dictionary.

748
00:35:40,519 --> 00:35:43,682
例如对于一个值0，然后加1。
For example, a value 0, and then add 1.

749
00:35:43,682 --> 00:35:45,349
DAVID J. MALAN：是的，很好的直觉。
DAVID J. MALAN: Yeah, so good instincts.

750
00:35:45,349 --> 00:35:46,729
在这里，我可以使用另一个隐喻。
And here, I can use another metaphor.

751
00:35:46,730 --> 00:35:49,147
我担心那里可能有鸡肉和鸡蛋的问题，
I worry we might have a chicken and the egg problem there,

752
00:35:49,146 --> 00:35:51,469
因为我认为我无法进入代码的顶部，
because I don't think I can go to the top of my code,

753
00:35:51,469 --> 00:35:56,419
添加一个将字典中所有值初始化为0的循环，
add a loop that initializes all of the values in the dictionary to 0,

754
00:35:56,420 --> 00:36:01,130
因为那时我需要知道所有的演出名称。
because I would need to know all of the names of the shows at that point.

755
00:36:01,130 --> 00:36:02,180
现在，很好。
Now, that's fine.

756
00:36:02,179 --> 00:36:05,329
我想我也许可以更确切地说带你，[？格雷格，？]
I think I could take you maybe more literally, [? Greg, ?]

757
00:36:05,329 --> 00:36:09,629
并打开CSV文件，从上到下对其进行迭代，
and open up the CSV file, iterate over it top to bottom,

758
00:36:09,630 --> 00:36:12,920
而且，只要我看到标题，就将其初始化
and, any time I see a title, just initialize it

759
00:36:12,920 --> 00:36:16,220
在字典中的值为0、0、0。
in the dictionary as having a value of 0, 0, 0.

760
00:36:16,219 --> 00:36:20,279
然后进行另一个for循环，也许重新打开文件，然后执行相同的操作。
Then have another for loop, maybe reopen the file, and do the same.

761
00:36:20,280 --> 00:36:21,380
那会起作用。
And that would work.

762
00:36:21,380 --> 00:36:23,540
但这可以说不是很有效。
But it's arguably not very efficient.

763
00:36:23,539 --> 00:36:26,329
就大O而言，这是渐近的。但是那会
It is asymptotically, in terms of big O. But that would

764
00:36:26,329 --> 00:36:28,219
似乎在做两倍的工作。
seem to be doing twice as much work.

765
00:36:28,219 --> 00:36:31,819
遍历文件一次，仅将所有内容初始化为0。
Iterate over the file once just to initialize everything to 0.

766
00:36:31,820 --> 00:36:35,330
然后第二次遍历文件只是为了增加计数。
Then iterate over the file a second time just to increment the counts.

767
00:36:35,329 --> 00:36:38,359
我认为我们可以做些更有效率的事情。
I think we can do things a little more efficiently.

768
00:36:38,360 --> 00:36:41,090
我认为我们不仅可以实现正确性，而且可以实现更好的设计。
I think we can achieve not only correctness but better design.

769
00:36:41,090 --> 00:36:45,560
关于我们如何仍然可以解决这个问题的任何想法
Any thoughts on how we can still solve this problem without having

770
00:36:45,559 --> 00:36:48,289
遍历整个事情两次？
to iterate over the whole thing twice?

771
00:36:48,289 --> 00:36:50,359
是的， [？西摩威特？ ？]
Yeah, [? Semowit? ?]

772
00:36:50,360 --> 00:36:53,450
听众：我认为我们可以添加一个if语句
AUDIENCE: I think we can add in an if statement

773
00:36:53,449 --> 00:36:55,969
检查该键是否在字典中。
to check if that key is in the dictionary.

774
00:36:55,969 --> 00:36:59,864
如果不是，则添加它，然后继续，然后增加值。
And if it's not, then add it and then go ahead and increment the value after.

775
00:36:59,864 --> 00:37:00,739
DAVID J. MALAN：好的。
DAVID J. MALAN: Nice.

776
00:37:00,739 --> 00:37:02,459
我们可以做到这一点。
And we can do exactly that.

777
00:37:02,460 --> 00:37:04,310
因此，让我们直接运用这种直觉。
So let's just apply that intuition.

778
00:37:04,309 --> 00:37:08,582
如果问题是我正在尝试访问尚不存在的密钥，
If the problem is that I'm trying to access a key that does not yet exist,

779
00:37:08,583 --> 00:37:10,500
好吧，让我们稍微聪明一点。
well, let's just be a little smarter about it.

780
00:37:10,500 --> 00:37:14,089
并 [？ Semowit的？]点，让我们检查该密钥是否存在。
And to [? Semowit's ?] point, let's check whether the key exists.

781
00:37:14,090 --> 00:37:16,020
如果确实如此，则将其递增。
And if it does, then increment it.

782
00:37:16,019 --> 00:37:19,339
但是，如果没有，那么，只有然后，[？格雷格（Greg）的建议]，
But if it does not, then and only then, [? to Greg's ?] advice,

783
00:37:19,340 --> 00:37:20,730
将其初始化为0。
initialize it to 0.

784
00:37:20,730 --> 00:37:21,570
所以，让我这样做。
So let me do that.

785
00:37:21,570 --> 00:37:24,980
让我继续说一下标题是否为标题，
Let me go ahead and say if title in titles,

786
00:37:24,980 --> 00:37:28,520
这是问问题的非常Pythonic的，优美的方式
which is the very Pythonic, beautiful way of asking a question

787
00:37:28,519 --> 00:37:30,499
这样，比C语言更干净
like that, way cleaner than in C--

788
00:37:30,500 --> 00:37:35,389
那么，让我继续，准确说出之前的界线。
let me go ahead, then, and say exactly the line from before.

789
00:37:35,389 --> 00:37:40,279
不过，如果其他标题还没有出现在名为“标题”的字典中，
Else, though, if that title is not yet in the dictionary called titles,

790
00:37:40,280 --> 00:37:41,720
好，那也没关系。
well, that's OK, too.

791
00:37:41,719 --> 00:37:47,149
我可以说标题支架title = 0。
I can go ahead and say titles bracket title = 0.

792
00:37:47,150 --> 00:37:51,950
所以这里的区别是我当然可以索引
So the difference here is that I can certainly index

793
00:37:51,949 --> 00:37:57,739
如果我当时计划的话，使用不存在的键将其放入字典中
into a dictionary using a key that doesn't exist if I plan at that moment

794
00:37:57,739 --> 00:37:58,729
给它一个价值。
to give it a value.

795
00:37:58,730 --> 00:38:02,030
没关系，自上周以来一直都是这样。
That's OK, and that has always been OK since last week.

796
00:38:02,030 --> 00:38:07,490
但是，但是，如果我想继续增加那里的价值，
But, however, if I want to go ahead and increment the value that's there,

797
00:38:07,489 --> 00:38:11,629
我将继续在单独的一行中进行操作。
I'm going to go ahead and do that in this separate line.

798
00:38:11,630 --> 00:38:13,850
但是我确实引入了一个错误。
But I did introduce a bug.

799
00:38:13,849 --> 00:38:15,769
我确实在这里介绍了一个错误。
I did introduce a bug here.

800
00:38:15,769 --> 00:38:19,219
我认为我需要在逻辑上更进一步。
I think I need to go one step further logically.

801
00:38:19,219 --> 00:38:24,479
我不希望自己将其初始化为0。
I don't think I want to initialize this to 0 per se.

802
00:38:24,480 --> 00:38:29,090
有人在这里看到我逻辑中的细微错误吗？
Does anyone see a subtle bug in my logic here?

803
00:38:29,090 --> 00:38:32,570
如果标题已经在字典中，则将其递增1。
If the title is already in the dictionary, I'm incrementing it by 1.

804
00:38:32,570 --> 00:38:37,000
否则，我将其初始化为0。
Otherwise, I'm initializing it to 0.

805
00:38:37,000 --> 00:38:38,500
这里有什么妙招吗？
Any subtle catches here?

806
00:38:38,500 --> 00:38:40,689
是的，Olivia，您看到了什么？
Yeah, Olivia, what do you see?

807
00:38:40,690 --> 00:38:44,700
听众：我认为您应该将其初始化为1，因为它是第一个实例。
AUDIENCE: I think you should initialize it to 1, since it's the first instance.

808
00:38:44,699 --> 00:38:45,699
戴维·J·马兰（David J. MALAN）：好的。
DAVID J. MALAN: Exactly.

809
00:38:45,699 --> 00:38:46,869
我应该将其初始化为1。
I should initialize it to 1.

810
00:38:46,869 --> 00:38:50,136
否则，我会无意间忽略了这个特定的标题，
Otherwise, I'm accidentally overlooking this particular title,

811
00:38:50,137 --> 00:38:51,970
我将继续进行下去，并低估它。
and I'm going to go ahead and undercount it.

812
00:38:51,969 --> 00:38:54,099
因此，我可以通过执行此操作来解决此问题。
So I can fix this either by doing this.

813
00:38:54,099 --> 00:38:57,819
或坦率地说，如果您愿意，从技术上讲，我不需要使用if。
Or frankly, if you prefer, I don't technically need to use an if else.

814
00:38:57,820 --> 00:39:00,730
我可以通过执行类似这样的操作来使用if。
I can use just an if by doing something like this instead.

815
00:39:00,730 --> 00:39:04,900
我可以说如果标题中没有标题，那么我可以继续
I could say if title not in titles, then I could go ahead

816
00:39:04,900 --> 00:39:07,420
并说title括号title得到0。
and say titles bracket title gets 0.

817
00:39:07,420 --> 00:39:12,270
然后在那之后，我可以盲目地说，就是这样做。
And then after that, I can blindly, so to speak, just do this.

818
00:39:12,269 --> 00:39:13,479
那么哪一个更好呢？
So which one is better?

819
00:39:13,480 --> 00:39:15,460
我认为第二个也许更好
I think the second one is maybe a little better

820
00:39:15,460 --> 00:39:17,420
因为我节省了一行代码。
in that I'm saving one line of code.

821
00:39:17,420 --> 00:39:19,270
但这可以确保条件
But it's ensuring with that if condition,

822
00:39:19,269 --> 00:39:24,189
到 [？ Semowit的？]建议，即我不将其编入标题词典
to [? Semowit's ?] advice, that I'm not indexing into the titles dictionary

823
00:39:24,190 --> 00:39:27,050
直到我确定标题在那里。
until I'm sure that the title is in there.

824
00:39:27,050 --> 00:39:31,570
因此，让我继续并立即运行此命令，收藏夹python的python，输入。
So let me go ahead and run this now, python of favorites.py, Enter.

825
00:39:31,570 --> 00:39:34,090
好吧，它没有崩溃，所以很好。
And OK, it didn't crash, so that's good.

826
00:39:34,090 --> 00:39:36,400
但是我还没有看到任何有用的信息。
But I'm not yet seeing any useful information.

827
00:39:36,400 --> 00:39:38,740
但是我现在可以使用更多了。
But I now have access to a bit more.

828
00:39:38,739 --> 00:39:41,679
现在，我向下滚动到该程序的底部
Let me scroll down now to the bottom of this program, where

829
00:39:41,679 --> 00:39:43,359
我现在有这个循环。
I have now this loop.

830
00:39:43,360 --> 00:39:45,460
让我继续打印并不仅仅是标题
Let me go ahead and print out not just the title

831
00:39:45,460 --> 00:39:49,870
但是该键在字典中的值只是通过索引
but the value of that key in the dictionary by just indexing

832
00:39:49,869 --> 00:39:50,499
在这里。
into it here.

833
00:39:50,500 --> 00:39:52,030
而且您以前可能没有看过这种语法。
And you might not have seen this syntax before.

834
00:39:52,030 --> 00:39:54,758
但是使用print时，您实际上可以传递多个参数。
But with print, you can actually pass in multiple arguments.

835
00:39:54,757 --> 00:39:57,549
默认情况下，打印将只为它们隔开一个空格。
And by default, print will just separate them with a space for you.

836
00:39:57,550 --> 00:39:59,860
您可以覆盖该行为并将其与任何内容分开。
You can override that behavior and separate them with anything.

837
00:39:59,860 --> 00:40:02,777
但这只是一个快速而又肮脏的程序，可以打印出来
But this is just meant to be a quick and dirty program that prints out

838
00:40:02,777 --> 00:40:04,820
标题以及现在的流行度。
titles and now the popularity thereof.

839
00:40:04,820 --> 00:40:07,210
因此，让我再次运行此命令，收藏夹python的python。
So let me run this again, python of favorites.py.

840
00:40:07,210 --> 00:40:08,470
和瞧。
And voila.

841
00:40:08,469 --> 00:40:12,039
到处都是。
It's kind of all over the place.

842
00:40:12,039 --> 00:40:14,799
办公室，那里以26票的超人气。
Office, super popular with 26 votes there.

843
00:40:14,800 --> 00:40:18,220
这里有很多单票。
A lot of single votes here.

844
00:40:18,219 --> 00:40:19,809
大爆炸理论有九个。
Big Bang Theory has nine.

845
00:40:19,809 --> 00:40:21,339
你知道，这一切都很好。
You know, this is all nice and good.

846
00:40:21,340 --> 00:40:24,548
但是我觉得这将带我永远思考
But I feel like this is going to take me forever to wrap my mind around which

847
00:40:24,547 --> 00:40:25,989
是最受欢迎的节目。
are the most popular shows.

848
00:40:25,989 --> 00:40:27,559
那么，当然，我们将如何做呢？
So of course, how would we do this?

849
00:40:27,559 --> 00:40:30,249
好吧，至此，我的天哪，有了电子表格，
Well, to the point made earlier, with spreadsheets, my god,

850
00:40:30,250 --> 00:40:33,100
在Microsoft Excel或Google Spreadsheets或Apple Numbers中，
in Microsoft Excel or Google Spreadsheets or Apple Numbers,

851
00:40:33,099 --> 00:40:35,589
您只需单击列标题和繁荣，即可对其进行排序。
you just click the column heading and boom, sorted.

852
00:40:35,590 --> 00:40:38,450
除非我们现在在代码中进行操作，否则我们似乎已经失去了这种能力。
We seem to have lost that capability unless we now do it in code.

853
00:40:38,449 --> 00:40:40,449
因此，让我为我们做到这一点。
So let me do that for us.

854
00:40:40,449 --> 00:40:42,549
让我继续并回到我的代码。
Let me go ahead and go back to my code.

855
00:40:42,550 --> 00:40:48,520
尽管它确实适用于字典，但看起来还是经过排序的，
And it looks like sorted, even though it does work on dictionaries,

856
00:40:48,519 --> 00:40:52,339
实际上是按键排序，而不是按值排序。
is actually sorting by key, not by value.

857
00:40:52,340 --> 00:40:55,030
这是我们的Python编程技术需要的地方
And here's where our Python programming techniques need

858
00:40:55,030 --> 00:40:56,530
变得更加复杂。
to get a little more sophisticated.

859
00:40:56,530 --> 00:40:58,572
我们现在想在这里介绍另一个功能
And we want to introduce another feature here now

860
00:40:58,572 --> 00:41:01,660
Python的版本，它将专门解决此问题
of Python which is going to solve this problem specifically

861
00:41:01,659 --> 00:41:03,679
但以一种非常普遍的方式
but in a pretty general way.

862
00:41:03,679 --> 00:41:06,309
因此，如果我们阅读了有关分类的文档，
So if we read the documentation for sorted,

863
00:41:06,309 --> 00:41:11,319
排序的函数实际上是根据其中的值对集合进行排序的。
the sorted function indeed sorts sets by the values therein.

864
00:41:11,320 --> 00:41:13,840
它按其中的值对列表进行排序。
It sorts lists by the values therein.

865
00:41:13,840 --> 00:41:17,140
它通过其中的键对字典进行排序，
It sorts dictionaries by the keys therein,

866
00:41:17,139 --> 00:41:20,959
因为字典每个元素都有两条信息。
because dictionaries have two pieces of information for every element.

867
00:41:20,960 --> 00:41:23,450
它有一个键和一个值，而不仅仅是一个值。
It has a key and a value, not just a value.

868
00:41:23,449 --> 00:41:25,389
因此，默认情况下，按键对排序进行排序。
So by default, sorted sorts by key.

869
00:41:25,389 --> 00:41:28,149
因此，我们必须以某种方式覆盖该行为。
So we somehow have to override that behavior.

870
00:41:28,150 --> 00:41:29,390
那么我们该怎么做呢？
So how can we do this?

871
00:41:29,389 --> 00:41:31,839
好吧，事实证明，排序功能
Well, it turns out that the sorted function

872
00:41:31,840 --> 00:41:35,890
接受另一个可选参数，字面上称为key。
takes another optional argument literally called key.

873
00:41:35,889 --> 00:41:41,569
key参数将函数的名称作为其值。
And the key argument takes as its value the name of a function.

874
00:41:41,570 --> 00:41:43,690
这就是事情变得非常有趣的地方，
And this is where things get really interesting,

875
00:41:43,690 --> 00:41:45,370
如果不引起混淆，那真的很快。
if not confusing, really quickly.

876
00:41:45,369 --> 00:41:50,619
事实证明，在Python中，您可以将函数作为参数传递
It turns out, in Python, you can pass around functions as arguments

877
00:41:50,619 --> 00:41:51,789
以他们的名字
by way of their name.

878
00:41:51,789 --> 00:41:56,079
从技术上讲，您可以使用C进行此操作。这在语法上涉及更多。
And technically, you can do this in C. It's a lot more syntactically involved.

879
00:41:56,079 --> 00:41:57,776
但是在Python中，这很常见。
But in Python, it's very common.

880
00:41:57,777 --> 00:41:59,110
在JavaScript中，这很常见。
In JavaScript, it's very common.

881
00:41:59,110 --> 00:42:01,930
在很多语言中，想到函数是很普遍的
In a lot of languages, it's very common to think of functions

882
00:42:01,929 --> 00:42:06,039
作为一流的对象，这是一种奇妙的说法，您可以将它们传递出去
as first-class objects, which is a fancy way of saying you can pass them around

883
00:42:06,039 --> 00:42:08,439
就像它们本身就是变量一样。
just like they are variables themselves.

884
00:42:08,440 --> 00:42:09,730
我们还没有打电话给他们。
We're not calling them yet.

885
00:42:09,730 --> 00:42:11,720
但是您可以通过他们的名字来传递它们。
But you can pass them around by their name.

886
00:42:11,719 --> 00:42:13,309
那我是什么意思呢？
So what do I mean by this?

887
00:42:13,309 --> 00:42:18,939
好吧，我现在需要一个函数来按其值对字典进行排序。
Well, I need a function now to sort my dictionary by its value.

888
00:42:18,940 --> 00:42:22,900
而且也许只有我知道该怎么做，所以让我继续前进，给自己
And only I know how to do this, perhaps, so let me go ahead and give myself

889
00:42:22,900 --> 00:42:25,990
泛型函数名称，此刻称为f-- f，
a generic function name just for the moment called f-- f for function,

890
00:42:25,989 --> 00:42:26,906
有点像数学
kind of like in math--

891
00:42:26,907 --> 00:42:28,907
因为我们最终将要摆脱它。
because we're going to get rid of it eventually.

892
00:42:28,907 --> 00:42:31,120
但是，让我继续并临时定义一个函数
But let me go ahead and temporarily define a function

893
00:42:31,119 --> 00:42:34,149
被称为f的f以标题为输入。
called f that takes as input a title.

894
00:42:34,150 --> 00:42:39,140
然后它为我返回与该键相对应的值。
And then it returns for me the value corresponding to that key.

895
00:42:39,139 --> 00:42:43,059
因此，我将继续返回标题支架标题。
So I'm going to go ahead and return titles bracket title.

896
00:42:43,059 --> 00:42:47,479
因此，在这里，我们有一个功能，其生活目的非常简单。
So here, we have a function whose purpose in life is super simple.

897
00:42:47,480 --> 00:42:48,700
您给它一个标题。
You give it a title.

898
00:42:48,699 --> 00:42:52,989
它为您提供数量，频率，受欢迎程度，
It gives you the count thereof, the frequency, the popularity thereof,

899
00:42:52,989 --> 00:42:56,079
只需在该全球词典中查找它即可。
by just looking it up in that global dictionary.

900
00:42:56,079 --> 00:42:59,829
因此，它非常简单，但这是生活中唯一的目的。
So it's super simple, but that's its only purpose in life.

901
00:42:59,829 --> 00:43:03,399
但是现在，根据排序的文档，
But now, according to the documentation for sorted,

902
00:43:03,400 --> 00:43:06,730
现在要做什么，因为我传入了第二个参数
what it's now going to do, because I'm passing in a second argument called

903
00:43:06,730 --> 00:43:12,250
键，排序功能，而不只是假设您想对所有内容进行排序
key, the sorted function, rather than just presume you want everything sorted

904
00:43:12,250 --> 00:43:15,279
按字母顺序，相反
alphabetically by key, it's instead going

905
00:43:15,280 --> 00:43:22,420
在字典中的每个元素上调用该函数f。
to call that function f on every one of the elements in your dictionary.

906
00:43:22,420 --> 00:43:25,960
根据您的回答，返回值
And depending on your answer, the return value

907
00:43:25,960 --> 00:43:30,760
你用那个f函数给定，它将代替
you give with that f function, that will be used instead

908
00:43:30,760 --> 00:43:34,060
确定实际订购。
to determine the actual ordering.

909
00:43:34,059 --> 00:43:36,899
因此，默认情况下，排序仅查看键。
So by default, sorted just looks at key.

910
00:43:36,900 --> 00:43:39,750
我正在用这个f函数有效地做什么
What I'm effectively doing with this f function

911
00:43:39,750 --> 00:43:44,160
而是返回与每个键对应的值。
is instead returning the value corresponding to every key.

912
00:43:44,159 --> 00:43:48,359
因此，尽管在语法上有些新，但这样做的逻辑含义是，
And so the logical implication of this, even though the syntax is a little new,

913
00:43:48,360 --> 00:43:51,690
就是这个标题词典现在
is that this dictionary of titles will now

914
00:43:51,690 --> 00:43:55,140
按值而不是键排序。
be sorted by value instead of by key.

915
00:43:55,139 --> 00:43:57,459
因为同样，默认情况下，它是按键排序的。
Because again, by default, it sorts by key.

916
00:43:57,460 --> 00:44:01,740
但是如果我定义自己的键功能并覆盖该行为
But if I define my own key function and override that behavior

917
00:44:01,739 --> 00:44:05,369
返回相应的值，即值，数字，
to return the corresponding value, it's the values, the numbers,

918
00:44:05,369 --> 00:44:08,749
实际上将用于此事物的计数。
the counts that will actually be used to this thing.

919
00:44:08,750 --> 00:44:09,250
好的。
All right.

920
00:44:09,250 --> 00:44:11,333
让我们继续前进，看看在实践中是否如此。
Let's go ahead and see if that's true in practice.

921
00:44:11,333 --> 00:44:13,440
让我继续并重新运行“ favourites.py”的python。
Let me go ahead and rerun python of favorites.py.

922
00:44:13,440 --> 00:44:14,790
我应该看所有的标题。
I should see all the titles.

923
00:44:14,789 --> 00:44:17,519
瞧，这是最受欢迎的节目
And voila, conveniently, the most popular show

924
00:44:17,519 --> 00:44:22,169
似乎是《权力的游戏》，得票33票，其次是朋友，得27票，
seems to be Game of Thrones with 33 votes, followed by Friends with 27,

925
00:44:22,170 --> 00:44:25,000
紧随其后的是Office的26，依此类推。
followed by The Office with 26, and so forth.

926
00:44:25,000 --> 00:44:27,060
但是，当然，该列表有点倒退。
But of course, the list is kind of backwards.

927
00:44:27,059 --> 00:44:29,679
我的意思是，在屏幕底部看到它很方便。
I mean, it's convenient that I can see it at the bottom of my screen.

928
00:44:29,679 --> 00:44:32,529
但是，实际上，如果我们要列出一个列表，那么它应该实际上是最重要的。
But really, if we're making a list, it should really be at the top.

929
00:44:32,530 --> 00:44:34,170
那么，我们如何覆盖这种行为呢？
So how can we override that behavior?

930
00:44:34,170 --> 00:44:36,840
列出排序后的函数，如果您阅读了它的文档，
Turns out the sorted function, if you read its documentation,

931
00:44:36,840 --> 00:44:41,020
还采用了另一个称为反向的可选参数。
also takes another optional parameter called reverse.

932
00:44:41,019 --> 00:44:43,589
如果将反向设置为True，则大写
And if you set reverse equal to True, capital

933
00:44:43,590 --> 00:44:48,120
用Python T，这将继续并给我们
T in Python, that's going to go ahead and give us now

934
00:44:48,119 --> 00:44:50,189
相同顺序的相反顺序。
the reverse order of that same sort.

935
00:44:50,190 --> 00:44:53,790
因此，让我继续操作并最大化我的终端窗口，然后再次运行它。
So let me go ahead and maximize my terminal window, rerun it again.

936
00:44:53,789 --> 00:44:57,479
瞧，如果我向上滚动到顶部，它不是按字母顺序排序的。
And voila, if I scroll back up to the top, it's not alphabetically sorted.

937
00:44:57,480 --> 00:44:59,970
但是如果我继续前进，继续前进，继续前进，继续前进，
But if I keep going, keep going, keep going, keep going,

938
00:44:59,969 --> 00:45:01,261
这个数字越来越大。
the numbers are getting bigger.

939
00:45:01,262 --> 00:45:06,770
瞧，现在《权力的游戏》以33排名第一。
And voila, now Game of Thrones with 33 is all the way at the top.

940
00:45:06,769 --> 00:45:08,489
好吧，太酷了。
All right, so pretty cool.

941
00:45:08,489 --> 00:45:11,359
再说一次，至少在Python中，这是新功能，
And again, the new functionality here in Python, at least,

942
00:45:11,360 --> 00:45:15,110
是我们实际上可以将函数传递给函数
is that we can actually pass in functions to functions

943
00:45:15,110 --> 00:45:19,380
并留给后者打电话给前者。
and leave it to the latter to call the former.

944
00:45:19,380 --> 00:45:21,180
所以这很复杂。
So that's complicated just to say.

945
00:45:21,179 --> 00:45:26,399
但是现在对我们如何使用字典有任何疑问或困惑
But any questions or confusion now on how we are using dictionaries

946
00:45:26,400 --> 00:45:34,290
以及我们如何以这种反向的，基于价值的方式对事物进行分类？
and how we are sorting things in this reverse, value-based way?

947
00:45:34,289 --> 00:45:35,449
有任何疑问或困惑吗？
Any questions or confusion?

948
00:45:35,449 --> 00:45:38,999
聊天中有任何内容或口头上的内容，Brian？
Anything in the chat or verbally, Brian?

949
00:45:39,000 --> 00:45:41,470
布莱恩·于：看来所有问题都在这里回答了。
BRIAN YU: Looks like all questions are answered here.

950
00:45:41,469 --> 00:45:42,319
DAVID J. MALAN：好的。
DAVID J. MALAN: OK.

951
00:45:42,320 --> 00:45:44,780
然后，在这种情况下，让我指出一个常见的错误。
Then in that case, let me point out a common mistake.

952
00:45:44,780 --> 00:45:50,000
请注意，即使f是一个函数，也请注意我没有在那儿调用它。
Notice that even though f is a function, notice that I did not call it there.

953
00:45:50,000 --> 00:45:53,629
那将是不正确的，原因是我们故意
That would be incorrect, the reason being we deliberately

954
00:45:53,630 --> 00:45:58,410
想要将函数f传递给已排序的函数
want to pass the function f into the sorted function

955
00:45:58,409 --> 00:46:03,809
这样排序后的函数就可以自己一次又一次地调用f
so that the sorted function can take it upon itself to call f again and again

956
00:46:03,809 --> 00:46:04,309
然后再次。
and again.

957
00:46:04,309 --> 00:46:07,226
我们不希望自己使用括号来一次调用它。
We don't want to just call it once by using the parentheses ourselves.

958
00:46:07,226 --> 00:46:11,029
我们只想按名称传递它，以便排序后的函数
We want to just pass it in by name so that the sorted function, which comes

959
00:46:11,030 --> 00:46:14,630
使用Python，反而可以为我们做到这一点。
with Python, can instead do it for us.

960
00:46:14,630 --> 00:46:17,060
圣地亚哥，你有问题吗？
Santiago, did you have a question?

961
00:46:17,059 --> 00:46:18,709
听众：是的，我要问。
AUDIENCE: Yes, I was going to ask.

962
00:46:18,710 --> 00:46:21,425
我们为什么不加标题f？
Why didn't we put f of title?

963
00:46:24,349 --> 00:46:26,959
我要特别问这个问题。
I was going to ask that question specifically.

964
00:46:26,960 --> 00:46:29,005
DAVID J. MALAN：哦，加上括号？
DAVID J. MALAN: Oh, with the parentheses?

965
00:46:29,005 --> 00:46:29,630
听众：是的。
AUDIENCE: Yeah.

966
00:46:29,630 --> 00:46:30,963
DAVID J. MALAN：好的，完美。
DAVID J. MALAN: Oh, OK, perfect.

967
00:46:30,963 --> 00:46:34,010
因此，因为那样只会调用一次函数。
So because that would call the function once and only once.

968
00:46:34,010 --> 00:46:37,013
我们希望排序能够一次又一次地调用它。
We want sorted to be able to call it again and again.

969
00:46:37,012 --> 00:46:38,929
现在，这实际上是一个示例，如我们所见
Now, here's actually an example, as we've seen

970
00:46:38,929 --> 00:46:40,759
过去的正确解决方案。
in the past, of a correct solution.

971
00:46:40,760 --> 00:46:45,170
正如我所期望的那样，这是从上到下的排序标题列表
This is behaving as I intend, a list of sorted titles from top to bottom

972
00:46:45,170 --> 00:46:47,450
以受欢迎程度排序。
in order of popularity.

973
00:46:47,449 --> 00:46:49,819
但这设计有点糟糕，因为我
But it's a little poorly designed, because I'm

974
00:46:49,820 --> 00:46:53,390
定义此函数f，其名称首先是la脚。
defining this function f, whose name in the first place is kind of lame.

975
00:46:53,389 --> 00:46:56,659
但是我定义一个函数只是在一个地方使用它。
But I'm defining a function only to use it in one place.

976
00:46:56,659 --> 00:47:00,859
我的天哪，功能太小了，感觉就像是在敲击键盘一样
And my god, the function is so tiny, it just feels like a waste of keystrokes

977
00:47:00,860 --> 00:47:03,740
定义了一个新函数然后传递给它。
to have defined a new function just to then pass it in.

978
00:47:03,739 --> 00:47:08,149
事实证明，在Python中，如果您有一个非常短的函数，而该函数的
So it turns out, in Python, if you have a very short function whose

979
00:47:08,150 --> 00:47:13,130
生活的目的是要一次解决一个局部问题，仅此而已
purpose in life is meant to be to solve a local problem just once and that's it

980
00:47:13,130 --> 00:47:16,880
而且它足够短，足以确保您可以将其放在一行代码中
and it's short enough that you're pretty sure you can fit it on one line of code

981
00:47:16,880 --> 00:47:21,080
事实证明，没有东西包裹起来并且开始变得丑陋，
without things wrapping and starting to get ugly stylistically, it turns out

982
00:47:21,079 --> 00:47:23,269
您实际上可以执行此操作。
you can actually do this instead.

983
00:47:23,269 --> 00:47:26,819
您可以像这样复制您想到的代码。
You can copy the code that you had in mind like this.

984
00:47:26,820 --> 00:47:30,680
而不是将f实际定义为函数名称，
And instead of actually defining f as a function name,

985
00:47:30,679 --> 00:47:34,069
您实际上可以在Python中使用一个称为lambda的特殊关键字。
you can actually use a special keyword in Python called lambda.

986
00:47:34,070 --> 00:47:37,760
您可以像以前一样为函数指定参数的名称。
You can specify the name of an argument for your function as before.

987
00:47:37,760 --> 00:47:41,690
然后您可以简单地指定返回值，此后
And then you can simply specify the return value, thereafter

988
00:47:41,690 --> 00:47:44,940
删除函数本身。
deleting the function itself.

989
00:47:44,940 --> 00:47:49,640
需要明确的是，key仍然是已排序函数的参数。
So to be clear, key is still an argument to the sorted function.

990
00:47:49,639 --> 00:47:54,119
它通常期望一个函数的名称作为其值。
It expects as its value typically the name of a function.

991
00:47:54,119 --> 00:47:57,589
但是，如果您决定这样做，这似乎是在浪费精力
But if you've decided that, eh, this seems like a waste of effort

992
00:47:57,590 --> 00:47:59,870
定义一个函数，然后传入该函数，
to define a function, then pass the function in,

993
00:47:59,869 --> 00:48:02,839
特别是当它很短时，您可以在一个衬里中完成。
especially when it's so short, you can do it in a one liner.

994
00:48:02,840 --> 00:48:05,990
Lambda函数是一个匿名函数。
A lambda function is an anonymous function.

995
00:48:05,989 --> 00:48:09,229
Lambda从字面上说，Python，给我一个函数。
Lambda literally says, Python, give me a function.

996
00:48:09,230 --> 00:48:11,147
我不在乎它的名字。
I don't care about its name.

997
00:48:11,146 --> 00:48:13,229
因此，您不必为其选择名称。
Therefore, you don't have to choose a name for it.

998
00:48:13,230 --> 00:48:17,940
但是它仍然关心它的参数和返回值。
But it does care still about its arguments and its return value.

999
00:48:17,940 --> 00:48:23,147
因此，仍然需要您提供零个或多个参数和一个返回值。
So it's still up to you to provide zero or more arguments and a return value.

1000
00:48:23,146 --> 00:48:24,229
并注意我已经做到了。
And notice I've done that.

1001
00:48:24,230 --> 00:48:28,010
我指定了关键字lambda，后跟参数名称
I've specified the keyword lambda followed by the name of the argument

1002
00:48:28,010 --> 00:48:31,490
我希望这个匿名的，无名的函数能够接受。
I want this anonymous, nameless function to accept.

1003
00:48:31,489 --> 00:48:33,889
然后我指定返回值。
And then I'm specifying the return value.

1004
00:48:33,889 --> 00:48:37,939
对于lambda函数，您无需指定return。
And with lambda functions, you do not need to specify return.

1005
00:48:37,940 --> 00:48:41,000
无论您在冒号之后写的是字面上的
Whatever you write after the colon is literally

1006
00:48:41,000 --> 00:48:43,049
什么会自动返回。
what will be returned automatically.

1007
00:48:43,050 --> 00:48:45,320
再次重申，这是非常Python化的事情。
So again, this is a very Pythonic thing to do.

1008
00:48:45,320 --> 00:48:49,250
这是一个非常聪明的班轮，尽管有点神秘
It's kind of a very clever one liner, even though it's a little cryptic

1009
00:48:49,250 --> 00:48:50,756
第一次看到。
to see for the very first time.

1010
00:48:50,757 --> 00:48:53,840
但这使您可以将自己的思想浓缩为简洁的陈述，
But it allows you to condense your thoughts into a succinct statement that

1011
00:48:53,840 --> 00:48:57,470
完成工作，因此您不必开始定义越来越多的功能
gets the job done so you don't have to start defining more and more functions

1012
00:48:57,469 --> 00:49:02,489
然后您或其他人需要跟踪。
that you or someone else then need to keep track of.

1013
00:49:02,489 --> 00:49:02,989
好的。
All right.

1014
00:49:02,989 --> 00:49:05,299
那么，对此有任何疑问吗？
Any questions, then, on this?

1015
00:49:05,300 --> 00:49:10,580
而且我很确定这与我们的Python代码一样复杂或复杂
And I am pretty sure this is as complex or sophisticated as our Python code

1016
00:49:10,579 --> 00:49:13,289
今天会得到。
today will get.

1017
00:49:13,289 --> 00:49:16,019
是的，交给索菲娅。
Yeah, over to Sophia.

1018
00:49:16,019 --> 00:49:19,379
听众：我想知道为什么专门使用“ lambda”
AUDIENCE: I was wondering why "lambda" is used specifically

1019
00:49:19,380 --> 00:49:21,217
而不是其他一些关键字。
rather than some other keyword.

1020
00:49:21,217 --> 00:49:23,550
DAVID J. MALAN：是的，所以有很长的历史。
DAVID J. MALAN: Yeah, so there's a long history in this.

1021
00:49:23,550 --> 00:49:27,060
实际上，如果您在哈佛上一门关于函数式编程的课程，
And if, in fact, you take a course on functional programming-- at Harvard,

1022
00:49:27,059 --> 00:49:28,829
叫做CS51
it's called CS51--

1023
00:49:28,829 --> 00:49:32,279
像这样的关键字背后有一个完整的词源。
there's a whole etymology behind keywords like this.

1024
00:49:32,280 --> 00:49:34,360
让我再推迟一次。
Let me defer that one for another time.

1025
00:49:34,360 --> 00:49:37,440
但是确实，不仅在Python中，而且在其他语言中，
But indeed, not only in Python but in other languages,

1026
00:49:37,440 --> 00:49:41,290
同样，这些东西也已经存在，称为lambda函数。
as well, these things have come to exist called lambda functions.

1027
00:49:41,289 --> 00:49:44,229
因此，它们实际上在其他语言中也很普遍。
So they're actually quite commonplace in other languages, as well.

1028
00:49:44,230 --> 00:49:48,580
因此，Python只是采用了艺术术语。
And so Python just adopted the term of art.

1029
00:49:48,579 --> 00:49:52,059
在数学上，lambda通常用作函数的符号。
Mathematically, lambda is often used as a symbol for functions.

1030
00:49:52,059 --> 00:49:55,979
因此，他们在编程领域借鉴了相同的想法。
And so they borrowed that same idea in the world of programming.

1031
00:49:55,980 --> 00:49:56,550
好的。
All right.

1032
00:49:56,550 --> 00:50:00,840
因此，没有其他问题，让我们继续解决相关问题
So seeing no other questions, let's go ahead and solve a related problem still

1033
00:50:00,840 --> 00:50:03,510
用一些Python，但这会增加
with some Python but that's going to push up

1034
00:50:03,510 --> 00:50:09,150
在将我们的数据存储在CSV文件中时，效率受到限制。
against the limits of efficiency when it comes to storing our data in CSV files.

1035
00:50:09,150 --> 00:50:13,113
让我继续，从这个文件“ Favorites.py”中重新开始。
Let me go ahead and start fresh in this file, Favorites.py.

1036
00:50:13,112 --> 00:50:15,029
不过，到目前为止，我已经编写了所有代码，
All of the code I've written thus far, though,

1037
00:50:15,030 --> 00:50:16,905
事先在课程的网站上，所以您
is on the course's website in advance, so you

1038
00:50:16,905 --> 00:50:18,570
可以看到逐步的改善。
can see the incremental improvement.

1039
00:50:18,570 --> 00:50:21,280
我要继续，再次在顶部导入csv。
I'm going to go ahead and, again, import csv at the top.

1040
00:50:21,280 --> 00:50:24,690
现在让我们编写一次不只是一个程序
And now let's write a program this time that doesn't just

1041
00:50:24,690 --> 00:50:27,990
自动打开CSV并对其进行分析
automatically open up the CSV and analyze it looking

1042
00:50:27,989 --> 00:50:31,019
节目的整体人气。
for the total popularity of shows.

1043
00:50:31,019 --> 00:50:35,429
让我们在CSV中搜索特定的节目，然后
Let's search for a specific show in the CSV and then

1044
00:50:35,429 --> 00:50:39,081
继续并输出其受欢迎程度。
go ahead and output the popularity thereof.

1045
00:50:39,081 --> 00:50:41,039
我可以通过多种不同的方式来做到这一点。
And I can do this in a bunch of different ways.

1046
00:50:41,039 --> 00:50:43,414
但是我将尝试使其尽可能简洁。
But I'm going to try to make this as concise as possible.

1047
00:50:43,414 --> 00:50:46,799
我首先要请用户输入标题。
I'm first going to ask the user to input a title.

1048
00:50:46,800 --> 00:50:49,170
我可以使用CS50的get_string函数。
I could use CS50's get_string function.

1049
00:50:49,170 --> 00:50:52,330
但是请记住，它与Python的输入函数几乎相同，
But recall that it's pretty much the same as Python's input function,

1050
00:50:52,329 --> 00:50:55,739
因此，今天我将使用Python的输入函数。
so I'm going to use Python's input function today.

1051
00:50:55,739 --> 00:50:57,779
然后，我将继续，和以前一样，
And then I'm going to go ahead and, as before,

1052
00:50:57,780 --> 00:51:01,350
打开称为“收藏的电视节目”的相同CSV-
open up that same CSV called Favorite TV Shows -

1053
00:51:01,349 --> 00:51:08,009
表单响应1.csv在只读模式下为变量，称为文件。
Form Responses 1.csv in read-only mode as a variable called file.

1054
00:51:08,010 --> 00:51:11,160
然后，我要给自己一个读者，然后我将再次使用DictReader
I'm then going to give myself a reader, and I'll use a DictReader again

1055
00:51:11,159 --> 00:51:14,519
因此我不必担心知道事物在哪一列中，
so I don't have to worry about knowing which columns things are in,

1056
00:51:14,519 --> 00:51:16,079
传入文件。
passing in file.

1057
00:51:16,079 --> 00:51:17,339
然后让我们看看。
And then let's see.

1058
00:51:17,340 --> 00:51:20,310
如果我只关心一个标题，则可以使该程序更简单。
If I only care about one title, I can keep this program simpler.

1059
00:51:20,309 --> 00:51:23,339
我不需要弄清楚每个节目的受欢迎程度。
I don't need to figure out the popularity of every show.

1060
00:51:23,340 --> 00:51:26,880
我只需要弄清楚一个节目的受欢迎程度，标题
I just need to figure out the popularity of one show, the title

1061
00:51:26,880 --> 00:51:28,510
人类输入的内容。
that the human has typed in.

1062
00:51:28,510 --> 00:51:32,160
所以我要继续给自己一个很简单的int叫做counter
So I'm going to go ahead and give myself a very simple int called counter

1063
00:51:32,159 --> 00:51:33,479
并将其设置为0。
and set it equal to 0.

1064
00:51:33,480 --> 00:51:34,950
我不需要一本完整的字典。
I don't need a whole dictionary.

1065
00:51:34,949 --> 00:51:36,929
现在只有一个变量就足够了。
Just one variable suffices now.

1066
00:51:36,929 --> 00:51:42,299
我将像以前一样继续遍历阅读器中的行。
And I'm going to go ahead and iterate over the rows in the reader, as before.

1067
00:51:42,300 --> 00:51:48,600
然后我要说的是当前行的标题是否为人类的标题
And then I'm going to say if the current row's title == the title the human

1068
00:51:48,599 --> 00:51:51,929
输入，让我们继续前进，将计数器加1。
typed in, let's go ahead and increment counter by 1.

1069
00:51:51,929 --> 00:51:54,509
并且它已经初始化，因为我在第7行上执行了该操作。
And it's already initialized, because I did that on line 7.

1070
00:51:54,510 --> 00:51:55,500
所以我认为我很好。
So I think I'm good.

1071
00:51:55,500 --> 00:51:57,449
然后在该程序结束时，让我们
And then at the end of this program, let's

1072
00:51:57,449 --> 00:51:59,939
非常简单地打印出计数器的值。
very simply print out the value of counter.

1073
00:51:59,940 --> 00:52:04,920
因此，该程序的目的是提示用户显示节目的标题
So the purpose of this program is to prompt the user for a title of a show

1074
00:52:04,920 --> 00:52:08,220
然后只报告其受欢迎程度
and then just report the popularity thereof

1075
00:52:08,219 --> 00:52:11,039
通过计算它在文件中的实例数。
by counting the number of instances of it in the file.

1076
00:52:11,039 --> 00:52:14,519
因此，让我继续并使用favorite.py的python运行它。
So let me go ahead and run this with python of favorites.py.

1077
00:52:14,519 --> 00:52:15,449
进入。
Enter.

1078
00:52:15,449 --> 00:52:21,439
我继续输入“办公室”，然后按Enter，然后输入19。
Let me go ahead and type in "The Office," Enter, and 19.

1079
00:52:21,440 --> 00:52:23,710
现在，我不记得确切的数字了。
Now, I don't remember exactly what the number was.

1080
00:52:23,710 --> 00:52:26,620
但是我记得办公室比这更受欢迎。
But I remember The Office was more popular than that.

1081
00:52:26,619 --> 00:52:29,839
我很确定那不是19岁。
I'm pretty sure it was not 19.

1082
00:52:29,840 --> 00:52:35,645
关于为什么该程序有错误或看起来如此直观的任何直觉？
Any intuition as to why this program is buggy or so it would seem?

1083
00:52:35,644 --> 00:52:37,519
布莱恩·于：聊天中的几个人在说
BRIAN YU: A few people in the chat are saying

1084
00:52:37,519 --> 00:52:40,634
您需要记住再次处理大写和空白。
you need to remember to deal with capitalization and white space again.

1085
00:52:40,635 --> 00:52:41,510
DAVID J. MALAN：是的。
DAVID J. MALAN: Yeah.

1086
00:52:41,510 --> 00:52:44,790
因此，我们需要实践从以前学到的相同的经验教训。
So we need to practice those same lessons learned from before.

1087
00:52:44,789 --> 00:52:48,829
因此，我应该真正规范化我刚刚输入的人类的输入
So I should really canonicalize the input that the human, I, just typed in

1088
00:52:48,829 --> 00:52:51,979
以及来自CSV文件的输入。
and also the input that's coming from the CSV file.

1089
00:52:51,980 --> 00:52:53,990
也许最简单的方法是在这里，
Perhaps the simplest way to do this is, up here,

1090
00:52:53,989 --> 00:52:57,199
首先去除开头和结尾的空白，以防万一
to first strip off leading and trailing white space in case I get a little

1091
00:52:57,199 --> 00:52:59,669
马虎，打我不应该的空格键。
sloppy and hit the Space bar where I shouldn't.

1092
00:52:59,670 --> 00:53:02,612
然后，让我们继续将其强制为大写是因为。
And then let's go ahead and force it to uppercase just because.

1093
00:53:02,612 --> 00:53:04,320
大小无关紧要
It doesn't matter if it's upper or lower,

1094
00:53:04,320 --> 00:53:06,420
但至少我们将以这种方式进行标准化。
but at least we'll standardize things that way.

1095
00:53:06,420 --> 00:53:10,130
然后，当我执行此操作时，请查看当前行标题。
And then when I do this, look at the current rows title.

1096
00:53:10,130 --> 00:53:12,170
我认为我确实需要做同样的事情。
I think I really need to do the same thing.

1097
00:53:12,170 --> 00:53:15,140
如果要规范一个，则需要规范另一个。
If I'm going to canonicalize one, I need to canonical the other.

1098
00:53:15,139 --> 00:53:19,789
现在比较全大写，空格分隔的版本
And now compare the all-caps, white-space-stripped versions

1099
00:53:19,789 --> 00:53:20,729
这两个字符串。
of both strings.

1100
00:53:20,730 --> 00:53:21,920
现在让我重新运行它。
So now let me rerun it.

1101
00:53:21,920 --> 00:53:24,020
现在，我要输入“ The Office”，然后按Enter。
Now I'm going to type in "The Office," Enter.

1102
00:53:24,019 --> 00:53:24,769
和瞧。
And voila.

1103
00:53:24,769 --> 00:53:28,129
现在我已经26岁了，我认为这是我们以前的位置。
Now I'm at 26, which I think is where we were at before.

1104
00:53:28,130 --> 00:53:30,890
实际上，现在我（用户）可能有点草率。
And in fact, now I, the user, can be a little sloppy.

1105
00:53:30,889 --> 00:53:32,449
我可以说“办公室”。
I can say "the office."

1106
00:53:32,449 --> 00:53:35,779
我可以再次运行它并说“办公室”，然后无论出于何种原因，
I can run it again and say "the office" and then, for whatever reason,

1107
00:53:35,780 --> 00:53:37,460
打很多空格键，回车。
hit the Space bar a lot, Enter.

1108
00:53:37,460 --> 00:53:38,570
它仍然可以正常工作。
It's still going to work.

1109
00:53:38,570 --> 00:53:41,810
确实，尽管我们似乎在这里here脚
And indeed, though we seem to be belaboring the pedantic here

1110
00:53:41,809 --> 00:53:44,682
修剪空白等等，只是想一想。
with trimming off white space and so forth, just think.

1111
00:53:44,682 --> 00:53:46,849
在相对较小的受众群体中，你们中有多少人
In a relatively small audience here, how many of you

1112
00:53:46,849 --> 00:53:50,149
不小心碰到了空格键还是大写的东西不一样？
accidentally hit the Space bar or capitalized things differently?

1113
00:53:50,150 --> 00:53:52,340
这是大规模发生的。
This happens massively on scale.

1114
00:53:52,340 --> 00:53:55,040
您可以想象，在标记时，这一点很重要
And you can imagine this being important when you're tagging

1115
00:53:55,039 --> 00:53:56,779
一些社交媒体帐户中的朋友。
friends in some social media account.

1116
00:53:56,780 --> 00:53:58,940
你在做@Brian之类的。
You're doing @Brian or the like.

1117
00:53:58,940 --> 00:54:02,510
您不需要要求用户输入@，大写B，
You don't want to have to require the user to type @, capital B,

1118
00:54:02,510 --> 00:54:05,100
小写的rian，依此类推。
lowercase r-i-a-n, and so forth.

1119
00:54:05,099 --> 00:54:07,879
因此可以容忍分散的，混乱的用户输入
So tolerating disparate, messy user input

1120
00:54:07,880 --> 00:54:11,990
是要解决的常见问题，包括
is such a common problem to solve, including

1121
00:54:11,989 --> 00:54:14,739
在我们大家都使用的当今应用程序中。
in today's apps that we all use.

1122
00:54:14,739 --> 00:54:15,279
好的。
All right.

1123
00:54:15,280 --> 00:54:21,000
那么，对此程序有什么疑问，我认为是正确的吗？
Any questions, then, on this program, which I think is correct?

1124
00:54:21,000 --> 00:54:22,889
然后让我问你一个问题。
Then let me ask a question of you.

1125
00:54:22,889 --> 00:54:27,079
在什么意义上该程序设计不佳？
In what sense is this program poorly designed?

1126
00:54:27,079 --> 00:54:30,859
在什么意义上该程序设计不佳？
In what sense is this program poorly designed?

1127
00:54:30,860 --> 00:54:33,480
这更加微妙。
This is more subtle.

1128
00:54:33,480 --> 00:54:38,040
但是从大O角度考虑该程序的运行时间。
But think about the running time of this program in terms of big O.

1129
00:54:38,039 --> 00:54:45,029
如果CSV文件有n个不同的节目，该程序的运行时间是多少
What is the running time of this program if the CSV file has n different shows

1130
00:54:45,030 --> 00:54:47,610
还是n个不同的提交？
in it or n different submissions?

1131
00:54:47,610 --> 00:54:50,310
所以n是有问题的变量。
So n is the variable in question.

1132
00:54:50,309 --> 00:54:53,121
是的，那是什么时间，安德鲁？
Yeah, what's the running time, Andrew?

1133
00:54:53,121 --> 00:54:55,509
观众：[听不清]
AUDIENCE: [INAUDIBLE]

1134
00:54:55,510 --> 00:54:58,260
DAVID J. MALAN：是的，这是n的大O，因为我实际上是在使用
DAVID J. MALAN: Yeah, it's big O of n, because I'm literally using

1135
00:54:58,260 --> 00:55:00,400
通过for循环进行线性搜索。
linear search by way of the for loop.

1136
00:55:00,400 --> 00:55:04,000
就像C中一样，这就是for循环在Python中的工作方式。
That's how a for loop works in Python, just like in C. Starts at the beginning

1137
00:55:04,000 --> 00:55:06,080
并可能一路走到尽头。
and potentially goes all the way till the end.

1138
00:55:06,079 --> 00:55:08,729
因此，我正在使用隐式线性搜索，
And so I'm using implicitly linear search,

1139
00:55:08,730 --> 00:55:11,910
因为我没有使用任何花哨的数据结构，没有集合，没有字典。
because I'm not using any fancy data structures, no sets, no dictionaries.

1140
00:55:11,909 --> 00:55:14,139
我只是从上到下循环。
I'm just looping from top to bottom.

1141
00:55:14,139 --> 00:55:18,389
因此，您可以想象，如果我们不仅调查了这里的所有学生，
So you can imagine that if we surveyed not just all of the students here

1142
00:55:18,389 --> 00:55:21,389
在课堂上，但也许每个人都在校园里或世界上每个人-
in class but maybe everyone on campus or everyone in the world--

1143
00:55:21,389 --> 00:55:24,239
也许我们是互联网电影数据库，IMDb。
maybe we're Internet Movie Database, IMDb.

1144
00:55:24,239 --> 00:55:28,709
可能会有大量的选票和大量的演出。
There could be a huge number of votes and a huge number of shows.

1145
00:55:28,710 --> 00:55:32,460
因此编写程序，无论是在像我这样的终端窗口中
And so writing a program, whether it's in a terminal window like mine

1146
00:55:32,460 --> 00:55:36,480
或在移动设备上，或者在笔记本电脑或台式机的网页上，
or maybe on a mobile device or maybe on a webpage for your laptop or desktop,

1147
00:55:36,480 --> 00:55:40,800
这可能不是不断循环的最佳设计
it's probably not the best design to constantly loop

1148
00:55:40,800 --> 00:55:44,190
从顶部开始浏览数据库中的所有节目
over all of the shows in your database from top

1149
00:55:44,190 --> 00:55:47,250
仅仅回答一个问题。
to bottom just to answer a single question.

1150
00:55:47,250 --> 00:55:51,501
以n次或以固定时间记录会更好。
It would be much nicer to do things in log of n time or in constant time.

1151
00:55:51,501 --> 00:55:54,209
值得庆幸的是，在过去的几周中，无论是在C语言还是Python语言中，
And thankfully, over the past few weeks, both in C and in Python,

1152
00:55:54,210 --> 00:55:57,390
我们已经看到了更聪明的方法来做到这一点。
we have seen smarter ways to do this.

1153
00:55:57,389 --> 00:56:00,419
但是我没有练习我在这里讲的内容。
But I'm not practicing what I've preached here.

1154
00:56:00,420 --> 00:56:05,520
实际上，在某种程度上，这种平面文件数据库的概念
And in fact, at some point, this notion of a flat-file database

1155
00:56:05,519 --> 00:56:07,439
对我们来说太原始了。
starts to get too primitive for us.

1156
00:56:07,440 --> 00:56:11,670
平面文件数据库（如CSV文件）非常有用
Flat-file databases, like CSV files, are wonderfully useful

1157
00:56:11,670 --> 00:56:13,590
当您只想快速做某事时
when you just want to do something quickly

1158
00:56:13,590 --> 00:56:16,410
或者当您想从某个第三方下载数据时，
or when you want to download data from some third party,

1159
00:56:16,409 --> 00:56:18,517
像Google一样，以一种标准的可移植方式进行。
like Google, in a standard, portable way.

1160
00:56:18,518 --> 00:56:21,810
“便携式”意味着它可以由不同的人和不同的系统使用。
"Portable" means that it can be used by different people and different systems.

1161
00:56:21,809 --> 00:56:23,759
CSV尽可能简单，因为您
CSV is about as simple as it gets, because you

1162
00:56:23,760 --> 00:56:26,250
不需要拥有Microsoft Word或Apple
don't need to own Microsoft Word or Apple

1163
00:56:26,250 --> 00:56:28,149
数字或任何特定产品。
Numbers or any particular product.

1164
00:56:28,150 --> 00:56:30,750
这只是一个文本文件，因此您可以使用任何文本编辑
It's just a text file, so you can use any text editing

1165
00:56:30,750 --> 00:56:34,140
程序或任何编程语言来访问它。
program or any programming language to access it.

1166
00:56:34,139 --> 00:56:38,729
但是平面文件数据库不一定是最佳结构
But flat-file databases aren't necessarily the best structure

1167
00:56:38,730 --> 00:56:42,750
最终用于较大的数据集，因为它们实际上并没有
to use ultimately for larger data sets, because they don't really

1168
00:56:42,750 --> 00:56:44,790
使自己能够进行更有效的查询。
lend themselves to more efficient queries.

1169
00:56:44,789 --> 00:56:48,279
因此，CSV文件最多只能搜索到上至下，
So CSV files, pretty much at best, you have to search top to bottom,

1170
00:56:48,280 --> 00:56:49,140
左到右。
left to right.

1171
00:56:49,139 --> 00:56:53,069
但是事实证明，那里有更好的数据库
But it turns out that there are better databases out there generally known

1172
00:56:53,070 --> 00:56:57,960
作为关系数据库，而不是存储数据的文件，
as relational databases that, instead of being files in which you store data,

1173
00:56:57,960 --> 00:57:01,230
它们是存储数据的程序。
they are instead programs in which you store data.

1174
00:57:01,230 --> 00:57:04,830
现在，公平地说，这些程序会占用大量RAM，内存，
Now, to be fair, those programs use a lot of RAM, memory,

1175
00:57:04,829 --> 00:57:06,389
他们实际在哪里存储您的数据。
where they actually store your data.

1176
00:57:06,389 --> 00:57:08,669
而且他们的确可以持久保存您的数据。
And they do certainly persist your data.

1177
00:57:08,670 --> 00:57:12,600
他们通过将数据也存储在文件中来长期保存数据。
They keep it long term by storing your data also in files.

1178
00:57:12,599 --> 00:57:16,109
但是在您和您的数据之间，有这个正在运行的程序。
But between you and your data, there is this running program.

1179
00:57:16,110 --> 00:57:20,070
而且，如果您曾经听说过Oracle或MySQL或PostgreSQL或SQL Server
And if you've ever heard of Oracle or MySQL or PostgreSQL or SQL Server

1180
00:57:20,070 --> 00:57:23,880
或Microsoft Access或许多其他受欢迎的产品，
or Microsoft Access or bunches of other popular products,

1181
00:57:23,880 --> 00:57:26,520
商业，免费和开源都一样，
both commercial and free and open source alike,

1182
00:57:26,519 --> 00:57:30,719
关系数据库在本质上与电子表格非常相似。
relational databases are so similar in spirit to spreadsheets.

1183
00:57:30,719 --> 00:57:33,689
但是它们是用软件实现的。
But they are implemented in software.

1184
00:57:33,690 --> 00:57:35,490
而且它们为我们提供了越来越多的功能。
And they give us more and more features.

1185
00:57:35,489 --> 00:57:37,359
而且他们使用越来越多的数据结构
And they use more and more data structures

1186
00:57:37,360 --> 00:57:42,550
这样我们就可以搜索数据，插入数据，删除数据，大量更新数据，
so that we can search for data, insert data, delete data, update data much,

1187
00:57:42,550 --> 00:57:47,350
比起只使用CSV文件这样的方式，效率要高得多。
much more efficiently than we could if just using something like a CSV file.

1188
00:57:47,349 --> 00:57:49,599
因此，让我们继续前进，在这里休息五分钟。
So let's go ahead and take our five-minute break here.

1189
00:57:49,599 --> 00:57:52,557
当我们回来时，我们将研究关系数据库，然后，
And when we come back, we'll look at relational databases and, in turn,

1190
00:57:52,557 --> 00:57:54,399
一种称为SQL的语言。
a language called SQL.

1191
00:57:54,400 --> 00:57:55,170
好的。
All right.

1192
00:57:55,170 --> 00:57:56,190
所以我们回来了。
So we are back.

1193
00:57:56,190 --> 00:57:58,890
现在的目标是过渡
And the goal at hand now is to transition

1194
00:57:58,889 --> 00:58:02,339
从这些相当简单的平面文件数据库中
from these fairly simplistic flat-file databases

1195
00:58:02,340 --> 00:58:04,260
到更合适的关系数据库。
to a more proper relational database.

1196
00:58:04,260 --> 00:58:07,500
关系数据库的确具有如此强大的功能
And relational databases are indeed what power so many

1197
00:58:07,500 --> 00:58:10,470
当今的移动应用程序，Web应用程序等。
of today's mobile applications, web applications, and the like.

1198
00:58:10,469 --> 00:58:13,169
现在我们开始过渡到现实世界的软件
Now we're beginning to transition to real-world software

1199
00:58:13,170 --> 00:58:16,210
使用现实世界的语言。
with real-world languages, at that.

1200
00:58:16,210 --> 00:58:20,610
现在，让我介绍一下我们称之为SQLite的内容。
And so now, let me introduce what we're going to call SQLite.

1201
00:58:20,610 --> 00:58:23,040
因此事实证明，一个关系数据库
So it turns out that a relational database

1202
00:58:23,039 --> 00:58:27,659
是一个数据库，它以行和列的形式存储所有数据。
is a database that stores all of the data still in rows and columns.

1203
00:58:27,659 --> 00:58:30,959
但是，使用电子表格或工作表并不能做到这一点。
But it doesn't do so using spreadsheets or sheets.

1204
00:58:30,960 --> 00:58:33,930
相反，它使用我们将要调用的表来实现。
It instead does so using what we're going to call tables.

1205
00:58:33,929 --> 00:58:36,119
因此，几乎是相同的想法。
So it's pretty much the same idea.

1206
00:58:36,119 --> 00:58:39,119
但是，有了表，我们可以获得一些附加功能。
But with tables, we get some additional functionality.

1207
00:58:39,119 --> 00:58:41,129
有了这些表，我们将有能力
With those tables, we'll have the ability

1208
00:58:41,130 --> 00:58:46,480
搜索数据，更新数据，删除数据，插入新数据等。
to search for data, update data, delete data, insert new data, and the like.

1209
00:58:46,480 --> 00:58:49,188
这些是我们绝对可以使用电子表格完成的事情。
And these are things that we absolutely can do with spreadsheets.

1210
00:58:49,188 --> 00:58:52,105
但是在电子表格的世界中，如果您要搜索某些内容，
But in the world of spreadsheets, if you want to search for something,

1211
00:58:52,105 --> 00:58:54,840
是您，人类，通过手动单击和滚动来做到这一点，
it's you, the human, doing it by manually clicking and scrolling,

1212
00:58:54,840 --> 00:58:55,340
通常。
typically.

1213
00:58:55,340 --> 00:58:57,390
如果您要插入数据，就是您，人类，
If you want to insert data, it's you, the human,

1214
00:58:57,389 --> 00:58:59,361
添加新行后手动输入。
typing it in manually after adding a new row.

1215
00:58:59,362 --> 00:59:01,320
如果要删除某物，就对了
If you want to delete something, it's you right

1216
00:59:01,320 --> 00:59:04,350
单击或按住Control单击并删除整行
clicking or Control-clicking and deleting a whole row

1217
00:59:04,349 --> 00:59:06,749
或更新它们所在的单个单元格。
or updating the individual cells they're in.

1218
00:59:06,750 --> 00:59:11,910
有了SQL，结构化查询语言，我们有了新的编程语言
With SQL, Structured Query Language, we have a new programming language

1219
00:59:11,909 --> 00:59:15,359
通常与其他编程语言结合使用。
that is very often used in conjunction with other programming languages.

1220
00:59:15,360 --> 00:59:18,930
因此，今天，我们将看到SQL最初是单独使用的。
And so today, we'll see SQL used on its own initially.

1221
00:59:18,929 --> 00:59:21,989
但是我们还将在Python程序的上下文中看到它。
But we'll also see it in the context of a Python program.

1222
00:59:21,989 --> 00:59:28,169
因此，像Python这样的语言本身就可以使用SQL来完成更强大的功能
So a language like Python can itself use SQL to do more powerful things

1223
00:59:28,170 --> 00:59:30,660
比Python独有。
than Python alone could do.

1224
00:59:30,659 --> 00:59:34,439
如此说来，SQLite就像是SQL的简易版。
So with that said, SQLite is like a light version of SQL.

1225
00:59:34,440 --> 00:59:35,940
这是一个更加用户友好的版本。
It's a more user-friendly version.

1226
00:59:35,940 --> 00:59:36,780
更便携。
It's more portable.

1227
00:59:36,780 --> 00:59:40,260
它可以在Mac和PCS以及手机，笔记本电脑和台式机上使用
It can be used on Macs and PCS and phones and laptops and desktops

1228
00:59:40,260 --> 00:59:40,950
和服务器。
and servers.

1229
00:59:40,949 --> 00:59:42,119
但这是非常普遍的。
But it's incredibly common.

1230
00:59:42,119 --> 00:59:45,809
实际上，在您的iPhone和Android手机中，许多应用程序
In fact, in your iPhone and your Android phone, many of the applications

1231
00:59:45,809 --> 00:59:50,249
您今天在自己的设备上运行，并且在后台使用SQLite。
you are running today on your own device are using SQLite underneath the hood.

1232
00:59:50,250 --> 00:59:52,290
因此，它本身不是玩具语言。
So it isn't a toy language per se.

1233
00:59:52,289 --> 00:59:55,149
相反，这是一个相对简单的实现
It's instead a relatively simple implementation

1234
00:59:55,150 --> 00:59:56,920
一种通常称为SQL的语言。
of a language generally known as SQL.

1235
00:59:56,920 --> 01:00:00,680
长话短说，关系数据库还有其他实现
But long story short, there's other implementations of relational databases

1236
01:00:00,679 --> 01:00:01,179
在那里。
out there.

1237
01:00:01,179 --> 01:00:02,971
我已经吵了几声-
And I rattled off several of them already--

1238
01:00:02,972 --> 01:00:05,620
Oracle和MySQL以及PostgreSQL之类。
Oracle and MySQL and PostgreSQL and the like.

1239
01:00:05,619 --> 01:00:09,909
这些都具有稍微不同的SQL风格或方言。
Those all have slightly different flavors or dialects of SQL.

1240
01:00:09,909 --> 01:00:14,859
因此，SQL是用于与数据库交互的相当标准的语言。
So SQL is a fairly standard language for interacting with databases.

1241
01:00:14,860 --> 01:00:16,960
但是不同的公司，不同的社区
But different companies, different communities

1242
01:00:16,960 --> 01:00:20,200
有增加或减少自己喜欢的功能。
have kind of added or subtracted their own preferred features.

1243
01:00:20,199 --> 01:00:24,339
因此，您使用的语法通常在所有平台上都是不变的。
And so the syntax you use is generally constant across all platforms.

1244
01:00:24,340 --> 01:00:27,458
但是我们将针对我们的目的在SQLite上进行标准化。
But we will standardize for our purposes on SQLite.

1245
01:00:27,458 --> 01:00:29,500
确实，这就是您最近使用的方式
And indeed, this is what you would use these days

1246
01:00:29,500 --> 01:00:31,819
在移动应用程序世界中。
in the world of mobile applications.

1247
01:00:31,820 --> 01:00:33,710
因此，那里非常紧密。
So it's very much germane there.

1248
01:00:33,710 --> 01:00:39,760
因此，使用SQLite，我们最终将拥有查询数据的功能
So with SQLite, we're going to have ultimately the ability to query data

1249
01:00:39,760 --> 01:00:41,690
以及更新数据，删除数据等。
and update data, delete data, and the like.

1250
01:00:41,690 --> 01:00:44,080
但是要做到这一点，我们实际上需要一个程序
But to do so, we actually need a program with which

1251
01:00:44,079 --> 01:00:46,219
与我们的数据库进行交互。
to interact with our database.

1252
01:00:46,219 --> 01:00:50,319
因此，SQLite的工作方式是存储所有数据
So the way SQLite works is that it stores all of your data

1253
01:00:50,320 --> 01:00:51,920
仍在文件中。
still in a file.

1254
01:00:51,920 --> 01:00:53,500
但这是一个二进制文件。
But it's a binary file now.

1255
01:00:53,500 --> 01:00:55,689
也就是说，它是一个包含0和1的文件。
That is, it's a file containing 0's and 1's.

1256
01:00:55,690 --> 01:00:57,550
而那些0和1可能代表文本。
And those 0's and 1's might represent text.

1257
01:00:57,550 --> 01:00:58,810
它们可能代表数字。
They might represent numbers.

1258
01:00:58,809 --> 01:01:01,569
但这是一种更紧凑，更有效的表示
But it's a more compact, efficient representation

1259
01:01:01,570 --> 01:01:05,290
而不是仅CSV文件将使用ASCII还是Unicode。
than a mere CSV file would be using ASCII or Unicode.

1260
01:01:05,289 --> 01:01:06,669
所以这是第一个区别。
So that's the first difference.

1261
01:01:06,670 --> 01:01:10,690
SQLite使用一个文件，一个二进制文件，
SQLite uses a single file, a binary file,

1262
01:01:10,690 --> 01:01:14,470
存储所有数据，并通过所有方式将其表示在该文件中
to store all of your data and represent it inside of that file by way of all

1263
01:01:14,469 --> 01:01:18,109
我之前提到的那些0和1或表格中的一个，
of those 0's and 1's or the tables to which I alluded before,

1264
01:01:18,110 --> 01:01:22,180
这是工作表或电子表格的数据库世界中的类似物
which are the analogue in the database world of sheets or spreadsheets

1265
01:01:22,179 --> 01:01:23,689
在电子表格世界中。
in the spreadsheet world.

1266
01:01:23,690 --> 01:01:28,940
因此，要与存储所有数据的二进制文件进行交互，
So to interact with that binary file wherein all of your data is stored,

1267
01:01:28,940 --> 01:01:31,283
我们需要某种面向用户的程序。
we need some kind of user-facing program.

1268
01:01:31,282 --> 01:01:32,949
并且有许多不同的工具可供使用。
And there's many different tools to use.

1269
01:01:32,949 --> 01:01:36,969
但是SQLite附带的标准
But the standard one that comes with SQLite

1270
01:01:36,969 --> 01:01:40,749
称为sqlite3，本质上是该工具的第3版。
is called sqlite3, essentially version 3 of the tool.

1271
01:01:40,750 --> 01:01:44,049
这是一种命令行工具，其实质类似于任何命令
This is a command line tool similar in spirit to any of the commands

1272
01:01:44,050 --> 01:01:46,000
到目前为止，您已经在终端窗口中运行了
you've run in a terminal window thus far that

1273
01:01:46,000 --> 01:01:50,394
允许您打开该二进制文件并与所有表进行交互。
allows you to open up that binary file and interact with all of your tables.

1274
01:01:50,394 --> 01:01:53,019
现在，再次在这里，我们遇到了鸡肉和鸡蛋的问题。
Now, here again, we kind of have a chicken and the egg problem.

1275
01:01:53,019 --> 01:01:56,289
如果我想使用数据库但还没有数据库
If I want to use a database but I don't yet have a database

1276
01:01:56,289 --> 01:01:58,569
但是我想从数据库中选择数据，
and yet I want to select data from my database,

1277
01:01:58,570 --> 01:02:00,040
我如何实际加载东西？
how do I actually load things in?

1278
01:02:00,039 --> 01:02:04,129
好了，您可以通过至少两种方式将数据加载到SQLite数据库中。
Well, you can load data into a SQLite database in at least two ways.

1279
01:02:04,130 --> 01:02:06,490
一会儿，我会做的，你可以
One, which I'll do in a moment, you can just

1280
01:02:06,489 --> 01:02:10,479
导入现有的平面文件数据库，例如CSV。
import an existing flat-file database, like a CSV.

1281
01:02:10,480 --> 01:02:15,640
您要做的就是将CSV保存在Mac或PC上的CS50 IDE上。
And what you do is you save the CSV on your Mac or PC on your CS50 IDE.

1282
01:02:15,639 --> 01:02:18,099
您可以使用sqlite3运行特殊命令。
You run a special command with sqlite3.

1283
01:02:18,099 --> 01:02:21,429
它将仅将CSV加载到内存中。
And it will just load the CSV into memory.

1284
01:02:21,429 --> 01:02:23,619
它将找出所有逗号在哪里。
It will figure out where all of the commas are.

1285
01:02:23,619 --> 01:02:28,509
它将在该二进制文件内部构造相应的行
And it will construct inside of that binary file the corresponding rows

1286
01:02:28,510 --> 01:02:31,360
和使用适当的0和1的列
and columns using the appropriate 0's and 1's

1287
01:02:31,360 --> 01:02:32,810
存储所有这些信息。
to store all of that information.

1288
01:02:32,809 --> 01:02:35,409
因此，它将自动为您导入。
So it just imports it for you automatically.

1289
01:02:35,409 --> 01:02:39,309
方法2是实际使用Python之类的语言编写代码
Approach 2 would be to actually write code in a language like Python

1290
01:02:39,309 --> 01:02:44,289
或任何其他实际手动插入所有数据的数据
or any other that actually manually inserts all of the data

1291
01:02:44,289 --> 01:02:45,154
到您的数据库中。
into your database.

1292
01:02:45,155 --> 01:02:46,280
我们也会这样做。
And we'll do that, as well.

1293
01:02:46,280 --> 01:02:47,290
但是，让我们从简单开始。
But let's start simple.

1294
01:02:47,289 --> 01:02:51,069
让我继续运行，例如sqlite3。
Let me go ahead and run, for instance, sqlite3.

1295
01:02:51,070 --> 01:02:54,550
这是预安装在CS50 IDE上的，安装起来并不难
And this is preinstalled on CS50 IDE, and it's not that hard to get it up

1296
01:02:54,550 --> 01:02:56,570
并可以在Mac和PC上运行。
and running on a Mac and PC, as well.

1297
01:02:56,570 --> 01:02:59,860
我将继续在此处的终端窗口中运行sqlite3。
I'm going to go ahead and run sqlite3 in my terminal window here.

1298
01:02:59,860 --> 01:03:00,610
和瞧。
And voila.

1299
01:03:00,610 --> 01:03:03,430
您只看到一些非常简单的输出。
You just see some very simple output.

1300
01:03:03,429 --> 01:03:07,022
它告诉我如果要查看一些使用提示，请键入.help。
It's telling me to type .help if I want to see some usage hints.

1301
01:03:07,023 --> 01:03:09,190
但是我知道大多数命令，我们通常会
But I know most of the commands, and we'll generally

1302
01:03:09,190 --> 01:03:11,232
提供您可能需要的所有命令。
give you all of the commands that you might need.

1303
01:03:11,231 --> 01:03:15,759
实际上，我们可以使用的命令之一是.mode，另一个是.import。
In fact, one of the commands that we can use is .mode, and another is .import.

1304
01:03:15,760 --> 01:03:18,100
因此，通常来说，您不会经常使用这些内容。
So generally, you won't use these that frequently.

1305
01:03:18,099 --> 01:03:21,669
仅当首次创建数据库时，才使用它们
You'll only use them when creating a database for the first time when

1306
01:03:21,670 --> 01:03:25,002
您是通过现有CSV文件创建该数据库的。
you are creating that database from an existing CSV file.

1307
01:03:25,001 --> 01:03:26,709
确实，这是我目前的目标。
And indeed, that's my goal at the moment.

1308
01:03:26,710 --> 01:03:30,610
让我来获取包含您所有喜欢的电视节目的CSV文件
Let me take our CSV file containing all of your favorite TV shows

1309
01:03:30,610 --> 01:03:35,650
并将其加载到适当的关系数据库中的SQLite中
and load it into SQLite in a proper relational database

1310
01:03:35,650 --> 01:03:39,460
这样我们可以做得比n的大O好
so that we can do better than, for instance, big O of n

1311
01:03:39,460 --> 01:03:42,730
当涉及到搜索数据并对其进行其他操作时。
when it comes to searching that data and doing anything else on it.

1312
01:03:42,730 --> 01:03:44,960
为此，我必须执行两个命令。
So to do this, I have to execute two commands.

1313
01:03:44,960 --> 01:03:48,280
第一，我需要将SQLite置于CSV模式。
One, I need to put SQLite into CSV mode.

1314
01:03:48,280 --> 01:03:51,010
这只是将其与其他平面文件格式区分开来，
And that's just to distinguish it from other flat-file formats,

1315
01:03:51,010 --> 01:03:53,890
例如用于制表符或其他格式的TSV。
like TSV for tabs or some other format.

1316
01:03:53,889 --> 01:03:56,229
现在，我将继续运行.import。
And now I'm going to go ahead and run .import.

1317
01:03:56,230 --> 01:03:59,920
然后，我必须指定要导入的文件的名称，即CSV。
Then I have to specify the name of the file to import, which is the CSV.

1318
01:03:59,920 --> 01:04:03,490
我将继续打电话给我的桌子秀。
And I'm going to go ahead and call my table shows.

1319
01:04:03,489 --> 01:04:08,499
因此，.import需要两个参数，即您要导入的文件的名称。
So .import takes two arguments, the name of the file that you want to import

1320
01:04:08,500 --> 01:04:12,430
以及要从该文件中创建的表的名称。
and the name of the table that you want to create out of that file.

1321
01:04:12,429 --> 01:04:14,679
同样，表具有行和列。
And again, tables have rows and columns.

1322
01:04:14,679 --> 01:04:18,279
文件中的逗号要划定
And the commas in the file are going to delineate

1323
01:04:18,280 --> 01:04:20,290
这些列的开始和结束位置。
where those columns begin and end.

1324
01:04:20,289 --> 01:04:21,789
我要继续并按Enter。
I'm going to go ahead and hit Enter.

1325
01:04:21,789 --> 01:04:24,669
看起来飞起来很快。
It looks like it flew by pretty fast.

1326
01:04:24,670 --> 01:04:26,560
似乎什么都没发生。
Nothing seems to have happened.

1327
01:04:26,559 --> 01:04:30,939
但我认为可以，因为现在我们要继续前进，并有能力
But I think that's OK, because now we're going to go ahead and have the ability

1328
01:04:30,940 --> 01:04:32,710
实际操作该数据。
to actually manipulate that data.

1329
01:04:32,710 --> 01:04:34,630
但是，我们如何处理数据？
But how do we manipulate the data?

1330
01:04:34,630 --> 01:04:36,070
我们需要一种新的语言。
We need a new language.

1331
01:04:36,070 --> 01:04:42,280
SQL，结构化查询语言，是SQLite和Oracle使用的语言
SQL, Structured Query Language, is the language used by SQLites and Oracle

1332
01:04:42,280 --> 01:04:45,220
和MySQL和PostgreSQL以及其他一系列产品
and MySQL and PostgreSQL and bunches of other products

1333
01:04:45,219 --> 01:04:48,039
您不需要很快就知道或记住其名字。
whose names you don't need to know or remember any time soon.

1334
01:04:48,039 --> 01:04:53,259
但是SQL是我们将用于查询数据库以获取信息的语言
But SQL is the language we'll use to query the database for information

1335
01:04:53,260 --> 01:04:54,620
并用它做点什么。
and do something with it.

1336
01:04:54,619 --> 01:04:57,919
一般而言，是一个关系数据库，然后是
Generally speaking, a relational database and, in turn,

1337
01:04:57,920 --> 01:05:02,480
SQL，这是一种您可以与关系数据库进行交互的语言，
SQL, which is a language via which you can interact with relational databases,

1338
01:05:02,480 --> 01:05:04,910
支持四个基本操作。
support four fundamental operations.

1339
01:05:04,909 --> 01:05:08,089
而且，它们只是一个粗略的缩写，是双关语的意思，
And they're sort of a crude acronym, pun intended,

1340
01:05:08,090 --> 01:05:11,960
只是有助于记住那些基本操作是什么
that is just helpful for remembering what those fundamental operations are

1341
01:05:11,960 --> 01:05:13,190
关系数据库。
with relational databases.

1342
01:05:13,190 --> 01:05:19,220
CRUD代表创建，读取，更新和删除。
CRUD stands for Create, Read, Update, and Delete.

1343
01:05:19,219 --> 01:05:21,799
实际上，首字母缩写是CRUD，CRUD。
And indeed, the acronym is CRUD, C-R-U-D.

1344
01:05:21,800 --> 01:05:25,040
因此，它可以帮助您记住任何设备支持的四个基本操作
So it helps you remember that the four basic operations supported by any

1345
01:05:25,039 --> 01:05:28,589
关系数据库被创建，读取，更新，删除。
relational database are create, read, update, delete.

1346
01:05:28,590 --> 01:05:30,710
“创建”是指创建或添加新数据。
"Create" means to create or add new data.

1347
01:05:30,710 --> 01:05:34,550
“读取”是指访问新数据并将新数据加载到内存中。
"Read" means to access and load into memory new data.

1348
01:05:34,550 --> 01:05:36,710
我们已经阅读过打开文件的内容。
We've seen read before with opening files.

1349
01:05:36,710 --> 01:05:39,140
同样，“更新”和“删除”的含义也是如此，
"Update" and "delete" mean exactly that, as well,

1350
01:05:39,139 --> 01:05:41,449
如果要操作数据集中的数据。
if you want to manipulate the data in your data set.

1351
01:05:41,449 --> 01:05:44,529
现在，这些是任何关系数据库的通用术语。
Now, those are generic terms for any relational database.

1352
01:05:44,530 --> 01:05:48,200
这些是任何关系数据库通常支持的四个属性。
Those are the four properties typically supported by any relational database.

1353
01:05:48,199 --> 01:05:53,489
在SQL的世界中，有一些非常具体的命令或功能，
In the world of SQL, there are some very specific commands or functions,

1354
01:05:53,489 --> 01:05:58,549
如果您愿意，则可以实现这四个功能。
if you will, that implement those four functionalities.

1355
01:05:58,550 --> 01:06:00,980
它们是创建并插入-
They are create and insert--

1356
01:06:00,980 --> 01:06:03,620
实现与更普遍地创建相同的功能。
achieve the same thing as create more generally.

1357
01:06:03,619 --> 01:06:07,849
关键字“选择”是用于从数据库读取数据的关键字。
The keyword "select" is what's used to read data from a database.

1358
01:06:07,849 --> 01:06:09,459
更新和删除相同。
Update and delete are the same.

1359
01:06:09,460 --> 01:06:11,210
因此，这是一种令人讨厌的不一致。
So it's kind of an annoying inconsistency.

1360
01:06:11,210 --> 01:06:14,803
首字母缩略词或术语是CRUD，创建，读取，更新，删除。
The acronym or the term of art is CRUD, Create, Read, Update, Delete.

1361
01:06:14,802 --> 01:06:16,969
但是在SQL的世界里，语言的作者
But in the world of SQL, the authors of the language

1362
01:06:16,969 --> 01:06:20,029
决定通过方式实施这四个想法
decided to implement those four ideas by way

1363
01:06:20,030 --> 01:06:24,760
这五个关键字，功能或命令（如果需要）中的一种
of these five keywords or functions or commands, if you will, in the language

1364
01:06:24,760 --> 01:06:25,260
SQL。
SQL.

1365
01:06:25,260 --> 01:06:28,800
所以您要看的是其中五个关键字
So what you are looking at are five of the keywords

1366
01:06:28,800 --> 01:06:32,990
您可以使用这种称为SQL的新语言来实际执行某项操作
that you can use in this new language called SQL to actually do something

1367
01:06:32,989 --> 01:06:33,979
与您的数据库。
with your database.

1368
01:06:33,980 --> 01:06:35,070
这是什么意思？
Now, what does that mean?

1369
01:06:35,070 --> 01:06:37,190
好吧，假设您想手动创建
Well, suppose that you wanted to manually create

1370
01:06:37,190 --> 01:06:38,960
第一次建立数据库。
a database for the very first time.

1371
01:06:38,960 --> 01:06:39,585
你做什么工作？
What do you do?

1372
01:06:39,585 --> 01:06:42,752
好吧，回到电子表格的世界，这很简单，对吧？
Well, back in the world of spreadsheets, it's pretty straightforward, right?

1373
01:06:42,751 --> 01:06:44,299
您将打开Google Spreadsheets。
You'd open up Google Spreadsheets.

1374
01:06:44,300 --> 01:06:46,370
您转到“文件”，“新建”或其他内容。
You go to File, New or whatever.

1375
01:06:46,369 --> 01:06:48,349
然后，您就可以得到一个新的电子表格
And then you just, voila, get a new spreadsheet

1376
01:06:48,349 --> 01:06:51,169
您可以在其中开始创建行和列等。
into which you can start creating rows and columns and the like.

1377
01:06:51,170 --> 01:06:53,840
在Microsoft Excel中，Apple Numbers同样是-
In Microsoft Excel, Apple Numbers, same thing--

1378
01:06:53,840 --> 01:06:57,840
“文件”菜单，“新建电子表格”或其他任何东西，以及繁荣，您都有一个新的电子表格。
File menu, New Spreadsheet or whatever, and boom, you have a new spreadsheet.

1379
01:06:57,840 --> 01:07:00,860
现在，在SQL世界中，SQL数据库通常是
Now, in the world of SQL, SQL databases are generally

1380
01:07:00,860 --> 01:07:02,840
旨在与代码进行交互。
meant to be interacted with code.

1381
01:07:02,840 --> 01:07:05,930
但是，有图形用户界面，GUI，通过它们
However, there are Graphical User Interfaces, GUIs, by which

1382
01:07:05,929 --> 01:07:07,429
您也可以与他们互动。
you can interact with them, as well.

1383
01:07:07,429 --> 01:07:11,599
但是，我们今天将使用代码来执行此操作，并在命令行中使用程序。
But we're going to use code today to do so and programs at a command line.

1384
01:07:11,599 --> 01:07:17,119
事实证明，您可以通过编程方式创建表
It turns out that you can create tables programmatically

1385
01:07:17,119 --> 01:07:19,529
通过运行这样的命令。
by running a command like this.

1386
01:07:19,530 --> 01:07:24,320
因此，如果您按照CREATE TABLE的方式逐字输入语法，则
So if you literally type out syntax along the lines of CREATE TABLE, then

1387
01:07:24,320 --> 01:07:27,230
表格名称，以小写字母表示，
the name of your table, indicated here in lowercase,

1388
01:07:27,230 --> 01:07:31,490
然后是一个括号，然后是您要创建的列的名称
then a parenthesis, then the name of your column that you want to create

1389
01:07:31,489 --> 01:07:36,189
以及该列的类型（la C），然后是逗号，点，
and the type of that column, a la C, and then comma, dot,

1390
01:07:36,190 --> 01:07:39,050
点，点，更多列，这通常是
dot, dot, some more columns, this is generally

1391
01:07:39,050 --> 01:07:43,350
说出您将用这种语言创建的语法，称为
speaking the syntax you'll use to create in this language called

1392
01:07:43,349 --> 01:07:44,801
SQL一个新表。
SQL a new table.

1393
01:07:44,802 --> 01:07:46,010
现在，这是抽象的。
Now, this is in the abstract.

1394
01:07:46,010 --> 01:07:49,077
同样，小写的表代表名称
Again, table in lowercase is meant to represent the name

1395
01:07:49,077 --> 01:07:50,660
你想给你的实际表。
you want to give to your actual table.

1396
01:07:50,659 --> 01:07:52,579
小写的列是名称
column in lowercase is meant to be the name

1397
01:07:52,579 --> 01:07:54,079
您想给自己的专栏。
you want to give to your own column.

1398
01:07:54,079 --> 01:07:54,787
也许是标题。
Maybe it's Title.

1399
01:07:54,788 --> 01:07:55,567
也许是流派。
Maybe it's Genres.

1400
01:07:55,567 --> 01:07:57,400
点，点，点只是意味着，当然，您
And dot, dot, dot just means, of course, you

1401
01:07:57,400 --> 01:07:59,100
可以有更多的列。
can have even more columns than that.

1402
01:07:59,099 --> 01:08:02,989
但是从字面上看，如果我要键入这种命令
But literally in a moment, if I were to type in this kind of command

1403
01:08:02,989 --> 01:08:06,499
运行sqlite3程序后进入终端窗口，
into the terminal window after running the sqlite3 program,

1404
01:08:06,500 --> 01:08:09,979
我可以开始为自己创建一个或多个表。
I could start creating one or more tables for myself.

1405
01:08:09,980 --> 01:08:12,920
实际上，这就是我已经发生的事情。
And in fact, that's what already happened for me.

1406
01:08:12,920 --> 01:08:15,560
此.import命令不是SQL的一部分-
This .import command, which is not part of SQL--

1407
01:08:15,559 --> 01:08:19,578
这等效于Excel或Google Spreadsheets中的“菜单”选项。
this is the equivalent of a Menu option in Excel or Google Spreadsheets.

1408
01:08:19,578 --> 01:08:22,728
.import只是为我自动化了一个特定的过程。
.import just automates a certain process for me.

1409
01:08:22,729 --> 01:08:24,319
它为我所做的就是这个。
And what it did for me is this.

1410
01:08:24,319 --> 01:08:28,609
如果我现在输入.schema，这是另一个SQLite特定命令-
If I type now .schema, which is another SQLite-specific command--

1411
01:08:28,609 --> 01:08:32,479
以。开头的任何东西。仅针对sqlite3，
anything that starts with a . is specific only to sqlite3,

1412
01:08:32,479 --> 01:08:34,250
该终端窗口程序。
this terminal window program.

1413
01:08:34,250 --> 01:08:36,830
注意输出的是这个。
Notice what's outputted is this.

1414
01:08:36,829 --> 01:08:44,419
通过运行对我自动执行的.import，在数据库中创建了一个表
By running .import that automatically for me created a table in my database

1415
01:08:44,420 --> 01:08:46,010
叫做表演。
called shows.

1416
01:08:46,010 --> 01:08:47,540
它给了它三列
And it gave it three columns--

1417
01:08:47,539 --> 01:08:50,059
时间戳记，标题和流派。
Timestamp, title, and genres.

1418
01:08:50,060 --> 01:08:52,529
这些列名称从何而来？
Where did those column names come from?

1419
01:08:52,529 --> 01:08:55,220
好吧，它们来自CSV的第一行。
Well, they came from the very first line in the CSV.

1420
01:08:55,220 --> 01:08:58,850
它们看起来都像文本，所以这些值的类型
And they all looked like text, so the type of those values

1421
01:08:58,850 --> 01:09:02,490
只是假设是文本，文本，文本。
was just assumed to be text, text, text.

1422
01:09:02,489 --> 01:09:05,089
现在，要明确一点，我可以手动输入此信息，
Now, to be clear, I could have manually type this out,

1423
01:09:05,090 --> 01:09:08,359
在名为shows的新表中创建了这三列。
created these three columns in a new table called shows for me.

1424
01:09:08,359 --> 01:09:11,870
但同样，.import命令只是从CSV中自动执行该命令。
But again, the .import command just automated that from a CSV.

1425
01:09:11,869 --> 01:09:17,369
但是，SQL是我们在这里看到的，CREATE TABLE显示了等等。
But the SQL is what we see here, CREATE TABLE shows and so forth.

1426
01:09:17,369 --> 01:09:22,608
就是说，现在，在这个数据库中，有一个文件-
So that is to say now, in this database, there is a file--

1427
01:09:22,609 --> 01:09:27,500
或者更确切地说，里面有一个名为shows的表
or rather, there is a table called shows inside

1428
01:09:27,500 --> 01:09:29,629
其中是来自该CSV的所有数据。
of which is all of the data from that CSV.

1429
01:09:29,630 --> 01:09:31,580
我实际上如何获得这些数据？
How do I actually get at that data?

1430
01:09:31,579 --> 01:09:33,829
好吧，事实证明还有其他命令被调用了。
Well, it turns out there's other commands were called.

1431
01:09:33,829 --> 01:09:37,429
事实证明，不仅创建，而且选择。
Not just CREATE, but also SELECT, it turns out.

1432
01:09:37,430 --> 01:09:40,850
SELECT相当于读取，从数据库中获取数据。
SELECT is the equivalent of read, getting data from the database.

1433
01:09:40,850 --> 01:09:42,590
这个功能非常强大。
And this one is pretty powerful.

1434
01:09:42,590 --> 01:09:45,950
以及之所以有如此多的数据科学家和统计学家
And the reason that so many data scientists and statisticians

1435
01:09:45,949 --> 01:09:48,289
使用并喜欢使用SQL之类的语言-
use and like using languages like SQL--

1436
01:09:48,289 --> 01:09:51,619
他们使得获取数据和过滤数据相对容易
they make it relatively easy to just get data and filter that data

1437
01:09:51,619 --> 01:09:55,379
并使用今天适用于我们的新语法分析数据，
and analyze that data using new syntax for us today,

1438
01:09:55,380 --> 01:09:58,940
但是相对于我们已经看到的其他东西而言，语法相对简单。
but relatively simple syntax relative to other things we've seen.

1439
01:09:58,939 --> 01:10:03,589
SQL中的SELECT命令使您可以选择一列或多列
The SELECT command in SQL lets you select one or more columns

1440
01:10:03,590 --> 01:10:06,710
从您的表中按给定的名称。
from your table by the given name.

1441
01:10:06,710 --> 01:10:10,040
因此，我们现在将在这里过一会儿。
So we'll see this now in just a moment here.

1442
01:10:10,039 --> 01:10:11,459
我该怎么做呢？
How might I go about doing this?

1443
01:10:11,460 --> 01:10:15,170
好吧，让我继续，现在，只是在清除窗口后，在我的提示下
Well, let me go ahead and now, at my prompt after just clearing the window

1444
01:10:15,170 --> 01:10:17,340
为了保持整洁，让我尝试一下。
to keep things neat, let me try this out.

1445
01:10:17,340 --> 01:10:26,090
让我继续进行选择，例如，标题FROM显示;。
Let me go ahead and SELECT, let's say, title FROM shows;.

1446
01:10:26,090 --> 01:10:27,290
那我为什么要这样做呢？
So why am I doing this?

1447
01:10:27,289 --> 01:10:29,799
嗯，再次，SELECT命令的常规格式
Well, again, the conventional format for the SELECT command

1448
01:10:29,800 --> 01:10:33,400
是说SELECT，然后是一列或多列的名称，然后
is to say SELECT, then the name of one or more columns, then

1449
01:10:33,399 --> 01:10:37,239
从字面上看是介词FROM，然后是您从中使用的表的名称
literally the preposition FROM, and then the name of the table from which you

1450
01:10:37,239 --> 01:10:38,839
要选择该数据。
want to select that data.

1451
01:10:38,840 --> 01:10:43,390
因此，如果我的表格称为shows，而该列称为title，
So if my table is called shows and the column is called title,

1452
01:10:43,390 --> 01:10:46,930
有理由说SELECT标题FROM节目应该给我
it stands to reason that SELECT title FROM shows should give me

1453
01:10:46,930 --> 01:10:48,100
备份我想要的数据。
back the data I want.

1454
01:10:48,100 --> 01:10:50,080
现在，请注意几个样式选择
Now, notice a couple of stylistic choices

1455
01:10:50,079 --> 01:10:52,629
并不是严格要求的，但是是好的样式。
that aren't strictly required but are good style.

1456
01:10:52,630 --> 01:10:56,470
按照惯例，我会大写任何SQL关键字，
Conventionally, I would capitalize any SQL keywords,

1457
01:10:56,470 --> 01:10:59,470
在这种情况下包括SELECT和FROM，然后
including SELECT and FROM in this case, and then

1458
01:10:59,470 --> 01:11:03,610
将列名或表名都小写，
lowercase anything that's a column name or a table name,

1459
01:11:03,609 --> 01:11:07,022
假设您实际上以小写形式创建了这些列和表。
assuming you created those columns and tables in, in fact, lowercase.

1460
01:11:07,023 --> 01:11:08,690
那里有不同的约定。
There's different conventions out there.

1461
01:11:08,689 --> 01:11:09,814
有些人会大写。
Some people will uppercase.

1462
01:11:09,814 --> 01:11:12,949
有些人会使用称为骆驼箱或蛇皮箱之类的东西。
Some people will use something called camel case or snake case or the like.

1463
01:11:12,949 --> 01:11:15,219
但总的来说，我会鼓励所有上限
But generally speaking, I would encourage all caps

1464
01:11:15,220 --> 01:11:19,180
表示SQL语法，小写表示列和表名。
for SQL syntax and lowercase for the column and table names.

1465
01:11:19,180 --> 01:11:21,190
我现在要继续并按Enter。
I'm going to go ahead now and hit Enter.

1466
01:11:21,189 --> 01:11:22,059
和瞧。
And voila.

1467
01:11:22,060 --> 01:11:26,950
我们迅速看到了从数据库输出的值的完整列表。
We see rapidly a whole list of values outputted from the database.

1468
01:11:26,949 --> 01:11:30,789
如果回想起来，您可能会意识到这实际上是
And if you think way back, you might recognize that this actually

1469
01:11:30,789 --> 01:11:35,199
恰好与以前的顺序相同，因为CSV
happens to be the same order as before, because the CSV

1470
01:11:35,199 --> 01:11:39,009
文件从上到下被加载到同一数据库表中。
file was loaded top to bottom into this same database table.

1471
01:11:39,010 --> 01:11:42,370
因此，实际上，我们看到的是所有相同的数据，重复的
And so what we're seeing, in fact, is all of that same data, duplicates

1472
01:11:42,369 --> 01:11:46,029
以及资本缩水，怪异的间距等等。
and miscapitalizations and weird spacing and all.

1473
01:11:46,029 --> 01:11:48,789
但是，假设我想查看CSV中的所有数据。
But suppose I want to see all of the data from the CSV.

1474
01:11:48,789 --> 01:11:51,159
好吧，事实证明您可以选择多个列。
Well, it turns out you can select multiple columns.

1475
01:11:51,159 --> 01:11:54,477
您不仅可以选择标题，还可以选择时间戳。
You can select not only title, but maybe timestamp was of interest.

1476
01:11:54,478 --> 01:11:56,770
而且这个人当然是大写的，因为那是
And this one admittedly was capitalized, because that's

1477
01:11:56,770 --> 01:11:58,360
电子表格中的内容。
what it was in the spreadsheet.

1478
01:11:58,359 --> 01:12:00,289
那不是我手动选择的。
That was not something I chose manually.

1479
01:12:00,289 --> 01:12:02,799
因此，如果我只使用逗号分隔的列名列表，
So if I just use a comma-separated list of column names,

1480
01:12:02,800 --> 01:12:04,090
注意我现在能做什么。
notice what I can do now.

1481
01:12:04,090 --> 01:12:07,790
对于我们人类来说，这有点困难，因为现在发生了很多事情。
It's a little hard to see for us humans, because there's a lot going on now.

1482
01:12:07,789 --> 01:12:10,119
但是请注意，在左侧用双引号括起来，
But notice that in double quotes on the left,

1483
01:12:10,119 --> 01:12:14,169
有所有的时间戳，代表你们所有人的时间
there are all of the timestamps, which represent the time at which you all

1484
01:12:14,170 --> 01:12:15,490
提交了您喜欢的节目。
submitted your favorite shows.

1485
01:12:15,489 --> 01:12:19,389
在逗号右边，还有另一个带引号的字符串
And on the right of the comma, there's another quoted string

1486
01:12:19,390 --> 01:12:22,210
这是您喜欢的节目的标题，尽管使用SQLite
that is the title of the show that you liked, although SQLite

1487
01:12:22,210 --> 01:12:27,070
按照惯例，如果只是一个单词（例如“朋友”），则省略引号。
omits the quotes if it's just a single word, like Friends, just by convention.

1488
01:12:27,069 --> 01:12:29,289
实际上，如果我想获取所有列，
In fact, if I want to get all of the columns,

1489
01:12:29,289 --> 01:12:31,509
原来有一些速记语法。
turns out there's some shorthand syntax for that.

1490
01:12:31,510 --> 01:12:34,270
*是所谓的通配符运算符。
* is the so-called wild card operator.

1491
01:12:34,270 --> 01:12:37,780
这将使我获得表中从左到右的所有列。
And it will get me all of the columns from left to right in my table.

1492
01:12:37,779 --> 01:12:38,499
和瞧。
And voila.

1493
01:12:38,500 --> 01:12:44,179
现在，我看到了所有数据，包括所有流派。
Now I see all of the data, including all of the genres, as well.

1494
01:12:44,180 --> 01:12:49,090
所以现在我实际上在这里一次输出了三列。
So now I effectively have three columns being outputted all at once here.

1495
01:12:49,090 --> 01:12:51,520
好吧，到目前为止，这还没有那么有用。
Well, this is not that useful thus far.

1496
01:12:51,520 --> 01:12:53,770
实际上，我一直在做的只是输出
In fact, all I've been doing is really just outputting

1497
01:12:53,770 --> 01:12:55,060
CSV的内容。
the contents of the CSV.

1498
01:12:55,060 --> 01:12:58,990
但是SQL之所以强大，是因为它具有其他功能，即开即用，
But SQL's powerful because it comes with other features right out of the box,

1499
01:12:58,989 --> 01:13:02,829
在精神上与Google Spreadsheets中内置的功能有些相似
somewhat similar in spirit to functions that are built into Google Spreadsheets

1500
01:13:02,829 --> 01:13:03,549
和Excel。
and Excel.

1501
01:13:03,550 --> 01:13:06,110
但是现在我们可以最终在我们自己的代码中使用它们了。
But now we can use them ultimately in our own code.

1502
01:13:06,109 --> 01:13:09,459
因此，像AVG，COUNT，DISTINCT，LOWER，MAX，MIN，
So functions like AVG, COUNT, DISTINCT, LOWER, MAX, MIN,

1503
01:13:09,460 --> 01:13:13,540
和UPPER等更多功能，这些都是SQL内置的功能
and UPPER and bunches more, these are all functions built into SQL

1504
01:13:13,539 --> 01:13:19,369
您可以将其用作查询的一部分，以在返回数据时更改数据
that you can use as part of your query to alter the data as it's coming back

1505
01:13:19,369 --> 01:13:21,369
从数据库中获取-不是永久的，而是
from the database-- not permanently, but as it's

1506
01:13:21,369 --> 01:13:25,039
回到您的位置-使其具有您真正关心的格式。
coming back to you-- so that it's in a format you actually care about.

1507
01:13:25,039 --> 01:13:26,869
例如，我之前的目标之一
So for instance, one of my goals earlier,

1508
01:13:26,869 --> 01:13:29,679
是为了找回独特的，独特的头衔。
was to get back just the distinct, the unique titles.

1509
01:13:29,680 --> 01:13:32,620
而且我们必须使用一组代码编写所有烦人的代码
And we had to write all that annoying code using a set

1510
01:13:32,619 --> 01:13:35,559
然后将内容添加到集合中，然后再次遍历，对吗？
and then add things to the set and then loop over it again, right?

1511
01:13:35,560 --> 01:13:37,180
那不是大量的代码。
That was not a huge amount of code.

1512
01:13:37,180 --> 01:13:40,840
但是，至少要花5、10分钟才能完成这项工作。
But it definitely took us, what, 5, 10 minutes to get the job done at least.

1513
01:13:40,840 --> 01:13:43,780
在SQL中，您可以一口气完成所有这些工作。
In SQL, you can do all of that in one breath.

1514
01:13:43,779 --> 01:13:45,649
我现在要继续执行此操作。
I'm going to go ahead now and do this.

1515
01:13:45,649 --> 01:13:49,689
SELECT不仅显示标题FROM。
SELECT not just title FROM shows.

1516
01:13:49,689 --> 01:13:54,369
让我继续，并显示SELECT DISTINCT标题FROM。
Let me go ahead and SELECT DISTINCT title FROM shows.

1517
01:13:54,369 --> 01:13:57,639
因此，DISTINCT再次是SQL中的可用函数
So DISTINCT, again, is an available function in SQL

1518
01:13:57,640 --> 01:13:58,900
顾名思义，那就做到了。
that does what the name says.

1519
01:13:58,899 --> 01:14:00,649
它会过滤掉所有标题
It's going to filter out all of the titles

1520
01:14:00,649 --> 01:14:02,449
只给我与众不同的东西
to just give me the distinct ones back.

1521
01:14:02,449 --> 01:14:08,739
因此，如果我现在按Enter键，您会看到一个类似的混乱列表，但其中包括-
So if I hit Enter now, you'll see a similarly messy list but including--

1522
01:14:08,739 --> 01:14:10,809
“不知道，”不看电视的人-
"no idea," someone that doesn't watch TV--

1523
01:14:10,810 --> 01:14:14,230
包括这些标题的未排序列表。
including an unsorted list of those titles.

1524
01:14:14,229 --> 01:14:18,129
因此，我认为我们可能可以像以前一样开始清理此东西。
So I think we can probably start to clean this thing up as we did before.

1525
01:14:18,130 --> 01:14:20,950
让我继续，现在选择不仅是DISTINCT，
Let me go ahead and now SELECT not just DISTINCT,

1526
01:14:20,949 --> 01:14:23,659
但让我继续，并将所有内容都大写。
but let me go ahead and uppercase everything as well.

1527
01:14:23,659 --> 01:14:25,969
我可以将UPPER用作另一个功能。
And I can use UPPER as another function.

1528
01:14:25,970 --> 01:14:27,580
请注意，我只是在嵌套东西。
And notice I'm just nesting things.

1529
01:14:27,579 --> 01:14:30,246
正如我们现在在多种语言中所看到的，一个函数的输出，
The output of one function, as we've seen in many languages now,

1530
01:14:30,247 --> 01:14:31,450
可以作为另一个的输入。
can be the input to another.

1531
01:14:31,449 --> 01:14:32,829
让我现在按Enter键。
Let me hit Enter now.

1532
01:14:32,829 --> 01:14:36,609
现在，它变得更加规范了，可以这么说，
And now it's getting a little more canonicalized, so to speak,

1533
01:14:36,609 --> 01:14:39,189
因为我对所有内容都使用大写。
because I'm using capitalization for everything.

1534
01:14:39,189 --> 01:14:43,689
但是似乎事情仍然没有得到真正的解决。
But it would seem that things still aren't really sorted.

1535
01:14:43,689 --> 01:14:46,069
这与您输入的顺序相同
It's just the same order in which you inputted them

1536
01:14:46,069 --> 01:14:48,369
但这次没有重复。
but without duplicates this time.

1537
01:14:48,369 --> 01:14:51,699
因此事实证明，SQL具有其他语法
So it turns out that SQL has other syntax

1538
01:14:51,699 --> 01:14:55,579
我们可以用来使查询更精确，更强大。
that we can use to make our queries more precise and more powerful.

1539
01:14:55,579 --> 01:14:57,639
所以除了这些功能
So in addition to these kinds of functions

1540
01:14:57,640 --> 01:15:00,340
您可以用来更改显示给您的数据
that you can use to alter the data that's being shown to you

1541
01:15:00,340 --> 01:15:04,570
然后回来，您也可以使用这些子句或语法
and coming back, you can also use these kinds of clauses or syntax

1542
01:15:04,569 --> 01:15:05,799
在SQL查询中。
in SQL queries.

1543
01:15:05,800 --> 01:15:09,130
您可以说WHERE，它相当于一个条件。
You can say WHERE, which is the equivalent of a condition.

1544
01:15:09,130 --> 01:15:13,600
您可以说选择所有正确或错误的数据。
You can say select all of this data where something is true or false.

1545
01:15:13,600 --> 01:15:17,440
您可以说喜欢，在这里您可以说给我的数据不完全是这样
You can say LIKE, where you can say give me data that isn't exactly this

1546
01:15:17,439 --> 01:15:18,519
但是就是这样
but is like this.

1547
01:15:18,520 --> 01:15:20,660
您可以按某一列对数据进行排序。
You can order the data by some column.

1548
01:15:20,659 --> 01:15:23,209
您可以限制返回的行数。
You can limit the number of rows that come back.

1549
01:15:23,210 --> 01:15:26,850
您可以通过某种方式将相同的值分组在一起。
And you can group identical values together in some way.

1550
01:15:26,850 --> 01:15:28,640
因此，让我们看一些例子。
So let's see a few examples of this.

1551
01:15:28,640 --> 01:15:32,055
让我回到这里，现在和...一起玩
Let me go back here and play around now with--

1552
01:15:32,055 --> 01:15:32,930
办公室怎么样？
how about The Office?

1553
01:15:32,930 --> 01:15:34,513
那就是我们前面看过的那个。
That was the one we looked at earlier.

1554
01:15:34,512 --> 01:15:42,259
因此，让我继续，SELECT title FROM显示WHERE title =“ The Office”;。
So let me go ahead and SELECT title FROM shows WHERE title = "The Office";.

1555
01:15:42,260 --> 01:15:48,200
因此，我添加了这个WHERE谓词，可以这么说，WHERE title =“ The Office”。
So I've added this WHERE predicate, so to speak, WHERE title = "The Office."

1556
01:15:48,199 --> 01:15:49,189
因此，SQL很不错。
So SQL's nice.

1557
01:15:49,189 --> 01:15:52,669
与Python的精神相似，它可能更加用户友好，
Similar in spirit to Python, it's more user friendly, perhaps,

1558
01:15:52,670 --> 01:15:55,910
比C的东西都读起来像一个英语句子，
than C where everything kind of sort of reads like an English sentence,

1559
01:15:55,909 --> 01:15:58,229
即使更精确。
even though it's a little more precise.

1560
01:15:58,229 --> 01:15:59,879
而且更加简洁。
And it's a little more succinct.

1561
01:15:59,880 --> 01:16:01,130
让我继续并按Enter。
Let me go ahead and hit Enter.

1562
01:16:01,130 --> 01:16:02,120
和瞧。
And voila.

1563
01:16:02,119 --> 01:16:05,849
那就是您输入The Office的人数。
That's how many of you inputted The Office.

1564
01:16:05,850 --> 01:16:08,520
但是请注意，不是所有人，不是吗？
But notice it's not everyone, is it?

1565
01:16:08,520 --> 01:16:10,050
我们仍然缺少一些。
We're missing some still.

1566
01:16:10,050 --> 01:16:14,070
看来，我只回覆了那些从字面上输入的人
It seems that I got back only those of you who typed in literally

1567
01:16:14,069 --> 01:16:16,709
“办公室”，大写字母T，大写字母O。
"The Office," capital T, capital O.

1568
01:16:16,710 --> 01:16:19,200
那么，如果我想变得比以前更有弹性呢？
So what if I want to be a little more resilient than that?

1569
01:16:19,199 --> 01:16:23,279
好吧，让我找回所有您在“办公室”中键入的行。
Well, let me get back any rows where you all typed in "office."

1570
01:16:23,279 --> 01:16:26,819
也许您省略了文章“ the”。
Maybe you omitted the article "the."

1571
01:16:26,819 --> 01:16:30,389
因此，让我继续前进，不要说title =“ Office”。
So let me go ahead and say not title = "Office."

1572
01:16:30,390 --> 01:16:33,780
但让我继续说一下标题在哪里，例如“ Office”。
but let me go ahead and say where the title is like "Office."

1573
01:16:33,779 --> 01:16:35,489
但是我不希望它只是“办公室”。
But I don't want it to just be "office."

1574
01:16:35,489 --> 01:16:39,119
我想在开始时允许一些东西，也许一些东西
I want to allow for maybe some stuff at the beginning, maybe some stuff

1575
01:16:39,119 --> 01:16:39,672
在最后。
at the end.

1576
01:16:39,672 --> 01:16:42,089
即使那看起来有点矛盾，
And even though that seems like a bit of an inconsistency,

1577
01:16:42,090 --> 01:16:46,950
在使用LIKE的情况下，还有另一个通配符。
in the context of using LIKE, there's another wild card character.

1578
01:16:46,949 --> 01:16:51,389
百分号表示左侧的零个或多个字符。
The percent sign represents zero or more characters to the left.

1579
01:16:51,390 --> 01:16:55,410
这个百分号代表右边的零个或多个字符。
And this percent sign represents zero or more characters to the right.

1580
01:16:55,409 --> 01:16:59,939
因此，这种包罗万象的东西现在可以在某个地方找到我的所有标题
So it's kind of this catchall that will now find me all titles that somewhere

1581
01:16:59,939 --> 01:17:02,979
在他们里面有办公室。
have O-F-F-I-C-E inside of them.

1582
01:17:02,979 --> 01:17:04,777
事实证明，LIKE不区分大小写，
And it turns out LIKE is case insensitive,

1583
01:17:04,778 --> 01:17:07,320
因此，我什至不必担心LIKE的大写字母。
so I don't even need to worry about capitalization with LIKE.

1584
01:17:07,319 --> 01:17:08,609
现在让我按Enter。
Now let me hit Enter.

1585
01:17:08,609 --> 01:17:09,449
和瞧。
And voila.

1586
01:17:09,449 --> 01:17:10,889
现在，我得到了更多答案。
Now I get back more answers.

1587
01:17:10,890 --> 01:17:12,780
现在您可以真正看到混乱了。
And you can really see the messiness now.

1588
01:17:12,779 --> 01:17:15,899
注意这里您使用的是小写字母。
Notice up here one of you used lowercase.

1589
01:17:15,899 --> 01:17:18,449
在快速键入内容时，这通常很常见。
That tends to be common when typing things in quickly.

1590
01:17:18,449 --> 01:17:21,269
你们中的一个人在这里做了小写，然后还给了
One of you did it lowercase here and then also gave

1591
01:17:21,270 --> 01:17:23,160
最后给我们额外的空白。
us an extra white space at the end.

1592
01:17:23,159 --> 01:17:24,899
你们其中一位刚刚输入了“办公室”。
One of you just typed in "office."

1593
01:17:24,899 --> 01:17:27,539
你们其中一位再次输入“办公室”，并在末尾加一个空格。
One of you typed in "the office" again with a space at the end.

1594
01:17:27,539 --> 01:17:29,199
因此，这里有很多变化。
And so there's a lot of variation here.

1595
01:17:29,199 --> 01:17:31,559
这就是为什么当我们将所有内容都强制为大写时
And that's why, when we forced everything to uppercase

1596
01:17:31,560 --> 01:17:34,650
然后我们开始修剪东西，我们得以摆脱
and we started trimming things, we were able to get rid

1597
01:17:34,649 --> 01:17:37,439
这些冗余中的许多。
of a lot of those redundancies.

1598
01:17:37,439 --> 01:17:40,289
好吧，事实上，让我们现在就开始订购吧。
Well, in fact, let's go ahead and order this now.

1599
01:17:40,289 --> 01:17:44,039
因此，让我回到选择独特的大写标题的过程中，
So let me go back to selecting the distinct uppercase title,

1600
01:17:44,039 --> 01:17:51,059
因此显示标题FROM的SELECT DISTINCT UPPER。
so SELECT DISTINCT UPPER of title FROM shows.

1601
01:17:51,060 --> 01:17:56,220
现在让我来ORDER BY，这是一个新的子句，大写版本
And let me now ORDER BY, which is a new clause, the uppercased version

1602
01:17:56,220 --> 01:17:57,868
头衔。
of title.

1603
01:17:57,868 --> 01:17:59,910
现在，请注意这里发生了一些事情。
So now notice there's a few things going on here.

1604
01:17:59,909 --> 01:18:01,709
但我只是建立更复杂的查询
But I'm just building up more complicated queries

1605
01:18:01,710 --> 01:18:04,260
类似于从头开始，在这里我们开始抛出越来越多的谜题
similar to scratch, where we just started throwing more and more puzzle

1606
01:18:04,260 --> 01:18:05,340
出现问题。
pieces at a problem.

1607
01:18:05,340 --> 01:18:10,530
我正在从shows表中选择所有不同的大写标题。
I'm selecting all of the distinct uppercase titles from the shows table.

1608
01:18:10,529 --> 01:18:13,049
但是这次我要订购结果
But I'm going to order the results this time

1609
01:18:13,050 --> 01:18:15,780
标题的大写形式。
by the uppercased version of title.

1610
01:18:15,779 --> 01:18:17,549
因此，所有内容都将大写。
So everything is going to be uppercased.

1611
01:18:17,550 --> 01:18:20,460
然后将其从A到Z进行排序。点击Enter，
And then it's going to be sorted A through Z. Hit Enter now,

1612
01:18:20,460 --> 01:18:23,160
现在事情变得更容易理解了。
and now things are a little easier to make sense of.

1613
01:18:23,159 --> 01:18:26,969
请注意，仅当标题中包含多个单词时，引号才会出现。
Notice the quotes are there only when there are multiple words in a title.

1614
01:18:26,970 --> 01:18:29,400
否则，sqlite3不会显示给我们。
Otherwise, sqlite3 doesn't bother showing us.

1615
01:18:29,399 --> 01:18:32,189
但是请注意，这里是所有“ the”节目。
But notice here's all the "the" shows.

1616
01:18:32,189 --> 01:18:36,269
如果我们继续向上滚动，则P，N，M，L等
And if we keep scrolling up, the P's, the N's, the M's, the L's, and so

1617
01:18:36,270 --> 01:18:41,190
第四-确实是按字母顺序排列的，这要归功于使用ORDER BY。
forth-- it's indeed alphabetized thanks to using ORDER BY.

1618
01:18:41,189 --> 01:18:41,949
好的。
All right.

1619
01:18:41,949 --> 01:18:45,539
好吧，让我们现在开始解决更多类似的SQL问题
Well, let's start to solve more similar problems now in SQL

1620
01:18:45,539 --> 01:18:49,829
与以前用Python编写的代码相比，编写的代码更少了。
by writing way less code than we did a bit ago in Python.

1621
01:18:49,829 --> 01:18:54,779
假设我想实际算出这些最受欢迎节目的数量。
Suppose I want to actually figure out the counts of these most popular shows.

1622
01:18:54,779 --> 01:18:58,049
所以我想合并所有相同的节目
So I want to combine all of the identical shows

1623
01:18:58,050 --> 01:19:00,510
并找出所有相应的计数。
and figure out all of the corresponding counts.

1624
01:19:00,510 --> 01:19:02,330
好吧，让我继续尝试一下。
Well, let me go ahead and try this.

1625
01:19:02,329 --> 01:19:07,931
让我继续并再次选择标题的大写版本。
Let me go ahead and SELECT again the uppercased version of title.

1626
01:19:07,931 --> 01:19:10,139
但是这次我不会做DISTINCT，因为我
But I'm not going to do DISTINCT this time, because I

1627
01:19:10,140 --> 01:19:11,830
想要做一些不同的事情。
want to do that a little differently.

1628
01:19:11,829 --> 01:19:13,649
我要选择大写版本
I'm going to SELECT the uppercased version

1629
01:19:13,649 --> 01:19:16,509
标题中的COUNT个，
of title, the COUNT of those titles--

1630
01:19:16,510 --> 01:19:19,320
因此给定标题出现的次数，因此COUNT
so the number of times a given title appears, so COUNT

1631
01:19:19,319 --> 01:19:20,609
现在是一个新关键字-
is a new keyword now--

1632
01:19:20,609 --> 01:19:22,079
从节目。
FROM shows.

1633
01:19:22,079 --> 01:19:25,859
但是，现在我如何弄清楚计数是多少？
But now how do I figure out what the count is?

1634
01:19:25,859 --> 01:19:29,699
好吧，如果您认为这张桌子有很多标题，
Well, if you think about this table as having a lot of titles--

1635
01:19:29,699 --> 01:19:31,929
标题，标题，标题，标题，标题-
title, title, title, title, title--

1636
01:19:31,930 --> 01:19:35,970
最好将相同的标题归为一组
it would be nice to kind of group the identical titles together

1637
01:19:35,970 --> 01:19:42,460
然后实际上算出我们归类了多少个这样的标题。
and then actually count how many such titles we grouped together.

1638
01:19:42,460 --> 01:19:47,710
而其语法实际上是说GROUP BY UPPER（title）;。
And the syntax for that is literally to say GROUP BY UPPER(title);.

1639
01:19:47,710 --> 01:19:51,130
这告诉SQL将所有大写的标题分组
This tells SQL to group all of the uppercased titles

1640
01:19:51,130 --> 01:19:53,860
一起，将多行合拢为一，
together, kind of collapse multiple rows into one,

1641
01:19:53,859 --> 01:19:58,989
但要跟踪崩溃后的标题计数。
but keep track of the count of titles after that collapse.

1642
01:19:58,989 --> 01:20:01,809
现在让我继续，然后按Enter。
Let me go ahead now and hit Enter.

1643
01:20:01,810 --> 01:20:05,980
您会看到，与我们编写的较早的Python程序之一非常相似，
And you'll see, very similar to one of the earlier Python programs we wrote,

1644
01:20:05,979 --> 01:20:10,039
左侧的所有标题后面都带有逗号，然后是计数。
all of the titles on the left followed by a comma, followed by the count.

1645
01:20:10,039 --> 01:20:11,919
所以你们中的一个真的很喜欢汤姆和杰里。
So one of you really likes Tom and Jerry.

1646
01:20:11,920 --> 01:20:14,470
你们当中的一位真的很喜欢Top Gear。
One of you really likes Top Gear.

1647
01:20:14,470 --> 01:20:17,140
但是，如果我向上滚动，其中两个人真的很喜欢The Wire。
If I scroll up, though, two of you really liked The Wire.

1648
01:20:17,140 --> 01:20:19,930
你们当中有23个人像The Office，尽管我们仍然
23 of you here like The Office, although we still

1649
01:20:19,930 --> 01:20:22,010
还没有在这里解决这个问题。
haven't trimmed the issue here.

1650
01:20:22,010 --> 01:20:25,180
因此，如果需要，我们仍然可以通过修剪空白将其进一步结合。
So we could still combine that further by trimming whitespace if we want.

1651
01:20:25,180 --> 01:20:27,040
但是现在我们得到了这些计数。
But now we're getting these kinds of counts.

1652
01:20:27,039 --> 01:20:32,509
好吧，我该像以前一样继续订购吗？
Well, how can I go ahead and order this, as we did before?

1653
01:20:32,510 --> 01:20:39,820
让我继续在此处添加标题的“ ORDER BY COUNT”
Let me go ahead here and add ORDER BY COUNT of title

1654
01:20:39,819 --> 01:20:42,009
然后立即打分号。
and then hit semicolon now.

1655
01:20:42,010 --> 01:20:45,310
现在请注意，就像在Python中一样，
And now notice, just as in Python, everything

1656
01:20:45,310 --> 01:20:47,800
从最初的最小到最大，通过《权力的游戏》
is from smallest to largest initially, with Game of Thrones

1657
01:20:47,800 --> 01:20:49,180
在这里落在底部。
here down on the bottom.

1658
01:20:49,180 --> 01:20:50,360
我怎样才能解决这个问题？
How can I fix this?

1659
01:20:50,359 --> 01:20:53,889
好吧，事实证明，如果您可以按降序排序，
Well, it turns out if you can order things in descending order,

1660
01:20:53,890 --> 01:20:58,510
简称DESC，而不是ASC，这是默认的升序-
D-E-S-C for short instead of A-S-C, which is the default for ascending--

1661
01:20:58,510 --> 01:21:02,110
所以如果我按降序排列，现在我必须一直滚动到上一步
so if I do it in descending order, now I'd have to scroll all the way back up

1662
01:21:02,109 --> 01:21:07,479
到A的最上方，以查看线条的起点。
to the A's, the very top, to see where the lines begin.

1663
01:21:07,479 --> 01:21:09,419
哎呀
Whoops.

1664
01:21:09,420 --> 01:21:13,020
如果我一直滚动回到顶部，我们将看到所有A字在哪里
If I scroll all the way back up to the top, we'll see where all of the A words

1665
01:21:13,020 --> 01:21:14,610
在这里开始。
begin up here.

1666
01:21:14,609 --> 01:21:17,251
现在，如果我想-
And now if I want to--

1667
01:21:17,252 --> 01:21:18,210
哎呀，哎呀，哎呀。
whoops, whoops, whoops.

1668
01:21:18,210 --> 01:21:20,190
我做对了吗？
Did I do that right?

1669
01:21:20,189 --> 01:21:20,689
对不起。
Sorry.

1670
01:21:20,689 --> 01:21:21,949
我不想-
I don't want to--

1671
01:21:21,949 --> 01:21:23,826
我们去了，ORDER BY COUNT降序。
there we go, ORDER BY COUNT descending.

1672
01:21:23,827 --> 01:21:26,660
现在，让我继续前进-这有点笨拙，看不到。
Now let me go ahead and-- this is just a little too unwieldy to see.

1673
01:21:26,659 --> 01:21:29,034
让我将自己限制在前十名并保持简单
Let me just limit myself to the top 10 and keep it simple

1674
01:21:29,034 --> 01:21:30,919
并且仅查看此处的前10个值。
and only look at the top 10 values here.

1675
01:21:30,920 --> 01:21:31,730
瞧。
Voila.

1676
01:21:31,729 --> 01:21:36,584
现在我有33岁的权力游戏，26岁的朋友，23岁的办公室-
Now I have Game of Thrones at 33, Friends at 26, The Office at 23--

1677
01:21:36,585 --> 01:21:38,210
尽管我认为我仍然缺少一些。
though I think I'm still missing a few.

1678
01:21:38,210 --> 01:21:41,660
Brian，您还记得修剪前导和尾随的SQL函数吗？
Brian, do you recall the SQL function for trimming leading and trailing

1679
01:21:41,659 --> 01:21:43,409
空白？
white space?

1680
01:21:43,409 --> 01:21:44,784
布莱恩·于：我认为这只是TRIM。
BRIAN YU: I think it's just TRIM.

1681
01:21:44,784 --> 01:21:45,659
DAVID J. MALAN：TRIM？
DAVID J. MALAN: TRIM?

1682
01:21:45,659 --> 01:21:46,339
好的。
OK.

1683
01:21:46,340 --> 01:21:47,577
我自己不记得了。
I myself did not remember.

1684
01:21:47,577 --> 01:21:49,160
因此，如有疑问，请谷歌或询问Brian。
So when in doubt, google or ask Brian.

1685
01:21:49,159 --> 01:21:50,999
因此，让我继续进行修复。
So let me go ahead and fix this.

1686
01:21:51,000 --> 01:21:55,669
让我继续，首先选择大写的标题。
Let me go ahead and SELECT uppercase of trimming the title first.

1687
01:21:55,670 --> 01:22:00,840
然后我要进行GROUP BY修剪，然后在上面大写。
And then I'm going to GROUP BY trimming and then uppercasing it there.

1688
01:22:00,840 --> 01:22:02,372
现在进入，瞧。
And now Enter, and voila.

1689
01:22:02,372 --> 01:22:03,080
谢谢你，布莱恩。
Thank you, Brian.

1690
01:22:03,079 --> 01:22:07,019
因此，现在我们在这里拥有26个办事处。
So now we're up to our 26 Offices here.

1691
01:22:07,020 --> 01:22:09,110
简而言之，我们花了一些时间才能得到
So in short, it took us a little while to get

1692
01:22:09,109 --> 01:22:10,879
到此为止，SQL中的故事。
to this point in the story in SQL.

1693
01:22:10,880 --> 01:22:12,020
但是请注意我们所做的。
But notice what we've done.

1694
01:22:12,020 --> 01:22:14,210
我们采取了一个程序，这花了我们几分钟
We've taken a program that took us a few minutes

1695
01:22:14,210 --> 01:22:16,790
当然还有十几行或更多行代码。
and certainly a dozen or more lines of code.

1696
01:22:16,789 --> 01:22:20,299
我们已经将其提炼成一种新语言
And we've distilled it into something that, yes, is a new language

1697
01:22:20,300 --> 01:22:22,310
但只是一个班轮。
but is just kind of a one liner.

1698
01:22:22,310 --> 01:22:24,888
一旦您熟悉了SQL之类的语言，
And once you get comfortable with a language like SQL,

1699
01:22:24,887 --> 01:22:27,679
特别是如果您甚至不是计算机科学家，但也许是数据专家
especially if you're not even a computer scientist but maybe a data

1700
01:22:27,680 --> 01:22:31,130
花费大量时间寻找的科学家或某种分析师
scientist or an analyst of some sort who spends a lot of their day looking

1701
01:22:31,130 --> 01:22:33,470
在财务信息或医疗信息上
at financial information or medical information

1702
01:22:33,470 --> 01:22:37,070
或实际上可以加载到行和列中的任何数据集，
or really any data set that can be loaded into rows and columns,

1703
01:22:37,069 --> 01:22:41,149
一旦您开始讲和阅读SQL即可
once you start to speak and read SQL as a human can

1704
01:22:41,149 --> 01:22:44,989
您开始相对简洁地表达一些非常强大的查询
you start to express some pretty powerful queries relatively succinctly

1705
01:22:44,989 --> 01:22:47,389
繁荣起来，找回你的答案。
and, boom, get back your answer.

1706
01:22:47,390 --> 01:22:50,000
通过使用命令行程序（例如sqlite3），
And by using a command line program, like sqlite3,

1707
01:22:50,000 --> 01:22:53,540
您可以立即在此处看到结果，尽管它是非常简单的文本。
you can immediately see the results there, albeit as very simplistic text.

1708
01:22:53,539 --> 01:22:56,689
但是也如上所述，还有一些图形程序
But as mentioned, too, there's also some graphical programs

1709
01:22:56,689 --> 01:23:00,116
既免费又商业的，也支持SQL，您仍然可以在其中
out there, free and commercial, that also support SQL, where you can still

1710
01:23:00,117 --> 01:23:00,950
键入这些命令。
type these commands.

1711
01:23:00,949 --> 01:23:03,769
然后它将以一种更加用户友好的方式向您显示
And then it will show it to you in a more user friendly way, much

1712
01:23:03,770 --> 01:23:07,790
例如在Windows或macOS中默认情况下。
like in Windows or macOS would by default.

1713
01:23:07,789 --> 01:23:16,057
那么，现在对SELECT语句的语法或功能有任何疑问吗？
So any questions now on the syntax or capabilities of SELECT statements?

1714
01:23:16,057 --> 01:23:17,349
布莱恩·于：一个问题来了。
BRIAN YU: One question came in.

1715
01:23:17,350 --> 01:23:20,450
带有此数据的文件实际存储在哪里？
Where is the file with this data actually being stored?

1716
01:23:20,449 --> 01:23:21,699
DAVID J. MALAN：好问题。
DAVID J. MALAN: Good question.

1717
01:23:21,699 --> 01:23:24,029
文件实际存储在哪里？
Where is the file actually being stored?

1718
01:23:24,029 --> 01:23:27,459
因此，在退出之前，我实际上可以将此文件另存为任何文件。
So before quitting, I can actually save this file as anything.

1719
01:23:27,460 --> 01:23:30,043
我希望文件扩展名通常是.db。
I want the file extension would typically be .db.

1720
01:23:30,042 --> 01:23:31,959
实际上，布莱恩，您介意检查一下吗？
And in fact, Brian, do you mind just checking?

1721
01:23:31,960 --> 01:23:34,930
用点东西手动写入文件的语法是什么？
What's the syntax for writing the file manually with dot something?

1722
01:23:34,930 --> 01:23:36,910
我认为这将在.help下。
It would be under .help, I think.

1723
01:23:36,909 --> 01:23:39,549
BRIAN YU：我认为它是.save，后面跟着文件名。
BRIAN YU: I think it's .save followed by the name of the file.

1724
01:23:39,550 --> 01:23:43,240
DAVID J. MALAN：.save，所以我将其命名为shows.db，然后按Enter。
DAVID J. MALAN: .save, so I'll call this shows.db, Enter.

1725
01:23:43,239 --> 01:23:46,599
如果我现在继续打开另一个终端窗口，然后键入
If I now go ahead and open up another terminal window and type

1726
01:23:46,600 --> 01:23:49,990
我们的老朋友ls，您现在会看到我有一个CSV文件。
our old friend ls, you'll see that now I have a CSV file.

1727
01:23:49,989 --> 01:23:51,759
我有以前的Python文件。
I have my Python file from before.

1728
01:23:51,760 --> 01:23:54,790
我已经创建了一个名为shows.db的新文件。
And I have a new file called shows.db, which I've created.

1729
01:23:54,789 --> 01:24:00,909
那是包含我动态加载的表的二进制文件
That is the binary file that contains the table that I've loaded dynamically

1730
01:24:00,909 --> 01:24:04,699
从该CSV文件输入。
in from that CSV file.

1731
01:24:04,699 --> 01:24:08,809
关于SELECT查询还有其他问题，或者我们可以如何处理？
Any other questions on SELECT queries or what we can do with them?

1732
01:24:08,810 --> 01:24:12,620
布莱恩·于（Brian Yu）：是的，有人在问这是什么时间。
BRIAN YU: Yeah, a few people are asking about what the runtime of this is.

1733
01:24:12,619 --> 01:24:14,429
DAVID J. MALAN：好的，这是一个很好的问题。
DAVID J. MALAN: Yeah, really good question.

1734
01:24:14,430 --> 01:24:15,170
什么是运行时？
What is the runtime?

1735
01:24:15,170 --> 01:24:18,253
如果可以的话，我将稍等一下。
I'm going to come back to that question in just a little bit if that's OK.

1736
01:24:18,252 --> 01:24:20,959
现在，公认的是n的大O。
Right now, it's admittedly big O of n.

1737
01:24:20,960 --> 01:24:23,390
我实际上没有比我们做得更好
I've not actually done anything better than we did

1738
01:24:23,390 --> 01:24:26,090
与我们的CSV文件或我们的Python代码一起使用。
with our CSV file or our Python code.

1739
01:24:26,090 --> 01:24:28,040
现在，默认情况下它仍然是n的大O。
Right now, it's still big O of n by default.

1740
01:24:28,039 --> 01:24:30,229
但这将有一个更好的答案
But there's going to be a better answer to that

1741
01:24:30,229 --> 01:24:33,029
这将使它更具对数性。
that's going to make it something much more logarithmic.

1742
01:24:33,029 --> 01:24:36,686
因此，当我要启用该功能时，让我回到该功能。
So let me come back to that feature when it's time to enable it.

1743
01:24:36,686 --> 01:24:39,019
但实际上，让我们开始采取一些措施。
But in fact, let's start to take some steps toward that.

1744
01:24:39,020 --> 01:24:40,812
因为事实证明，在加载数据时，
Because it turns out, when loading in data,

1745
01:24:40,811 --> 01:24:42,852
我们并不总是会拥有
we're not always going to have the luxury of just

1746
01:24:42,853 --> 01:24:44,900
我们导入了一个CSV格式的大文件，
having one big file in CSV format that we import,

1747
01:24:44,899 --> 01:24:46,069
然后我们开展业务。
and we go about our business.

1748
01:24:46,069 --> 01:24:47,779
我们将必须预先决定如何
We're going to have to decide in advance how

1749
01:24:47,779 --> 01:24:50,209
我们要存储数据以及要存储什么数据
we want to store the data and what data we want to store

1750
01:24:50,210 --> 01:24:53,120
以及可能存在的关系不是一个
and what the relationships might be across not one

1751
01:24:53,119 --> 01:24:55,277
单个表，但多个表。
single table, but multiple tables.

1752
01:24:55,278 --> 01:24:57,320
所以让我继续在这里运行另一个命令
So let me go ahead and run one other command here

1753
01:24:57,319 --> 01:25:00,169
实际上引入了第一个问题。
that actually introduces the first of a problem.

1754
01:25:00,170 --> 01:25:03,830
让我继续，并显示SELECT标题FROM
Let me go ahead and SELECT title FROM shows

1755
01:25:03,829 --> 01:25:07,159
例如，“流派”等于“喜剧”。
WHERE genres equals, for instance, "Comedy."

1756
01:25:07,159 --> 01:25:08,569
那是流派之一。
That was one of the genres.

1757
01:25:08,569 --> 01:25:11,689
并注意，我们得到了很多结果。
And notice that we get back a whole bunch of results.

1758
01:25:11,689 --> 01:25:14,299
但是我敢打赌我会想念一些。
But I bet I'm missing some.

1759
01:25:14,300 --> 01:25:16,470
我正在快速浏览一下。
I'm skimming through this pretty quickly.

1760
01:25:16,470 --> 01:25:19,880
但是我敢打赌我会错过一些，因为如果我检查类型是否
But I bet I'm missing some, because if I check if genres

1761
01:25:19,880 --> 01:25:21,872
=“喜剧”，我要省略什么？
= "Comedy," what am I omitting?

1762
01:25:21,872 --> 01:25:24,830
好吧，那些选中了多个复选框的人可能会说些什么
Well, those of you who checked multiple boxes might have said something

1763
01:25:24,829 --> 01:25:28,309
是一部喜剧和戏剧或喜剧和浪漫片
is a comedy and a drama or comedy and romance

1764
01:25:28,310 --> 01:25:30,800
或其他几种流派的排列。
or maybe a couple of other permutations of genres.

1765
01:25:30,800 --> 01:25:34,070
如果我在这里寻找平等，=“喜剧”
If I'm searching for equality here, = "Comedy,"

1766
01:25:34,069 --> 01:25:37,879
我只会从您那里得到您最喜欢的内容，
I'm only going to get those favorites from you where you only said,

1767
01:25:37,880 --> 01:25:40,250
我最喜欢的电视节目是喜剧。
my favorite TV show is a comedy.

1768
01:25:40,250 --> 01:25:48,113
但是，如果我们想做类似喜剧这样的事情怎么办？
But what if we want to do something like LIKE comedy instead?

1769
01:25:48,113 --> 01:25:50,030
我们可以说，好久了
And we could say something like, well, so long

1770
01:25:50,029 --> 01:25:54,289
因为其中有“喜剧”一词，所以我们应该获得更多结果。
as the word "comedy" is in there, then we should get back even more results.

1771
01:25:54,289 --> 01:25:57,479
而且，我要指出的是，的确，我现在拥有更长的结果列表。
And let me stipulate that, indeed, I now have a longer list of results.

1772
01:25:57,479 --> 01:26:01,009
现在，我们可以在所有节目中至少选中“喜剧”框。
Now we have all shows where you checked at least the Comedy box.

1773
01:26:01,010 --> 01:26:03,770
但不幸的是，这开始变得有点草率，
But unfortunately, this starts to get a little sloppy,

1774
01:26:03,770 --> 01:26:06,410
因为请记住“类型”列的外观。
because recall what the Genres column looks like.

1775
01:26:06,409 --> 01:26:07,729
选择。
SELECT.

1776
01:26:07,729 --> 01:26:11,149
让我从节目中选择流派；
Let me SELECT genres FROM shows;.

1777
01:26:11,149 --> 01:26:16,009
请注意，我们从CSV加载到此表中的所有流派
Notice that all of the genres that we loaded into this table from the CSV

1778
01:26:16,010 --> 01:26:20,030
文件是用逗号分隔的流派列表。
file are a comma-separated list of genres.

1779
01:26:20,029 --> 01:26:22,069
这就是Google Forms做到的方式。
That's just the way Google Forms did it.

1780
01:26:22,069 --> 01:26:24,319
这对于CSV来说很好。
And that's fine for CSV purposes.

1781
01:26:24,319 --> 01:26:28,309
出于SQL目的，这很好，但这有点混乱。
That's kind of fine for SQL purposes, but this is kind of messy.

1782
01:26:28,310 --> 01:26:31,700
一般而言，存储逗号分隔的列表
Generally speaking, storing comma-separated lists

1783
01:26:31,699 --> 01:26:35,839
SQL数据库中值的取值不是您应该做的。
of values in a SQL database is not what you should be doing.

1784
01:26:35,840 --> 01:26:41,030
使用SQL数据库的全部目的是摆脱逗号和CSV
The whole point of using a SQL database is to move away from commas and CSVs

1785
01:26:41,029 --> 01:26:42,859
并更干净地存储东西。
and to actually store things more cleanly.

1786
01:26:42,859 --> 01:26:45,919
因为实际上，让我提出一个问题。
Because in fact, let me propose a problem.

1787
01:26:45,920 --> 01:26:50,540
假设我不想搜寻喜剧，但也许也搜寻
Suppose I want to search not for comedy but maybe also

1788
01:26:50,539 --> 01:26:55,519
像这样的音乐，因此让我可以找到任何节目
music, like this, thereby allowing me to find any shows where

1789
01:26:55,520 --> 01:26:59,990
“音乐”一词在逗号分隔的列表中。
the word "music" is somewhere in the comma-separated list.

1790
01:26:59,989 --> 01:27:01,939
这里有一个细微的错误。
There's a subtle bug here.

1791
01:27:01,939 --> 01:27:05,689
您可能需要回想一下我们从哪里开始，表格
And you might have to think back to where we began, the form

1792
01:27:05,689 --> 01:27:07,909
你拉起来。
that you pulled up.

1793
01:27:07,909 --> 01:27:09,859
我无法在此处显示全部内容，但我们
I can't show the whole thing here, but we

1794
01:27:09,859 --> 01:27:14,059
从动作，冒险，动画，传记，点，点，点开始，
started with action, adventure, animation, biography, dot, dot, dot,

1795
01:27:14,060 --> 01:27:15,620
音乐。
music.

1796
01:27:15,619 --> 01:27:18,499
音乐剧也在那里，如此与众不同。
Musical was also there, so distinct.

1797
01:27:18,500 --> 01:27:22,700
音乐录影带和音乐录影带是两种不同类型的流派。
A music video versus a musical are two different types of genres.

1798
01:27:22,699 --> 01:27:25,249
但是请注意我的询问。
But notice my query at the moment.

1799
01:27:25,250 --> 01:27:26,929
这有什么问题？
What's problematic with this?

1800
01:27:26,930 --> 01:27:31,070
目前，我们似乎有一个错误，该查询将选择
At the moment, we would seem to have a bug whereby this query will select

1801
01:27:31,069 --> 01:27:34,369
不仅是“音乐”，而且是“音乐”。
not only "music," but also "musical."

1802
01:27:34,369 --> 01:27:36,619
所以这就是事情变得混乱的地方。
And so this is just where things are getting messy.

1803
01:27:36,619 --> 01:27:37,399
现在，是的，你知道吗？
Now, yeah, you know what?

1804
01:27:37,399 --> 01:27:38,809
我们可以清理一下。
We could kind of clean this up.

1805
01:27:38,810 --> 01:27:43,790
也许我们可以在这里加一个逗号，这样它就不仅仅是音乐。
Maybe we could put a comma here so that it can't just be music something.

1806
01:27:43,789 --> 01:27:45,409
它必须是音乐逗号。
It has to be music comma.

1807
01:27:45,409 --> 01:27:47,839
但是，如果音乐是您选中的最后一个框，该怎么办？
But what if music is the last box that you checked?

1808
01:27:47,840 --> 01:27:49,310
好吧，那就没音乐了。
Well, then it's music nothing.

1809
01:27:49,310 --> 01:27:50,210
没有逗号。
There is no comma.

1810
01:27:50,210 --> 01:27:52,262
所以现在我需要对事物进行“或”运算。
So now I need to OR things together.

1811
01:27:52,261 --> 01:27:54,469
因此，也许我必须执行WHERE“％Music，％”之类的操作
So maybe I have to do something like WHERE "%Music,%"

1812
01:27:54,470 --> 01:28:00,800
或OR风格，例如“％Music”。
like this or OR genres LIKE "%Music" like this.

1813
01:28:00,800 --> 01:28:02,750
但老实说，这只是一团糟。
But honestly, this is just getting messy.

1814
01:28:02,750 --> 01:28:04,040
这是设计不良的。
This is poorly designed.

1815
01:28:04,039 --> 01:28:07,219
如果您只是将数据存储为内部以逗号分隔的值列表
If you're just storing your data as a comma-separated list of values inside

1816
01:28:07,220 --> 01:28:11,010
列，您必须借助这种技巧来弄清楚，
of a column and you have to resort to this kind of hack to figure out,

1817
01:28:11,010 --> 01:28:13,130
好吧，也许是在这里，这里或这里，
well, maybe it's over here or here or here,

1818
01:28:13,130 --> 01:28:16,640
考虑到语法的所有排列，您做错了。
and thinking about all the permutations of syntax, you're doing it wrong.

1819
01:28:16,640 --> 01:28:20,130
您没有充分利用SQL数据库的潜力。
You're not using a SQL database to its fullest potential.

1820
01:28:20,130 --> 01:28:22,490
那么我们如何更好地设计这个东西
So how do we go about designing this thing better

1821
01:28:22,489 --> 01:28:26,689
并实际上更干净地将此CSV加载到数据库中？
and actually load this CSV into a database a little more cleanly?

1822
01:28:26,689 --> 01:28:31,819
简而言之，我们如何摆脱流派列中的愚蠢逗号
In short, how do we get rid of the stupid commas in the Genres column

1823
01:28:31,819 --> 01:28:36,739
而是放一个词“喜剧”或“音乐”或“音乐”
and instead put one word, "comedy" or "music" or "musical,"

1824
01:28:36,739 --> 01:28:38,929
在每个单元格中，可以这么说吗？
in each of those cells, so to speak?

1825
01:28:38,930 --> 01:28:40,250
不是两个，不是三个-
Not two, not three--

1826
01:28:40,250 --> 01:28:43,819
只有在不放弃其中某些流派的情况下才能做到这一点。
one only without throwing away some of those genres.

1827
01:28:43,819 --> 01:28:46,729
好吧，让我介绍一些能够帮助我们实现目标的构件。
Well, let me introduce a few building blocks that will get us there.

1828
01:28:46,729 --> 01:28:48,679
事实证明，当创建自己的表时
It turns out, when creating your own tables

1829
01:28:48,680 --> 01:28:51,260
并自行将数据加载到数据库中，
and loading data into a database on your own,

1830
01:28:51,260 --> 01:28:53,375
我们将需要的不仅是SELECT。
we're going to need more than just SELECT.

1831
01:28:53,375 --> 01:28:55,219
SELECT当然只是为了阅读。
SELECT, of course, is just for reading.

1832
01:28:55,220 --> 01:28:59,330
但是，如果我们要做得更好，而不仅仅是使用sqlite3作为内置函数，
But if we're going to do this better and not just use sqlite3 as a built-in

1833
01:28:59,329 --> 01:29:04,879
.import命令，但是相反，我们将编写一些代码来加载所有
.import command, but instead we're going to write some code to load all

1834
01:29:04,880 --> 01:29:07,580
将我们的数据分为两个表-
of our data into maybe two tables--

1835
01:29:07,579 --> 01:29:10,099
一种是标题，一种是流派-
one for the titles, one for the genres--

1836
01:29:10,100 --> 01:29:15,680
当涉及到SQL时，我们将需要更多的表现力。
we're going to need a little more expressiveness when it comes to SQL.

1837
01:29:15,680 --> 01:29:17,990
因此，我们将需要一种能力
And so for that, we're going to need, one, the ability

1838
01:29:17,989 --> 01:29:19,112
创建我们自己的表。
to create our own tables.

1839
01:29:19,113 --> 01:29:20,780
我们之前已经看到了这一点。
And we've seen a glimpse of this before.

1840
01:29:20,779 --> 01:29:23,279
但是我们还需要看另一段语法，
But we're also going to need to see another piece of syntax,

1841
01:29:23,279 --> 01:29:24,499
以及，因此插入。
as well, so inserting.

1842
01:29:24,500 --> 01:29:29,059
插入是可以在SQL数据库上执行的另一命令
Inserting is another command that you can execute on a SQL database

1843
01:29:29,060 --> 01:29:32,720
以便将数据实际添加到数据库，这很棒。
in order to actually add data to a database, which is great.

1844
01:29:32,720 --> 01:29:38,630
因为如果我想最终迭代相同的CSV，但是这次，
Because if I want to ultimately iterate over that same CSV but, this time,

1845
01:29:38,630 --> 01:29:43,075
自己将所有行手动添加到数据库中，
manually add all of the rows to the database myself,

1846
01:29:43,074 --> 01:29:45,199
好，那么我将需要某种插入方式。
well, then I'm going to need some way of inserting.

1847
01:29:45,199 --> 01:29:46,849
并且其语法如下。
And the syntax for that is as follows.

1848
01:29:46,850 --> 01:29:50,720
插入表名，列名或列名
INSERT INTO the name of the table, the column or columns

1849
01:29:50,720 --> 01:29:54,890
您要在其中插入值的字面意思是“ VALUES”，
that you want to insert values into, then literally the word VALUES,

1850
01:29:54,890 --> 01:29:58,787
然后再用括号括起来，即实际的值列表。
and then literally in parentheses again, the actual list of values.

1851
01:29:58,787 --> 01:30:01,370
因此，当我们以这种通用形式看到它时，它有点抽象。
So it's a little abstract when we see it in this generic form.

1852
01:30:01,369 --> 01:30:06,479
但是，我们也将在此稍后更清楚地看到这一点。
But we'll see this more explicitly in just a moment here, as well.

1853
01:30:06,479 --> 01:30:09,482
因此，在向数据库中插入内容时，
So when it comes to inserting something into a database,

1854
01:30:09,483 --> 01:30:10,650
让我们继续尝试。
let's go ahead and try this.

1855
01:30:10,649 --> 01:30:13,099
因此，假设-让我们看看。
So suppose that-- let's see.

1856
01:30:13,100 --> 01:30:15,080
这是什么节目-
What's a show that--

1857
01:30:15,079 --> 01:30:15,984
布偶表演。
The Muppet Show.

1858
01:30:15,984 --> 01:30:17,359
我从小就喜欢The Muppet Show。
I grew up loving The Muppet Show.

1859
01:30:17,359 --> 01:30:18,649
就像70年代那样。
It was out in, like, the '70s.

1860
01:30:18,649 --> 01:30:21,679
而且我不认为它在列表中，但是我可以肯定地检查一下。
And I don't think it was on the list, but I can check this for sure.

1861
01:30:21,680 --> 01:30:28,100
所以SELECT * FROM显示WHERE标题LIKE--
So SELECT * FROM shows WHERE title LIKE--

1862
01:30:28,100 --> 01:30:30,950
让我们只用通配符搜索“布偶”。
let's just search for "muppets" with a wild card.

1863
01:30:30,949 --> 01:30:32,499
我猜没有人把它放在那里。
And I'm guessing no one put it there.

1864
01:30:32,500 --> 01:30:33,000
好的。
Good.

1865
01:30:33,000 --> 01:30:34,320
因此，这是一个错失的机会。
So it's a missed opportunity.

1866
01:30:34,319 --> 01:30:35,569
我忘了填写表格。
I forgot to fill out the form.

1867
01:30:35,569 --> 01:30:37,819
我可以返回并填写表格，然后重新导入CSV，
I could go back and fill out the form and re-import the CSV,

1868
01:30:37,819 --> 01:30:39,486
但让我们继续手动执行此操作。
but let's go ahead and do this manually.

1869
01:30:39,487 --> 01:30:44,420
那么，让我继续，INSERT INTO显示哪些列？
So let me go ahead and INSERT INTO shows what columns?

1870
01:30:44,420 --> 01:30:50,360
标题和流派，我想我可以做一个时间戳记。
title and genres, and I guess I could do a Timestamp just for kicks.

1871
01:30:50,359 --> 01:30:52,219
然后我要插入什么值？
And then I'm going to insert what values?

1872
01:30:52,220 --> 01:30:55,430
值，现在不知道是什么时候，我不知道。
The values will be, well, I don't know, whatever time it is now.

1873
01:30:55,430 --> 01:30:58,460
因此，我将在此处作弊，而不是查找日期和时间。
So I'm going to cheat there rather than look up the date and the time.

1874
01:30:58,460 --> 01:31:01,430
标题将是“木偶戏”。
The title will be "The Muppet Show."

1875
01:31:01,430 --> 01:31:05,100
体裁将是-有点像喜剧。
And the genres will be-- it was kind of a comedy.

1876
01:31:05,100 --> 01:31:06,290
这有点像音乐剧。
It was kind of a musical.

1877
01:31:06,289 --> 01:31:08,359
因此，我们将保留它。
So we'll kind of leave it at that.

1878
01:31:08,359 --> 01:31:09,349
分号。
Semicolon.

1879
01:31:09,350 --> 01:31:11,870
同样，这遵循此处的标准语法
So again, this follows the standard syntax here

1880
01:31:11,869 --> 01:31:14,029
指定要插入的表，
of specifying the table you want to insert into,

1881
01:31:14,029 --> 01:31:16,909
您要插入的列和值
the columns you want to insert into, and the values

1882
01:31:16,909 --> 01:31:18,466
您想放入这些列中。
you want to put into those columns.

1883
01:31:18,466 --> 01:31:20,299
我要继续并立即按Enter。
And I'm going to go ahead and hit Enter now.

1884
01:31:20,300 --> 01:31:22,250
似乎什么都没发生。
Nothing seems to have happened.

1885
01:31:22,250 --> 01:31:28,070
但是，如果我现在选择相同的查询，
But if I now select that same query--

1886
01:31:28,069 --> 01:31:32,629
哦，好的，仍然没什么，因为我犯了一个微妙的错误。
oh, OK, it's still nothing, because I made a subtle mistake.

1887
01:31:32,630 --> 01:31:34,700
我不是要搜索“布偶”（复数）。
I'm not searching for "Muppets," plural.

1888
01:31:34,699 --> 01:31:37,249
我正在搜索“布偶秀”（Muppet Show）单数形式。
I'm searching for "Muppet," singular, The Muppet Show.

1889
01:31:37,250 --> 01:31:38,000
瞧。
Voila.

1890
01:31:38,000 --> 01:31:40,790
现在，您在该数据库中看到我的行。
Now you see my row in this database.

1891
01:31:40,789 --> 01:31:42,679
因此，INSERT现在将使我们具备此功能
And so INSERT would give us the ability now

1892
01:31:42,680 --> 01:31:44,570
在数据库中插入新行。
to insert new rows into the database.

1893
01:31:44,569 --> 01:31:48,409
假设您要更新某些内容。
Suppose you want to update something.

1894
01:31:48,409 --> 01:31:51,539
你知道吗，一些布偶表演实际上是非常戏剧性的。
You know, some of the Muppet Shows were actually pretty dramatic.

1895
01:31:51,539 --> 01:31:52,709
那么我们该怎么做呢？
So how might we do that?

1896
01:31:52,710 --> 01:31:56,960
好吧，我可以说UPDATE显示SET--
Well, I can say UPDATE shows SET--

1897
01:31:56,960 --> 01:32:04,250
让我们看看-类型=“喜剧，戏剧，音乐”在哪里
let's see-- genres = "Comedy, Drama, Musical" WHERE

1898
01:32:04,250 --> 01:32:07,910
title =“木偶戏”。
title = "The Muppet Show."

1899
01:32:07,909 --> 01:32:10,889
同样，我将对此稍作规范化的语法。
So again, I'll pull up the canonical syntax for this in a bit.

1900
01:32:10,890 --> 01:32:14,120
但是就目前而言，您只需一点点预告片，就可以轻松更新内容。
But for now, just a little teaser, you can update things pretty simply.

1901
01:32:14,119 --> 01:32:16,661
即使需要一些时间来适应语法，
And even though it takes a little getting used to the syntax,

1902
01:32:16,662 --> 01:32:17,960
它按照它说的做。
it kind of does what it says.

1903
01:32:17,960 --> 01:32:23,250
UPDATE显示SET风格=此WHERE标题= that。
UPDATE shows SET genres = this WHERE title = that.

1904
01:32:23,250 --> 01:32:24,649
现在我可以继续输入了。
And now I can go ahead and Enter.

1905
01:32:24,649 --> 01:32:27,289
如果我继续选择相同的内容，就像在终端窗口中一样，
If I go ahead and select the same thing, just like in a terminal window,

1906
01:32:27,289 --> 01:32:28,249
你可以上下。
you can go up and down.

1907
01:32:28,250 --> 01:32:29,600
这就是我这么快打字的方式。
That's how I'm typing so quickly.

1908
01:32:29,600 --> 01:32:31,600
我只是上下移动以前的命令。
I'm just going up and down to previous commands.

1909
01:32:31,600 --> 01:32:32,120
瞧。
Voila.

1910
01:32:32,119 --> 01:32:36,829
现在，我看到木偶戏是一部喜剧，戏剧和音乐剧。
Now I see that the Muppet Show is a comedy, a drama, and a musical.

1911
01:32:36,829 --> 01:32:40,069
好吧，不过，我比较关注的是其中一部比较受欢迎的节目，
Well, I take issue, though, with one of the more popular shows that

1912
01:32:40,069 --> 01:32:40,969
在列表中。
was in the list.

1913
01:32:40,970 --> 01:32:44,637
一大堆你喜欢的朋友，
A whole bunch of you liked, let's say, Friends,

1914
01:32:44,636 --> 01:32:46,219
我从没真正喜欢过。
which I've never really been a fan of.

1915
01:32:46,220 --> 01:32:53,828
让我继续，SELECT title FROM显示WHERE title =“ Friends”。
And let me go ahead and SELECT title FROM shows WHERE title = "Friends."

1916
01:32:53,828 --> 01:32:56,120
也许我应该比这更严格一些。
And maybe I should be a little more rigorous than that.

1917
01:32:56,119 --> 01:32:59,149
我应该说标题“ Friends”，以防万一
I should say title LIKE "Friends" just in case

1918
01:32:59,149 --> 01:33:00,649
大小写不同。
there was different capitalizations.

1919
01:33:00,649 --> 01:33:01,459
进入。
Enter.

1920
01:33:01,460 --> 01:33:03,148
你们中的许多人真的很喜欢Friends。
A lot of you really liked Friends.

1921
01:33:03,148 --> 01:33:04,190
其实你们有几个？
In fact, how many of you?

1922
01:33:04,189 --> 01:33:05,609
好吧，记得我可以做到这一点。
Well, recall that I can do this.

1923
01:33:05,609 --> 01:33:08,899
我可以说COUNT，我可以让SQL为我做计数。
I can say COUNT, and I can let SQL do the count for me.

1924
01:33:08,899 --> 01:33:10,574
你们中的26个人，我非常不同意。
26 of you, I disagree with strongly.

1925
01:33:10,574 --> 01:33:12,949
你们当中有几个甚至都加了点
And there's a couple of you that even added all the dots,

1926
01:33:12,949 --> 01:33:14,239
但我们稍后再处理。
but we'll deal with you later.

1927
01:33:14,239 --> 01:33:16,099
因此，假设我确实对此表示怀疑。
So suppose I do take issue with this.

1928
01:33:16,100 --> 01:33:22,970
好吧，DELETE FROM显示WHERE title =“ Friends”-
Well, DELETE FROM shows WHERE title = "Friends"--

1929
01:33:22,970 --> 01:33:24,390
实际上，标题为“朋友”。
actually, title LIKE "Friends."

1930
01:33:24,390 --> 01:33:25,220
让我们全力以赴。
Let's get them all.

1931
01:33:25,220 --> 01:33:26,090
进入。
Enter.

1932
01:33:26,090 --> 01:33:29,450
现在，如果我们再次选择此选项，对不起。
And now if we SELECT this again, I'm sorry.

1933
01:33:29,449 --> 01:33:30,869
朋友已被取消。
Friends has been canceled.

1934
01:33:30,869 --> 01:33:34,909
因此，您可以再次执行CRUD的这些基本命令，
So you can again execute these fundamental commands of CRUD,

1935
01:33:34,909 --> 01:33:38,629
通过使用CREATE或INSERT创建读取，更新和删除，
Create Read, Update, and Delete, by using CREATE or INSERT,

1936
01:33:38,630 --> 01:33:41,540
通过使用SELECT，通过按字面意义使用UPDATE
by using SELECT, by using UPDATE literally

1937
01:33:41,539 --> 01:33:43,379
和从字面上删除，以及。
and DELETE literally, as well.

1938
01:33:43,380 --> 01:33:44,580
就是这样。
And that's about it.

1939
01:33:44,579 --> 01:33:46,579
即使很快，但实际上
Even though this was a lot quickly, there really

1940
01:33:46,579 --> 01:33:49,039
只是SQL中的四个基本操作
are just those four fundamental operations in SQL

1941
01:33:49,039 --> 01:33:53,089
加上其中一些附加功能，例如COUNT等这些附加功能
plus some of these add-on features, like these additional functions like COUNT

1942
01:33:53,090 --> 01:33:57,420
您可以使用的关键字，以及其中的一些关键字，例如WHERE等。
that you can use and also some of these keywords like WHERE and the like.

1943
01:33:57,420 --> 01:33:59,810
好吧，让我建议我们现在做得更好。
Well, let me propose that we now do better.

1944
01:33:59,810 --> 01:34:04,580
如果我们有能力选择数据并创建表并插入数据，
If we have the ability to select data and create tables and insert data,

1945
01:34:04,579 --> 01:34:11,269
让我们继续编写我们自己的使用SQL的Python脚本，例如在循环中，
let's go ahead and write our own Python script that uses SQL, as in a loop,

1946
01:34:11,270 --> 01:34:16,130
阅读我的CSV文件并插入，插入，插入，插入每一行
to read over my CSV file and to insert, insert, insert, insert each of the rows

1947
01:34:16,130 --> 01:34:16,700
手动。
manually.

1948
01:34:16,699 --> 01:34:18,407
老实说，这将带我永远
Because honestly, it will take me forever

1949
01:34:18,408 --> 01:34:22,220
手动键入数百个SQL查询以导入所有行
to manually type out hundreds of SQL queries to import all of your rows

1950
01:34:22,220 --> 01:34:23,390
进入新的数据库。
into a new database.

1951
01:34:23,390 --> 01:34:25,520
我想编写一个执行此操作的程序。
I want to write a program that does this instead.

1952
01:34:25,520 --> 01:34:29,430
我将建议我们按照以下方式进行设计。
And I'm going to propose that we design it in the following way.

1953
01:34:29,430 --> 01:34:32,720
这次我要有两个表，在这里表示
I'm going to have two tables this time, represented here

1954
01:34:32,720 --> 01:34:34,190
这位艺术家的演绎。
with this artist's rendition.

1955
01:34:34,189 --> 01:34:36,019
一个将被称为表演。
One is going to be called shows.

1956
01:34:36,020 --> 01:34:38,060
一种将被称为流派。
One is going to be called genres.

1957
01:34:38,060 --> 01:34:44,270
这是设计关系数据库的基本原则，
And this is a fundamental principle of designing relational databases,

1958
01:34:44,270 --> 01:34:49,700
找出数据之间的关系并规范化数据。
to figure out the relationships among data and to normalize your data.

1959
01:34:49,699 --> 01:34:53,479
标准化数据意味着消除冗余。
To normalize your data means to eliminate redundancies.

1960
01:34:53,479 --> 01:34:58,519
规范化数据意味着消除对相同单词的提及
To normalize your data means to eliminate mentions of the same words

1961
01:34:58,520 --> 01:35:02,320
一遍又一遍，只有真实的数据来源，
again and again and have just single sources of truth for your data,

1962
01:35:02,319 --> 01:35:02,819
可以这么说。
so to speak.

1963
01:35:02,819 --> 01:35:04,139
那我是什么意思呢？
So what do I mean by that?

1964
01:35:04,140 --> 01:35:07,520
我将建议我们改为创建一个更简单的表，称为
I'm going to propose that we instead create a simpler table called

1965
01:35:07,520 --> 01:35:10,320
显示只有两列。
shows that has just two columns.

1966
01:35:10,319 --> 01:35:13,097
一个将被称为id，这是新的。
One is going to be called id, which is new.

1967
01:35:13,097 --> 01:35:15,139
另一个将像以前一样被称为标题。
The other is going to be called title, as before.

1968
01:35:15,140 --> 01:35:16,940
老实说，我不在乎时间戳，所以我们只是
Honestly, I don't care about timestamps, so we're just

1969
01:35:16,939 --> 01:35:19,729
会抛弃那个价值，这是写作的另一个好处
going to throw that value away, which is another upside of writing

1970
01:35:19,729 --> 01:35:20,419
我们自己的程序。
our own program.

1971
01:35:20,420 --> 01:35:23,030
我们可以添加或删除所需的任何数据。
We can add or remove any data we want.

1972
01:35:23,029 --> 01:35:25,849
对于id，我正在介绍它，这将是
For id, I'm introducing this, which is going

1973
01:35:25,850 --> 01:35:28,490
成为唯一的标识符，实际上是一个简单的整数-
to be a unique identifier, literally a simple integer--

1974
01:35:28,489 --> 01:35:31,189
一，二，三，一路上升到十亿或二十亿，
1, 2, 3, all the way up to a billion or 2 billion,

1975
01:35:31,189 --> 01:35:33,079
但是我们有很多最爱。
however many favorites we have.

1976
01:35:33,079 --> 01:35:35,689
我只是想让这个自动递增。
I'm just going to let this auto increment as we go.

1977
01:35:35,689 --> 01:35:36,709
为什么？
Why?

1978
01:35:36,710 --> 01:35:42,530
我建议我们将所有流派移到另一张桌子，
I propose that we move to another table all of the genres and that,

1979
01:35:42,529 --> 01:35:48,349
而不是在一列中包含一，二，三或五种流派
instead of having one or two or three or five genres in one column

1980
01:35:48,350 --> 01:35:51,860
作为一个愚蠢的逗号分隔列表-仅在某种意义上是愚蠢的
as a stupid comma-separated list-- which is stupid only in the sense

1981
01:35:51,859 --> 01:35:53,179
那只是一团糟，对吗？
that it's just messy, right?

1982
01:35:53,180 --> 01:35:55,040
这意味着我必须运行愚蠢的命令
It means that I have to run stupid commands

1983
01:35:55,039 --> 01:35:57,331
我在这里检查逗号的地方。
where I'm checking for the comma here, the comma there.

1984
01:35:57,332 --> 01:35:58,850
可以这么说，它非常骇人听闻。
It's very hackish, so to speak.

1985
01:35:58,850 --> 01:36:00,080
设计不良。
Bad design.

1986
01:36:00,079 --> 01:36:03,769
而不是这样做，我将创建另一个表
Instead of doing that, I'm going to create another table that

1987
01:36:03,770 --> 01:36:05,580
也有两列。
also has two columns.

1988
01:36:05,579 --> 01:36:09,319
一种将被称为show_id，另一种将被称为流派。
One is going to be called show_id, and the other is going to be called genre.

1989
01:36:09,319 --> 01:36:12,829
现在，这里的流派只是一个字而已。
And genre here is just going to be a single word now.

1990
01:36:12,829 --> 01:36:16,339
该列将包含流派的单个字词，
That column will contain single words for genres,

1991
01:36:16,340 --> 01:36:19,400
例如“喜剧”或“音乐”或“音乐”。
like "comedy" or "music" or "musical."

1992
01:36:19,399 --> 01:36:23,569
但是我们将把所有这些流派联系起来
But we're going to associate all of those genres

1993
01:36:23,569 --> 01:36:27,469
根据您的Google表单显示其所属的原始节目
with the original show to which they belong, per your Google form

1994
01:36:27,470 --> 01:36:31,500
提交，请在此处使用此show_id。
submissions, by using this show_id here.

1995
01:36:31,500 --> 01:36:33,290
那么，这特别意味着什么呢？
So what does this mean in particular?

1996
01:36:33,289 --> 01:36:37,369
通过添加到我们的第一个表格中，可以看到该唯一标识符-
By adding to our first table, shows, this unique identifier--

1997
01:36:37,369 --> 01:36:39,079
1，2，3，4，5，6--
1, 2, 3, 4, 5, 6--

1998
01:36:39,079 --> 01:36:44,629
我现在可以使用
I can now refer to that same show in a very efficient way using

1999
01:36:44,630 --> 01:36:46,940
一个非常简单的数字，而不是多余的
a very simple number instead of redundantly

2000
01:36:46,939 --> 01:36:49,729
拥有办公室，办公室，办公室一次又一次。
having The Office, The Office, The Office again and again.

2001
01:36:49,729 --> 01:36:52,279
我只能用一个规范数字来指代它
I can refer to it by just one canonical number, which

2002
01:36:52,279 --> 01:36:54,979
只会是4个字节或32位。
is only going to be 4 bytes or 32 bits.

2003
01:36:54,979 --> 01:36:56,329
相当有效。
Pretty efficient.

2004
01:36:56,329 --> 01:37:00,919
但我仍然可以将该节目与一种或两种或三种类型相关联
But I can still associate that show with one genre or two or three

2005
01:37:00,920 --> 01:37:03,210
甚至更多甚至没有。
or more or even none.

2006
01:37:03,210 --> 01:37:07,610
这样，我们当前表中的每一行
So in this way, every row in our current table

2007
01:37:07,609 --> 01:37:12,859
在我们的新表对中将成为一个或多个行。
is going to become one or more rows in our new pair of tables.

2008
01:37:12,859 --> 01:37:15,559
我们正在考虑流派，以便我们
We're factoring out the genres so that we

2009
01:37:15,560 --> 01:37:20,270
可能会为每个节目添加多行，但仍然
can add multiple rows for every show, potentially, but still

2010
01:37:20,270 --> 01:37:25,050
将这些类型重新映射回原始节目本身。
remap those genres back to the original show itself.

2011
01:37:25,050 --> 01:37:27,890
那么，这里的一些流行词是什么？
So what is some of the buzzwords here?

2012
01:37:27,890 --> 01:37:31,070
有哪些熟悉的语言？
What's some of the language to be familiar with?

2013
01:37:31,069 --> 01:37:35,089
好吧，我们需要知道这里可以使用哪种类型。
Well, we need to know what kinds of types are at our disposal here.

2014
01:37:35,090 --> 01:37:37,250
因此，让我提出这个建议。
So for that, let me propose this.

2015
01:37:37,250 --> 01:37:41,299
我建议在这里列出这个清单。
Let me propose that we have this list here.

2016
01:37:41,300 --> 01:37:44,590
事实证明，在SQLite中，有五种主要的数据类型。
It turns out, in SQLite, there are five main data types.

2017
01:37:44,590 --> 01:37:46,340
这有点过分简化了，
And that's a bit of an oversimplification,

2018
01:37:46,340 --> 01:37:49,430
但是有五种主要的数据类型，其中一些看起来很熟悉，
but there's five main data types, some of which look familiar,

2019
01:37:49,430 --> 01:37:51,410
其中有些有点奇怪。
a couple of which are a little weird.

2020
01:37:51,409 --> 01:37:53,809
整数是一回事。
INTEGER is a thing.

2021
01:37:53,810 --> 01:37:55,910
REAL与float相同。
REAL is the same thing as float.

2022
01:37:55,909 --> 01:38:00,079
因此整数可能是32位或4字节的值，例如1、2、3或4
So an integer might be a 32-bit or 4-byte value, like 1, 2, 3, or 4,

2023
01:38:00,079 --> 01:38:01,129
正面或负面。
positive or negative.

2024
01:38:01,130 --> 01:38:03,213
实数将有一个小数点，
Real number's going to have a decimal point in it,

2025
01:38:03,212 --> 01:38:05,569
浮点值，默认情况下可能为32位。
a floating point value, probably 32 bits by default.

2026
01:38:05,569 --> 01:38:08,239
但是这些东西，这些类型的大小，
But those kinds of things, the sizes of these types,

2027
01:38:08,239 --> 01:38:10,429
因系统而异，就像技术上一样
vary by system, just like they technically

2028
01:38:10,430 --> 01:38:13,760
在C语言中完成。因此，在SQL领域，它们随系统的不同而不同。
did in C. So do they vary by system in the world of SQL.

2029
01:38:13,760 --> 01:38:16,010
但总的来说，这些是很好的经验法则。
But generally speaking, these are good rules of thumb.

2030
01:38:16,010 --> 01:38:16,970
TEXT就是这样。
TEXT is just that.

2031
01:38:16,970 --> 01:38:19,820
它有点像某个长度的字符串。
It's sort of the equivalent of a string of some length.

2032
01:38:19,819 --> 01:38:22,361
但随后在SQLite中，发现还有另外两个数据
But then in SQLite, it turns out there's two other data

2033
01:38:22,362 --> 01:38:23,570
我们以前从未见过的类型
types we've not seen before--

2034
01:38:23,569 --> 01:38:25,009
NUMERIC和BLOB。
NUMERIC and BLOB.

2035
01:38:25,010 --> 01:38:26,750
但是更多的只是这些。
But more on those in just a little bit.

2036
01:38:26,750 --> 01:38:28,370
BLOB是二进制大对象。
BLOB is Binary Large Object.

2037
01:38:28,369 --> 01:38:30,859
这意味着您可以在数据库中存储0和1。
It means you can store 0's and 1's in your database.

2038
01:38:30,859 --> 01:38:34,669
NUMERIC将类似于数字，但本身不是数字。
NUMERIC is going to be something that's number-like but isn't a number per se.

2039
01:38:34,670 --> 01:38:38,360
就像一年或一段时间，有数字但没有
It's like a year or a time, something that has numbers, but isn't

2040
01:38:38,359 --> 01:38:40,729
只是一个简单的整数。
just a simple integer at that.

2041
01:38:40,729 --> 01:38:44,209
我也建议，SQLite也将允许我们指定，
And let me propose, too, that SQLite is going to allow us to specify, too,

2042
01:38:44,210 --> 01:38:49,520
当我们通过自己执行SQL代码手动创建自己的列时，
when we create our own columns manually by executing the SQL code ourselves,

2043
01:38:49,520 --> 01:38:52,430
我们可以指定一列不能为空。
we can specify that a column cannot be null.

2044
01:38:52,430 --> 01:38:53,840
到目前为止，我们已经忽略了这一点。
Thus far, we've ignored this.

2045
01:38:53,840 --> 01:38:56,090
但是你们中有些人可能已经拿到了第五
But some of you might have taken the fifth

2046
01:38:56,090 --> 01:38:58,850
只是没有给我们一个节目或流派的标题。
and just not given us the title of a show or a genre.

2047
01:38:58,850 --> 01:39:01,020
您的答案可能是空白。
Your answers might be blank.

2048
01:39:01,020 --> 01:39:03,020
你们中的一些人，也许是在注册网站时，
Some of you, maybe in registering for a website,

2049
01:39:03,020 --> 01:39:06,170
不想提供诸如您的住所或电话号码之类的信息。
don't want to provide information like where you live or your phone number.

2050
01:39:06,170 --> 01:39:10,190
因此，数据库通常有时确实希望支持空值。
So a database in general sometimes does want to support null values.

2051
01:39:10,189 --> 01:39:12,289
但是您可能想说它不能为null。
But you might want to say that it can't be null.

2052
01:39:12,289 --> 01:39:14,389
网站可能需要您的电子邮件地址，
A website probably needs your email address,

2053
01:39:14,390 --> 01:39:18,570
需要您的密码和其他一些字段，但不是全部。
needs your password and a few other fields, but not everything.

2054
01:39:18,569 --> 01:39:22,249
而且在SQL中还有另一个关键字，就像您看到的一样，它称为UNIQUE，其中
And there's another keyword in SQL, just so you've seen it, called UNIQUE, where

2055
01:39:22,250 --> 01:39:25,459
您还可以说此列中的任何值
you can additionally say that whatever values are in this column

2056
01:39:25,460 --> 01:39:26,520
必须是唯一的。
must be unique.

2057
01:39:26,520 --> 01:39:28,670
因此，一个网站也可能会使用它。
So a website might also use that.

2058
01:39:28,670 --> 01:39:31,910
如果您要确保无法注册相同的电子邮件地址
If you want to make sure that the same email address can't register

2059
01:39:31,909 --> 01:39:33,829
多次访问您的网站，
for your website multiple times, you just

2060
01:39:33,829 --> 01:39:36,019
指定电子邮件列是唯一的。
specify that the email column is unique.

2061
01:39:36,020 --> 01:39:40,370
这样一来，您就无法将多个人放入相同的电子邮件地址。
That way, you can't put multiple people in with identical email addresses.

2062
01:39:40,369 --> 01:39:44,059
长话短说，这只是我们SQL工具包中的更多工具，
So long story short, this is just more of the tools in our SQL toolkit,

2063
01:39:44,060 --> 01:39:46,280
因为我们现在会间接看到其中的一些。
because we'll see some of these now indirectly.

2064
01:39:46,279 --> 01:39:49,669
在设计自己的表之前，我们需要用到的最后一条术语
And the last piece of jargon we need before designing our own tables

2065
01:39:49,670 --> 01:39:51,150
将会是这个。
is going to be this.

2066
01:39:51,149 --> 01:39:54,109
事实证明，在SQL中，有一个概念
It turns out that, in SQL, there's this notion

2067
01:39:54,109 --> 01:39:56,269
主键和外键的集合。
of primary keys and foreign keys.

2068
01:39:56,270 --> 01:39:59,390
而且我们还没有在电子表格中看到这一点。
And we've not seen this in spreadsheets.

2069
01:39:59,390 --> 01:40:02,150
除非您在现实世界中工作了几年
Unless you've been working in the real world for some years

2070
01:40:02,149 --> 01:40:04,399
而且您面前有相当不错的电子表格
and you have fairly fancy spreadsheets in front of you

2071
01:40:04,399 --> 01:40:06,379
作为分析师或财务人员等，
as an analyst or financial person or the like,

2072
01:40:06,380 --> 01:40:11,750
很有可能您没有以完全相同的方式看到键或唯一标识符。
odds are you've not seen keys or unique identifiers in quite the same way.

2073
01:40:11,750 --> 01:40:13,169
但是它们相对简单。
But they're relatively simple.

2074
01:40:13,170 --> 01:40:17,390
实际上，让我回到之前的图片并提出建议
In fact, let me go back to our picture before and propose

2075
01:40:17,390 --> 01:40:21,230
当你有两个这样的表，而你
that when you have two tables like this and you

2076
01:40:21,229 --> 01:40:25,789
想要使用一个简单的整数唯一地标识一个行中的所有行
want to use a simple integer to uniquely identify all of the rows in one

2077
01:40:25,789 --> 01:40:28,394
这些表中的技术上称为ID。
of the tables, that's called technically an ID.

2078
01:40:28,395 --> 01:40:30,020
按照惯例，这就是我所说的。
That's what I'll call it by convention.

2079
01:40:30,020 --> 01:40:33,770
您可以随意命名，但ID只是表示它是唯一标识符。
You could call it anything you want, but ID just means it's a unique identifier.

2080
01:40:33,770 --> 01:40:37,470
但是从语义上讲，此ID称为主键。
But semantically, this ID is what's called a primary key.

2081
01:40:37,470 --> 01:40:43,940
主键是表中唯一标识每一行的列。
A primary key is the column in a table that uniquely identifies every row.

2082
01:40:43,939 --> 01:40:46,819
这意味着您可以拥有多个版本的Office
This means you can have multiple versions of The Office

2083
01:40:46,819 --> 01:40:48,859
在该标题字段中。
in that title field.

2084
01:40:48,859 --> 01:40:52,489
但是这些行中的每一行都可能唯一地拥有自己的编号。
But each of those rows is going to have its own number uniquely, potentially.

2085
01:40:52,489 --> 01:40:56,629
因此，主键唯一地标识每一行。
So primary key uniquely identifies each row.

2086
01:40:56,630 --> 01:41:01,550
在另一个表中，例如我建议我们在短时间内创建的流派，
In another table, like genres, which I'm proposing we create in just a moment,

2087
01:41:01,550 --> 01:41:06,770
原来，欢迎您再次参考另一张桌子
it turns out that you're welcome to refer back to another table

2088
01:41:06,770 --> 01:41:09,260
通过该唯一标识符。
by way of that unique identifier.

2089
01:41:09,260 --> 01:41:13,710
但是在这种情况下，该ID称为外键。
But when it's in this context, that ID is called a foreign key.

2090
01:41:13,710 --> 01:41:16,130
因此，即使我在这里将其命名为show_id，
So even though I've called it show_id here,

2091
01:41:16,130 --> 01:41:18,470
这只是许多SQL数据库中的约定
that's just a convention in a lot of SQL databases

2092
01:41:18,470 --> 01:41:23,030
暗示从技术上讲这是表中称为ID的列
to imply that this is technically a column called ID in a table

2093
01:41:23,029 --> 01:41:26,759
称为演出，在这种情况下为复数。
called show or shows, plural in this case.

2094
01:41:26,760 --> 01:41:29,900
因此，如果这里有一个数字1，假设
So if there's a number 1 here, and suppose

2095
01:41:29,899 --> 01:41:34,189
该办公室的唯一ID为1，我们将
that The Office has a unique ID of 1, we would

2096
01:41:34,189 --> 01:41:38,419
在此表中有一行名为id为1的行，标题为The Office。
have a row in this table called id is 1, title is The Office.

2097
01:41:38,420 --> 01:41:43,730
办公室可能属于喜剧类，戏剧类，
The Office might be in the comedy category, the drama category,

2098
01:41:43,729 --> 01:41:46,399
浪漫类别，所以有多个。
the romance category, so multiple ones.

2099
01:41:46,399 --> 01:41:51,049
因此，在流派表中，我们要输出三行，
Therefore, in the genres table, we want to output three rows,

2100
01:41:51,050 --> 01:41:56,150
每行中的数字1、1、1，但单词“喜剧”
the number 1, 1, 1 in each of those rows but the words "comedy,"

2101
01:41:56,149 --> 01:42:00,449
这些行中的每一行分别为“戏剧”，“浪漫”。
"drama," "romance" in each of those rows respectively.

2102
01:42:00,449 --> 01:42:03,619
同样，这里的目标是更好地设计我们的数据库，而不是
So again, the goal here is to just design our database better, not

2103
01:42:03,619 --> 01:42:08,119
在单列中包含这些愚蠢的逗号分隔值列表。
have these stupid comma-separated lists of values inside of a single column.

2104
01:42:08,119 --> 01:42:12,979
我们想要将其炸毁，炸裂成单独的行。
We want to kind of blow that up, explode it, into individual rows.

2105
01:42:12,979 --> 01:42:15,709
您可能会想，为什么我们不只使用多列？
You might think, well, why don't we just use multiple columns?

2106
01:42:15,710 --> 01:42:18,560
但是同样，根据我们在电子表格中的原则，
But again, per our principle from spreadsheets,

2107
01:42:18,560 --> 01:42:21,650
您不应该习惯在以下情况下添加越来越多的列
you should not be in the habit of adding more and more columns when

2108
01:42:21,649 --> 01:42:25,189
数据都是一样的，像流派，流派，流派，对不对？
the data is all the same, like genre, genre, genre, right?

2109
01:42:25,189 --> 01:42:27,409
在电子表格世界中执行此操作的愚蠢方法
The stupid way to do this in the spreadsheet world

2110
01:42:27,409 --> 01:42:29,659
会有一个名为Genre 1的列
would be to have one column called Genre 1,

2111
01:42:29,659 --> 01:42:34,099
另一列称为流派2，另一列称为流派3，流派4。
another column called Genre 2, another column called Genre 3, Genre 4.

2112
01:42:34,100 --> 01:42:37,340
您可以想象这是多么愚蠢和低效。
And you can imagine just how stupid and inefficient this is.

2113
01:42:37,340 --> 01:42:41,510
对于那些类型很少的节目，很多这些栏将是空的。
A lot of those columns are going to be empty for shows with very few genres.

2114
01:42:41,510 --> 01:42:43,770
那时有点混乱。
And it's just kind of messy at that point.

2115
01:42:43,770 --> 01:42:47,030
更好的是，在关系数据库的世界中，
So better, in the world of relational databases,

2116
01:42:47,029 --> 01:42:51,349
具有第二个表之类的东西，其中有多行
to have something like a second table, where you have multiple rows that

2117
01:42:51,350 --> 01:42:55,700
通过我们所说的方式以某种方式链接回该主键，
somehow link back to that primary key by way of what we're calling,

2118
01:42:55,699 --> 01:42:58,439
从概念上讲，是外键。
conceptually, a foreign key.

2119
01:42:58,439 --> 01:42:59,089
好的。
All right.

2120
01:42:59,090 --> 01:43:01,640
因此，让我们现在开始尝试编写此代码。
So let's go ahead now and try to write this code.

2121
01:43:01,640 --> 01:43:03,710
让我回到我的IDE。
Let me go back to my IDE.

2122
01:43:03,710 --> 01:43:07,850
现在让我退出SQLite。
Let me quit out of SQLite now.

2123
01:43:07,850 --> 01:43:10,640
让我走开。
And let me just move away.

2124
01:43:10,640 --> 01:43:15,402
我暂时将其移开，我的文件
I'm going to move this away, my file, for just a moment

2125
01:43:15,402 --> 01:43:17,360
这样我们只剩下原始数据。
so that we're only left with our original data.

2126
01:43:17,359 --> 01:43:21,679
让我们去实现我的Python文件的最终版本
Let's go about implementing a final version of my Python file that does

2127
01:43:21,680 --> 01:43:23,540
这-创建了两个表-
this-- creates two tables--

2128
01:43:23,539 --> 01:43:26,269
一种叫做表演，一种叫做流派
one called shows, one called genres--

2129
01:43:26,270 --> 01:43:30,200
然后，在for循环中，两个迭代该CSV
and then, two, in a for loop, iterates over that CSV

2130
01:43:30,199 --> 01:43:34,489
并将一些数据插入到节目中，将其他数据插入到流派中。
and inserts some data into the shows and other data into the genres.

2131
01:43:34,489 --> 01:43:36,349
我们如何以编程方式做到这一点？
How can we do this programmatically?

2132
01:43:36,350 --> 01:43:38,720
好吧，这是我们需要解决的最后一个难题。
Well, there's a final piece of the puzzle that we need.

2133
01:43:38,720 --> 01:43:41,912
我们需要某种方法来架起Python和SQL的世界。
We need some way of bridging the world of Python and SQL.

2134
01:43:41,912 --> 01:43:44,120
在这里，我们确实需要一个库，因为它只会
And here, we do need a library, because it would just

2135
01:43:44,119 --> 01:43:46,699
没有图书馆就太痛苦了。
be way too painful to do without a library.

2136
01:43:46,699 --> 01:43:47,539
可以是CS50。
It can be CS50.

2137
01:43:47,539 --> 01:43:50,729
正如我们将看到的，CS50使这一过程非常简单。
CS50, as we'll see, makes this very simple.

2138
01:43:50,729 --> 01:43:53,479
还有其他第三方商业和开源库
There are other third-party commercial and open-source libraries

2139
01:43:53,479 --> 01:43:56,521
您也可以在现实世界中使用它们来做同样的事情。
that you can also use in the real world, as well, that do the same thing.

2140
01:43:56,521 --> 01:43:58,669
但是语法不太友好，
But the syntax is a little less friendly,

2141
01:43:58,670 --> 01:44:01,880
因此，我们将从使用CS50库开始，在Python中，
so we'll start by using the CS50 library, which in Python, recall,

2142
01:44:01,880 --> 01:44:04,330
具有类似get_string和get_int和get_float的功能。
has functions like get_string and get_int and get_float.

2143
01:44:04,329 --> 01:44:10,429
但是今天，事实证明，它也支持SQL功能。
But today, it also has support, it turns out, for SQL capabilities, as well.

2144
01:44:10,430 --> 01:44:12,760
因此，我将返回到“我的收藏夹”文件。
So I'm going to go back to my Favorites file.

2145
01:44:12,760 --> 01:44:15,970
我不仅要导入CSV，而且要导入
And I'm going to import not only CSV, but I'm also

2146
01:44:15,970 --> 01:44:21,310
将从CS50库中导入一个称为SQL的功能。
going to import from the CS50 library a feature called SQL.

2147
01:44:21,310 --> 01:44:25,930
因此，如果您愿意，我们在CS50库中有一个变量
So we have a variable, if you will, inside of the CS50 library

2148
01:44:25,930 --> 01:44:28,600
或者，而是CS50库中的函数
or, rather, a function inside of the CS50 library

2149
01:44:28,600 --> 01:44:31,870
称为SQL，如果我调用它，它将允许我
called SQL that, if I call it, will allow me

2150
01:44:31,869 --> 01:44:35,269
将SQLite数据库加载到内存中。
to load a SQLite database into memory.

2151
01:44:35,270 --> 01:44:36,290
那么我该怎么做呢？
So how do I do this?

2152
01:44:36,289 --> 01:44:38,789
好吧，让我继续并添加几行新代码。
Well, let me go ahead and add a couple of new lines of code.

2153
01:44:38,789 --> 01:44:45,339
让我继续打开一个名为shows.db的文件，
Let me go ahead and open up a file called shows.db,

2154
01:44:45,340 --> 01:44:47,055
但这一次处于写入模式。
but this time in write mode.

2155
01:44:47,055 --> 01:44:49,180
然后只是踢球-暂时，我是
And then just for kicks-- just for now, rather, I'm

2156
01:44:49,180 --> 01:44:50,930
将继续并立即将其关闭。
going to go ahead and close it right away.

2157
01:44:50,930 --> 01:44:54,260
这是创建空文件的Python方式。
This is a Pythonic way of creating an empty file.

2158
01:44:54,260 --> 01:44:58,210
看起来有点愚蠢，但是可以打开一个名为shows.db的文件
It's kind of stupid looking, but by opening a file called shows.db

2159
01:44:58,210 --> 01:45:00,790
在写入模式下，然后立即将其关闭，
in write mode and then immediately closing it,

2160
01:45:00,789 --> 01:45:03,669
它具有创建文件，关闭文件的作用。
it has the effect of creating the file, closing the file.

2161
01:45:03,670 --> 01:45:06,310
因此，我现在有一个与之交互的空文件。
So I now have an empty file with which to interact.

2162
01:45:06,310 --> 01:45:09,100
顺便说一句，我也可以这样做-
I could also do this, as an aside, by doing this--

2163
01:45:09,100 --> 01:45:10,810
触摸shows.db。
touch shows.db.

2164
01:45:10,810 --> 01:45:14,470
有点奇怪的命令，但是在终端窗口中，
touch kind of a strange command, but in a terminal window,

2165
01:45:14,470 --> 01:45:17,870
这意味着创建一个文件（如果不存在）。
it means to create a file if it doesn't exist.

2166
01:45:17,869 --> 01:45:19,449
因此，我们也可以这样做。
So we could also do that instead.

2167
01:45:19,449 --> 01:45:22,419
但这将独立于Python。
But that would be independent of Python.

2168
01:45:22,420 --> 01:45:24,790
所以一旦我创建了这个文件，让我继续
So once I've created this file, let me go ahead

2169
01:45:24,789 --> 01:45:28,719
并立即以SQLite数据库打开文件。
and open the file now as a SQLite database.

2170
01:45:28,720 --> 01:45:31,600
我将为数据库声明一个名为db的变量。
I'm going to declare a variable called db for database.

2171
01:45:31,600 --> 01:45:34,930
我将使用CS50库中的SQL函数。
I'm going to use the SQL function from CS50's library.

2172
01:45:34,930 --> 01:45:38,170
我将通过有点神秘的字符串来打开它
And I'm going to open via somewhat cryptic string this--

2173
01:45:38,170 --> 01:45:43,600
sqlite：///shows.db。
sqlite:///shows.db.

2174
01:45:43,600 --> 01:45:48,740
现在，它看起来像一个URL，http：//，但它是SQLite。
Now, it looks like a URL, http://, but it's SQLite instead.

2175
01:45:48,739 --> 01:45:52,299
而且有三个斜杠，而不是通常的两个斜杠。
And there's three slashes instead of the usual two.

2176
01:45:52,300 --> 01:45:54,430
但是，这行代码（第6行）具有结果
But this line of code, line 6, has the result

2177
01:45:54,430 --> 01:45:57,820
现在打开，否则没有任何内容的空文件
of opening now that otherwise empty file with nothing

2178
01:45:57,819 --> 01:46:04,039
它仍然是使用CS50库的SQLite数据库。
in it yet as being a SQLite database using CS50's library.

2179
01:46:04,039 --> 01:46:05,329
我为什么要那样做？
Why did I do that?

2180
01:46:05,329 --> 01:46:09,019
好吧，我这样做是因为我现在要创建我的第一个表。
Well, I did that because I now want to create my first table.

2181
01:46:09,020 --> 01:46:12,140
让我继续执行db.execute。
Let me go ahead and execute, db.execute.

2182
01:46:12,140 --> 01:46:16,330
因此，CS50 SQL库内部有一个称为execute的函数。
So there's a function called execute inside of the CS50 SQL library.

2183
01:46:16,329 --> 01:46:17,979
我将继续进行此操作。
And I'm going to go ahead and run this.

2184
01:46:17,979 --> 01:46:23,769
CREATE TABLE称为shows，其中的列
CREATE TABLE called shows, the columns of which

2185
01:46:23,770 --> 01:46:27,430
是一个id，将是一个整数，一个标题，这是
are an id, which is going to be an integer, a title, which

2186
01:46:27,430 --> 01:46:33,380
将是文本，其中的主键将是id列。
is going to be text, the primary key in which is going to be the id column.

2187
01:46:33,380 --> 01:46:34,870
因此，这有点神秘。
So this is a bit cryptic.

2188
01:46:34,869 --> 01:46:36,519
但是，让我们看看发生了什么。
But let's see what's happening.

2189
01:46:36,520 --> 01:46:41,950
我现在似乎在第8行中将Python与SQL结合在一起。
I seem to now, in line 8, be combining Python with SQL.

2190
01:46:41,949 --> 01:46:45,999
这就是现在编程变得真正强大，花哨，酷，
And this is where now programming gets really powerful, fancy, cool,

2191
01:46:46,000 --> 01:46:48,250
困难，但是您想感知它。
difficult, however you want to perceive it.

2192
01:46:48,250 --> 01:46:50,680
实际上，我可以在另一种语言中使用一种语言。
I can actually use one language inside of another.

2193
01:46:50,680 --> 01:46:51,250
如何？
How?

2194
01:46:51,250 --> 01:46:53,419
好吧，SQL只是一堆纹理命令。
Well, SQL is just a bunch of textural commands.

2195
01:46:53,420 --> 01:46:55,420
到目前为止，我一直在手动输入
Up until now, I've been typing them out manually

2196
01:46:55,420 --> 01:46:57,430
在此程序中称为SQLite3。
in this program called SQLite3.

2197
01:46:57,430 --> 01:47:00,010
但是，没有什么可以阻止我进行存储
There's nothing stopping me, though, from storing

2198
01:47:00,010 --> 01:47:02,830
在Python字符串中使用相同的命令，然后
those same commands in Python strings and then

2199
01:47:02,829 --> 01:47:05,889
使用代码将它们传递到数据库。
passing them to a database using code.

2200
01:47:05,890 --> 01:47:08,230
我正在使用的代码是一个称为execute的函数。
The code I'm using is a function called execute.

2201
01:47:08,229 --> 01:47:10,989
以及其人生目标，CS50员工写下了这一点，
And its purpose in life, and CS50 staff wrote this,

2202
01:47:10,989 --> 01:47:18,949
是将参数从您的Python代码传递到数据库中以执行。
is to pass the argument from your Python code into the database for execution.

2203
01:47:18,949 --> 01:47:22,509
因此，这就像手动输入内容的编程方式
So it's like the programmatic way of just typing things manually

2204
01:47:22,510 --> 01:47:25,160
几分钟前在SQLite提示下。
at the SQLite prompt a few minutes ago.

2205
01:47:25,159 --> 01:47:27,879
这样就可以继续创建我的表了
So that's going to go ahead and create my table called

2206
01:47:27,880 --> 01:47:30,610
显示，我将在其中存储所有这些唯一ID
shows, in which I'm going to store all of those unique IDs

2207
01:47:30,609 --> 01:47:32,289
还有标题。
and also the titles.

2208
01:47:32,289 --> 01:47:33,669
然后让我再做一次。
And then let me do this again.

2209
01:47:33,670 --> 01:47:39,040
db.execute CREATE TABLE流派，那就是
db.execute CREATE TABLE genres, and that's

2210
01:47:39,039 --> 01:47:43,669
将会有一个名为show_id的列，该列也是一个整数，
going to have a column called show_id, which is an integer also, genre,

2211
01:47:43,670 --> 01:47:45,340
这是文字。
which is text.

2212
01:47:45,340 --> 01:47:48,130
最后，它将有一个外键-
And lastly, it's going to have a foreign key--

2213
01:47:48,130 --> 01:47:51,190
它会在这里包起来很长的时间-
it's going to wrap a little long here--

2214
01:47:51,189 --> 01:47:56,562
在show_id上，该ID引用了shows表ID。
on show_id, which references the shows table id.

2215
01:47:56,563 --> 01:47:57,730
好吧，这很多。
All right, so this is a lot.

2216
01:47:57,729 --> 01:47:59,859
因此，让我们回顾一下从左到右。
So let's just recap left to right.

2217
01:47:59,859 --> 01:48:03,729
db.execute是我的Python函数，它执行我想要的任何SQL。
db.execute is my Python function that executes any SQL I want.

2218
01:48:03,729 --> 01:48:06,459
CREATE TABLE流派创建一个称为流派的表。
CREATE TABLE genres creates a table called genres.

2219
01:48:06,460 --> 01:48:10,060
该表中的列将称为show_id，
The columns in that table will be something called show_id,

2220
01:48:10,060 --> 01:48:13,630
这是一个整数，体裁是一个文本字段。
which is an integer, and genre, which is a text field.

2221
01:48:13,630 --> 01:48:17,050
但这将一次成为一种流派，而不是多种流派。
But it's going to be one genre at a time, not multiple.

2222
01:48:17,050 --> 01:48:20,170
然后在这里，我指定一个外键
And then here, I'm specifying a foreign key

2223
01:48:20,170 --> 01:48:24,280
将是show_id列，该列恰好会返回引用
will be the show_id column, which happens to refer back

2224
01:48:24,279 --> 01:48:28,179
到shows表的ID列。
to the shows table's IDs column.

2225
01:48:28,180 --> 01:48:31,480
这有点神秘，但是所有要做的就是为我们实现
It's a little cryptic, but all this is doing is implementing for us

2226
01:48:31,479 --> 01:48:33,469
等效于此图片。
the equivalent of this picture here.

2227
01:48:33,470 --> 01:48:35,770
我本可以手动键入这两个SQL
I could have manually typed both of these SQL

2228
01:48:35,770 --> 01:48:37,690
在该闪烁的提示下输入命令。
commands at that blinking prompt.

2229
01:48:37,689 --> 01:48:39,849
但是再次，不，我想现在写一个程序
But again, no, I want to write a program now

2230
01:48:39,850 --> 01:48:43,720
在Python中为我创建了表格，现在，更有趣的是，
in Python that creates the tables for me and now, more interestingly,

2231
01:48:43,720 --> 01:48:47,583
将数据加载到该数据库中。
loads the data into that database.

2232
01:48:47,582 --> 01:48:48,999
现在开始吧。
So let's go ahead and do this now.

2233
01:48:49,000 --> 01:48:51,100
我不会从用户中选择标题，
I'm not going to select a title from the user,

2234
01:48:51,100 --> 01:48:52,660
因为我想导入所有内容。
because I want to import everything.

2235
01:48:52,659 --> 01:48:54,992
我将不使用任何计数或类似方法。
I'm not going to use any counting or anything like that.

2236
01:48:54,993 --> 01:48:57,700
因此，让我们继续前进，就像以前一样进入我的循环。
So let's go ahead and just go inside of my loop as before.

2237
01:48:57,699 --> 01:49:02,239
这次，让我们继续前进，在读者中排成一列，
And this time, let's go ahead and, for row in reader,

2238
01:49:02,239 --> 01:49:05,109
像往常一样，让我们继续获取当前标题。
let's go ahead and get the current title, as we've always done.

2239
01:49:05,109 --> 01:49:08,639
但我们还是一如既往地将其剥离空白
But let's also, as always, go ahead and strip it of white space

2240
01:49:08,640 --> 01:49:11,700
并资本化它，只是为了规范化它。
and capitalize it, just to canonicalize it.

2241
01:49:11,699 --> 01:49:15,959
现在，我要继续执行db.execute，用引号引起来，
And now I'm going to go ahead and execute db.execute, quote unquote,

2242
01:49:15,960 --> 01:49:24,707
INSERT INTO显示标题列，值为“ title”。
INSERT INTO shows the title column, the value of "title."

2243
01:49:24,707 --> 01:49:26,040
所以我想把标题放在这里。
So I want to put the title here.

2244
01:49:26,039 --> 01:49:31,689
事实证明，像我们这样的SQL库支持最后一种语法，
It turns out that SQL libraries like ours support one final piece of syntax,

2245
01:49:31,689 --> 01:49:32,849
这是一个占位符。
which is a placeholder.

2246
01:49:32,850 --> 01:49:34,800
在C语言中，我们使用％s。
In C, we use %s.

2247
01:49:34,800 --> 01:49:37,950
在Python中，我们仅使用花括号并将单词放在此处。
In Python, we just use curly braces and put the word right there.

2248
01:49:37,949 --> 01:49:41,519
在SQL中，对于同一个问题，我们有第三种方法-只是在语法上
In SQL, we have a third approach to the same problem-- just syntactically

2249
01:49:41,520 --> 01:49:43,590
不同，但概念上相同。
different, but conceptually the same.

2250
01:49:43,590 --> 01:49:46,560
您在要放置占位符的位置放置一个问号。
You put a question mark where you want to put a placeholder.

2251
01:49:46,560 --> 01:49:50,670
然后在该字符串之外，我将实际输入值
And then outside of this string, I'm going to actually type in the value

2252
01:49:50,670 --> 01:49:53,070
我想插入问号。
that I want to plug into that question mark.

2253
01:49:53,069 --> 01:49:55,589
因此，这与第1周的printf非常相似。
So this is so similar to printf in week 1.

2254
01:49:55,590 --> 01:50:00,180
但是现在不是问号，而是一个问号，然后是一个逗号分隔的列表
But instead of %s, it's a question mark now and then a comma-separated list

2255
01:50:00,180 --> 01:50:03,120
您要为这些占位符插入的参数。
of the arguments you want to plug in for those placeholders.

2256
01:50:03,119 --> 01:50:08,819
所以现在这行代码16刚刚插入了所有这些值
So now this line of code 16 has just inserted all of those values

2257
01:50:08,819 --> 01:50:09,669
进入我的数据库。
into my database.

2258
01:50:09,670 --> 01:50:10,440
让我们继续运行它。
And let's go ahead and run this.

2259
01:50:10,439 --> 01:50:12,969
在继续之前，请允许我继续执行此操作。
Before I go any further, let me go ahead and do this.

2260
01:50:12,970 --> 01:50:15,960
我现在要继续运行python的收藏夹.py
I'm going to go ahead now and run python of favorites.py

2261
01:50:15,960 --> 01:50:18,030
一如既往地交叉我的手指。
and cross my fingers, as always.

2262
01:50:18,029 --> 01:50:20,009
这花了一点时间，花了一点时间。
It's taking a moment, taking a moment.

2263
01:50:20,010 --> 01:50:23,340
那是因为那里有一个像样的文件。
That's because there's a decent-sized file there.

2264
01:50:23,340 --> 01:50:25,650
或者我搞砸了。
Or I screwed up.

2265
01:50:25,649 --> 01:50:27,929
这花了太长时间。
This is taking too long.

2266
01:50:27,930 --> 01:50:28,950
哦好的。
Oh, OK.

2267
01:50:28,949 --> 01:50:30,959
我本来应该更耐心。
I should have just been more patient.

2268
01:50:30,960 --> 01:50:31,560
好的。
All right.

2269
01:50:31,560 --> 01:50:33,970
所以看来我的连线有点慢。
So it just seems my connection's a little slow.

2270
01:50:33,970 --> 01:50:38,717
因此，正如我所料，一切都是100％正确的，并且一切正常。
So as I expected, everything is 100% correct, and it's working fine.

2271
01:50:38,716 --> 01:50:40,799
现在，让我们继续前进，看看我实际上做了什么。
So now let's go ahead and see what I actually did.

2272
01:50:40,800 --> 01:50:44,970
如果输入ls，请注意我有一个名为shows.db的文件。
If I type ls, notice that I have a file called shows.db.

2273
01:50:44,970 --> 01:50:48,180
这是全新的，因为我的Python程序这次创建了它。
This is brand new, because my Python program created it this time.

2274
01:50:48,180 --> 01:50:51,060
让我们继续运行show.db的sqlite3
Let's go ahead and run sqlite3 of shows.db

2275
01:50:51,060 --> 01:50:53,080
以便现在我可以看到其中的内容。
just so I can now see what's inside of it.

2276
01:50:53,079 --> 01:50:57,089
请注意，我可以执行.schema只是为了查看存在哪些表。
Notice that I can do .schema just to see what tables exist.

2277
01:50:57,090 --> 01:51:00,660
实际上，我在Python代码中创建的两个表
And indeed, the two tables that I created in my Python code

2278
01:51:00,659 --> 01:51:01,919
似乎存在。
seem to exist.

2279
01:51:01,920 --> 01:51:04,020
但是请注意，
But notice that there's--

2280
01:51:04,020 --> 01:51:08,730
如果我执行SELECT * FROM节目，让我们查看所有数据。
if I do SELECT * FROM shows, let's see all the data.

2281
01:51:08,729 --> 01:51:09,749
瞧。
Voila.

2282
01:51:09,750 --> 01:51:13,169
有一个以编程方式创建的表。
There is a table that's been programmatically created.

2283
01:51:13,170 --> 01:51:16,350
这次注意，它没有时间戳记，没有流派。
And it has, notice this time, no timestamps, no genres.

2284
01:51:16,350 --> 01:51:20,730
但是左侧有一个ID，右侧有标题。
But it has an ID on the left and the title on the right.

2285
01:51:20,729 --> 01:51:25,349
令人惊讶的是，所有ID都从1单调增加
And amazingly, all of the IDs are monotonically increasing from 1

2286
01:51:25,350 --> 01:51:27,390
在这种情况下，最高可达513。
on up to 513, in this case.

2287
01:51:27,390 --> 01:51:28,300
这是为什么？
Why is that?

2288
01:51:28,300 --> 01:51:30,600
好吧，您在SQL数据库中获得的功能之一
Well, one of the features you get in a SQL database

2289
01:51:30,600 --> 01:51:34,410
是如果您将列定义为SQLite中的主键，
is if you define a column as being a primary key in SQLite,

2290
01:51:34,409 --> 01:51:36,479
它会自动为您增加。
it's going to be auto incremented for you.

2291
01:51:36,479 --> 01:51:41,969
回想一下，在我的代码中我什至都没有一行，一个整数，
Recall that nowhere in my code did I even have a line, an integer,

2292
01:51:41,970 --> 01:51:43,830
输入1，然后输入2，然后输入3。
inputting 1, then 2, then 3.

2293
01:51:43,829 --> 01:51:45,309
我绝对可以那样做。
I could absolutely do that.

2294
01:51:45,310 --> 01:51:47,730
我本可以做这样的事-反击-
I could have done something like this-- counter--

2295
01:51:47,729 --> 01:51:51,659
相反，我本可以做这样的事情-counter = 1。
rather, I could have done something like this-- counter = 1.

2296
01:51:51,659 --> 01:51:56,279
然后在这里，我可以说身份证，头衔，给我自己
And then down here, I could have said id, title, give myself

2297
01:51:56,279 --> 01:51:59,121
两个占位符，然后每次都传递给计数器。
two placeholders, and then pass in the counter each time.

2298
01:51:59,122 --> 01:52:01,830
我本可以自己实现的，然后在每次迭代中
I could have implemented this myself and then, on each iteration,

2299
01:52:01,829 --> 01:52:03,959
完成计数器+ = 1。
done counter += 1.

2300
01:52:03,960 --> 01:52:06,330
但是，正如我们所见，对于SQL数据库，您
But with SQL databases, as we've seen, you

2301
01:52:06,329 --> 01:52:08,309
获得更多内置功能。
get a lot more functionality built in.

2302
01:52:08,310 --> 01:52:11,130
我不需要做任何事情，因为如果我已经
I don't have to do any of that, because if I've

2303
01:52:11,130 --> 01:52:16,710
声明该ID为主键，SQLite将为我插入它
declared that ID as being a primary key, SQLite is going to insert it for me

2304
01:52:16,710 --> 01:52:19,870
并为我增加它。
and increment it also for me, as well.

2305
01:52:19,869 --> 01:52:20,399
好的。
All right.

2306
01:52:20,399 --> 01:52:24,509
因此，如果我回到SQLite，请注意我确实有ID和标题。
So if I go back to SQLite, though, notice that I do have IDs and titles.

2307
01:52:24,510 --> 01:52:28,860
但是，如果我从流派中选择*，当然还没有任何东西。
But if I SELECT * FROM genres, there's of course nothing there yet.

2308
01:52:28,859 --> 01:52:32,249
那么，现在如何获得所有这些节目的所有流派？
So how now do I get all of the genres for each of these shows in?

2309
01:52:32,250 --> 01:52:33,909
我需要完成我的脚本。
I need to finish my script.

2310
01:52:33,909 --> 01:52:38,969
因此，在同一循环中，我不仅在当前行中拥有标题，
So inside of this same loop, I have not only the title in my current row,

2311
01:52:38,970 --> 01:52:42,570
但我在当前行中也有流派。
but I also have genres in the current row.

2312
01:52:42,569 --> 01:52:45,569
但是类型之间以逗号分隔。
But the genres are separated by commas.

2313
01:52:45,569 --> 01:52:47,879
记得在CSV中，每个标题旁边，
Recall that in the CSV, next to every title,

2314
01:52:47,880 --> 01:52:51,450
有一个以逗号分隔的流派列表。
there's a comma-separated list of genres.

2315
01:52:51,449 --> 01:52:53,459
如何分别了解每种类型？
How do I get at each genre individually?

2316
01:52:53,460 --> 01:52:59,190
好吧，我想说一下行括号类型中的类型。
Well, I'd like to be able to say for genre in row bracket genres.

2317
01:52:59,189 --> 01:53:02,519
但这是行不通的，因为那是行不通的
But this is not going to work, because that's not going

2318
01:53:02,520 --> 01:53:05,310
根据这些逗号分开。
to be split up based on those commas.

2319
01:53:05,310 --> 01:53:07,190
从字面上看，这只是要反复进行，
That's literally just going to iterate over,

2320
01:53:07,189 --> 01:53:10,859
实际上，如上周所见，该字符串中的所有字符。
in fact, all of the characters in that string, as we saw last week.

2321
01:53:10,859 --> 01:53:13,949
但事实证明，Python中的字符串有花哨的分割
But it turns out that strings in Python have a fancy split

2322
01:53:13,949 --> 01:53:19,299
函数，这样我就可以在逗号后面加一个空格。
function, whereby I can split on a comma followed by a space.

2323
01:53:19,300 --> 01:53:21,930
在Python中此功能将为我做的是
And what this function will do for me in Python is

2324
01:53:21,930 --> 01:53:26,130
可以用逗号分隔的流派列表并将其爆炸，可以这么说，
take a comma separated list of genres and explode it, so to speak,

2325
01:53:26,130 --> 01:53:31,800
在每个逗号处将其拆分为一个Python列表
split it on every comma, space into a Python list

2326
01:53:31,800 --> 01:53:36,570
在实际的Python列表中包含类型之后的类型
containing genre after genre in an actual Python list

2327
01:53:36,569 --> 01:53:37,989
左方括号。
a la square brackets.

2328
01:53:37,989 --> 01:53:42,359
现在，我可以遍历该单个类型的列表。
So now I can iterate over that list of individual genres.

2329
01:53:42,359 --> 01:53:49,469
在这里，我可以执行db.execute INSERT INTO流派show_id，流派，
And inside of here, I can do db.execute INSERT INTO genres show_id, genre,

2330
01:53:49,470 --> 01:53:53,130
值，问号，问号。
the values, question mark, question mark.

2331
01:53:53,130 --> 01:53:56,100
但是，有一个问题。
But huh, there's a problem.

2332
01:53:56,100 --> 01:53:59,970
我绝对可以插入当前类型，就是这个。
I can definitely plug in the current genre, which is this.

2333
01:53:59,970 --> 01:54:02,970
但我需要在这里放些东西。
But I need to put something here still.

2334
01:54:02,970 --> 01:54:07,560
对于第一个问号，我需要一个show_id的值。
For that first question mark, I need a value for the show_id.

2335
01:54:07,560 --> 01:54:11,130
我怎么知道当前电视节目的ID？
How do I know what the ID is of the current TV show?

2336
01:54:11,130 --> 01:54:13,650
好吧，事实证明该库可以为您提供帮助。
Well, it turns out the library can help you with this.

2337
01:54:13,649 --> 01:54:18,969
当您将新行插入具有主键的表中时，
When you insert new rows into a table that has a primary key,

2338
01:54:18,970 --> 01:54:23,400
事实证明，大多数库都会以某种方式返回该值。
it turns out that most libraries will return you that value in some way.

2339
01:54:23,399 --> 01:54:26,519
如果我回到第15行，我实际上
And if I go back to line 15 and I actually

2340
01:54:26,520 --> 01:54:31,470
使用INSERT后，存储db.execute的返回值，
store the return value of db.execute after using INSERT,

2341
01:54:31,470 --> 01:54:34,500
图书馆会告诉我什么是整数
the library will tell me what was the integer that

2342
01:54:34,500 --> 01:54:36,389
仅用于该给定的节目。
was just used for this given show.

2343
01:54:36,390 --> 01:54:37,650
也许是1、2、3
Maybe it's 1, 2, 3.

2344
01:54:37,649 --> 01:54:39,939
作为程序员，我不必了解或关心。
I don't have to know or care as the programmer.

2345
01:54:39,939 --> 01:54:42,569
但是返回值，我可以存储在一个变量中。
But the return value, I can store in a variable.

2346
01:54:42,569 --> 01:54:47,519
然后在这里，我可以从字面上输入相同的ID，以便现在，
And then down here, I can literally put that same ID so that now,

2347
01:54:47,520 --> 01:54:51,600
如果我在shows表中输入ID为1的Office
if I am inputting The Office, whose ID is 1, into the shows table

2348
01:54:51,600 --> 01:54:54,720
其类型为喜剧，戏剧，浪漫，
and its genres are comedy, drama, romance,

2349
01:54:54,720 --> 01:54:57,990
我现在可以在此for循环内，此嵌套的for循环内，
I can now inside of this for loop, this nested for loop,

2350
01:54:57,989 --> 01:55:03,239
插入1后跟“喜剧”，1后跟“戏剧”，后跟1
insert 1 followed by "comedy," 1 followed by "drama," 1 followed

2351
01:55:03,239 --> 01:55:07,329
通过“浪漫”一次三行。
by "romance," three rows all at once.

2352
01:55:07,329 --> 01:55:11,979
现在让我们回到这里，进入我的终端窗口。
And so now let's go back down here into my terminal window.

2353
01:55:11,979 --> 01:55:15,659
让我用rm删除旧的shows.db，只是为了重新开始。
Let me remove the old shows.db with rm, just to start fresh.

2354
01:55:15,659 --> 01:55:19,919
让我继续并重新运行“ favourites.py”的python。
Let me go ahead and rerun python of favorites.py.

2355
01:55:19,920 --> 01:55:23,733
这次我会更加耐心，因为云的运行速度有点慢。
I'll be more patient this time, because cloud's being a little slow.

2356
01:55:23,733 --> 01:55:24,900
因此，它正在做一些思考。
So it's doing some thinking.

2357
01:55:24,899 --> 01:55:27,029
实际上，现在还有更多工作要做。
And in fact, there's more work being done now.

2358
01:55:27,029 --> 01:55:29,339
在故事的这一点上，我的程序大概是
At this point in the story, my program is presumably

2359
01:55:29,340 --> 01:55:33,060
遍历CSV中的所有行。
iterating over all of the rows in the CSV.

2360
01:55:33,060 --> 01:55:37,170
一次插入到shows表中，
And it's inserting into the shows table one at a time,

2361
01:55:37,170 --> 01:55:43,380
然后将一种或多种类型插入到类型表中。
and then it's inserting one or more genres into the genres table.

2362
01:55:43,380 --> 01:55:44,250
有点慢。
It's a little slow.

2363
01:55:44,250 --> 01:55:47,370
如果我们使用的是速度更快的系统，或者我是在自己的Mac或PC上运行的，
If we were on a faster system or if I were doing it on my own Mac or PC,

2364
01:55:47,369 --> 01:55:49,479
它可能会更快地下降。
it would probably go down more quickly.

2365
01:55:49,479 --> 01:55:52,739
但是您可以在这里看到一个为什么我在第一个中使用.import命令的示例
But you can see here an example of why I use the .import command in the first

2366
01:55:52,739 --> 01:55:53,129
地方。
place.

2367
01:55:53,130 --> 01:55:54,670
这使某些过程自动化。
That automated some of this process.

2368
01:55:54,670 --> 01:55:58,440
但不幸的是，它不允许我更改数据格式。
But unfortunately, it didn't allow me to change the format of my data.

2369
01:55:58,439 --> 01:56:01,529
但是，这里要做的关键是
But the key point to make here is that even though this

2370
01:56:01,529 --> 01:56:05,489
花费一点时间一次插入这数百行，
is taking a little bit of time to insert these hundreds of rows all at once,

2371
01:56:05,489 --> 01:56:07,259
我只需要这样做一次。
I'm only going to have to do this once.

2372
01:56:07,260 --> 01:56:10,840
刚才问的是这种性能。
And what was asked a bit ago was the performance of this.

2373
01:56:10,840 --> 01:56:15,390
事实证明，既然我们已经完全控制了SQL数据库，
It turns out that now that we have full control over the SQL database,

2374
01:56:15,390 --> 01:56:20,640
事实证明，我们将有能力进行实际改进
it turns out we're going to have the ability to actually improve

2375
01:56:20,640 --> 01:56:22,230
其性能。
the performance thereof.

2376
01:56:22,229 --> 01:56:23,999
哦好的。
Oh, OK.

2377
01:56:24,000 --> 01:56:25,830
如预期的那样，它按时完成了。
As expected, it finished right on time.

2378
01:56:25,829 --> 01:56:29,969
现在让我继续并在shows.db上运行sqlite3。
And let me go ahead now and run sqlite3 on shows.db.

2379
01:56:29,970 --> 01:56:32,670
好的，现在我回到了原始SQL环境。
All right, so now I'm back in my raw SQL environment.

2380
01:56:32,670 --> 01:56:36,180
如果我之前做过SELECT * FROM节目，
If I do SELECT * FROM shows, which I did before,

2381
01:56:36,180 --> 01:56:37,650
我们将像以前一样看到所有这些。
we'll see all of this as before.

2382
01:56:37,649 --> 01:56:42,089
如果我选择* FROM显示WHERE title =“ THE OFFICE”，
If I SELECT * FROM shows WHERE title = "THE OFFICE,"

2383
01:56:42,090 --> 01:56:45,103
我将看到所有这些的实际唯一ID。
I'll see the actual unique IDs of all of those.

2384
01:56:45,103 --> 01:56:46,770
我们没有费心消除重复项。
We didn't bother eliminating duplicates.

2385
01:56:46,770 --> 01:56:50,610
我们只是按原样保留了所有内容，但为所有内容赋予了唯一的ID。
We just kept everything as is, but we gave everything a unique ID.

2386
01:56:50,609 --> 01:56:57,519
但是，如果我现在执行SELECT * FROM类型，我们将在那里看到所有值。
But if I now do SELECT * FROM genres, we'll see all of the values there.

2387
01:56:57,520 --> 01:56:59,070
并注意关键细节。
And notice the key detail.

2388
01:56:59,069 --> 01:57:03,359
每行只有一种类型。
There is only one genre per row here.

2389
01:57:03,359 --> 01:57:06,479
因此，我们最终可以将他们与我们的头衔联系在一起。
And so we can ultimately line those up with our titles.

2390
01:57:06,479 --> 01:57:10,249
在这里，我们的头衔都在这里。
And our titles here, we had all of these here.

2391
01:57:10,250 --> 01:57:12,537
出了点问题。
Something's wrong.

2392
01:57:12,537 --> 01:57:13,579
我想做对了。
I want to get this right.

2393
01:57:13,579 --> 01:57:15,939
让我们继续前进，在这里进行第二个也是最后的5分钟休息。
Let's go ahead and take our second and final five-minute break here.

2394
01:57:15,939 --> 01:57:18,279
我们会回来的，我会解释发生了什么。
And we'll come back, and I will explain what's going on.

2395
01:57:18,279 --> 01:57:20,169
好吧，我们回来了。
All right, we are back.

2396
01:57:20,170 --> 01:57:23,710
在我们分手之前，我的自我怀疑开始蔓延。
And just before we broke up, my own self-doubt was starting to creep in.

2397
01:57:23,710 --> 01:57:26,830
但我很高兴地说，幕后没有花哨的魔法，
But I'm happy to say, with no fancy magic behind the scenes,

2398
01:57:26,829 --> 01:57:28,429
一切实际上都正常。
everything was actually working fine.

2399
01:57:28,430 --> 01:57:30,263
我只是在怀疑这一点的正确性。
I was just doubting the correctness of this.

2400
01:57:30,262 --> 01:57:33,459
如果我执行SELECT * FROM节目，我确实会回来
If I do SELECT * FROM shows, I indeed get back

2401
01:57:33,460 --> 01:57:37,540
两列，其中一列具有唯一ID，即所谓的主键
two columns, one with the unique ID, the so-called primary key, followed

2402
01:57:37,539 --> 01:57:40,279
每个节目的标题。
by the title of each of those shows.

2403
01:57:40,279 --> 01:57:46,119
而且，如果我类似地搜索* FROM风格，那么我一次就会获得一种风格。
And if I similarly search for * FROM genres, I get single genres at a time.

2404
01:57:46,119 --> 01:57:49,599
但是左侧本身不是主键
But on the left-hand side are not primary keys per se

2405
01:57:49,600 --> 01:57:52,450
但是现在在这种情况下，这些相同的数字称为
but now those same numbers here in this context called

2406
01:57:52,449 --> 01:57:55,159
一个映射到另一个的外键。
foreign keys that map one to the other.

2407
01:57:55,159 --> 01:58:01,259
因此，例如，无论哪个节目512都有五种不同的流派
So for instance, whatever show 512 is had five different genres associated

2408
01:58:01,260 --> 01:58:01,760
用它。
with it.

2409
01:58:01,760 --> 01:58:05,320
实际上，如果我回想一下节目，看起来就像《权力的游戏》
And in fact, if I go back a moment to shows, it looks like Game of Thrones

2410
01:58:05,319 --> 01:58:10,419
由你们中的一个人决定属于惊悚片，历史片，冒险片，
was decided by one of you as belonging in thriller, history, adventure,

2411
01:58:10,420 --> 01:58:14,660
动作和战争，还有那五个。
action, and war, as well, those five.

2412
01:58:14,659 --> 01:58:17,319
所以现在这就是关系数据库的含义。
So now this is what's meant by relational database.

2413
01:58:17,319 --> 01:58:21,429
您在多个表中具有这种关系或关系
You have this relation or relationship across multiple tables

2414
01:58:21,430 --> 01:58:25,050
将其中的一些数据链接到类似的其他数据。
that link some data in one to some other data in the like.

2415
01:58:25,050 --> 01:58:27,550
不过，要注意的是，现在看来要难一些
The catch, though, is that it would seem a little harder now

2416
01:58:27,550 --> 01:58:30,910
回答问题，因为现在我必须要查询两个表
to answer questions, because now I have to kind of query two tables

2417
01:58:30,909 --> 01:58:34,449
或执行两个单独的查询，然后合并数据。
or execute two separate queries and then combine the data.

2418
01:58:34,449 --> 01:58:36,129
但是实际上并非如此。
But that's not actually the case.

2419
01:58:36,130 --> 01:58:39,100
假设我要回答的问题是
Suppose that I want to answer the question of,

2420
01:58:39,100 --> 01:58:42,760
您最喜欢的电视节目中有哪些音乐剧？
what are all of the musicals among your favorite TV shows?

2421
01:58:42,760 --> 01:58:46,490
我不能只选择演出，因为那里已经没有类型了。
I can't select just the shows, because there's no genres in there anymore.

2422
01:58:46,489 --> 01:58:48,729
但是我也不能只选择流派表，
But I also can't select just the genres table,

2423
01:58:48,729 --> 01:58:50,899
因为那里没有标题。
because there's no titles in there.

2424
01:58:50,899 --> 01:58:55,059
但是有一个值可以相互桥接，即外键
But there is a value that's bridging one and the other, that foreign key

2425
01:58:55,060 --> 01:58:56,980
到主键关系。
to primary key relationship.

2426
01:58:56,979 --> 01:58:59,169
所以，您知道我该怎么办吗？
So you know what I can do off the top of my head?

2427
01:58:59,170 --> 01:59:03,790
我很确定我可以从类型表中选择所有的show_id
I'm pretty sure I can select all of the show_ids from the genres table

2428
01:59:03,789 --> 01:59:07,071
其中特定类型=“音乐”。
where a specific genre = "Musical."

2429
01:59:07,072 --> 01:59:09,280
而且我现在不必担心逗号或空格，
And I don't have to worry about commas or spaces now,

2430
01:59:09,279 --> 01:59:13,209
因为再次，在这个我以编程方式设计的新版本中
because again, in this new version that I have designed programmatically

2431
01:59:13,210 --> 01:59:16,990
加上代码，音乐和所有其他流派，只是一个字而已。
with code, musical and every other genre is just a single word.

2432
01:59:16,989 --> 01:59:21,219
如果我按Enter键，则所有这些show_id均已确定
If I hit Enter, all of these show_ids were decided

2433
01:59:21,220 --> 01:59:23,930
你们所有人都属于音乐剧。
by you all as belonging to musicals.

2434
01:59:23,930 --> 01:59:25,930
但是现在这并不有趣，我当然可以
But now this is not interesting, and I certainly

2435
01:59:25,930 --> 01:59:28,360
不想手动执行10个左右的查询
don't want to execute 10 or so queries manually

2436
01:59:28,359 --> 01:59:30,399
查找这些ID中的每个ID。
to look up every one of those IDs.

2437
01:59:30,399 --> 01:59:32,679
但请注意，我们也可以在SQL中进行操作。
But notice what we can do in SQL, as well.

2438
01:59:32,680 --> 01:59:33,880
我可以嵌套查询。
I can nest queries.

2439
01:59:33,880 --> 01:59:36,940
让我将整个查询放在括号中一会儿
Let me put this whole query in parentheses for just a moment

2440
01:59:36,939 --> 01:59:39,069
然后在其前面添加以下内容。
and then prepend to it the following.

2441
01:59:39,069 --> 01:59:46,929
SELECT title FROM显示此子查询中的主键id。
SELECT title FROM shows WHERE the primary key, id, is in this subquery.

2442
01:59:46,930 --> 01:59:50,650
因此，您可以使嵌套查询在本质上类似Python和C
So you can have nested queries similar in spirit a bit like in Python and C

2443
01:59:50,649 --> 01:59:52,509
当您嵌套循环时。
when you have nested for loops.

2444
01:59:52,510 --> 01:59:55,690
在这种情况下，就像小学数学一样，括号中的任何内容
In this case, just like in grade school math, whatever is in the parentheses

2445
01:59:55,689 --> 01:59:57,159
将首先执行。
will be executed first.

2446
01:59:57,159 --> 02:00:02,139
然后，将使用该内部查询的结果执行外部查询。
Then the outer query will be executed using the results of that inner query.

2447
02:00:02,140 --> 02:00:07,000
因此，如果我从显示中选择ID在该ID列表中的位置的标题，
So if I select the title from shows where the ID is in that list of IDs,

2448
02:00:07,000 --> 02:00:07,660
瞧。
voila.

2449
02:00:07,659 --> 02:00:11,559
似乎有些有趣
It seems that, somewhat amusingly, several of you

2450
02:00:11,560 --> 02:00:15,280
认为《绝命毒师》，《超自然》，《欢乐合唱团》，《福尔摩斯》，《我如何见到你的母亲》，
think that Breaking Bad, Supernatural, Glee, Sherlock, How I Met Your Mother,

2451
02:00:15,279 --> 02:00:18,189
夏威夷五-0，双峰，律师，和我的兄弟，我的兄弟
Hawaii Five-0, Twin Peaks, The Lawyer, and My Brother, My Brother

2452
02:00:18,189 --> 02:00:19,899
和我都是音乐剧。
and Me are all musicals.

2453
02:00:19,899 --> 02:00:22,629
我对其中一些例外，但事实如此。
I take exception to a few of those, but so be it.

2454
02:00:22,630 --> 02:00:24,850
您已为那些演出选中了音乐盒。
You checked the box for musical for those shows.

2455
02:00:24,850 --> 02:00:29,260
因此，即使我们在某种意义上设计了更好的东西
So even though we've designed things better in the sense

2456
02:00:29,260 --> 02:00:33,010
我们已经通过排除通用性对数据库进行了规范化
that we've normalized our database by factoring out commonalities

2457
02:00:33,010 --> 02:00:35,050
或者，更确切地说，我们已经清理了数据，
or, rather, we've cleaned up the data, there's

2458
02:00:35,050 --> 02:00:37,150
仍然承认有些冗余。
still admittedly some redundancy.

2459
02:00:37,149 --> 02:00:39,369
诚然，仍然存在一些冗余。
There's still admittedly some redundancy.

2460
02:00:39,369 --> 02:00:44,409
但是我至少现在有干净的数据
But I at least now have the data in clean fashion

2461
02:00:44,409 --> 02:00:47,799
这样每一列都只有一个值而不是
so that every column has just a single value in it and not

2462
02:00:47,800 --> 02:00:49,870
一些人为的用逗号分隔的列表。
some contrived comma-separated list.

2463
02:00:49,869 --> 02:00:51,724
假设我想找出所有类型
Suppose I want to find out all of the genres

2464
02:00:51,725 --> 02:00:53,350
你们都以为办公室在。
that you all thought The Office was in.

2465
02:00:53,350 --> 02:00:55,480
因此，让我们提出相反的问题。
So let's ask kind of the opposite question.

2466
02:00:55,479 --> 02:00:56,839
好吧，我该怎么做？
Well, how might I do that?

2467
02:00:56,840 --> 02:01:00,430
好吧，要弄清楚The Office，我首先需要选择ID
Well, to figure out The Office, I'm going to first need to SELECT the id

2468
02:01:00,430 --> 02:01:06,400
FROM显示WHERE title =“ THE OFFICE”，因为你们中的很多人
FROM shows WHERE title = "THE OFFICE," because a whole bunch of you

2469
02:01:06,399 --> 02:01:07,329
在办公室里输入。
typed in The Office.

2470
02:01:07,329 --> 02:01:09,901
我们为您的每个答案提供了唯一的标识符
And we gave each of your answers a unique identifier

2471
02:01:09,902 --> 02:01:11,110
这样我们就可以跟踪它。
so we could keep track of it.

2472
02:01:11,109 --> 02:01:12,499
还有所有这些数字。
And there's all of those numbers.

2473
02:01:12,500 --> 02:01:14,260
现在，这是数十种回应。
Now, this is, like, dozens of responses.

2474
02:01:14,260 --> 02:01:16,540
我当然不想执行那么多查询。
I certainly don't want to execute that many queries.

2475
02:01:16,539 --> 02:01:18,849
但是我认为子查询将再次帮助我们。
But I think a subquery will help us out again.

2476
02:01:18,850 --> 02:01:21,470
让我在整个内容中加上括号。
Let me put parentheses around this whole thing.

2477
02:01:21,470 --> 02:01:27,910
现在让我说说从哪里选择不同的类型
And now let me say SELECT DISTINCT genre FROM genres WHERE

2478
02:01:27,909 --> 02:01:32,379
该查询中包含流派表中的show_id。
the show_id in the genres table is in that query.

2479
02:01:32,380 --> 02:01:37,400
只是为了踢球，让我继续进行ORDER BY体裁。
And just for kicks, let me go ahead and ORDER BY genre.

2480
02:01:37,399 --> 02:01:38,929
因此，让我继续执行此操作。
So let me go ahead and execute this.

2481
02:01:38,930 --> 02:01:42,490
好吧，有些有趣的是，那些输入了Office的人
And, OK, somewhat amusingly, those of you who inputted The Office

2482
02:01:42,489 --> 02:01:46,959
动画，喜剧，纪录片，戏剧，家庭，恐怖，
checked boxes for animation, comedy, documentary, drama, family, horror,

2483
02:01:46,960 --> 02:01:49,000
真人秀，浪漫片和科幻片。
reality-TV, romance, and sci-fi.

2484
02:01:49,000 --> 02:01:51,020
我也对其中一些例外。
I take exception to a few of those, too.

2485
02:01:51,020 --> 02:01:53,720
但这是当您接受用户输入时发生的情况。
But this is what happens when you accept user input.

2486
02:01:53,720 --> 02:01:57,293
所以在这里，我们再次使用了这种SQL语言
So here again, we have with this SQL language

2487
02:01:57,292 --> 02:01:59,709
相当简洁地表达的能力，即使
the ability to express fairly succinctly, even though it's

2488
02:01:59,710 --> 02:02:03,670
今天一次有很多新功能，否则会带给我什么
a lot of new features today all at once, what would otherwise take me

2489
02:02:03,670 --> 02:02:06,593
在Python代码中执行一两行
a dozen or two lines in Python code to implement

2490
02:02:06,592 --> 02:02:09,009
神知道多少行代码和多少小时
and god knows how many lines of code and how many hours it

2491
02:02:09,010 --> 02:02:13,060
会带我在C语言中实现类似的功能。现在，坦白地说，
would take me to implement something like this in C. Now, admittedly,

2492
02:02:13,060 --> 02:02:15,220
我们可以做得比这个设计更好。
we could do better than this design.

2493
02:02:15,220 --> 02:02:18,550
这张桌子或这张图片代表了我们现在所拥有的。
This table or this picture represents what we have now.

2494
02:02:18,550 --> 02:02:22,360
但是您会注意到类型表中隐含了很多冗余。
But you'll notice a lot of redundancy implicit in the genres table.

2495
02:02:22,359 --> 02:02:25,509
每当您选中喜剧框时，我都会排一行
Any time you check the comedy box, I have a row now

2496
02:02:25,510 --> 02:02:27,940
那就是喜剧，喜剧，喜剧，喜剧。
that says comedy, comedy, comedy, comedy.

2497
02:02:27,939 --> 02:02:31,929
和show_id不同，但是我一次又一次地使用“喜剧”一词。
And the show_id differs, but I have the word "comedy" again and again.

2498
02:02:31,930 --> 02:02:35,740
而现在，在关系数据库的世界中，这一点变得不那么普遍了，
And now, that tends to be frowned upon in the world of relational databases,

2499
02:02:35,739 --> 02:02:39,369
因为如果您有一种类型的喜剧或喜剧
because if you have a genre called comedy or one

2500
02:02:39,369 --> 02:02:42,429
称为音乐剧或其他任何音乐，理想情况下，您应该
called musical or anything else, you should ideally just

2501
02:02:42,430 --> 02:02:43,970
有那种生活在一个地方。
have that living in one place.

2502
02:02:43,970 --> 02:02:47,980
因此，如果我们真的想变得特别，真正，真正
And so if we really wanted to be particular and really, truly

2503
02:02:47,979 --> 02:02:51,099
标准化此数据库，这是一个学术术语，指的是
normalize this database, which is an academic term referring

2504
02:02:51,100 --> 02:02:55,530
为了消除所有这些冗余，我们实际上可以这样做。
to removing all such redundancies, we could actually do it like this.

2505
02:02:55,529 --> 02:02:59,479
我们可以有一个显示表，它仍然带有ID和标题，两者之间没有区别。
We could have a shows table still with an id and title, no difference there.

2506
02:02:59,479 --> 02:03:03,889
但是我们可以拥有一个包含两列的流派表，即id和name。
But we could have a genres table with two columns, id and name.

2507
02:03:03,890 --> 02:03:05,020
现在，这是它自己的ID。
Now, this is its own id.

2508
02:03:05,020 --> 02:03:06,910
它与show_id没有任何关系。
It has no connection with the show_id.

2509
02:03:06,909 --> 02:03:10,659
它只是它自己的唯一标识符，现在是这里的主键，
It's just its own unique identifier, a primary key here now,

2510
02:03:10,659 --> 02:03:12,319
以及该类型的名称。
and the name of that genre.

2511
02:03:12,319 --> 02:03:14,349
所以您在类型表中会有一行
So you would have one row in the genres table

2512
02:03:14,350 --> 02:03:17,690
用于喜剧，戏剧，音乐，音乐剧和其他所有内容。
for comedy, for drama, music, musical, and everything else.

2513
02:03:17,689 --> 02:03:19,869
然后，您将使用第三个表格，
And then you would use a third table, which

2514
02:03:19,869 --> 02:03:23,919
通俗地称为联接表，我将在中间画出它。
is colloquially called a join table, which I'll draw here in the middle.

2515
02:03:23,920 --> 02:03:25,960
您可以随心所欲地调用它，但是我们已经
And you can call it anything you want, but we've

2516
02:03:25,960 --> 02:03:29,920
称它为shows_genres来表明该表实现了
called it shows_genres to make clear that this table implements

2517
02:03:29,920 --> 02:03:33,400
这两个表之间的关系。
a relationship between those two tables.

2518
02:03:33,399 --> 02:03:36,909
并且请注意，该表中实际上没有多汁的数据。
And notice that in this table is really no juicy data.

2519
02:03:36,909 --> 02:03:38,799
只是外键
It's just foreign keys--

2520
02:03:38,800 --> 02:03:41,380
show_id，genre_id。
show_id, genre_id.

2521
02:03:41,380 --> 02:03:43,930
通过拥有第三张桌子，我们现在可以
And by having this third table, we can now

2522
02:03:43,930 --> 02:03:47,890
确保“喜剧”一词只出现在任何地方的一行中。
make sure that the word "comedy" only appears in one row anywhere.

2523
02:03:47,890 --> 02:03:50,860
“音乐”一词仅在任何地方显示为一行。
The word "musical" only appears in one row anywhere.

2524
02:03:50,859 --> 02:03:55,449
但是我们使用了效率更高的整数，称为show_id和genre_id，
But we use these more efficient integers called show_id and genre_id,

2525
02:03:55,449 --> 02:04:00,849
分别指向这些主键及其主表
which respectively point to those primary keys and their primary tables

2526
02:04:00,850 --> 02:04:02,072
将这两个链接在一起。
to link those two together.

2527
02:04:02,072 --> 02:04:04,780
这是数据库世界中所谓的一个例子
And this is an example of what's called in the world of databases

2528
02:04:04,779 --> 02:04:06,789
多对多关系。
a many-to-many relationship.

2529
02:04:06,789 --> 02:04:09,609
一个节目可以有多种流派。
One show can have many genres.

2530
02:04:09,609 --> 02:04:12,729
一种类型可以属于许多表演。
One genre can belong to many shows.

2531
02:04:12,729 --> 02:04:14,529
因此，有了这个第三张桌子，您可以
And so by having this third table, you can

2532
02:04:14,529 --> 02:04:16,729
有多对多的关系。
have that many-to-many relationship.

2533
02:04:16,729 --> 02:04:19,569
再次，第三张表现在使我们能够真正归一化
And again, the third table now allows us to truly normalize

2534
02:04:19,569 --> 02:04:23,919
通过消除所有重复的喜剧，喜剧，喜剧来获得我们的数据集。
our data set by getting rid of all of the duplicate comedy, comedy, comedy.

2535
02:04:23,920 --> 02:04:25,420
为什么这很重要？
Why is this important?

2536
02:04:25,420 --> 02:04:27,310
对于类型来说，可能不算什么。
Probably not a huge deal for genres.

2537
02:04:27,310 --> 02:04:30,910
但是，请想象一下我目前的设计是否犯了拼写错误，
But imagine with my current design if I made a spelling mistake,

2538
02:04:30,909 --> 02:04:32,439
我给喜剧取了个名字
and I misnamed comedy.

2539
02:04:32,439 --> 02:04:36,189
我现在必须一次又一次地用喜剧这个词来更改每一行。
I would now have to change every row with the word comedy again and again.

2540
02:04:36,189 --> 02:04:39,579
或者，如果您改变了节目的类型，
Or if maybe you change the genres of the shows,

2541
02:04:39,579 --> 02:04:41,839
您将不得不在多个地方进行更改。
you would have to change it in multiple places.

2542
02:04:41,840 --> 02:04:44,260
但是用另一种方法，用三个表，
But with this other approach with three tables,

2543
02:04:44,260 --> 02:04:46,450
你可以说现在你只需要改变
you can argue that now you only have to change

2544
02:04:46,449 --> 02:04:49,749
类型的名称位于一个地方，而不是整个地方。
the name of a genre in one place, not all over the place.

2545
02:04:49,750 --> 02:04:52,419
而且，通常在C语言中，现在在Python中，现在
And that, in general, in C and now in Python and now

2546
02:04:52,420 --> 02:04:57,040
通常，SQL最好不要复制粘贴相同的值
SQL has generally been a good thing not to copy paste identical values

2547
02:04:57,039 --> 02:05:00,059
到处都是。
all over the place.

2548
02:05:00,060 --> 02:05:00,720
好的。
All right.

2549
02:05:00,720 --> 02:05:04,410
因此，我们还有什么其他工具可以使用？
So with that said, what other tools do we have at our disposal?

2550
02:05:04,409 --> 02:05:09,179
好吧，事实证明，现实世界中还有其他数据类型
Well, it turns out that there are other data types out there in the real world

2551
02:05:09,180 --> 02:05:11,280
除了这五个以外，还使用SQL
using SQL besides just these five--

2552
02:05:11,279 --> 02:05:13,619
BLOB，INTEGER，NUMERIC，REAL和TEXT。
BLOB, INTEGER, NUMERIC, REAL, and TEXT.

2553
02:05:13,619 --> 02:05:15,869
同样，BLOB是二进制文件，通常不是
BLOB, again, is for binary stuff, generally not

2554
02:05:15,869 --> 02:05:18,839
可以说，除了更专业的应用之外，
used except for more specialized applications, let's say.

2555
02:05:18,840 --> 02:05:21,270
INTEGER，它是一个int，通常为32位；
INTEGER, which is an int, typically 32 bits;

2556
02:05:21,270 --> 02:05:23,700
NUMERIC，类似于日期或年份
NUMERIC, which is something like a date or a year

2557
02:05:23,699 --> 02:05:26,219
或时间之类的东西；实数，其中
or time or something like that; REAL numbers, which

2558
02:05:26,220 --> 02:05:30,180
是浮点值；和TEXT，就像字符串一样。
are floating point values; and TEXT, which are things like strings.

2559
02:05:30,180 --> 02:05:34,110
但是，如果您最终从手机上的SQLite毕业
But if you graduate ultimately from SQLite on phones

2560
02:05:34,109 --> 02:05:38,521
在Mac和PC上运行运行Oracle，MySQL，
and on Macs and PCs to actual servers that run Oracle, MySQL,

2561
02:05:38,521 --> 02:05:40,229
和PostgreSQL（如果您实际上正在运行）
and PostgreSQL if you're actually running

2562
02:05:40,229 --> 02:05:42,539
您自己的互联网业务，好吧
your own internet-style business, well, it

2563
02:05:42,539 --> 02:05:47,309
事实证明，功能更强大，功能更强大
turns out that more sophisticated, even more powerful

2564
02:05:47,310 --> 02:05:50,620
如果可能的话，数据库还带有其他子类型。
databases come with other subtypes, if you will.

2565
02:05:50,619 --> 02:05:54,269
因此，除了INTEGER外，您还可以为小数字指定smallint，
So besides INTEGER, you can specify smallint for small numbers,

2566
02:05:54,270 --> 02:05:57,690
也许只用几位而不是32-
maybe using just a few bits instead of 32--

2567
02:05:57,689 --> 02:06:01,799
INTEGER或bigint，它使用64位而不是32位。
INTEGER or bigint, which uses 64 bits instead of 32.

2568
02:06:01,800 --> 02:06:05,130
世界各地的Facebook和Twitter都需要大量使用bigint，
The Facebooks, the Twitters of the world need to use bigint a lot,

2569
02:06:05,130 --> 02:06:06,720
因为他们有很多数据
because they have so much data.

2570
02:06:06,720 --> 02:06:09,330
您和我可以摆脱简单的整数，因为我们不是
You and I can get away with simple integers, because we're not

2571
02:06:09,329 --> 02:06:12,449
一个班级将有超过40亿个喜欢的电视节目，
going to have more than 4 billion favorite TV shows in a class,

2572
02:06:12,449 --> 02:06:13,289
当然。
certainly.

2573
02:06:13,289 --> 02:06:17,039
像REAL这样的东西，您可以使用32位实数，或者有些奇怪
Something like REAL, you can have 32-bit real numbers or, a little weirdly

2574
02:06:17,039 --> 02:06:22,469
命名为double precision，它类似于C中的double，使用64位代替
named, double precision, which is like a double was in C, using 64 bits instead

2575
02:06:22,470 --> 02:06:23,640
以获得更高的精度。
for more precision.

2576
02:06:23,640 --> 02:06:25,230
NUMERIC就是这种包罗万象的东西。
NUMERIC is kind of this catchall.

2577
02:06:25,229 --> 02:06:29,159
您不仅可以拥有日期和日期时间，还可以拥有布尔值之类的东西。
You can have not only dates and date times but things like Boolean values.

2578
02:06:29,159 --> 02:06:31,199
您可以指定总位数
You can specify the total number of digits

2579
02:06:31,199 --> 02:06:34,179
使用此数字刻度和精度进行存储。
to store using this numeric scale and precision.

2580
02:06:34,180 --> 02:06:37,440
因此，它涉及的数字不只是整数。
So it relates to numbers that aren't just quite integers.

2581
02:06:37,439 --> 02:06:39,719
然后您还有TEXT的类别-
And then you also have categories of TEXT--

2582
02:06:39,720 --> 02:06:42,570
字符后跟一个数字，该数字指定
char followed by a number, which specifies

2583
02:06:42,569 --> 02:06:47,009
该列中的每个值都将具有相同数量的字符，
that every value in the column will have the same number of characters,

2584
02:06:47,010 --> 02:06:50,190
这对于长度提前的事情很有用，例如在美国。
that's helpful for things where the length in advance, like in the US.

2585
02:06:50,189 --> 02:06:54,029
所有州（共50个州）都有两个字符的代码，
All states, all 50 states, have two-character codes,

2586
02:06:54,029 --> 02:06:57,449
例如马萨诸塞州的马萨诸塞州，加利福尼亚州的CA。
like MA for Massachusetts, CA for California.

2587
02:06:57,449 --> 02:07:00,149
char（2）在那里很合适，因为您
char(2) would be appropriate there, because you

2588
02:07:00,149 --> 02:07:02,999
知道该列中的每个值都将包含两个字符。
know every value in the column is going to have two characters.

2589
02:07:03,000 --> 02:07:05,250
但是，当您不知道时，可以使用varchar。
When you don't know, though, you can use varchar.

2590
02:07:05,250 --> 02:07:08,399
varchar指定最大字符数。
And varchar specifies a maximum number of characters.

2591
02:07:08,399 --> 02:07:12,059
因此，您可以指定varchar，例如32。
And so you might specify varchar of, like, 32.

2592
02:07:12,060 --> 02:07:15,600
没有人可以输入长度超过32个字符的名称，
No one might be able to type in a name that's longer than 32 characters,

2593
02:07:15,600 --> 02:07:18,900
或varchar（200）（如果要允许更大的值）。
or varchar(200) if you want to allow for something even bigger.

2594
02:07:18,899 --> 02:07:21,689
但这与我们在网络上的实际经验密切相关。
But this is germane to our real-world experience with the web.

2595
02:07:21,689 --> 02:07:24,539
如果您曾经访问过网站，请开始填写表格，
If you've ever gone to a website, start filling out a form,

2596
02:07:24,539 --> 02:07:26,849
突然之间，您无法再输入任何字符，
and all of a sudden you can't type any more characters,

2597
02:07:26,850 --> 02:07:28,440
您的回复太长了-
your response is too long--

2598
02:07:28,439 --> 02:07:29,461
这是为什么？
why is that?

2599
02:07:29,462 --> 02:07:31,170
好吧，一个，程序员可能不会
Well, one, the programmers just might not

2600
02:07:31,170 --> 02:07:33,810
希望您继续表达更多细节，尤其是
want you to keep expressing yourself in more detail, especially

2601
02:07:33,810 --> 02:07:36,330
如果是客户服务网站上的投诉表。
if it's a complaint form on a customer service site.

2602
02:07:36,329 --> 02:07:40,619
但务实的是，这可能是因为他们的数据库是经过设计的
But pragmatically, it's probably because their database was designed

2603
02:07:40,619 --> 02:07:42,569
存储有限数量的字符。
to store a finite number of characters.

2604
02:07:42,569 --> 02:07:44,024
而您已经达到了这个门槛。
And you have hit that threshold.

2605
02:07:44,024 --> 02:07:45,899
而且您当然不希望有缓冲区
And you certainly don't want to have a buffer

2606
02:07:45,899 --> 02:07:50,189
溢出，就像在C中一样。因此数据库将强制执行最大值n。
overflow, like in C. So the database will enforce a maximum value n.

2607
02:07:50,189 --> 02:07:52,829
然后，文本用于更大的文本块。
And then text is for even bigger chunks of text.

2608
02:07:52,829 --> 02:07:54,929
如果您要让人们复制，请粘贴他们的简历
If you're letting people copy paste their resumes

2609
02:07:54,930 --> 02:07:59,680
或保存文档或什至更大的文本集，则可以改用文本。
or hold documents or even larger sets of text, you might use text instead.

2610
02:07:59,680 --> 02:08:03,510
因此，让我们考虑一个真实的数据集。
So let's then consider a real-world data set.

2611
02:08:03,510 --> 02:08:07,320
事情变得非常有趣，所有这些非常学术的想法
Things get really interesting, and all of these very academic ideas

2612
02:08:07,319 --> 02:08:09,599
和建议真正发挥作用
and recommendations really come into play

2613
02:08:09,600 --> 02:08:14,830
当我们没有数百个收藏夹时，而是当我们有数千个收藏夹时。
when we don't had hundreds of favorites but when we have thousands instead.

2614
02:08:14,829 --> 02:08:19,179
因此，我要继续执行的操作是在此处下载文件，
And so what I'm going to go ahead and do here is download a file here,

2615
02:08:19,180 --> 02:08:25,120
这是IMDb，互联网电影数据库的SQLite版本，
which is a SQLite version of the IMDb, Internet Movie Database,

2616
02:08:25,119 --> 02:08:27,119
你们中的一些人可能已经在网站表单中使用过
that some of you might have used in website form

2617
02:08:27,119 --> 02:08:30,329
为了查找电影及其收视率等。
in order to look up movies and ratings thereof and the like.

2618
02:08:30,329 --> 02:08:32,099
我们事先要做的是写
And what we've done in advance is we wrote

2619
02:08:32,100 --> 02:08:38,490
预先将所有这些信息下载为TSV文件的脚本。
a script that downloaded all of that information in advance as TSV files.

2620
02:08:38,489 --> 02:08:42,599
事实证明，他们，互联网电影数据库，制作了所有数据
It turns out that they, Internet Movie Database, make all of their data

2621
02:08:42,600 --> 02:08:46,650
可作为TSV文件（制表符分隔值）使用。
available as TSV files, Tab-Separated Values.

2622
02:08:46,649 --> 02:08:54,009
然后，我们继续使用名为show.db的脚本将其导入，如下所示。
And we went ahead and imported it with a script called shows.db as follows.

2623
02:08:54,010 --> 02:08:55,800
所以我马上就去
So I'm going to go ahead in just a moment

2624
02:08:55,800 --> 02:08:59,520
并打开shows.db，它不是我之前创建的版本
and open up shows.db, which is not the version I created earlier

2625
02:08:59,520 --> 02:09:00,990
根据您的收藏夹。
based on your favorites.

2626
02:09:00,989 --> 02:09:02,819
现在是我们员工的版本
This is now the version that we, the staff,

2627
02:09:02,819 --> 02:09:06,629
通过下载成千上万个预先创建的
created in advance by downloading hundreds of thousands

2628
02:09:06,630 --> 02:09:10,950
电影和电视节目以及来自IMDb.com的演员和导演
of movies and TV shows and actors and directors from IMDb.com

2629
02:09:10,949 --> 02:09:15,659
在他们的许可下，然后导入到SQLite数据库中。
under their license and then imported into a SQLite database.

2630
02:09:15,659 --> 02:09:17,129
那我怎么看这里的东西呢？
So how can I see what's in here?

2631
02:09:17,130 --> 02:09:19,530
好吧，让我继续输入.schema，回想一下。
Well, let me go ahead and type .schema, recall.

2632
02:09:19,529 --> 02:09:22,544
您将在其中看到大量数据。
And you'll see a whole bunch of data therein.

2633
02:09:22,545 --> 02:09:25,690
实际上，以图片形式，它实际上是这样的。
And in fact, in pictorial form, it actually looks like this.

2634
02:09:25,689 --> 02:09:28,139
这是一张只给您土地的图片。
Here is a picture that just gives you the lay of the land.

2635
02:09:28,140 --> 02:09:30,330
将会有一个人桌
There's going to be a people table that has

2636
02:09:30,329 --> 02:09:33,902
每个人的ID，姓名和出生年月。
an ID for every person, a name, and their birth year.

2637
02:09:33,903 --> 02:09:36,570
就像我们一直在谈论一样，将有一个节目表。
There's going to be a shows table, just like we've been talking,

2638
02:09:36,569 --> 02:09:41,099
这是ID，节目标题，但也包括该节目首次亮相的年份
which is IDs, titles of shows-- also, though, the year that the show debuted

2639
02:09:41,100 --> 02:09:43,380
以及该节目的剧集数量。
and the number of episodes that the show had.

2640
02:09:43,380 --> 02:09:46,410
然后将有类似设计的流派。
Then there's going to be genres, similar in design to before.

2641
02:09:46,409 --> 02:09:49,619
因此，我们并未全力以赴，将其分解为第三张表。
So we didn't go all out and factor it out into a third table.

2642
02:09:49,619 --> 02:09:52,829
诚然，我们在流派上只是有些重复。
We just have some duplication here, admittedly, in genres.

2643
02:09:52,829 --> 02:09:54,239
但是，这里有一个评分表。
But then there's a ratings table.

2644
02:09:54,239 --> 02:09:57,239
在这里，您可以看到关系数据库变得有趣的地方。
And here's where you can see where relational databases get interesting.

2645
02:09:57,239 --> 02:10:00,999
您可以拥有一个评分表，用于存储评分（例如1到5）
You can have a ratings table storing ratings, like 1 to 5,

2646
02:10:01,000 --> 02:10:05,080
而且还可以通过show_id将这些评分与演出相关联。
but also associate those ratings with a show by way of its show_id.

2647
02:10:05,079 --> 02:10:08,439
然后，您可以跟踪显示的票数。
And then you can keep track of the number of votes that that show got.

2648
02:10:08,439 --> 02:10:10,909
请注意，作家是一个单独的表格。
Writers, notice, is a separate table.

2649
02:10:10,909 --> 02:10:12,559
并请注意，这有点酷。
And notice this is kind of cool.

2650
02:10:12,560 --> 02:10:19,060
每个箭头所对应的表格都与shows表格和people表格相关，
This table, per the arrows, relates to the shows table and the people table,

2651
02:10:19,060 --> 02:10:20,770
因为这是一个联接表。
because this is a joined table.

2652
02:10:20,770 --> 02:10:24,040
show_id的外键和person_id的外键
A foreign key of show_id and a foreign key of person_id

2653
02:10:24,039 --> 02:10:28,249
分别参考表演表和人物表
refer to the shows table and the people table respectively

2654
02:10:28,250 --> 02:10:32,709
这样一个人可以成为多个节目的作家
so that a human person can be a writer for multiple shows

2655
02:10:32,710 --> 02:10:36,560
一个节目可以有多位作家，另一对多对多的关系。
and one show can have multiple writers, another many-to-many relationship.

2656
02:10:36,560 --> 02:10:39,310
最后是明星，一场演出中的演员。
And then lastly, stars, the actors in a show.

2657
02:10:39,310 --> 02:10:41,050
注意，这也是一个联接表。
Notice that this, too, is a join table.

2658
02:10:41,050 --> 02:10:43,540
它只有两个外键，即show_id
It's only got two foreign keys, a show_id

2659
02:10:43,539 --> 02:10:47,446
和一个person_id分别返回这些表。
and a person_id that are referring back to those tables respectively.

2660
02:10:47,447 --> 02:10:50,030
这正是关系数据库真正有意义的地方。
And here's where it really makes sense of relational database.

2661
02:10:50,029 --> 02:10:52,929
如果您这样做将是非常愚蠢和糟糕的设计
It would be pretty stupid and bad design if you

2662
02:10:52,930 --> 02:10:57,520
有所有董事的姓名和所有作家的姓名
had names of all of the directors and names of all of the writers

2663
02:10:57,520 --> 02:11:01,840
以及所有这些节目的所有星星的名称，分别放在一个表格中，一式两份，
and names of all of the stars of these shows in separate tables in duplicate,

2664
02:11:01,840 --> 02:11:04,330
像史蒂夫·卡雷尔（Steve Carell），史蒂夫·卡雷尔（Steve Carell），史蒂夫·卡雷尔（Steve Carell）。
like Steve Carell, Steve Carell, Steve Carell.

2665
02:11:04,329 --> 02:11:06,669
所有这些演员，导演和作家
All of those actors and directors and writers

2666
02:11:06,670 --> 02:11:11,450
而业务中的所有其他角色最终都是人。
and every other role in the business are just people at the end of the day.

2667
02:11:11,449 --> 02:11:13,629
因此，在关系数据库中，建议将
So in a relational database, the advice would

2668
02:11:13,630 --> 02:11:16,570
将所有这些人放在一个人桌中
be to put all of those people in a people table

2669
02:11:16,569 --> 02:11:21,039
然后使用主键和外键来引用它们，
and then use primary and foreign keys to refer to, to relate them to,

2670
02:11:21,039 --> 02:11:24,009
这些其他类型的表。
these other types of tables.

2671
02:11:24,010 --> 02:11:26,720
但是要注意的是，当我们这样做时，
The catch is, though, that when we do this,

2672
02:11:26,720 --> 02:11:31,280
事实证明，当我们拥有大量数据时，事情可能会变慢。
it turns out that things can be slow when we have lots of data.

2673
02:11:31,279 --> 02:11:33,249
因此，例如，让我谈谈这一点。
So for instance, let me go into this.

2674
02:11:33,250 --> 02:11:37,209
让我继续进行，SELECT * FROM显示；。
Let me go ahead and SELECT * FROM shows;.

2675
02:11:37,210 --> 02:11:38,343
大量的数据。
That's a lot of data.

2676
02:11:38,342 --> 02:11:41,259
在我的Mac上，速度非常快，我只是从IDE切换到了Mac
It's pretty fast on my Mac, and I switched from the IDE to my Mac just

2677
02:11:41,260 --> 02:11:43,270
节省时间，因为这样做的速度更快
to save time, because it's a little faster doing things

2678
02:11:43,270 --> 02:11:44,800
本地而不是云中。
locally instead of in the cloud.

2679
02:11:44,800 --> 02:11:48,460
让我继续计算这个IMDb数据库中的节目数量
Let me go ahead and count the number of shows in this IMDb database

2680
02:11:48,460 --> 02:11:49,720
通过使用COUNT。
by using COUNT.

2681
02:11:49,720 --> 02:11:53,390
153,331个电视节目。
153,331 TV shows.

2682
02:11:53,390 --> 02:11:54,250
所以很多。
So that's a lot.

2683
02:11:54,250 --> 02:11:59,110
人数表中的人数如何？
How about the count of people from the people table?

2684
02:11:59,109 --> 02:12:06,289
457,886人也可能是明星，作家或其他角色。
457,886 people who might be stars or writers or some other role, as well.

2685
02:12:06,289 --> 02:12:07,764
因此，这是一个相当大的数据集。
So this is a sizable data set.

2686
02:12:07,765 --> 02:12:09,890
因此，让我继续做一些简单的事情。
So let me go ahead and do something simple, though.

2687
02:12:09,890 --> 02:12:14,560
让我继续，SELECT * FROM显示WHERE title =“ The Office”。
Let me go ahead and SELECT * FROM shows WHERE title = "The Office."

2688
02:12:14,560 --> 02:12:17,900
这次，我不必担心大写字母或空格的怪异现象。
And this time, I don't have to worry about weird capitalization or spacing.

2689
02:12:17,899 --> 02:12:18,849
这是IMDb。
This is IMDb.

2690
02:12:18,850 --> 02:12:21,727
这是来自权威来源的干净数据。
This is clean data from an authoritative source.

2691
02:12:21,726 --> 02:12:24,309
请注意，实际上有不同版本的Office。
Notice that there's actually different versions of The Office.

2692
02:12:24,310 --> 02:12:26,590
您可能知道英国和美国。
You probably know the UK one and the US one.

2693
02:12:26,590 --> 02:12:30,520
还有其他与特定类型的节目无关的节目。
There's other shows that are unrelated to that particular type of show.

2694
02:12:30,520 --> 02:12:34,540
但是，请注意，此处的每个年份都与众不同。
But each of them is distinguished, notice, by the year here.

2695
02:12:34,539 --> 02:12:37,279
好吧，这很多。
All right, so that's kind of a lot.

2696
02:12:37,279 --> 02:12:38,679
让我们再做一次。
And let's do this again.

2697
02:12:38,680 --> 02:12:40,930
让我继续并暂时开启一项功能
Let me go ahead and turn on a feature temporarily just

2698
02:12:40,930 --> 02:12:44,000
通过打开该程序中的计时器来计时此查询。
to time this query by turning on a timer in this program.

2699
02:12:44,000 --> 02:12:45,370
让我再运行一次。
And let me run it again.

2700
02:12:45,369 --> 02:12:51,969
看起来该搜索需要花费0.012秒的实时时间。
It looks like it took 0.012 seconds of real time to do that search.

2701
02:12:51,970 --> 02:12:52,780
那太快了。
That's pretty fast.

2702
02:12:52,779 --> 02:12:55,179
我几乎没有注意到，当然是因为它是如此之快。
I barely noticed, certainly because it's so fast.

2703
02:12:55,180 --> 02:12:56,710
但是，让我继续执行此操作。
But let me go ahead and do this.

2704
02:12:56,710 --> 02:13:01,510
让我继续在表上创建一个名为title_index的索引
Let me go ahead and create an index called title_index on the table

2705
02:13:01,510 --> 02:13:04,360
在其标题栏上显示。
called shows on its title column.

2706
02:13:04,359 --> 02:13:05,469
好吧，我在做什么？
Well, what am I doing?

2707
02:13:05,470 --> 02:13:08,680
好吧，最后要回答以前关于性能的问题，
Well, to answer the question finally from before about performance,

2708
02:13:08,680 --> 02:13:11,340
默认情况下，我们一直在做的事情的确是n的大O。
by default, everything we've been doing is indeed big O of n.

2709
02:13:11,340 --> 02:13:13,090
只是从顶部开始线性搜索
It's just being linearly searched from top

2710
02:13:13,090 --> 02:13:16,630
归根到底，这似乎使人们怀疑SQL的全部用途
to bottom, which seems to call into question the whole purpose of SQL if we

2711
02:13:16,630 --> 02:13:18,850
并没有比使用CSV更好。
were doing no better than with CSVs.

2712
02:13:18,850 --> 02:13:22,480
但是索引是要加载数据库的线索
But an index is a clue to the database to load

2713
02:13:22,479 --> 02:13:25,959
以获取对数时间的方式更有效地处理数据。
the data more efficiently in such a way that you get logarithmic time.

2714
02:13:25,960 --> 02:13:30,520
索引是SQLite数据库或Oracle的一种奇特的数据结构
An index is a fancy data structure that the SQLite database or the Oracle

2715
02:13:30,520 --> 02:13:33,520
数据库或MySQL数据库，无论您使用什么产品，
database or the MySQL database, whatever product you're using,

2716
02:13:33,520 --> 02:13:35,680
在内存中为您积聚。
builds up for you in memory.

2717
02:13:35,680 --> 02:13:38,560
然后它使用这样的语法做一些事情
And then it does something using syntax like this

2718
02:13:38,560 --> 02:13:42,340
通常会在内存中建立B树。
that builds in memory generally something known as a B-tree.

2719
02:13:42,340 --> 02:13:44,178
我们在课堂上讨论了一些树木。
We've talked a bit about trees in the class.

2720
02:13:44,177 --> 02:13:46,719
我们谈到了二进制搜索树，
We talked about binary search trees, things that kind of look

2721
02:13:46,720 --> 02:13:47,920
像家谱。
like family trees.

2722
02:13:47,920 --> 02:13:50,620
B树本质上是一棵家谱，
A B-tree is essentially a family tree that's

2723
02:13:50,619 --> 02:13:53,019
只是非常宽而不那么高。
just very wide and not that tall.

2724
02:13:53,020 --> 02:13:56,500
这是一种数据结构，其实质与我们在C语言中所看到的类似。
It's a data structure similar in spirit to what we looked at in C.

2725
02:13:56,500 --> 02:13:59,830
但是它尝试保留所有叶节点，所有子节点
But it tries to keep all of the leaf nodes, all of the children

2726
02:13:59,829 --> 02:14:02,229
或者说孙子或曾孙子，可以这么说，
or grandchildren or great-grandchildren, so to speak,

2727
02:14:02,229 --> 02:14:04,389
尽可能靠近根。
as close to the root as possible.

2728
02:14:04,390 --> 02:14:08,320
而且它所使用的算法往往是专有的或有文件证明的
And the algorithm it uses for that tends to be proprietary or documented

2729
02:14:08,319 --> 02:14:09,969
根据您使用的系统。
based on the system you're using.

2730
02:14:09,970 --> 02:14:12,100
但是它不会将内容存储在列表中。
But it doesn't store things in a list.

2731
02:14:12,100 --> 02:14:17,620
它不会像我们将其视为表那样自上而下存储内容。
It does not store things top to bottom, like the tables we view them as.

2732
02:14:17,619 --> 02:14:21,639
在引擎盖下，那些桌子看起来像很高的结构
Underneath the hood, those tables that look like very tall structures

2733
02:14:21,640 --> 02:14:23,770
实际上是在引擎盖下
are actually, underneath the hood, implemented

2734
02:14:23,770 --> 02:14:25,820
与更奇特的东西称为树木。
with fancier things called trees.

2735
02:14:25,819 --> 02:14:29,709
如果我们通过创建适当的索引来创建这些树
And if we create those trees by creating what are properly called indexes

2736
02:14:29,710 --> 02:14:34,660
像这样，创建索引可能需要花费一些时间（如0.098秒）。
like this, it might take us a moment, like 0.098 seconds, to create an index.

2737
02:14:34,659 --> 02:14:36,219
但是现在请注意会发生什么。
But now notice what happens.

2738
02:14:36,220 --> 02:14:40,210
以前，当我使用线性搜索在The Office的标题中搜索时，
Previously, when I searched the titles for The Office, using linear search,

2739
02:14:40,210 --> 02:14:43,180
花了0.012秒。
it took 0.012 seconds.

2740
02:14:43,180 --> 02:14:46,750
如果创建索引后再次执行相同的查询
If I do the same query again after having created the index

2741
02:14:46,750 --> 02:14:50,919
并告诉SQLite，请在内存中为我建立这棵花哨的树，瞧。
and having told SQLite, build me this fancy tree in memory, voila.

2742
02:14:50,920 --> 02:14:55,450
0.001秒，因此快几个数量级。
0.001 seconds, so orders of magnitude faster.

2743
02:14:55,449 --> 02:14:57,549
现在，对我们人类而言，两者无疑是很快的。
Now, both are fast to us humans, certainly.

2744
02:14:57,550 --> 02:15:01,040
但是，想象一下数据集会更大，查询会更大。
But imagine the data set being even bigger, the query being even bigger.

2745
02:15:01,039 --> 02:15:05,899
这些索引甚至可以更大。
These indexes can get even larger than that.

2746
02:15:05,899 --> 02:15:07,969
相反，查询可能需要更长的时间
Rather, the queries can take longer than that

2747
02:15:07,970 --> 02:15:11,130
因此花费的时间甚至更多。
and therefore take even more time than that.

2748
02:15:11,130 --> 02:15:13,940
但是不幸的是，如果我到处都有我所有的数据，
But unfortunately, if I've got all of my data all over the place,

2749
02:15:13,939 --> 02:15:16,969
如上图所示，我的上帝。
as in a diagram like this, my god.

2750
02:15:16,970 --> 02:15:18,770
我实际上如何完成有用的工作？
How do I actually get useful work done?

2751
02:15:18,770 --> 02:15:21,590
我如何找回电影中的人和作家
How do I get back the people in a movie and the writers

2752
02:15:21,590 --> 02:15:24,260
还有星星和收视率（如果到处都是）？
and the stars and the ratings if it's all over the place?

2753
02:15:24,260 --> 02:15:26,840
我似乎已经造成了如此混乱，而我现在
I would seem to have created such a mess and that I now

2754
02:15:26,840 --> 02:15:28,910
需要执行所有这些查询。
need to execute all of these queries.

2755
02:15:28,909 --> 02:15:31,999
但是请注意，它不必那么复杂。
But notice it doesn't have to be that complicated.

2756
02:15:32,000 --> 02:15:35,660
事实证明，SQL中还有另一个关键字，实际上是最后一个
It turns out that there's another keyword in SQL, really the last

2757
02:15:35,659 --> 02:15:38,149
我们将在这里查看，称为JOIN。
that we'll look at here, called JOIN.

2758
02:15:38,149 --> 02:15:41,479
您可以隐式或显式使用JOIN关键字，
The JOIN keyword, which you can use implicitly or explicitly,

2759
02:15:41,479 --> 02:15:45,469
允许您将表连接在一起并进行重构
allows you to just join tables together and sort of reconstitute

2760
02:15:45,470 --> 02:15:47,760
更大，更人性化的表格。
a bigger, more user friendly table.

2761
02:15:47,760 --> 02:15:51,020
例如，假设我想获得史蒂夫·卡雷尔（Steve Carell）的所有电视节目，
So for instance, suppose I want to get all of Steve Carell's TV shows,

2762
02:15:51,020 --> 02:15:52,250
不只是办公室。
not just The Office.

2763
02:15:52,250 --> 02:15:55,879
好吧，回想一下，我可以从人们那里选择史蒂夫的身分证
Well, recall that I can select Steve's ID from the people

2764
02:15:55,880 --> 02:15:59,390
表格WHERE名称=“史蒂夫·卡雷尔”。
table WHERE name = "Steve Carell."

2765
02:15:59,390 --> 02:16:02,780
同样，他在此表中具有不同的ID，因为它来自IMDb。
So again, he has a different ID in this table, because this is from IMDb.

2766
02:16:02,779 --> 02:16:04,399
但是有他的身份证。
But there's his ID.

2767
02:16:04,399 --> 02:16:07,259
现在让我关闭计时器。
And let me go ahead and turn the timer off for now.

2768
02:16:07,260 --> 02:16:07,760
好的。
All right.

2769
02:16:07,760 --> 02:16:11,510
因此，他的ID为126797。
So there is his ID, 126797.

2770
02:16:11,510 --> 02:16:14,780
我可以将其复制粘贴到我的代码中，但这不是必需的
I could copy paste that into my code, but that's not necessary

2771
02:16:14,779 --> 02:16:16,489
多亏了这些嵌套查询。
thanks to these nested queries.

2772
02:16:16,489 --> 02:16:18,659
我可以做这样的事情。
I can do something like this.

2773
02:16:18,659 --> 02:16:23,719
让我继续，现在从stars表中选择所有show_id
Let me go ahead and now select all of the show_ids from the stars table

2774
02:16:23,720 --> 02:16:29,790
该表中的person_id等于此结果。
where person_id from that table is equal to this result.

2775
02:16:29,789 --> 02:16:33,239
因此，有连接表，星号，将人与节目联系起来的功能。
So there's that join table, stars, that links people and shows.

2776
02:16:33,239 --> 02:16:35,369
因此，让我继续执行该操作。
So let me go ahead and execute that.

2777
02:16:35,370 --> 02:16:35,870
好的。
All right.

2778
02:16:35,870 --> 02:16:39,559
因此，有史蒂夫·卡雷尔（Steve Carell）的电视节目的所有show_id。
So there's all of the show_ids of Steve Carell's TV shows.

2779
02:16:39,558 --> 02:16:40,378
好多啊。
That's a lot.

2780
02:16:40,379 --> 02:16:42,139
它们是什么，这不是很明显。
And it's very nonobvious what they are.

2781
02:16:42,138 --> 02:16:45,679
因此，让我通过将所有这些都放在括号中来进行另一个嵌套查询
So let me do another nested query by putting all of that in parentheses

2782
02:16:45,680 --> 02:16:51,530
现在，SELECT标题FROM节目在哪里节目的ID
and now SELECT title FROM shows WHERE the ID of the show

2783
02:16:51,530 --> 02:16:55,820
在这个很长的show_ids列表中。
is in this big, long list of show_ids.

2784
02:16:55,819 --> 02:17:00,259
还有他参加的所有表演，包括The Dana Carvey Show
And there are all of the shows that he's in, including The Dana Carvey Show

2785
02:17:00,260 --> 02:17:04,430
回来的时候，办公室在顶部，然后，最近一次，
back when, The Office up at the top, and then, most recently,

2786
02:17:04,430 --> 02:17:07,142
像Apple TV上的The Morning Show这样的节目。
shows like The Morning Show on Apple TV.

2787
02:17:07,141 --> 02:17:09,349
好吧，这很酷，我们实际上可以
All right, so that's pretty cool that we can actually

2788
02:17:09,350 --> 02:17:11,129
像这样重构数据。
reconstitute the data like that.

2789
02:17:11,129 --> 02:17:13,889
但是事实证明，还有不同的方法可以做到这一点。
But it turns out there's different ways of doing that, as well.

2790
02:17:13,888 --> 02:17:15,949
在接下来的几周中，您将会看到更多
And you'll see more of this in the coming weeks

2791
02:17:15,950 --> 02:17:18,150
以及习题集和实验室等。
and in the problem sets and labs and the like.

2792
02:17:18,149 --> 02:17:19,878
但事实证明，我们也可以做其他事情。
But it turns out we can do other things, as well.

2793
02:17:19,879 --> 02:17:21,962
而且，即使它会
And let me just show this syntax even though it'll

2794
02:17:21,961 --> 02:17:23,669
乍一看有点神秘。
look a little cryptic at first glance.

2795
02:17:23,670 --> 02:17:26,299
您还可以按如下方式使用该JOIN关键字。
You can also use that JOIN keyword as follows.

2796
02:17:26,299 --> 02:17:33,350
我可以从与星星表连接的人员表中选择标题
I can select the title from the people table joined with the stars table

2797
02:17:33,350 --> 02:17:39,959
在people.id列上，等于stars.person_id列。
on the people.id column equaling the stars.person_id column.

2798
02:17:39,959 --> 02:17:42,799
换句话说，我可以从结果中选择一个标题
So in other words, I can select a title from the result

2799
02:17:42,799 --> 02:17:46,940
像这样在一个id列中加入人物和明星的故事
of joining people and stars, like this, on the id column in one

2800
02:17:46,940 --> 02:17:49,129
另一个是person_id列。
and the person_id column in the other.

2801
02:17:49,129 --> 02:17:58,879
我可以加入stars.show_id上与shows.id相等的shows表。
And I can join in the shows table on the stars.show_id equaling the shows.id.

2802
02:17:58,879 --> 02:18:03,799
再一次，现在我要在这两个表上连接主键和外键
So again, now I'm joining the primary and foreign keys on these two tables

2803
02:18:03,799 --> 02:18:07,700
该名称等于“史蒂夫·卡雷尔”。
where the name equals "Steve Carell."

2804
02:18:07,700 --> 02:18:10,070
因此，这是我们迄今为止所看到的最神秘的东西。
So this is the most cryptic thing we've seen yet.

2805
02:18:10,069 --> 02:18:12,529
但这只是意味着拿起这张桌子并将其与这张桌子连在一起
But it just means take this table and join it with this one

2806
02:18:12,530 --> 02:18:16,580
然后将其与此连接并过滤所有结果连接的行
and then join it with this one and filter all of the resulting joined rows

2807
02:18:16,579 --> 02:18:18,529
以史蒂夫·卡雷尔（Steve Carell）的名字命名。
by a name of Steve Carell.

2808
02:18:18,530 --> 02:18:19,520
和瞧。
And voila.

2809
02:18:19,520 --> 02:18:22,469
在那里，我们也有所有这些答案。
There we have all of those answers, as well.

2810
02:18:22,468 --> 02:18:25,128
还有其他方法可以做到这一点。
And there's other ways of doing this, too.

2811
02:18:25,129 --> 02:18:27,809
现在，我不再赘述某些语法。
I'll leave unsaid now some of the syntax for that.

2812
02:18:27,808 --> 02:18:29,479
但这感觉有点慢。
But that felt a little slow.

2813
02:18:29,479 --> 02:18:32,089
实际上，让我继续并重新打开计时器。
And in fact, let me go ahead and turn my timer back on.

2814
02:18:32,090 --> 02:18:34,610
让我重新执行最后一个查询。
Let me re-execute this last query.

2815
02:18:34,610 --> 02:18:40,879
从参加明星，参加演出的人中选择标题
SELECT title FROM people joining on stars, joining on shows

2816
02:18:40,879 --> 02:18:42,650
WHERE名称=“史蒂夫·卡雷尔”。
WHERE name = "Steve Carell."

2817
02:18:42,649 --> 02:18:44,699
那花了半秒钟。
That took over half a second.

2818
02:18:44,700 --> 02:18:47,480
因此，实际上这确实有点慢。
So that was actually admittedly kind of slow.

2819
02:18:47,479 --> 02:18:50,208
但是同样，索引可以解救我们，如果再一次，我们
But again, indexes come to the rescue and if, again, we

2820
02:18:50,209 --> 02:18:52,610
不允许线性搜索占主导地位。
don't allow linear search to dominate.

2821
02:18:52,610 --> 02:18:54,889
但是，让我继续创建一些索引。
But let me go ahead and create a few indexes.

2822
02:18:54,888 --> 02:19:01,939
在stars表中的person_id列上创建一个名为person_index的索引。
Create an index called person_index on the stars table, the person_id column.

2823
02:19:01,940 --> 02:19:02,570
为什么？
Why?

2824
02:19:02,569 --> 02:19:05,599
好吧，我刚才的查询使用了person_id列。
Well, my query a moment ago used the person_id column.

2825
02:19:05,600 --> 02:19:06,510
它过滤了。
It filtered on it.

2826
02:19:06,510 --> 02:19:08,000
因此，这可能是一个瓶颈。
So that might be a bottleneck.

2827
02:19:08,000 --> 02:19:12,290
我将继续创建另一个名为show_index的索引
I'm going to go ahead and create another index called show_index

2828
02:19:12,290 --> 02:19:14,870
在show_id的星表上。
on the stars table on show_id.

2829
02:19:14,870 --> 02:19:18,290
同样，不久前，我的查询使用了show_id列。
Similarly, a moment ago, my query used the show_id column.

2830
02:19:18,290 --> 02:19:21,743
因此，从上到下线性地也可能是瓶颈。
And so that, too, might have been a bottleneck linearly, top to bottom.

2831
02:19:21,743 --> 02:19:22,910
因此，让我创建该索引。
So let me create that index.

2832
02:19:22,909 --> 02:19:25,367
最后，让我创建一个名为name_index的索引-
And then lastly, let me create an index called name_index--

2833
02:19:25,368 --> 02:19:28,459
这也许是最明显的，类似于之前的节目标题-
and this is perhaps the most obvious, similar to the show titles before--

2834
02:19:28,459 --> 02:19:31,549
在名称列的人员表上。
on the people table on the name column.

2835
02:19:31,549 --> 02:19:32,930
那也花了一点时间。
And that, too, took a moment.

2836
02:19:32,930 --> 02:19:35,330
现在，总共花了将近一整秒。
Now, in total, this took almost a full second.

2837
02:19:35,329 --> 02:19:37,849
但是这些索引仅创建一次。
But these indexes only get created once.

2838
02:19:37,850 --> 02:19:40,070
随着时间的推移，它们会自动得到维护。
They get maintained automatically over time.

2839
02:19:40,069 --> 02:19:42,079
但是，您不会在每个查询中都遇到这种情况。
But you don't incur this with every query.

2840
02:19:42,079 --> 02:19:44,388
现在，让我再次进行选择。
Now let me do my SELECT again.

2841
02:19:44,388 --> 02:19:48,799
让我从加入星表的人中选择标题，
Let me SELECT title FROM people joining the stars table,

2842
02:19:48,799 --> 02:19:52,729
加入显示表WHERE name =“ Steve Carell”。
joining the shows table WHERE name = "Steve Carell."

2843
02:19:52,729 --> 02:19:53,689
繁荣。
Boom.

2844
02:19:53,690 --> 02:19:56,630
0.001秒
0.001 seconds.

2845
02:19:56,629 --> 02:20:00,929
这比半秒多一点的速度快一个数量级
That was an order of magnitude faster than the more than half a second

2846
02:20:00,930 --> 02:20:02,620
我们花了一点时间。
it took us a little bit ago.

2847
02:20:02,620 --> 02:20:05,860
因此，在这里，您还将看到关系数据库的强大功能。
So here, too, you see the power of a relational database.

2848
02:20:05,860 --> 02:20:08,912
因此，即使我们随着时间的推移为自己制造了一些问题，
So even though we've created some problems for ourselves over time,

2849
02:20:08,912 --> 02:20:12,120
我们最终解决了这些问题-当然，还提供了一些更高级的功能
we've solved them ultimately-- granted, with some more sophisticated features

2850
02:20:12,120 --> 02:20:13,320
以及其他语法。
and additional syntax.

2851
02:20:13,319 --> 02:20:15,989
但是关系数据库的确是您使用它们的原因
But a relational database is indeed why you use them

2852
02:20:15,989 --> 02:20:19,469
在现实世界中，例如Twitter，Instagram，Facebook，Google，
in the real world for the Twitters, the Instagrams, the Facebooks, the Googles,

2853
02:20:19,469 --> 02:20:22,589
因为他们可以如此高效地存储数据
because they can store data so efficiently

2854
02:20:22,590 --> 02:20:25,960
没有冗余，因为您可以将它们归一化并考虑所有因素
without redundancy, because you can normalize them and factor everything

2855
02:20:25,959 --> 02:20:26,459
出去。
out.

2856
02:20:26,459 --> 02:20:28,739
但是他们仍然可以维持关系
But they can still maintain the relations

2857
02:20:28,739 --> 02:20:30,569
您可能已经在电子表格中看到的
that you might have seen in a spreadsheet

2858
02:20:30,569 --> 02:20:32,939
但使用接近对数的感谢
but using something closer to logarithmic thanks

2859
02:20:32,940 --> 02:20:34,770
那些树的结构。
to those tree structures.

2860
02:20:34,770 --> 02:20:35,910
但是有问题。
But there are problems.

2861
02:20:35,909 --> 02:20:38,879
而我们想要做的就是在今天结束两个主要问题
And what we wanted to do is end on today two primary problems

2862
02:20:38,879 --> 02:20:42,569
SQL引入的那些，因为不幸的是它们
that are introduced with SQL, because they are just unfortunately

2863
02:20:42,569 --> 02:20:43,919
所以通常做。
so commonly done.

2864
02:20:43,920 --> 02:20:45,462
今年注意。
Notice this year.

2865
02:20:45,461 --> 02:20:47,669
有一种通常称为SQL注入的东西
There is something generally known as a SQL injection

2866
02:20:47,670 --> 02:20:51,330
攻击，您在任何应用程序中都容易受到攻击
attack, which you are vulnerable to in any application

2867
02:20:51,329 --> 02:20:52,829
用户输入的地方。
where you're taking user input.

2868
02:20:52,829 --> 02:20:55,799
对于我的收藏夹.py文件而言，这不是问题，
That hasn't been an issue for my favorites.py file,

2869
02:20:55,799 --> 02:20:58,259
我只从CSV输入信息。
where I only took input from a CSV.

2870
02:20:58,260 --> 02:21:00,510
但是如果你们中的一个人是恶意的，如果你们中的一个人怎么办
But if one of you were malicious, what if one of you

2871
02:21:00,510 --> 02:21:03,750
恶意输入了“删除”或“更新”一词
had maliciously typed in the word "delete" or "update"

2872
02:21:03,750 --> 02:21:06,180
或其他节目的标题
or something else as the title of your show

2873
02:21:06,180 --> 02:21:11,040
并在执行查询时不小心将其插入我自己的Python代码中？
and I accidentally plugged it into my own Python code when executing a query?

2874
02:21:11,040 --> 02:21:14,940
您可以将SQL注入我自己的代码中。
You could potentially inject SQL into my own code.

2875
02:21:14,940 --> 02:21:15,750
怎么可能
How might that be?

2876
02:21:15,750 --> 02:21:18,959
好吧，如果通过耶鲁登录，通常会看到类似这样的表格。
Well, if logging in via Yale, you'll typically see a form like this.

2877
02:21:18,959 --> 02:21:21,849
或通过哈佛登录某些内容，您将看到类似这样的表格。
Or logging in via Harvard to something, you'll see a form like this.

2878
02:21:21,850 --> 02:21:23,767
这是一个我很确定都没有的例子
Here's an example that I'm pretty sure neither

2879
02:21:23,766 --> 02:21:25,709
哈佛大学和耶鲁大学都容易受到影响。
Harvard nor Yale are vulnerable to.

2880
02:21:25,709 --> 02:21:28,589
假设我在此登录表单中输入电子邮件地址
Suppose I type in my email address to this login form

2881
02:21:28,590 --> 02:21:32,350
作为malan@harvard.edu&#39;--。
as malan@harvard.edu'--.

2882
02:21:32,350 --> 02:21:34,890
事实证明，在SQL中，-
It turns out, in SQL, --

2883
02:21:34,889 --> 02:21:38,249
是要注释的符号。
is the symbol for commenting if you want to comment something out.

2884
02:21:38,250 --> 02:21:40,427
原来使用了单引号
It turns out that the single quote is used

2885
02:21:40,427 --> 02:21:43,469
当您想要搜索史蒂夫·卡雷尔（Steve Carell）之类的东西时（在这种情况下，
when you want to search for something like Steve Carell or, in this case,

2886
02:21:43,469 --> 02:21:44,929
malan@harvard.edu。
malan@harvard.edu.

2887
02:21:44,930 --> 02:21:45,930
它可以是双引号。
It can be double quotes.

2888
02:21:45,930 --> 02:21:47,040
它可以是单引号。
It can be single quotes.

2889
02:21:47,040 --> 02:21:50,040
在这种情况下，我在这里使用单引号。
In this case, I'm using single quotes here.

2890
02:21:50,040 --> 02:21:53,400
但是，如果可以的话，让我们考虑一些使用Python的示例代码。
But let's consider some sample code, if you will, in Python.

2891
02:21:53,399 --> 02:21:56,909
这是我建议的后端可能存在的一行代码
Here's a line of code that I propose might exist in the backend

2892
02:21:56,909 --> 02:22:00,179
用于哈佛或耶鲁大学或其他任何人的认证。
for Harvard's authentication or Yale's or anyone else's.

2893
02:22:00,180 --> 02:22:04,890
也许有人使用SELECT * FROM用户编写了这样的Python代码
Maybe someone wrote some Python code like this using SELECT * FROM users

2894
02:22:04,889 --> 02:22:06,869
用户名在哪里=问题？
WHERE username = question?

2895
02:22:06,870 --> 02:22:10,770
AND密码=问题？，他们插入了用户名和密码。
AND password = question?, and they plugged in username and password.

2896
02:22:10,770 --> 02:22:13,770
无论用户何时输入该Web表单，都会得到
Whatever the user typed into that web form a moment ago gets

2897
02:22:13,770 --> 02:22:16,270
在此处插入这些问号。
plugged in here to these question marks.

2898
02:22:16,270 --> 02:22:17,290
很好
This is good.

2899
02:22:17,290 --> 02:22:20,980
这是很好的代码，因为您正在使用SQL问号。
This is good code, because you're using the SQL question marks.

2900
02:22:20,979 --> 02:22:24,314
所以，如果您从字面上做我们今天宣讲的事情，并使用这些问题
So if you literally just do what we preach today and use these question

2901
02:22:24,315 --> 02:22:27,870
标记占位符，您就可以免受SQL注入攻击。
mark placeholders, you are safe from SQL injection attacks.

2902
02:22:27,870 --> 02:22:29,760
不幸的是，有太多的开发人员
Unfortunately, there are too many developers

2903
02:22:29,760 --> 02:22:34,950
在世界上没有实践或没有意识到这一点，或者忘记了这一点。
in the world that don't practice this or don't realize this or do forget this.

2904
02:22:34,950 --> 02:22:38,850
如果您改用这样的Python方法，
If you instead resort to Python approaches like this,

2905
02:22:38,850 --> 02:22:42,910
您改用F弦，这可能是您本能的本能
where you use an f-string instead, which might be your instincts after last

2906
02:22:42,909 --> 02:22:45,659
一周，因为使用花括号非常方便
week, because they're wonderfully convenient with the curly braces

2907
02:22:45,659 --> 02:22:46,289
和所有 -
and all--

2908
02:22:46,290 --> 02:22:50,370
假设您确实插入了用户名和密码
suppose that you literally plug in username and password

2909
02:22:50,370 --> 02:22:53,430
不带问号占位符，而是按字面意思
not with the question mark placeholders but just literally

2910
02:22:53,430 --> 02:22:55,260
在那些花括号之间。
in between those curly braces.

2911
02:22:55,260 --> 02:22:58,210
观察如果我的用户名malan@harvard.edu，会发生什么情况，
Watch what happens if my username, malan@harvard.edu,

2912
02:22:58,209 --> 02:23:03,119
实际上是被我恶意输入为malan@harvard.edu&#39;--。
was actually typed in by me maliciously as malan@harvard.edu'--.

2913
02:23:05,691 --> 02:23:09,030
那会欺骗这个Python
That would have the effect of tricking this Python

2914
02:23:09,030 --> 02:23:11,610
代码基本上可以做到这一点。
code into doing essentially this.

2915
02:23:11,610 --> 02:23:13,590
让我查找并替换。
Let me do a find and replace.

2916
02:23:13,590 --> 02:23:22,881
它将欺骗Python执行用户名=“ malan@harvard.edu”-“
It would trick Python into executing username = "malan@harvard.edu"--"

2917
02:23:22,880 --> 02:23:24,659
然后是其他东西。
and then other stuff.

2918
02:23:24,659 --> 02:23:27,479
不幸的是，-再次表示评论，
Unfortunately, the -- again means comment,

2919
02:23:27,479 --> 02:23:33,389
这意味着您可能会诱骗服务器忽略整个密码
which means you could maybe trick a server into ignoring the whole password

2920
02:23:33,389 --> 02:23:35,189
此SQL查询的一部分。
part of this SQL query.

2921
02:23:35,190 --> 02:23:37,530
如果SQL查询的目的是检查，
And if the SQL query's purpose in life is to check,

2922
02:23:37,530 --> 02:23:42,210
该用户名和密码是否有效，以便您可以决定将用户登录
is this username and password valid, so that you can decide to log the user in

2923
02:23:42,209 --> 02:23:44,879
或者说，不，你没有被授权，好吧，
or to say, no, you're not authorized, well,

2924
02:23:44,879 --> 02:23:48,389
通过实质上注释掉与密码有关的所有内容，
by essentially commenting out everything related to password,

2925
02:23:48,389 --> 02:23:49,709
注意我做了什么。
notice what I've done.

2926
02:23:49,709 --> 02:23:55,619
从理论上讲，我现在以malan@harvard.edu登录，而没有
I've just now theoretically logged myself in as malan@harvard.edu without

2927
02:23:55,620 --> 02:24:00,030
甚至知道或输入密码，因为我注入了SQL语法，
even knowing or inputting a password, because I injected SQL syntax,

2928
02:24:00,030 --> 02:24:04,620
引号和-，进入我的查询，欺骗服务器，只是忽略了
the quote and the --, into my query, tricking the server into just ignoring

2929
02:24:04,620 --> 02:24:06,870
密码相等性检查。
the password equality check.

2930
02:24:06,870 --> 02:24:11,250
因此，当执行INSERT时，db.execute成为事实，
And so it turns out that db.execute, when you execute an INSERT,

2931
02:24:11,250 --> 02:24:15,240
它会像新插入的行的ID一样返回给您。
it returns to you as said the ID of the newly inserted row.

2932
02:24:15,239 --> 02:24:20,369
当您使用db.execute从数据库表中选择行时，
When you use db.execute to select rows from a database table,

2933
02:24:20,370 --> 02:24:25,360
它会向您返回一个行列表，每行都是一个字典。
it returns to you a list of rows, each of which is a dictionary.

2934
02:24:25,360 --> 02:24:28,110
所以现在这是伪代码，下面是我的评论。
So this is now pseudocode down here with my comment.

2935
02:24:28,110 --> 02:24:31,140
但是，如果您返回一行，这似乎
But if you get back one row, that would seem

2936
02:24:31,139 --> 02:24:34,469
暗示有一个名为malan@harvard.edu的用户。
to imply that there is a user named malan@harvard.edu.

2937
02:24:34,469 --> 02:24:37,829
不知道他的密码是什么，因为这个人是恶意的
Don't know what his password is, because whoever this person is maliciously

2938
02:24:37,829 --> 02:24:40,859
诱骗服务器忽略该语法。
tricked the server into ignoring that syntax.

2939
02:24:40,860 --> 02:24:43,890
因此，不幸的是，SQL注入攻击
So SQL injection attacks are unfortunately

2940
02:24:43,889 --> 02:24:46,569
对SQL数据库的最常见攻击之一。
one of the most common attacks against SQL databases.

2941
02:24:46,569 --> 02:24:51,089
如果您仅使用占位符并使用，则完全可以避免它们
They are completely preventable if you simply use placeholders and use

2942
02:24:51,090 --> 02:24:53,940
库，无论是CS50还是其他第三方库
libraries, whether it's CS50's or other third-party libraries

2943
02:24:53,940 --> 02:24:55,440
以便您将来使用。
that you may use down the road.

2944
02:24:55,440 --> 02:24:58,530
这张图片是互联网上常见的模因。
A common meme on the internet is this picture here.

2945
02:24:58,530 --> 02:25:00,810
如果我们放大此人的车牌
If we Zoom in on this person's license plate

2946
02:25:00,809 --> 02:25:02,969
或车牌应在的位置
or where the license plate should be, this

2947
02:25:02,969 --> 02:25:05,939
是一个理论上尝试的人的例子
is an example of someone theoretically trying

2948
02:25:05,940 --> 02:25:10,350
欺骗高速公路上的一些摄像头来丢弃整个数据库。
to trick some camera on the highway into dropping the whole database.

2949
02:25:10,350 --> 02:25:13,710
DROP是SQL中的另一个关键字，它删除数据库表。
DROP is another keyword in SQL that deletes a database table.

2950
02:25:13,709 --> 02:25:15,809
这个人要么是有意的，要么是
And this person was either intentionally or just

2951
02:25:15,809 --> 02:25:19,979
幽默地试图诱使它执行SQL
a humorously trying to trick it into executing SQL

2952
02:25:19,979 --> 02:25:21,759
通过使用这样的语法。
by using syntax like this.

2953
02:25:21,760 --> 02:25:26,070
因此，单引号，-，分号之类的字符都可能
So characters like single quotes, --, semicolons are all potentially

2954
02:25:26,069 --> 02:25:29,189
SQL中的危险字符（如果未更改的话）
dangerous characters in SQL if they're passed through unchanged

2955
02:25:29,190 --> 02:25:30,120
到数据库。
to the database.

2956
02:25:30,120 --> 02:25:34,140
一部非常受欢迎的xkcd漫画-我给您一点时间来阅读它-
A very popular xkcd comic-- let me give you a moment to just read this--

2957
02:25:34,139 --> 02:25:40,079
是计算机科学中另一个众所周知的模因。
is another well-known meme of sorts now in computer science.

2958
02:25:40,079 --> 02:25:43,879
如果您愿意，请自己阅读。
If you'd like to, read this one on your own.

2959
02:25:43,879 --> 02:25:51,169
但是从今以后，您现在处于受过教育的学习者的家庭中，他们
But henceforth, you are now in the family of educated learners who

2960
02:25:51,170 --> 02:25:54,410
知道小鲍比桌子是谁。
know who Little Bobby Tables is.

2961
02:25:54,409 --> 02:25:56,239
不幸的是，这里一片死寂，
Unfortunately, it's dead silence in here,

2962
02:25:56,239 --> 02:25:58,339
所以我不知道是否有人真的在笑这个笑话。
so I can't tell if anyone is actually laughing at this joke.

2963
02:25:58,340 --> 02:26:00,110
但是无论如何，这是一个非常著名的模因。
But anyhow, this is a very well-known meme.

2964
02:26:00,110 --> 02:26:02,690
因此，如果您是一位了解SQL的计算机科学家，那么您就会知道这一点。
So if you're a computer scientist who knows SQL, you know this one.

2965
02:26:02,690 --> 02:26:05,565
如果您不介意的话，我们还有最后一个问题要介绍
And there's one last problem we'd like to introduce if you don't mind

2966
02:26:05,565 --> 02:26:07,250
这里只有几个最后的时刻。
just a couple of final moments here.

2967
02:26:07,250 --> 02:26:09,529
这是计算中的一个基本问题
And that is a fundamental problem in computing

2968
02:26:09,530 --> 02:26:11,690
称为比赛条件，这是第一次
called race conditions, which for the first time

2969
02:26:11,690 --> 02:26:14,300
现在在我们对SQL的讨论中很明显。
is now manifest in our discussion of SQL.

2970
02:26:14,299 --> 02:26:18,229
事实证明，再次经常使用SQL和SQL数据库，
It turns out that SQL and SQL databases are very often used, again,

2971
02:26:18,229 --> 02:26:21,379
在现实世界中用于非常高性能的应用程序。
in the real world for very high-performing applications.

2972
02:26:21,379 --> 02:26:24,319
再者，我的意思是Google，Facebook，Twitter
And by that, I mean, again, the Googles, the Facebooks, the Twitters

2973
02:26:24,319 --> 02:26:28,489
在世界上，大量数据一次全部流入服务器。
of the world where lots and lots of data is coming into servers all at once.

2974
02:26:28,489 --> 02:26:30,199
举例来说，你们中的一些人可能有
And case in point, some of you might have

2975
02:26:30,200 --> 02:26:33,320
不久前在此蛋上单击了“赞”。
clicked Like on this egg some time ago.

2976
02:26:33,319 --> 02:26:35,689
这是有史以来最受欢迎的Instagram帖子。
This is the most-liked Instagram post ever.

2977
02:26:35,690 --> 02:26:39,710
截至昨晚，已达到50亿以上的点赞数。
As of last night, it was up to 50-plus million likes.

2978
02:26:39,709 --> 02:26:42,619
远远超过了金·卡戴珊（Kim Kardashian）的以前的帖子，
Well eclipsed Kim Kardashian's previous post,

2979
02:26:42,620 --> 02:26:44,690
仍在1800万左右。
which is still at 18 million or so.

2980
02:26:44,690 --> 02:26:47,780
也就是说这是一个很难解决的问题，
This is to say this is a hard problem to solve,

2981
02:26:47,780 --> 02:26:51,800
喜欢的概念以惊人的速度出现。
this notion of likes coming in at such an incredible rate.

2982
02:26:51,799 --> 02:26:55,309
因为假设，长话短说，Instagram实际上
Because suppose that, long story short, Instagram actually

2983
02:26:55,309 --> 02:26:57,289
有一个带有SQL数据库的服务器。
has a server with a SQL database.

2984
02:26:57,290 --> 02:27:01,490
他们拥有使用Python或C ++或任何正在谈论的语言的代码
And they have code in Python or C++ or whatever language that's talking

2985
02:27:01,489 --> 02:27:02,659
到该数据库。
to that database.

2986
02:27:02,659 --> 02:27:04,909
并假设他们有正在尝试的代码
And suppose that they have code that's trying

2987
02:27:04,909 --> 02:27:06,679
增加喜欢的总数。
to increment the total number of likes.

2988
02:27:06,680 --> 02:27:08,240
好吧，这在逻辑上如何运作？
Well, how might this work logically?

2989
02:27:08,239 --> 02:27:11,659
好吧，为了增加喜欢这张鸡蛋的照片的喜欢次数
Well, in order to increment the number of likes that a picture like this egg

2990
02:27:11,659 --> 02:27:14,059
有，您可能首先要从数据库中选择
has, you might first select from the database

2991
02:27:14,059 --> 02:27:18,259
该蛋照片ID的当前点赞次数。
the current number of likes for the ID of that egg photograph.

2992
02:27:18,260 --> 02:27:19,790
然后，您可以将其加1。
Then you might add 1 to it.

2993
02:27:19,790 --> 02:27:21,797
然后，您可以更新数据库。
Then you might update the database.

2994
02:27:21,797 --> 02:27:24,630
而且我以前没有使用过，但是就像有INSERT和DELETE一样，
And I didn't use it before, but just like there's INSERT and DELETE,

2995
02:27:24,629 --> 02:27:26,009
还有更新。
there's UPDATE, as well.

2996
02:27:26,010 --> 02:27:29,600
因此，您可以使用新的计数加1来更新数据库。
So you might update the database with the new count plus 1.

2997
02:27:29,600 --> 02:27:31,970
因此，该代码可能看起来有点
So the code for that might look a little something

2998
02:27:31,969 --> 02:27:35,599
这样，使用CS50的库的三行代码，
like this, three lines of code using CS50's library here,

2999
02:27:35,600 --> 02:27:40,010
您在其中执行SELECT喜欢的帖子，其中ID =问题吗？，
where you execute SELECT likes FROM posts WHERE id = question?,

3000
02:27:40,010 --> 02:27:42,890
其中id是该鸡蛋的唯一标识符。
where id is the unique identifier for that egg.

3001
02:27:42,889 --> 02:27:45,739
然后将结果存储在一个row变量中，
And then I'm storing the result in a rows variable,

3002
02:27:45,739 --> 02:27:48,949
我再次声明是行列表。
which, again, I claim is a list of rows.

3003
02:27:48,950 --> 02:27:52,130
我将进入第一行，所以这是行括号0。
I'm going to go into the first row, so that's rows bracket 0.

3004
02:27:52,129 --> 02:27:55,069
我将进入“喜欢”列以获取实际号码。
And I'm going to go into the likes column to get the actual number.

3005
02:27:55,069 --> 02:27:57,139
这个数字，我将存储在一个名为likes的变量中。
And that number, I'm going to store in a variable called likes.

3006
02:27:57,139 --> 02:27:58,879
因此，这将是50,000,000
So this is going to be, like, 50,000,000,

3007
02:27:58,879 --> 02:28:01,099
我希望它能达到50,000,001。
and I want it to go to 50,000,001.

3008
02:28:01,100 --> 02:28:02,370
那我该怎么做呢？
So how do I do that?

3009
02:28:02,370 --> 02:28:08,780
好吧，我在数据库上执行UPDATE帖子SET likes =？。
Well, I execute on the database UPDATE posts SET likes = ?.

3010
02:28:08,780 --> 02:28:10,980
然后我就插入点赞+ 1。
And then I just plug in likes + 1.

3011
02:28:10,979 --> 02:28:15,019
但是，问题在于世界上的Instagram，Google和Twitter
The problem, though, with the Instagrams and Googles and Twitters of the world

3012
02:28:15,020 --> 02:28:16,790
他们不仅只有一台服务器。
is that they don't just have one server.

3013
02:28:16,790 --> 02:28:18,710
他们有成千上万的服务器。
They have many thousands of servers.

3014
02:28:18,709 --> 02:28:22,579
所有这些服务器可能同时收到您的点击
And all of those servers might in parallel be receiving clicks from you

3015
02:28:22,579 --> 02:28:23,959
和我在互联网上。
and I on the internet.

3016
02:28:23,959 --> 02:28:28,309
这些点击会转化为执行，执行，
And those clicks translate into this code getting executed, executed,

3017
02:28:28,309 --> 02:28:28,969
被执行。
executed.

3018
02:28:28,969 --> 02:28:32,929
问题是当您有三行代码并假设Brian
And the problem is that when you have three lines of code and suppose Brian

3019
02:28:32,930 --> 02:28:35,420
然后我几乎同时点击了那个鸡蛋，
and I click on that egg at roughly the same time,

3020
02:28:35,420 --> 02:28:40,010
我的三行可能不会在他的三行之前执行，反之亦然。
my three lines might not get executed before his three lines or vice versa.

3021
02:28:40,010 --> 02:28:42,650
他们可能会按时间顺序混合在一起。
They might get commingled chronologically.

3022
02:28:42,649 --> 02:28:46,129
我的第一行可能会执行，然后Brian的第一行可能会执行。
My first line might get executed, then Brian's first line might get executed.

3023
02:28:46,129 --> 02:28:48,749
我的第二行可能会执行，Brian的第二行。
My second line might get executed, Brian's second line.

3024
02:28:48,750 --> 02:28:50,959
因此它们可能散布在不同的服务器上
So they might get interspersed on different servers

3025
02:28:50,959 --> 02:28:53,899
或只是时间上的时间顺序，时间上的时间顺序。
or just temporally in time, chronologically.

3026
02:28:53,899 --> 02:28:56,689
那是有问题的，因为假设我和布莱恩（Brian）单击
That's problematic, because suppose Brian and I click

3027
02:28:56,690 --> 02:28:58,580
大约在同一时间在那个鸡蛋上。
on that egg roughly at the same time.

3028
02:28:58,579 --> 02:29:01,009
然后，我们得到与SELECT查询相同的答案。
And we get back the same answer to the SELECT query.

3029
02:29:01,010 --> 02:29:03,290
目前计数为5000万。
50 million is the current count.

3030
02:29:03,290 --> 02:29:06,620
然后，我们接下来的代码行将在我们碰巧所在的服务器上执行，
Then our next lines of code execute on the servers we happen to be on,

3031
02:29:06,620 --> 02:29:09,260
给喜欢加1。
which adds 1 to the likes.

3032
02:29:09,260 --> 02:29:14,780
服务器可能不小心最终更新了鸡蛋行
The server might accidentally end up updating the row for the egg

3033
02:29:14,780 --> 02:29:20,960
两次都有50,000,001，因为根本问题是
with 50,000,001 both times, because the fundamental problem is

3034
02:29:20,959 --> 02:29:24,889
如果我的代码在执行Brian的代码时执行，
if my code executes while Brian's code executes,

3035
02:29:24,889 --> 02:29:29,479
我们都基本上在同一时间检查变量的值。
we are both checking the value of a variable at essentially the same time.

3036
02:29:29,479 --> 02:29:32,089
然后我们俩都得出了一个结论-
And we are both then making a conclusion--

3037
02:29:32,090 --> 02:29:35,190
哦，目前的喜欢人数是5000万。
oh, the current likes are 50 million.

3038
02:29:35,190 --> 02:29:36,470
然后，我们要做出决定。
We are then making a decision.

3039
02:29:36,469 --> 02:29:38,309
让我们加1到5000万。
Let's add 1 to 50 million.

3040
02:29:38,309 --> 02:29:41,599
然后，我们将值更新为50,000,001。
We are then updating the value with 50,000,001.

3041
02:29:41,600 --> 02:29:46,640
但问题是，实际上，如果Brian的代码或他的服务器发生了
The problem is, though, that, really, if Brian's code or the server he happens

3042
02:29:46,639 --> 02:29:50,779
要在Instagram上连接，恰好选择了喜欢的次数
to be connected to on Instagram happens to have selected the number of likes

3043
02:29:50,780 --> 02:29:53,900
首先，应该允许他完成
first, he should be allowed to finish the code that's

3044
02:29:53,899 --> 02:29:57,949
被执行，所以当我选择它时，我看到50,000,001，
being executed so that when I select it, I see 50,000,001,

3045
02:29:57,950 --> 02:30:02,270
然后再加上1，所以新的计数是50,000,002。
and I add 1 to that so the new count is 50,000,002.

3046
02:30:02,270 --> 02:30:04,070
这就是所谓的竞争条件。
This is what's known as a race condition.

3047
02:30:04,069 --> 02:30:06,979
在多服务器中编写代码时-
When you write code in a multiserver--

3048
02:30:06,979 --> 02:30:11,119
更俗称的多线程环境-代码行
more fancily known as a multithreaded environment-- lines of code

3049
02:30:11,120 --> 02:30:16,160
按时间顺序可以在任何给定时间在不同服务器上混合。
chronologically can get commingled on different servers at any given time.

3050
02:30:16,159 --> 02:30:18,199
问题从根本上源于事实
The problem fundamentally derives from the fact

3051
02:30:18,200 --> 02:30:22,430
如果Brian的服务器正在检查变量的状态，
that if Brian's server is in the middle of checking the state of a variable,

3052
02:30:22,430 --> 02:30:23,840
我应该被锁定。
I should be locked out.

3053
02:30:23,840 --> 02:30:26,870
我不应该同时单击该按钮，
I should not be allowed to click on that button at the same time,

3054
02:30:26,870 --> 02:30:30,590
否则我的代码将不允许逻辑执行。
or my code should not be allowed to execute logically.

3055
02:30:30,590 --> 02:30:33,050
因此，当您必须编写代码时有一个解决方案
So there is a solution when you have to write code

3056
02:30:33,049 --> 02:30:36,499
像这样，就像Twitter，Instagram和Facebook等常见的情况一样，
like this, as is common for Twitter and Instagram and Facebook and the like,

3057
02:30:36,500 --> 02:30:38,419
使用所谓的交易。
to use what are called transactions.

3058
02:30:38,420 --> 02:30:41,815
事务添加了一些我们今天将不讨论的新语法
Transactions add some few new pieces of syntax that we won't dwell on today

3059
02:30:41,815 --> 02:30:43,690
而且未来几天您无需使用。
and you don't need to use in the coming days.

3060
02:30:43,690 --> 02:30:46,180
但是它们确实解决了一个根本上困难的问题。
But they do solve a fundamentally hard problem.

3061
02:30:46,180 --> 02:30:50,500
事务本质上允许您锁定表，或者，实际上，
Transactions essentially allow you to lock a table or, really,

3062
02:30:50,500 --> 02:30:54,884
表格中的一行，以便如果Brian对该蛋进行点击
a row in the table so that if Brian's click on that egg

3063
02:30:54,885 --> 02:30:57,760
导致某些代码正在执行中，该代码正在检查哪些内容
results in some code executing that's in the process of checking what

3064
02:30:57,760 --> 02:31:02,770
是总计数，我对鸡蛋的点击不会被服务器处理
is the total like count, my click on the egg will not get handled by the server

3065
02:31:02,770 --> 02:31:05,630
直到他的代码执行完毕。
until his code is done executing.

3066
02:31:05,629 --> 02:31:08,469
因此，在这里以绿色显示，我已经建议您执行此操作的方式。
So in green here, I've proposed the way you should do this.

3067
02:31:08,469 --> 02:31:12,967
您不应该只执行中间三行，“您”就是Facebook，
You shouldn't just execute the middle three lines, "you" being Facebook,

3068
02:31:12,968 --> 02:31:13,510
在这种情况下。
in this case.

3069
02:31:13,510 --> 02:31:17,200
Instagram应该先执行BEGIN TRANSACTION，然后
Instagram should execute BEGIN TRANSACTION first, then

3070
02:31:17,200 --> 02:31:19,300
最后提交事务。
COMMIT the transaction at the end.

3071
02:31:19,299 --> 02:31:22,779
交易的设计是介于两者之间的所有线
And the design of transactions is that all of the lines in between

3072
02:31:22,780 --> 02:31:26,320
将完全成功或完全失败。
will either succeed altogether or fail altogether.

3073
02:31:26,319 --> 02:31:28,179
数据库不会进入这种时髦的状态
The database won't get into this funky state

3074
02:31:28,180 --> 02:31:32,320
我们开始失去对鸡蛋的喜欢的踪迹。
where we start losing track of likes on eggs.

3075
02:31:32,319 --> 02:31:34,659
尽管近年来这不是一个问题，
And though this has not been an issue in recent years,

3076
02:31:34,659 --> 02:31:36,951
回到Twitter刚起步的那一天，
back in the day when Twitter was first getting started,

3077
02:31:36,951 --> 02:31:40,231
Twitter在很多时候非常受欢迎，而且离线非常多。
Twitter was super popular and super offline a lot of the time.

3078
02:31:40,231 --> 02:31:42,189
有个叫做鲸鱼的东西，
There was this thing called a Fail Whale, which

3079
02:31:42,190 --> 02:31:44,037
是他们在网站上显示的图片
is the picture they showed on their website

3080
02:31:44,037 --> 02:31:46,120
当他们获得太多流量以至于无法处理时。
when they were getting too much traffic to handle.

3081
02:31:46,120 --> 02:31:49,540
那是因为当人们喜欢，发推，转发的东西时，
That was because when people are liking and tweeting and retweeting things,

3082
02:31:49,540 --> 02:31:51,520
大量的数据输入。
it's a huge amount of data coming in.

3083
02:31:51,520 --> 02:31:54,500
事实证明，解决这些问题非常困难。
And it turns out it's very hard to solve these problems.

3084
02:31:54,500 --> 02:31:58,450
但是用这些事务锁定数据库表或行
But locking the database table or the rows with these transactions

3085
02:31:58,450 --> 02:32:00,490
是从根本上解决这个问题的一种方法。
is one way fundamentally to solve this.

3086
02:32:00,489 --> 02:32:03,159
在今天的最后加时赛中，我们认为
And in our final extra time today, we thought

3087
02:32:03,159 --> 02:32:05,079
我们将在同一示例中进行演示
we would play this out in the same example

3088
02:32:05,079 --> 02:32:07,509
几年前我曾被教过交易。
that I was taught transactions in some years ago.

3089
02:32:07,510 --> 02:32:10,750
假设当前情况是您和您的室友
Suppose that the scenario at hand is that you and your roommates

3090
02:32:10,750 --> 02:32:12,370
有一个不错的宿舍冰箱。
have a nice dorm fridge.

3091
02:32:12,370 --> 02:32:15,100
而且你们都有喝大量牛奶的习惯，
And you're all in the habit of drinking lots of milk,

3092
02:32:15,100 --> 02:32:17,050
并且您希望能够喝点牛奶。
and you want to be able to drink some milk.

3093
02:32:17,049 --> 02:32:19,419
但是你要去冰箱，就像我要去这里一样。
But you go to the fridge, like I'm about to here.

3094
02:32:19,420 --> 02:32:22,210
而且您意识到，嗯，我们没牛奶了。
And you realize, uh-oh, we're out of milk.

3095
02:32:22,209 --> 02:32:25,569
所以现在我正在检查这台冰箱的状态，
And so now I am inspecting the state of this refrigerator, which

3096
02:32:25,569 --> 02:32:27,969
很老，但也很空。
is quite old but also quite empty.

3097
02:32:27,969 --> 02:32:30,159
这个变量的状态为空，
And the state of this variable, being empty,

3098
02:32:30,159 --> 02:32:33,619
告诉我应该去CVS买一些牛奶。
tells me that I should go to CVS and buy some more milk.

3099
02:32:33,620 --> 02:32:35,080
那我该怎么办呢？
So what do I then do?

3100
02:32:35,079 --> 02:32:37,149
我大概要关上冰箱，
I'm presumably going to close the fridge,

3101
02:32:37,149 --> 02:32:40,599
我要去离开然后去CVS。
and I'm going to go and leave and go head to CVS.

3102
02:32:40,600 --> 02:32:43,510
不幸的是，同样的问题出现了，我们将在这里采取行动
Unfortunately, the same problem arises that we'll act out here

3103
02:32:43,510 --> 02:32:46,150
在最后60秒左右的时间里，
in our final 60 or so seconds together, whereby

3104
02:32:46,149 --> 02:32:49,659
如果我现在在这个故事中的室友布莱恩（Brian）也想要一些牛奶，
if Brian now, my roommate in this story, also wants some milk,

3105
02:32:49,659 --> 02:32:52,059
当我已经去商店的时候他来了
he comes by when I'm already headed to the store,

3106
02:32:52,059 --> 02:32:55,309
检查冰箱的状态，然后意识到，我们没牛奶了。
inspects the state of the fridge, and realizes, oh, we're out of milk.

3107
02:32:55,309 --> 02:32:57,649
因此，他也很乐意去补货。
So he nicely will go restock, as well.

3108
02:32:57,649 --> 02:32:59,619
因此，让我们看看它如何进行，我们将
So let's see how this plays out, and we'll

3109
02:32:59,620 --> 02:33:03,590
看看是否没有类似的类似解决方案。
see if there isn't a similar, analogous solution.

3110
02:33:03,590 --> 02:33:05,620
因此，我检查了变量的状态。
So I've checked the state of the variable.

3111
02:33:05,620 --> 02:33:06,920
我们确实没牛奶了。
We're indeed out of milk.

3112
02:33:06,920 --> 02:33:08,030
我马上回来。
I'll be right back.

3113
02:33:08,030 --> 02:33:09,085
刚要去CVS。
Just going to go to CVS.

3114
02:33:26,335 --> 02:33:29,828
[音乐播放]
[MUSIC PLAYING]

3115
02:34:44,239 --> 02:34:45,019
好的。
All right.

3116
02:34:45,020 --> 02:34:46,550
我现在从商店回来。
I am now back from the store.

3117
02:34:46,549 --> 02:34:47,869
我已经买了些牛奶。
I've picked up some milk.

3118
02:34:47,870 --> 02:34:50,090
继续将其放入冰箱，然后-
Going to go ahead and put it into the fridge and--

3119
02:34:50,090 --> 02:34:51,710
哦，这是怎么发生的？
oh, how did this happen?

3120
02:34:51,709 --> 02:34:53,569
现在有多罐牛奶。
Now there's multiple jugs of milk.

3121
02:34:53,569 --> 02:34:55,489
当然，牛奶不会持续那么长时间。
And of course, milk does not last that long.

3122
02:34:55,489 --> 02:34:57,281
布赖恩和我喝的牛奶不多。
And Brian and I don't drink that much milk.

3123
02:34:57,281 --> 02:34:58,969
因此，这是一个非常严重的问题。
So this is a really serious problem.

3124
02:34:58,969 --> 02:35:03,149
我们已经尝试过同时更新此变量的值。
We've sort of tried to update the value of this variable at the same time.

3125
02:35:03,149 --> 02:35:05,029
那么，我们该如何解决呢？
So how do we go about fixing this?

3126
02:35:05,030 --> 02:35:07,320
实际的解决方案是什么？
What's the actual solution here?

3127
02:35:07,319 --> 02:35:09,919
好吧，我敢说我们可以汲取一些灵感
Well, I dare say that we can draw some inspiration

3128
02:35:09,920 --> 02:35:13,787
来自交易世界和数据库世界。
from the world of transactions and the world of databases.

3129
02:35:13,787 --> 02:35:15,620
也许为我们创造一个视觉效果
And perhaps create a visual for here that we

3130
02:35:15,620 --> 02:35:18,270
希望您永远不会忘记，如果您今天没有采取任何行动。
hope you never forget if you take nothing away from today.

3131
02:35:18,270 --> 02:35:21,327
让我们继续，最后一次采取行动，这次，
Let's go ahead and act this out one last time where, this time,

3132
02:35:21,326 --> 02:35:22,909
我会更加极端。
I'm going to be a little more extreme.

3133
02:35:22,909 --> 02:35:24,289
我继续打开冰箱。
I go ahead and open the fridge.

3134
02:35:24,290 --> 02:35:25,940
我知道，哦，我们没牛奶了。
I realize, oh, we're out of milk.

3135
02:35:25,940 --> 02:35:27,380
我要去商店。
I'm going to go to the store.

3136
02:35:27,379 --> 02:35:29,449
我不想考虑这种情况
I do not want to allow for this situation

3137
02:35:29,450 --> 02:35:32,490
布莱恩不小心检查了冰箱。
where Brian accidentally checks the fridge, as well.

3138
02:35:32,489 --> 02:35:37,669
因此，我将锁定冰箱。
So I am going to lock the refrigerator instead.

3139
02:35:37,670 --> 02:35:41,390
让我继续并将其悬垂在这里。
Let me go ahead and drape this through here.

3140
02:35:43,940 --> 02:35:49,050
有点极端，但我认为只要他不能进入冰箱，
A little extreme, but I think so long as he can't get into the fridge,

3141
02:35:49,049 --> 02:35:52,789
这不应该是一个问题。
this shouldn't be a problem.

3142
02:35:52,790 --> 02:35:56,060
现在让我继续前进，然后将锁挂在这里。
Let me go ahead now and just attach the lock here.

3143
02:35:56,059 --> 02:35:57,169
差不多了。
Almost got it.

3144
02:35:57,170 --> 02:35:58,340
快点。
Come on.

3145
02:35:58,340 --> 02:35:59,570
好的。
All right.

3146
02:35:59,569 --> 02:36:01,992
现在冰箱已锁定。
Now the fridge is locked.

3147
02:36:01,993 --> 02:36:03,410
现在我要去喝点牛奶。
Now I'm going to go get some milk.

3148
02:36:17,209 --> 02:36:18,209
布莱恩·于：[SIGHS]
BRIAN YU: [SIGHS]

3149
02:36:18,709 --> 02:36:22,059
[音乐播放]
[MUSIC PLAYING]

