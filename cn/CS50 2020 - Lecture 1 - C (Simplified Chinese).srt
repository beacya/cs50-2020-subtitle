1
00:00:00,000 --> 00:00:02,970
[音乐响起--字幕精校中--By Persisan]
[MUSIC PLAYING]

2
00:00:50,049 --> 00:00:52,479
DAVID MALAN：好的，这是CS50。
DAVID MALAN: All right, this is CS50.

3
00:00:52,479 --> 00:00:55,329
这是第一周，第二周。
And this is week one, our second week.

4
00:00:55,329 --> 00:00:59,329
今天，回想一下，我们将专注于另一种称为
And today, recall that we'll focus on this other programming language called

5
00:00:59,329 --> 00:00:59,829
C。
C.

6
00:00:59,829 --> 00:01:02,709
我们给了你最后一瞥，其中
And we gave you a little glimpse of this last time, wherein

7
00:01:02,710 --> 00:01:05,140
我建议将此代码显示在屏幕上
I proposed that this code here on the screen

8
00:01:05,140 --> 00:01:08,620
你很快就会知道如何编程（如果还没有的话）。
is something that you will soon know how to program, if not already.

9
00:01:08,620 --> 00:01:11,350
但是可以说它看起来和它有很大的不同
But suffice it to say it looks quite a bit dissimilar to what

10
00:01:11,349 --> 00:01:14,559
我们看了上周，当然是Scratch，还有更多
we looked at last week which, of course, was Scratch, which was much more

11
00:01:14,560 --> 00:01:16,120
好玩，更生动。
playful, much more graphical.

12
00:01:16,120 --> 00:01:20,680
因此，请允许我从今天的一开始就声明，对于我们大多数人来说，
And so allow me to disclaim right from the get go today that for most of us,

13
00:01:20,680 --> 00:01:22,990
今天会感觉有点像消防水带。
today will feel like a bit of a fire hose.

14
00:01:22,989 --> 00:01:25,419
实际上，在这里被描绘为麻省理工学院的一个老黑客，
In fact, pictured here as an old hack from MIT,

15
00:01:25,420 --> 00:01:28,750
其中一些勤劳的老人挂了一个真正的消火栓
wherein some industrious seniors hooked up an actual fire hydrant

16
00:01:28,750 --> 00:01:30,310
到喷泉。
to a water fountain.

17
00:01:30,310 --> 00:01:32,440
俗话说，从麻省理工学院接受教育
The saying being that getting an education from MIT

18
00:01:32,439 --> 00:01:35,524
就像从消防栓上喝水一样。
is like drinking from a fire hydrant.

19
00:01:35,525 --> 00:01:37,150
今天会有这样的感觉。
Today will feel a little bit like that.

20
00:01:37,150 --> 00:01:40,270
因为这是一个特殊的场合，你实际上并没有
Because this is sort of a special occasion that you don't really have

21
00:01:40,269 --> 00:01:42,249
场合经常描述。
occasion to describe very often.

22
00:01:42,250 --> 00:01:44,987
但这是我们所有人都要学习一种新语言的地方。
But it's one in which we're all going to learn a new language.

23
00:01:44,987 --> 00:01:47,029
确实，这不是我们每天都要做的事情。
And indeed, that's not something we do every day.

24
00:01:47,030 --> 00:01:49,270
因此，乍一看，它看起来
And so at the first glance, it's going to look

25
00:01:49,269 --> 00:01:51,699
像很多新的语法，很多新的想法。
like a lot of new syntax, a lot of new ideas.

26
00:01:51,700 --> 00:01:55,945
但是，请允许我放心，很快会变成这样，
And yet, allow me to reassure, that what will soon look like this,

27
00:01:55,944 --> 00:01:59,499
这个C代码在本质上是一回事
this C code here, is fundamentally the same thing

28
00:01:59,500 --> 00:02:03,759
你已经看到，现在通过Scratch进行了尝试。
that you've seen and now experimented with last week by way of Scratch.

29
00:02:03,760 --> 00:02:06,083
也就是说，在另一种编程语言中
That is to say, within this other programming language

30
00:02:06,082 --> 00:02:09,249
C，它比较传统，它更多基于文本，更多基于键盘，
C, which is more traditional, which is more text-based, more keyboard-based,

31
00:02:09,250 --> 00:02:13,299
我们仍然会看到函数，条件，布尔表达式，循环，
we're still going to see functions, conditions, Boolean expressions, loops,

32
00:02:13,300 --> 00:02:14,065
等等。
and so on.

33
00:02:14,064 --> 00:02:15,939
他们看起来都会有些不同。
They're going to all look a little different.

34
00:02:15,939 --> 00:02:18,129
但是想法是一样的。
But the ideas are the same.

35
00:02:18,129 --> 00:02:22,762
就像第一次走进某人的家一样
And so much like when walking into someone's home for the very first time

36
00:02:22,763 --> 00:02:25,180
铺开土地，看到很多东西
and getting the lay of the land and seeing a lot of things

37
00:02:25,180 --> 00:02:28,180
你以前从未见过的东西，你通常不关心所有
that you haven't seen before, you typically don't care about all

38
00:02:28,180 --> 00:02:29,200
这些视觉细节。
of those visual details.

39
00:02:29,199 --> 00:02:31,489
你可能只是简单地向前走并坐下。
You might just simply walk forward and sit down.

40
00:02:31,490 --> 00:02:34,600
今天同样，我们将看到很多细节
Similarly today, we're about to see a whole lot of details

41
00:02:34,599 --> 00:02:36,549
在这种编程语言的世界中。
in the world of this programming language.

42
00:02:36,550 --> 00:02:39,160
但是眼下的目标是一眼就忽略一切
But the goal at hand is to ignore things at first glance

43
00:02:39,159 --> 00:02:43,059
我们不一定理解并束缚那些想法，
that we don't necessarily understand and latch onto those ideas that

44
00:02:43,060 --> 00:02:45,440
从上周开始熟悉。
are familiar from last week.

45
00:02:45,439 --> 00:02:48,949
那么，我们如何着手编写计算机程序呢？
So how do we go about actually writing computer programs?

46
00:02:48,949 --> 00:02:51,289
我们如何才能很好地编写它们？
How do we go about writing them well?

47
00:02:51,289 --> 00:02:55,749
因此，让我建议，有一些指示灯可以
And so allow me to propose that there's a few guiding lights that

48
00:02:55,750 --> 00:02:57,427
应该指导代码编写。
should guide writing of code.

49
00:02:57,427 --> 00:02:58,719
其中之一当然是正确性。
One, of course, is correctness.

50
00:02:58,719 --> 00:03:01,809
上周我们进行了探索，你的代码的正确性
And we explored this last week, whereby the correctness of your code

51
00:03:01,810 --> 00:03:04,540
只是说它是否按预期工作。
just speaks to does it work as intended.

52
00:03:04,539 --> 00:03:07,299
当你双击某个图标时，当你运行某些命令时，
When you double click some icon, when you run some command,

53
00:03:07,300 --> 00:03:11,020
你或其他人编写的程序是否正常运行？
does the program that you or someone else wrote behave correctly?

54
00:03:11,020 --> 00:03:12,740
它按照它说的做吗？
Does it do what it says?

55
00:03:12,740 --> 00:03:16,330
但是编写好的软件还有其他方面
But there's other aspects to writing good software

56
00:03:16,330 --> 00:03:18,100
和编写好的程序。
and writing good programs.

57
00:03:18,099 --> 00:03:19,449
这与设计有关。
And that has to do with design.

58
00:03:19,449 --> 00:03:22,069
上周我们提到了一点。
And we alluded a little bit this last week.

59
00:03:22,069 --> 00:03:26,049
但是通过设计，它更像是一种定性，更主观的衡量，
But with design it's more of a qualitative, a more subjective measure,

60
00:03:26,050 --> 00:03:28,090
你的代码编写得如何。
just how well written your code is.

61
00:03:28,090 --> 00:03:31,750
试想一下，例如，从上一堂必须写论文的课开始，
So imagine, for instance, from taking a class where you have to write essays,

62
00:03:31,750 --> 00:03:34,720
你当然可以提出非常正确的论据。
you could certainly make very correct arguments.

63
00:03:34,719 --> 00:03:37,809
但是通过写很长的文字，你可以提出非常正确的论据，
But you could make very correct arguments by writing very long,

64
00:03:37,810 --> 00:03:41,800
乱句子，重复自己，一般不写作
rambling sentences, repeating yourself, and generally not writing

65
00:03:41,800 --> 00:03:43,420
一篇很好的论文或论文。
a very good essay or paper.

66
00:03:43,419 --> 00:03:44,589
现在可能是正确的。
Now it might be correct.

67
00:03:44,590 --> 00:03:46,840
那份纸上没有你的英语课，
There's nothing in that paper for your English class,

68
00:03:46,840 --> 00:03:50,140
历史记录类，或者你说的任何不正确的内容。
history class, or whatever it may be that you said that was incorrect.

69
00:03:50,139 --> 00:03:51,999
但是你可能不会在上面得到很好的评分，
But you might not get very good marks on it,

70
00:03:52,000 --> 00:03:54,077
因为它的设计不是很好。
because it's just not very well-designed.

71
00:03:54,078 --> 00:03:55,870
同样，在编程世界中，
And so similarly, in the programming world,

72
00:03:55,870 --> 00:03:59,320
是否有实际上不仅仅编写正确代码的想法，
is there this notion of actually writing not only correct code,

73
00:03:59,319 --> 00:04:00,939
但设计合理的代码。
but well-designed code.

74
00:04:00,939 --> 00:04:02,739
在这里，你不会重复自己。
Wherein you don't repeat yourself.

75
00:04:02,740 --> 00:04:04,600
你编写的代码相当有效。
You write code that's fairly efficient.

76
00:04:04,599 --> 00:04:08,959
它没有完成比实际需要更多的工作。
It doesn't do more work than it actually needs to.

77
00:04:08,960 --> 00:04:12,340
最后，让我为今天的课程提出建议，
And then lastly, let me propose for today onward in this class,

78
00:04:12,340 --> 00:04:15,070
当你需要记住第三条轴时
that there's a third axis you should keep in mind when

79
00:04:15,069 --> 00:04:17,018
涉及编写好的代码。
it comes to writing good code.

80
00:04:17,019 --> 00:04:18,550
这与风格有关。
And that has to do with style.

81
00:04:18,550 --> 00:04:20,380
这更多的是美学。
This is much more of an aesthetic.

82
00:04:20,379 --> 00:04:23,259
因此，在类似撰写论文的世界中，
So this, in the analogous world of writing an essay,

83
00:04:23,259 --> 00:04:26,769
会使用良好的标点符号，大写吗？
would be are using good punctuation, capitalisation?

84
00:04:26,769 --> 00:04:28,449
你要缩进新段落吗？
Are you indenting new paragraphs?

85
00:04:28,449 --> 00:04:30,759
那些从根本上讲的美学
And those kinds of aesthetics that fundamentally

86
00:04:30,759 --> 00:04:33,429
不要改变你所说的正确性，
don't change the correctness of what you're saying,

87
00:04:33,430 --> 00:04:37,220
不一定会改变你所提出的论点的质量，
don't change necessarily the quality of the arguments that you're making,

88
00:04:37,220 --> 00:04:41,230
但是你的文章风格，就像你的代码风格一样，
but the style of your essay, much like the style of your code,

89
00:04:41,230 --> 00:04:44,090
使你的代码更具可读性。
makes your code much, much more readable.

90
00:04:44,089 --> 00:04:47,139
因此，在编写良好的代码时，你首先需要它
So when it comes to writing good code, you want it first

91
00:04:47,139 --> 00:04:49,839
而且最重要的是要正确设计
and foremost to be correct, but also well well-designed

92
00:04:49,839 --> 00:04:51,549
而且样式也不错。
and also well-styled.

93
00:04:51,550 --> 00:04:54,460
再次，你很希望在撰写论文时希望
Much like, again, you would when writing an essay that you would hope

94
00:04:54,459 --> 00:04:59,149
也会很好地反映你的能力。
would reflect well on your capabilities as well.

95
00:04:59,149 --> 00:05:02,602
因此，例如在编写代码时，
So when it comes to writing code, like this, for instance,

96
00:05:02,603 --> 00:05:05,020
上周有人提出的第一个C程序
this first C program that someone last week proposed quite

97
00:05:05,019 --> 00:05:07,659
只需在屏幕上打印出来，你好，世界。
simply prints out on the screen, hello, world.

98
00:05:07,660 --> 00:05:09,670
好吧，我们如何去编写这段代码？
Well, how do we go about writing this code?

99
00:05:09,670 --> 00:05:12,580
上周，我们去了Scratch.MIT.edu编写了代码
Last week we wrote code by going to Scratch.MIT.edu

100
00:05:12,579 --> 00:05:14,672
然后拖放拼图。
and then dragging and dropping puzzle pieces.

101
00:05:14,673 --> 00:05:16,340
今天将有所不同。
Today is going to be a little different.

102
00:05:16,339 --> 00:05:18,549
我们将在这里继续使用其他工具。
We're going to use a different tool here on out.

103
00:05:18,550 --> 00:05:20,425
而且我们将更多地使用键盘
And we're going to use our keyboard much more

104
00:05:20,425 --> 00:05:22,125
比我们的鼠标实际编程。
than our mouse to actually program.

105
00:05:22,125 --> 00:05:24,250
但要这样做，我们将继续介绍
But to do so, we're going to go ahead and introduce

106
00:05:24,250 --> 00:05:28,639
这学期的几种工具中的第一个，即CS50 IDE。
the first of several tools this semester, this one, known as CS50 IDE.

107
00:05:28,639 --> 00:05:31,779
IDE是首字母缩写，是编程中的一种艺术术语，
IDE is an acronym, a term of art in programming,

108
00:05:31,779 --> 00:05:34,719
代表集成开发环境。
that stands for Integrated Development Environment.

109
00:05:34,720 --> 00:05:37,150
在这种情况下，这只是一种奇特的说法，
Which is just a fancy way of saying, in this context,

110
00:05:37,149 --> 00:05:41,779
CS50 IDE是CS50自己的基于Web的编程环境。
that CS50 IDE is CS50's own web-based programming environment.

111
00:05:41,779 --> 00:05:44,469
它本身并不特定于CS50。
And it's not specific to CS50 per se.

112
00:05:44,470 --> 00:05:47,760
我们仅添加了许多对教育有用的功能
We've simply added a number of educationally useful features

113
00:05:47,759 --> 00:05:52,859
在互联网上任何人都可以使用的第三方云工具之上。
on top of a third party cloud tool that anyone on the internet can use.

114
00:05:52,860 --> 00:05:57,233
我们自己的版本位于此URLide.cs50.io。
And our own version thereof lives at this URL, ide.cs50.io.

115
00:05:57,233 --> 00:05:59,400
因此，欢迎你立即使用该URL。
So you're welcome to follow along at that URL today.

116
00:05:59,399 --> 00:06:01,619
但是你不需要在演讲过程中本身。
But you need not during lecture itself.

117
00:06:01,620 --> 00:06:04,110
但是，对于即将到来的问题以及以后的问题，
But on this upcoming problem set and beyond,

118
00:06:04,110 --> 00:06:08,500
你将实际使用该工具并对其更加熟悉吗？
will you actually use and get more familiar with this tool hands on.

119
00:06:08,500 --> 00:06:10,930
因此，让我继续并在此处打开此工具。
So let me go ahead and open up this tool here.

120
00:06:10,930 --> 00:06:12,600
所以我已经提前登录了。
So I've already logged in in advance.

121
00:06:12,600 --> 00:06:17,010
你在这里看到的是可供你使用的基本用户界面。
And what you see here is the basic user interface that's available to you.

122
00:06:17,009 --> 00:06:19,649
幸运的是，只有几个显着特征
And fortunately, there's only a couple of salient features

123
00:06:19,649 --> 00:06:21,269
我们现在需要指出。
that we need to point out right now.

124
00:06:21,269 --> 00:06:23,459
所以在屏幕顶部，它只是
So at the top of the screen here, it's just

125
00:06:23,459 --> 00:06:27,209
一个大的黑色矩形，稍后将用代码填充。
a big black rectangle that in a moment is going to be filled with code.

126
00:06:27,209 --> 00:06:29,849
就像使用Google文档一样
Much like using Google documents or something

127
00:06:29,850 --> 00:06:32,565
这样，你可以在其中创建新标签和创建新文件，
like that, where you can create new tabs and create new files,

128
00:06:32,564 --> 00:06:34,439
这是我要进行编程的地方，
this is where I'm going to do my programming,

129
00:06:34,439 --> 00:06:35,679
沿着屏幕顶部。
along the top of the screen.

130
00:06:35,680 --> 00:06:37,680
而在最下面的是我们现在的情况
And along the bottom is what we're, in a moment,

131
00:06:37,680 --> 00:06:39,780
开始调用我们的终端窗口。
going to start calling our terminal window.

132
00:06:39,779 --> 00:06:44,399
我可以在此终端窗口中实际运行命令并最终
It's in this terminal window that I can actually run commands and ultimately

133
00:06:44,399 --> 00:06:46,209
运行我的实际代码。
run my actual code.

134
00:06:46,209 --> 00:06:49,379
但是，让我们继续在这种环境下编写我们的第一个程序
But let's go ahead and write our very first program in this environment

135
00:06:49,379 --> 00:06:52,439
并意识到该工具的确不是CS50特有的。
and realize that this tool, indeed, is not very CS50 specific.

136
00:06:52,439 --> 00:06:56,609
旨在代表一个非常常见的流行编程
It's meant to be representative of a very common popular programming

137
00:06:56,610 --> 00:06:58,980
环境中，你拥有所谓的文本编辑器，
environment, where you have a so-called text editor,

138
00:06:58,980 --> 00:07:01,170
或选项卡式窗口，你可以在其中编写代码，
or tabbed windows where you can write code,

139
00:07:01,170 --> 00:07:03,900
还有一个终端窗口，你可以在其中实际运行命令。
and a terminal window where you can actually run commands.

140
00:07:03,899 --> 00:07:05,759
我们的恰好存在于云中。
Ours happens to exist in the cloud.

141
00:07:05,759 --> 00:07:07,949
但是你当然可以选择编程
But you can alternatively program, certainly,

142
00:07:07,949 --> 00:07:11,039
这些天在你自己的Mac，PC或任何其他设备上。
on your own Mac, or PC, or any other device these days.

143
00:07:11,040 --> 00:07:13,470
但坦率地说，它往往只涉及一个不重要的数字
But frankly, it tends to involve just a non-trivial number

144
00:07:13,470 --> 00:07:16,110
早期的技术困难，尤其是当我们所有人
of technical difficulties early on, especially when we all

145
00:07:16,110 --> 00:07:19,000
具有不同版本的Mac OS和Windows等。
have different versions of Mac OS and Windows and the like.

146
00:07:19,000 --> 00:07:22,439
因此，这种基于云的环境仅确保在第0天，
So this cloud-based environment just ensures that on day zero,

147
00:07:22,439 --> 00:07:25,917
我们都可以拥有相同的精确编程经验。
we can all have the same exact programming experience.

148
00:07:25,918 --> 00:07:27,460
因此，我将继续执行此操作。
So I'm going to go ahead and do this.

149
00:07:27,459 --> 00:07:30,429
我将继续前进，转到“文件”和“新文件”。
I'm going to go ahead and go up to File and New File.

150
00:07:30,430 --> 00:07:33,690
这将创建一个新标签，默认情况下名为Untitled1，
And this is going to create a new tab, by default called Untitled1,

151
00:07:33,689 --> 00:07:34,839
不太有趣。
not very interesting.

152
00:07:34,839 --> 00:07:37,199
因此，我现在将转到“文件和保存”。
So I'm going to now go up to File and Save.

153
00:07:37,199 --> 00:07:40,239
默认情况下，我将把该文件另存为
And by default, I'm going to save this file as, for instance,

154
00:07:40,240 --> 00:07:42,160
名称hello.c。
the name hello.c.

155
00:07:42,160 --> 00:07:45,180
所以我想用这种语言编写我的第一个程序
So I want to write my very first program in this language called

156
00:07:45,180 --> 00:07:47,230
C.我要打个招呼。
C. I'm going to call my file hello.

157
00:07:47,230 --> 00:07:50,495
但我将以名为.c的文件扩展名结尾。
But I'm going to end it in a file extension called .c.

158
00:07:50,495 --> 00:07:51,870
这确实是惯例。
And that's indeed the convention.

159
00:07:51,870 --> 00:07:55,440
编写C程序时，它们应以.c结尾。
When writing C programs, they should end with .c.

160
00:07:55,439 --> 00:07:59,684
就像你可能还记得的Scratch程序一样，它们以.sb3结尾。
Just like Scratch programs, as you may recall, end in .sb3.

161
00:07:59,685 --> 00:08:02,310
所以我要继续，只需单击此处的绿色按钮
So I'm going to go ahead and simply click the green button here

162
00:08:02,310 --> 00:08:03,360
这就是所谓的保存。
that's called Save.

163
00:08:03,360 --> 00:08:06,540
除了名称和标签之外，什么都不会改变。
Nothing is really going to change except for the name and the tab there.

164
00:08:06,540 --> 00:08:10,140
现在，我在左上角看到此选项卡称为hello.c。
Now I see at top left that this tab is called hello.c.

165
00:08:10,139 --> 00:08:12,059
现在，我可以开始键入任何想要的内容了。
And now I can start typing anything I want.

166
00:08:12,060 --> 00:08:14,130
坦率地说，我只是从内存中键入
And frankly, I'm just going to type from memory

167
00:08:14,129 --> 00:08:17,249
我们上周和不久前看到的第一个程序。
the very first program we saw last week and just a moment ago.

168
00:08:17,250 --> 00:08:21,570
我现在要包括stdio.h，无论现在是什么。
I'm going to do include stdio.h, whatever that is for now.

169
00:08:21,569 --> 00:08:25,529
我现在要去做int main（void），不管现在是什么。
I'm going then going to do int main(void), whatever that is for now.

170
00:08:25,529 --> 00:08:27,119
我要用花括号。
I'm going to use the curly brace.

171
00:08:27,120 --> 00:08:30,480
然后，可以说合上那个大括号。
And then close that curly brace, so to speak, thereafter.

172
00:08:30,480 --> 00:08:36,659
在这里，我要继续执行printf（“ hello，world”）
And in here, I'm going to go ahead and do printf("hello,world") followed

173
00:08:36,658 --> 00:08:38,229
用分号。
by a semicolon.

174
00:08:38,230 --> 00:08:41,027
现在，我脑海中浮现出了很多文字。
Now that was a whole lot of text right off the top of my head.

175
00:08:41,027 --> 00:08:43,110
这是你很快就会想到的一种肌肉记忆
This is the kind of muscle memory that you'll soon

176
00:08:43,110 --> 00:08:44,402
在编写程序时进行开发。
develop when writing a program.

177
00:08:44,402 --> 00:08:46,290
我当然已经做过很多次了。
I've, of course, done this many times before.

178
00:08:46,289 --> 00:08:48,599
这样我就可以做到了。
So I was able to just do it off the top of my head.

179
00:08:48,600 --> 00:08:52,500
但是稍后，我们将梳理一下所有不同的线条和字符
But in a moment, we'll tease apart what all of the various lines and characters

180
00:08:52,500 --> 00:08:54,750
我键入的内容确实可以。
that I typed actually do.

181
00:08:54,750 --> 00:08:57,029
但是我现在想做的就是运行该程序。
But what I'd now like to do is run this program.

182
00:08:57,029 --> 00:09:00,989
上周我们猜想这只会打个招呼，世界。
We conjectured last week that this is just going to print hello, world.

183
00:09:00,990 --> 00:09:01,800
但是如何？
But how?

184
00:09:01,799 --> 00:09:04,439
好吧，在我们的Mac，PC和手机的世界中，
Well, in the world of our Macs and PCs and phones,

185
00:09:04,440 --> 00:09:08,730
如果我们要实际运行程序，只需点击一个图标即可。
we would all just tap an icon if we want to actually run a program.

186
00:09:08,730 --> 00:09:12,000
今天不是这种情况，因为现在我们
That's not going to be the case today, because now we're

187
00:09:12,000 --> 00:09:14,649
在更多的传统编程环境中。
in more of a traditional programming environment.

188
00:09:14,649 --> 00:09:17,009
我们现在所处的环境要求
The environment that we're now in requires

189
00:09:17,009 --> 00:09:18,999
我多使用键盘，
that I use my keyboard a little bit more,

190
00:09:19,000 --> 00:09:22,830
或所谓的命令行界面或CLI。
or what's known as a Command Line Interface, or CLI.

191
00:09:22,830 --> 00:09:27,780
这与图形用户界面或GUI或GUI形成对比，
This is in contrast with a Graphical User Interface, or G-U-I, or GUI,

192
00:09:27,779 --> 00:09:31,049
这就是描述Mac OS窗口，iOS和Android的内容。
which is what describes Mac OS windows, iOS, and Android.

193
00:09:31,049 --> 00:09:33,539
但是在命令行界面中，我必须做所有事情
But in a command line interface, I have to do everything

194
00:09:33,539 --> 00:09:35,549
在所谓的命令行。
at a so-called command line.

195
00:09:35,549 --> 00:09:38,339
到此为止，我指的是这种闪烁
And by that, I'm referring to this blinking

196
00:09:38,340 --> 00:09:41,080
在屏幕底部提示。
prompt along the bottom of my screen.

197
00:09:41,080 --> 00:09:43,080
再次在屏幕底部，我
Along the bottom of my screen here, again, I

198
00:09:43,080 --> 00:09:46,380
被描述为终端窗口，我将在其中键入命令，
described as the terminal window, where I'm going to type commands,

199
00:09:46,379 --> 00:09:48,629
这是我的命令行界面。
and this is my command line interface.

200
00:09:48,629 --> 00:09:51,999
我在这里输入的任何内容都会发送到此计算机
Anything I type here is going to get sent to this computer

201
00:09:52,000 --> 00:09:55,509
并希望在自己的硬件上执行。
and hopefully execute on its own hardware.

202
00:09:55,509 --> 00:09:57,669
那么我该怎么做呢？
So how do I do this?

203
00:09:57,669 --> 00:09:58,959
那我该怎么办？
And what do I do?

204
00:09:58,960 --> 00:10:04,140
好吧，当然，要抓住的地方是用C或Python编写代码时
Well, the catch, of course, is that when writing code in C or Python

205
00:10:04,139 --> 00:10:07,319
或恰好存在的Java或其他多种语言，
or Java or bunches of other languages that happen to exist,

206
00:10:07,320 --> 00:10:11,400
那真的是要由我和你，人类来写和理解的。
that's really meant to be written and understood by me and you, the humans.

207
00:10:11,399 --> 00:10:14,219
但是上周，唯一的语言是什么，
But per last week, what is the only language,

208
00:10:14,220 --> 00:10:16,140
从某种意义上说，计算机能够理解？
in a sense, that computers understand?

209
00:10:16,139 --> 00:10:18,419
布莱恩，我们可以为此请人吗？
Brian, could we call on someone for this?

210
00:10:18,419 --> 00:10:23,729
电脑只会说什么语言？
What language do computers only speak?

211
00:10:23,730 --> 00:10:26,790
因为我认为上周我们离开的地方之间存在脱节
Because I think there's a disconnect between where we left off last week

212
00:10:26,789 --> 00:10:31,269
以及如果我正在编写现在看起来像这样的代码，我们目前所处的位置。
and where we're currently at if I'm writing code that now looks like this.

213
00:10:31,269 --> 00:10:35,099
辛迪，计算机会说什么语言？
Cindy, what language do computers speak, would you say?

214
00:10:35,100 --> 00:10:36,007
听众：二进制。
AUDIENCE: Binary.

215
00:10:36,006 --> 00:10:36,839
DAVID MALAN：二进制。
DAVID MALAN: Binary.

216
00:10:36,840 --> 00:10:38,173
并详细说明一下。
And just elaborate a little bit.

217
00:10:38,173 --> 00:10:39,977
回顾一下，你所说的二进制是什么意思？
What do you mean by binary, to recap?

218
00:10:39,976 --> 00:10:40,559
听众：是的。
AUDIENCE: Yes.

219
00:10:40,559 --> 00:10:43,824
因此，他们使用1和0来表示所有内容。
So they use 1's and 0's to represent everything.

220
00:10:43,825 --> 00:10:44,700
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

221
00:10:44,700 --> 00:10:46,830
他们使用1和0来表示所有内容。
They use 1's and 0's to represent everything.

222
00:10:46,830 --> 00:10:51,090
上周我们只关注数字和字母
And last week we focused on only things like numbers and letters

223
00:10:51,090 --> 00:10:54,220
颜色，图像，视频和声音等等。
and colors and images and videos and sound and so forth.

224
00:10:54,220 --> 00:10:58,410
但是我们实际上并没有谈论内置功能，哪些计算机也
But we didn't actually speak to built in functionality, which computers also

225
00:10:58,409 --> 00:11:00,599
用0和1表示。
use 0's and 1's to represent.

226
00:11:00,600 --> 00:11:04,260
那就是说，这些天计算机当然有能力打印
That is to say computers, of course, have the ability these days to print

227
00:11:04,259 --> 00:11:06,119
屏幕上的东西。
something on the screen.

228
00:11:06,120 --> 00:11:10,470
还有打印的概念，功能，功能，
And that notion of printing, that function, that functionality,

229
00:11:10,470 --> 00:11:13,780
也可以说是在计算机的机壳下面表示的
also is represented underneath the hood of a computer, so to speak,

230
00:11:13,779 --> 00:11:15,719
由0和1的某种模式组成。
by some pattern of 0's and 1's.

231
00:11:15,720 --> 00:11:18,510
也就是说，我刚才输入的所有内容，
Which is to say that everything I just typed,

232
00:11:18,509 --> 00:11:20,999
即使有点像英语
even though it kind of sort of looks like English

233
00:11:21,000 --> 00:11:25,919
并以一种清晰的方式向你问好印刷品，世界，计算机，讽刺意味的是，
and kind of sort of clearly says print hello, world, the computer, ironically,

234
00:11:25,919 --> 00:11:28,619
不知道我刚才打的是什么。
does not know what it is I have just typed.

235
00:11:28,620 --> 00:11:30,750
为了让它了解我刚刚输入的内容，
In order for it to understand what I've just typed,

236
00:11:30,750 --> 00:11:33,609
我实际上需要将其转换为0和1。
I need to actually convert it to 0's and 1's.

237
00:11:33,610 --> 00:11:35,790
因此，实际上，此过程的下一步
And so, indeed, the next step in this process

238
00:11:35,789 --> 00:11:39,929
是要用我在这里用C编写的描述为我的源代码的方式，
is to take what I'll describe as my source code, written here in C,

239
00:11:39,929 --> 00:11:42,689
上周，我们也看到了源代码，它只是图形化的。
and last week, too, we saw source code, it was just graphical.

240
00:11:42,690 --> 00:11:44,305
那是Scratch中的那些拼图。
It was those puzzle pieces in Scratch.

241
00:11:44,304 --> 00:11:47,429
这是我的源代码，尽管它是神秘的，但至少我是这样，
This is my source code that, even though cryptic, is something I, at least,

242
00:11:47,429 --> 00:11:49,709
人类，最终可以读写。
the human, eventually can read and write.

243
00:11:49,710 --> 00:11:53,370
但是我需要从字面上将其转换为0和1的模式
But I need to literally convert it to patterns of 0's and 1's

244
00:11:53,370 --> 00:11:54,960
计算机可以理解的。
that the computer can understand.

245
00:11:54,960 --> 00:11:56,320
现在我如何到达这一点？
Now how do I get to this point?

246
00:11:56,320 --> 00:11:58,680
好吧，值得庆幸的是，我们上周有了一个心理模型
Well, thankfully, we have a mental model from last week

247
00:11:58,679 --> 00:12:00,329
涉及解决问题。
that involves problem solving.

248
00:12:00,330 --> 00:12:01,330
这是一个问题。
And here's a problem.

249
00:12:01,330 --> 00:12:04,650
我如何获取以这种称为C的语言编写的源代码，
How do I take source code, written in this language supposedly called C,

250
00:12:04,649 --> 00:12:08,009
并将其转换为计算机可以理解的0和1？
and convert it to 0's and 1's that the computer understands?

251
00:12:08,009 --> 00:12:10,979
好吧，我敢说，我的输入将成为我的源代码。
Well, my input, I daresay, is going to be my source code.

252
00:12:10,980 --> 00:12:16,440
理想情况下，我的输出将是我们称为机器代码的东西。
And my output, ideally, is going to be what we'll call machine code.

253
00:12:16,440 --> 00:12:19,230
机器码只是描述0的艺术术语
Machine code is just a term of art describing the 0's

254
00:12:19,230 --> 00:12:21,150
和计算机可以理解的1。
and 1's that computers understand.

255
00:12:21,149 --> 00:12:23,099
上周我们没有使用该表达式。
We didn't use that expression last week.

256
00:12:23,100 --> 00:12:27,480
但这只是在右侧引用0和1，在左侧引用C代码。
But this just refers to 0's and 1's on the right and C code on the left.

257
00:12:27,480 --> 00:12:31,690
所以这引发了一个问题，好吧，我的源代码和机器之间是什么
So that invites the question, well, what is between my source code and machine

258
00:12:31,690 --> 00:12:32,190
代码？
code?

259
00:12:32,190 --> 00:12:36,030
如果我将源代码输入到众所周知的黑匣子中，
If I take my source code and feed it into the proverbial black box,

260
00:12:36,029 --> 00:12:39,809
我如何从黑匣子中取出计算机的0和1
how do I get out of this black box the 0's and 1's that the computer

261
00:12:39,809 --> 00:12:40,469
懂吗？
understands?

262
00:12:40,470 --> 00:12:42,270
好吧，我需要一个特殊的程序，
Well, I need a special program that we're

263
00:12:42,269 --> 00:12:44,219
开始调用编译器。
going to start calling a compiler.

264
00:12:44,220 --> 00:12:47,460
编译器是可以免费下载的程序，
A compiler is a program that you can download for free,

265
00:12:47,460 --> 00:12:50,760
或支付当天的费用，这是一个设计好的程序
or pay for back in the day, that is a program designed

266
00:12:50,759 --> 00:12:53,409
将源代码转换为机器代码。
to convert source code to machine code.

267
00:12:53,409 --> 00:12:55,859
所以，如果我想真正解决，我需要做的所有事情
So all I need do if I want to actually solve

268
00:12:55,860 --> 00:13:01,140
如前所述的问题，因此我用C编写了这段代码
the problem as stated earlier, whereby I have written this code in C

269
00:13:01,139 --> 00:13:03,599
现在我需要将其转换为0和1
and I now need to convert it to 0's and 1's, I just

270
00:13:03,600 --> 00:13:06,180
需要授予自己访问编译器的权限。
need to give myself access to a compiler.

271
00:13:06,179 --> 00:13:09,569
事实证明，CS50 IDE中存在其中一种。
And it turns out one of those exists within CS50 IDE.

272
00:13:09,570 --> 00:13:13,230
这是你可以在自己的Mac或PC或类似设备上下载的工具。
And this is a tool you could download on your own Mac or PC or the like.

273
00:13:13,230 --> 00:13:16,680
现在，我们将把这个工具描述为非常简单的称呼
And for now, we're going to describe that tool as being quite simply called

274
00:13:16,679 --> 00:13:17,769
“制作。”
"make."

275
00:13:17,769 --> 00:13:20,249
从字面上看，如果我想编写程序，我就是
Literally, if I want to make my program, I'm

276
00:13:20,250 --> 00:13:22,197
继续并输入make hello。
going to go ahead and type make hello.

277
00:13:22,197 --> 00:13:24,989
然后，我将使用一些神秘的语法来运行它，
And then I'm going to run it with a little bit of a cryptic syntax,

278
00:13:24,990 --> 00:13:26,820
。/你好。
./hello.

279
00:13:26,820 --> 00:13:29,760
但是，让我们看看将这些结合在一起的实际效果。
But let's see that in action to tie this all together.

280
00:13:29,759 --> 00:13:32,969
我将光标移到终端窗口，
I'm going to move my cursor down into my terminal window,

281
00:13:32,970 --> 00:13:34,590
或我的命令行界面。
or my command line interface.

282
00:13:34,590 --> 00:13:36,360
我将按字面意义打招呼。
And I'm going to literally type hello.

283
00:13:36,360 --> 00:13:39,450
注意，我没有输入make hello.c。
Notice I am not typing make hello.c.

284
00:13:39,450 --> 00:13:42,600
我正在输入实际上要制作的程序的名称
I'm typing the name of the program I actually want to make

285
00:13:42,600 --> 00:13:45,090
我只是想给这个程序打个招呼。
and I just want to call this program hello.

286
00:13:45,090 --> 00:13:48,570
编译器将从此命令推断
The compiler is going to infer from this command

287
00:13:48,570 --> 00:13:51,960
我实际上打算编译一个名为hello.c的文件。
that I actually intend to compile a file called hello.c.

288
00:13:51,960 --> 00:13:53,460
我要继续并按Enter。
I'm going to go ahead and hit Enter.

289
00:13:53,460 --> 00:13:55,140
有一些疯狂的神秘输出。
There's some crazy cryptic output.

290
00:13:55,139 --> 00:13:56,609
改天再说。
More on that another day.

291
00:13:56,610 --> 00:13:59,790
但是我看不到任何严重的红色错误消息的事实
But the fact that I don't see any big scary red error messages

292
00:13:59,789 --> 00:14:00,749
是一件好事。
is a good thing.

293
00:14:00,750 --> 00:14:03,569
这意味着我的程序已成功编译。
This means that my program compiled successfully.

294
00:14:03,570 --> 00:14:04,170
为什么？
Why?

295
00:14:04,169 --> 00:14:07,679
只是没有黄色或红色消息要说其他话。
There's just no yellow or red messages to say otherwise.

296
00:14:07,679 --> 00:14:10,409
但是现在，如果我想实际运行该程序，
But now, if I want to actually run this program,

297
00:14:10,409 --> 00:14:13,169
我需要键入另一个类似于double的命令
I need to type a different command that's the analog of double

298
00:14:13,169 --> 00:14:15,659
点击Mac或PC或手机上的图标。
clicking an icon on your Mac or PC or phone.

299
00:14:15,659 --> 00:14:18,989
我将按字面意思输入./hello。
I'm going to type literally ./hello.

300
00:14:18,990 --> 00:14:23,550
./hello本质上就像是说进入计算机上的当前文件夹
./hello essentially is like saying go into the current folder on the computer

301
00:14:23,549 --> 00:14:26,189
我正在使用并寻找一个名为hello的程序。
I'm using and look for a program called hello.

302
00:14:26,190 --> 00:14:30,540
我要继续并按Enter键，瞧，世界。
I'm going to go ahead and hit Enter and voila, hello, world.

303
00:14:30,539 --> 00:14:34,132
现在，我再次在屏幕上看到一个美元符号和一些其他文本。
Now I see, again, a dollar sign and some other text on the screen.

304
00:14:34,133 --> 00:14:36,300
我们将稍微说明一下这是什么意思。
And we'll tease apart in just a bit what this means.

305
00:14:36,299 --> 00:14:39,929
但是请注意，这个美元符号只是持续不断的视觉提醒
But notice, this dollar sign is just a constant visual reminder

306
00:14:39,929 --> 00:14:43,887
提示所在的位置，可以在其中键入更多命令的位置。
of where my prompt is, where I can type more commands.

307
00:14:43,888 --> 00:14:45,930
计算机确实完成了我所要求的。
And the computer has done literally what I asked.

308
00:14:45,929 --> 00:14:47,339
它打印出你好，世界。
It printed out hello, world.

309
00:14:47,340 --> 00:14:49,590
现在，它正在等待我的第二条命令。
And now it's waiting for my second command.

310
00:14:49,590 --> 00:14:53,520
所以这就像只是在猫的嘴里打个招呼，打个比方。
So that was the analog of just printing hello, world out of the cat's mouth

311
00:14:53,519 --> 00:14:54,509
上个星期。
last week.

312
00:14:54,509 --> 00:14:56,489
但是，我们当然可以做得更多。
But surely we can do more than this.

313
00:14:56,490 --> 00:14:59,530
但是，让我们将其与上周的工作联系起来。
But let's tie it back to what we did last week as well.

314
00:14:59,529 --> 00:15:02,609
因此，并非此处的所有内容都如此不同。
So that not everything here is all that dissimilar.

315
00:15:02,610 --> 00:15:04,758
所以回想一下上周，我们有职能。
So recall that last week, we had functions.

316
00:15:04,758 --> 00:15:07,800
事实证明，尽管我们没有
And it turns out we had something called arguments, even though we didn't

317
00:15:07,799 --> 00:15:09,609
必然如此形容他们。
necessarily describe them as such.

318
00:15:09,610 --> 00:15:12,070
因此，功能就像一个小程序。
So a function is like a mini-program.

319
00:15:12,070 --> 00:15:14,580
这是你在写作时可以使用的动作或动词
It's an action or a verb that you can use when writing

320
00:15:14,580 --> 00:15:16,560
你自己的程序可以执行某些操作。
your own program that does something.

321
00:15:16,559 --> 00:15:18,599
上周我们看到了发言权障碍。
We saw the say block last week.

322
00:15:18,600 --> 00:15:20,370
上周我们看到了等待的机会。
We saw the wait block last week.

323
00:15:20,370 --> 00:15:23,730
这些是动词或动作，或更常见的功能。
Those were verbs, or actions, or more generally noticed functions.

324
00:15:23,730 --> 00:15:27,390
但是函数也可以接受输入，调用，我们上周确实看到了。
But functions can also take inputs, recall, and we did see that last week.

325
00:15:27,389 --> 00:15:31,859
如今，我们将开始调用函数参数的输入，
And nowadays, we're going to start calling inputs to functions arguments,

326
00:15:31,860 --> 00:15:32,680
可以这么说。
so to speak.

327
00:15:32,679 --> 00:15:34,859
它们的另一个术语是参数。
Another term for them is parameters.

328
00:15:34,860 --> 00:15:37,380
但是出于所有意图和目的，它们都是同义词。
But for all intents and purposes, those are synonyms.

329
00:15:37,379 --> 00:15:39,489
参数是函数的输入。
Arguments are the inputs to functions.

330
00:15:39,490 --> 00:15:41,490
那么，让我们考虑一下，从上周开始，
So let's consider then, from last week, the say

331
00:15:41,490 --> 00:15:45,750
我们上次看到的方块，只是想说出来
block that we saw last time, which simply is trying to say out

332
00:15:45,750 --> 00:15:47,429
猫的嘴，你好，世界。
of the cat's mouth, hello, world.

333
00:15:47,429 --> 00:15:51,479
好吧，让我继续，如果可以的话，将其转换为相应的C代码，
Well, let me go ahead and convert this, if you will, to corresponding C code,

334
00:15:51,480 --> 00:15:55,800
只是为了强调这两种语言在本质上是多么相似
just to emphasize how similar, fundamentally, these two languages

335
00:15:55,799 --> 00:16:00,119
即使在语法上C在外观上绝对不同。
are, even though syntactically C absolutely looks visually different.

336
00:16:00,120 --> 00:16:03,540
事实证明，如果你想用C语言说些话，
It turns out that if you want to say something in C,

337
00:16:03,539 --> 00:16:06,069
像我一样使用这种基于文本的语言，
using this text-based language like I just did,

338
00:16:06,070 --> 00:16:07,320
你不会写说。
you're not going to write say.

339
00:16:07,320 --> 00:16:08,940
相反，你将要写印刷品。
You're instead going to write print.

340
00:16:08,940 --> 00:16:10,320
这实际上是个谎言。
That's actually a bit of a white lie.

341
00:16:10,320 --> 00:16:11,280
你不会说印刷品。
You're not going to say print.

342
00:16:11,279 --> 00:16:14,196
实际上，你将要说printf，这是我们最终会看到的原因。
You're actually going to say printf, for reasons we'll eventually see.

343
00:16:14,197 --> 00:16:17,050
这意味着打印格式化的东西。
It means print a formatted something or other.

344
00:16:17,049 --> 00:16:20,579
因此，printf是Scratch中C语言的类似物。
So printf is the analog in C of say in Scratch.

345
00:16:20,580 --> 00:16:23,190
现在注意在C中，我已经有了这个开放的括号
Now notice in C, I've got this open parenthesis

346
00:16:23,190 --> 00:16:26,500
和圆括号，这很好地是卵形的。
and closed parenthesis that, nicely enough, are kind of ovular in shape.

347
00:16:26,500 --> 00:16:28,950
并注意，它们有点模仿白色椭圆形
And notice that they kind of mimic the white oval

348
00:16:28,950 --> 00:16:31,480
上周我们在其中提供了意见。
into which we provided input last week.

349
00:16:31,480 --> 00:16:33,690
所以在这两个括号之间
So in between those parentheses are going

350
00:16:33,690 --> 00:16:37,932
作为我对该函数printf的输入，也称为参数。
to be my inputs to this function printf, otherwise known as arguments.

351
00:16:37,932 --> 00:16:40,140
但是，本周它们将有所不同。
But they're going to be a little different this week.

352
00:16:40,139 --> 00:16:43,079
是的，我要打个招呼，世界，中间用逗号隔开，
Yes, I'm going to say hello, world, with a comma in between,

353
00:16:43,080 --> 00:16:44,790
在语法上，就像上周一样。
grammatically, just like last week.

354
00:16:44,789 --> 00:16:47,939
但是在C语言世界中，我必须更加具体一些。
But in the world of C, I have to be a little more particular.

355
00:16:47,940 --> 00:16:51,450
我还必须在左右添加双引号。
I also have to add double quotes on the left and the right.

356
00:16:51,450 --> 00:16:55,440
而且，有些烦人的是，我还必须添加一个分号
And, somewhat annoyingly, I also have to add a semicolon

357
00:16:55,440 --> 00:16:56,773
在此代码行的末尾。
at the end of this line of code.

358
00:16:56,773 --> 00:16:59,107
因此，就像英语或许多人类语言一样，
So just like in English, or in a lot of human languages,

359
00:16:59,106 --> 00:17:01,199
例如，你用句号结尾一个句子，
you end a sentence, for instance, with a period,

360
00:17:01,200 --> 00:17:04,470
在许多行代码中，你将用C编写
in many lines of code you will write in C

361
00:17:04,470 --> 00:17:08,650
在这种情况下，你还必须使用分号来结束你的想法。
you've also got to finish your thought, in this case, with a semicolon.

362
00:17:08,650 --> 00:17:11,369
因此，这是最右边的方法
So this, then, on the right, is the closest way

363
00:17:11,368 --> 00:17:16,556
分别将左侧的内容从Scratch转换为C。
of translating this thing on the left from Scratch to C respectively.

364
00:17:16,557 --> 00:17:17,890
因此，想法仍然是相同的。
So the ideas are still the same.

365
00:17:17,890 --> 00:17:19,410
但是语法看起来有些不同。
But the syntax looks a little different.

366
00:17:19,410 --> 00:17:21,702
最终，我们必须根深蒂固，
And we've just got to ingrain in ourselves, ultimately,

367
00:17:21,701 --> 00:17:24,659
这些模式是什么以及这些人类惯例是什么。
what these patterns are and what these human conventions are.

368
00:17:24,660 --> 00:17:28,990
但是请注意，我们刚才所做的工作遵循与上周相同的范例。
But notice that what we just did follows the same paradigm as last week.

369
00:17:28,990 --> 00:17:31,660
但是，让我们在本周再添加一些术语。
But let's add a little more terminology this week.

370
00:17:31,660 --> 00:17:35,250
上周，我们将黑匣子描述为可能是算法，
Last week, we described the black box as potentially being algorithms,

371
00:17:35,250 --> 00:17:36,060
最初。
initially.

372
00:17:36,059 --> 00:17:38,049
然后我们开始调用它们的功能。
And then we started calling them functions.

373
00:17:38,049 --> 00:17:42,779
函数只是算法的编程版本，实现
Functions are just a programmed version of an algorithm, the implementation

374
00:17:42,779 --> 00:17:45,389
在软件中的代码算法的概念。
of an algorithm in code, in software.

375
00:17:45,390 --> 00:17:49,050
因此，此处的功能可能表示为采用现在已经知道的输入
So a function might be represented here as taking inputs otherwise known now

376
00:17:49,049 --> 00:17:50,429
作为参数。
as arguments.

377
00:17:50,430 --> 00:17:54,540
但是事实证明，函数至少可以完成两种不同类型的事情
But it turns out that functions can do at least two different types of things

378
00:17:54,539 --> 00:17:55,892
在编程领域。
in the world of programming.

379
00:17:55,893 --> 00:17:58,560
我们已经看过这些东西，但是我们没有描述它们
And we've seen these things already, but we didn't describe them

380
00:17:58,559 --> 00:18:00,779
就像我们今天要做到的一样。
quite as particularly as we will today.

381
00:18:00,779 --> 00:18:04,289
当一个函数接受输入时，就是说参数，
When a function takes inputs, that is to say arguments,

382
00:18:04,289 --> 00:18:08,669
就像你好一样，世界是Scratch中say块的输入
just like hello, world is an input to the say block in Scratch

383
00:18:08,670 --> 00:18:14,070
或C语言中的printf函数，这些函数可能具有所谓的副作用。
or the printf function in C, functions can have what are called side effects.

384
00:18:14,069 --> 00:18:16,109
回想一下，我们上次确实看到了这一点。
And recall, we did see this last time.

385
00:18:16,109 --> 00:18:20,009
当我们使用say块时，它确实输出了一些内容。
When we used the say block, it did output something.

386
00:18:20,009 --> 00:18:23,639
但是从技术上讲，它具有副作用，视觉上的副作用。
But more technically, it had a side effect, a visual side effect.

387
00:18:23,640 --> 00:18:27,450
当我上周使用say块和本周使用printf函数时，
When I used the say block last week and the printf function this week,

388
00:18:27,450 --> 00:18:29,160
你会在屏幕上看到一些东西。
you see something on the screen.

389
00:18:29,160 --> 00:18:31,080
也就是说，是某种形式的输出。
And that is, yes, some form of output.

390
00:18:31,079 --> 00:18:34,139
但这与其他形式的输出有些不同
But it's a little different from a different form of output

391
00:18:34,140 --> 00:18:35,070
我们上次看到的。
that we saw last time.

392
00:18:35,069 --> 00:18:38,759
因此，功能的副作用通常是视觉上的
So a side effect of a function is often something visual

393
00:18:38,759 --> 00:18:43,047
在屏幕上发生的情况，例如文本或音频。
that happens on the screen, like text or audio in that case.

394
00:18:43,048 --> 00:18:45,840
但是我们将要看到的其他功能是功能
But there's this other feature of functions that we're going to see

395
00:18:45,839 --> 00:18:49,619
并利用今天称为返回值的方法，其中一个函数可以真正地
and leverage today known as return values, where a function can really

396
00:18:49,619 --> 00:18:51,339
只是给你一个价值。
just hand you back a value.

397
00:18:51,339 --> 00:18:53,099
它不会在屏幕上说出来。
It's not going to say it on the screen.

398
00:18:53,099 --> 00:18:55,439
它不会发出声音。
It's not going to vocalize it audibly.

399
00:18:55,440 --> 00:18:58,680
它将以某种方式将其传递回给你，程序员，
It's going to just pass it back to you in a way that you, the programmer,

400
00:18:58,680 --> 00:19:01,530
可以重用该函数的任何输出
can reuse whatever the output of that function

401
00:19:01,529 --> 00:19:03,939
是，理想情况下甚至将其存储在变量中。
was, ideally storing it even in a variable.

402
00:19:03,940 --> 00:19:07,110
例如，回想一下上周我们问过人类
So for instance, recall last week that we asked the human

403
00:19:07,109 --> 00:19:09,389
他们的名字通过这个Ask块。
their name by way of this ask block.

404
00:19:09,390 --> 00:19:13,020
这个白色椭圆形的Ask块的输入是，你叫什么名字。
And the input to the ask block in this white oval was, what's your name.

405
00:19:13,019 --> 00:19:17,129
然后回想一下，上个星期这个问题块有点特殊。
And then recall that this ask block was a little special last week.

406
00:19:17,130 --> 00:19:21,900
因为它使我们能够访问人类最终输入的内容。
Because it gave us access to whatever the human ultimately typed in.

407
00:19:21,900 --> 00:19:27,660
也就是说，上周的ask块实际上返回了一个值。
And that is to say that the ask block last week essentially returned a value.

408
00:19:27,660 --> 00:19:32,790
它不仅会盲目地在屏幕上显示人类输入的任何单词。
It didn't just blindly display whatever word the human typed in on the screen.

409
00:19:32,789 --> 00:19:36,419
不，它在某种意义上隐喻地返回了它
No, it instead returned it in some sense metaphorically

410
00:19:36,420 --> 00:19:39,798
并将其存储在一个名为answer的特殊变量中。
and stored it in a special variable called answer.

411
00:19:39,798 --> 00:19:41,340
同样，这就是区别。
And so, again, that's the difference.

412
00:19:41,339 --> 00:19:44,039
say块实际上在屏幕上说出一些内容。
The say block literally says something on the screen.

413
00:19:44,039 --> 00:19:46,109
并立即产生视觉效果。
And there's an immediate visual effect.

414
00:19:46,109 --> 00:19:48,899
使用Ask块，输入你的姓名后，
With the ask block, after you type in your name,

415
00:19:48,900 --> 00:19:53,340
你不会在屏幕上看到你的姓名被打印或再次显示。
you don't see your name printed or displayed again on the screen.

416
00:19:53,339 --> 00:19:56,009
取而代之的是，你的名字隐藏在一个变量中，
Instead, your name is sort of tucked away in a variable,

417
00:19:56,009 --> 00:20:00,239
就像数学家将数字存储在x或y或z这样的变量中一样。
just like a mathematician would store a number in a variable like x or y or z.

418
00:20:00,240 --> 00:20:02,610
上个星期，我们的责任就在程序员身上
The onus was then on us, the programmer, last week

419
00:20:02,609 --> 00:20:07,319
最终用我的名字来做某事
to eventually do something with the value, my name, that

420
00:20:07,319 --> 00:20:09,609
在那个叫做答案的变量中。
was in that variable called answer.

421
00:20:09,609 --> 00:20:13,139
那么，我们本周如何将上周的Ask块翻译为C？
So how are we going to translate last week's ask block to C this week?

422
00:20:13,140 --> 00:20:16,140
好吧，事实证明在C中有不同的方法可以做到这一点，没有一个
Well, it turns out there's different ways to do this in C, none of which

423
00:20:16,140 --> 00:20:20,020
除非你使用所谓的库，否则非常容易。
are very easy unless you use what's called a library.

424
00:20:20,019 --> 00:20:22,494
库是别人写的代码。
A library is code that someone else has written.

425
00:20:22,494 --> 00:20:24,369
确实，我们今天将使用的一件事
And indeed, one of the things we'll use today

426
00:20:24,369 --> 00:20:28,479
是所谓的CS50库，它是一堆代码，不是很多，
is the so-called CS50 library, which is a bunch of code, not terribly much,

427
00:20:28,480 --> 00:20:32,560
员工和我写的只是为了使做简单的事情变得更容易。
that the staff and I wrote just to make it easier to do simple things.

428
00:20:32,559 --> 00:20:35,469
这些是我们将完全起飞的训练轮
These are training wheels of sorts that we'll take off completely

429
00:20:35,470 --> 00:20:36,702
在几周的时间内。
within a few weeks' time.

430
00:20:36,701 --> 00:20:38,409
但是为了快速起步，
But in order to get started quickly, it's

431
00:20:38,410 --> 00:20:41,690
这样将使操作变得更容易，例如从用户那里获取文本。
going to make it easier to do things like getting text from the user.

432
00:20:41,690 --> 00:20:44,530
因此，字符串是编程世界中的艺术术语。
So string is a term of art in the programming world.

433
00:20:44,529 --> 00:20:46,809
字符串是文本。
A string is text.

434
00:20:46,809 --> 00:20:47,709
这是一个词。
It's a word.

435
00:20:47,710 --> 00:20:48,310
这是一封信。
It's a letter.

436
00:20:48,309 --> 00:20:49,399
这是一段。
It's a paragraph.

437
00:20:49,400 --> 00:20:50,330
这是一页文字。
It's a page of text.

438
00:20:50,329 --> 00:20:52,149
它只是某种形式的文本。
It's just text in some form.

439
00:20:52,150 --> 00:20:55,210
字符串是计算机科学家所说的文本。
String is what a computer scientist would call text.

440
00:20:55,210 --> 00:20:58,150
get_string是一个我们编写的函数，我们将
get_string is a function that we wrote that we will

441
00:20:58,150 --> 00:21:00,340
提供给你确实需要输入。
provide to you that does take inputs.

442
00:21:00,339 --> 00:21:03,609
请注意，根据C此处的括号，它可以接受输入。
Notice, per the parentheses here in C, it can take input.

443
00:21:03,609 --> 00:21:05,109
该输入可能是什么？
What might that input be?

444
00:21:05,109 --> 00:21:06,909
好了，就像问块一样
Well, just like the ask block, it's going

445
00:21:06,910 --> 00:21:09,910
是人类最终应该看到的提示。
to be a prompt that the human should ultimately see.

446
00:21:09,910 --> 00:21:14,200
因此，除了使用此功能之外，还有更多的事情要做。
So there's a bit more involved, though, than just using this function.

447
00:21:14,200 --> 00:21:18,730
当你在C语言中使用get_string时，正如我们将在实时演示中很快看到的那样，
When you use get_string in C, as we will soon see in a live demo,

448
00:21:18,730 --> 00:21:20,910
你想用人的名字做某事。
you want to do something with the human's name.

449
00:21:20,910 --> 00:21:22,660
为了以人的名字做某事，
And to do something with the human's name,

450
00:21:22,660 --> 00:21:25,180
仅仅相信Scratch还不够
it's not quite sufficient to just trust that Scratch

451
00:21:25,180 --> 00:21:27,200
会为你将其放入变量中。
will put it in a variable for you.

452
00:21:27,200 --> 00:21:31,450
与大多数编程语言一样，在C语言中，它学究得多。
In C, as with most programming languages, it's a lot more pedantic.

453
00:21:31,450 --> 00:21:33,760
例如，如果你希望某些内容以变量结尾，
Like, if you want something to end up in a variable,

454
00:21:33,759 --> 00:21:35,099
你必须自己做。
you've got to do it yourself.

455
00:21:35,099 --> 00:21:38,649
麻省理工学院不会为你神奇地将其放在答案变量中。
MIT is not going to magically put it in an answer variable for you.

456
00:21:38,650 --> 00:21:40,040
你必须自己做。
You have to do it yourself.

457
00:21:40,039 --> 00:21:44,289
因此，你只需提供所需变量的名称，
So to do this, you simply come up with the name of the variable that you want,

458
00:21:44,289 --> 00:21:48,219
是x还是y或z，或更令人信服的是，
be it x or y or z, or more compellingly, answer,

459
00:21:48,220 --> 00:21:50,980
然后你使用等号，即单个等号。
and you use an equal sign, a single equal sign.

460
00:21:50,980 --> 00:21:55,870
即使在数学上这通常意味着在C的情况下相等，
And even though in math this generally implies equality, in the context of C,

461
00:21:55,869 --> 00:21:59,109
和大多数编程语言一样，实际上等号
and most programming languages, the equal sign actually

462
00:21:59,109 --> 00:22:01,029
就是我们所说的分配。
means what we'll call assignment.

463
00:22:01,029 --> 00:22:04,719
这意味着有效地复制右边的内容
It means, effectively, copy whatever is on the right

464
00:22:04,720 --> 00:22:07,130
进入左边的任何东西。
into whatever's on the left.

465
00:22:07,130 --> 00:22:10,150
因此，如果在右手边有一个功能，其作用在生活中
So if on the right-hand side there's a function whose purpose in life

466
00:22:10,150 --> 00:22:13,540
就是问人类他们叫什么名字
is to ask the human what their name is, that name

467
00:22:13,539 --> 00:22:16,569
最终将被从右复制到左
is going to get copied from right to left ultimately

468
00:22:16,569 --> 00:22:18,789
放入这个称为答案的变量中。
into this variable called answer.

469
00:22:18,789 --> 00:22:21,549
麻省理工学院在Scratch中自动为我们做到了。
MIT did that automatically for us in Scratch.

470
00:22:21,549 --> 00:22:24,499
在C语言中，你必须自己做。
In C, you have to do it yourself.

471
00:22:24,500 --> 00:22:26,649
但是你也必须更加特别。
But you have to be a little more particular, too.

472
00:22:26,650 --> 00:22:30,280
事实证明，在C语言世界中，你不能只拥有变量。
It turns out that in the world of C, you can't just have variables.

473
00:22:30,279 --> 00:22:34,089
你必须事先告诉计算机你想要什么类型的变量。
You have to tell the computer in advance what type of variable you want.

474
00:22:34,089 --> 00:22:38,049
具体来说，我要告诉计算机变量类型
And specifically, I'm going to tell the computer that the type of variable

475
00:22:38,049 --> 00:22:39,819
我要成为一个字符串。
I want is going to be a string.

476
00:22:39,819 --> 00:22:43,839
这样做的惯例是你从字面上写出类型的名称
And the convention for doing so is you literally write the name of the type

477
00:22:43,839 --> 00:22:47,169
你想要的字符串是到目前为止我们唯一看到的字符串。
that you want, string being the only one we've seen thus far.

478
00:22:47,170 --> 00:22:49,180
然后，编写变量的名称。
Then you write the name of the variable.

479
00:22:49,180 --> 00:22:53,810
然后，再次为该变量从右到左分配一个值，
And then, again, to assign a value to that variable from right to left,

480
00:22:53,809 --> 00:22:56,709
我们必须在这里使用单个等号。
we have to use the single equal sign here.

481
00:22:56,710 --> 00:22:58,450
而现在，只是一个短暂的停顿。
And now, just a quick pause.

482
00:22:58,450 --> 00:23:00,430
布赖恩，如果我们可以为此请人，
Brian, if we could call on someone for this,

483
00:23:00,430 --> 00:23:03,490
即使你以前从未编程过，如果你已经动心了
even if you've never programmed before, if you've taken to heart

484
00:23:03,490 --> 00:23:06,040
我之前的建议之一。
one of my pieces of advice earlier.

485
00:23:06,039 --> 00:23:08,109
我仍然想念一些东西。
I'm still missing something.

486
00:23:08,109 --> 00:23:11,709
我要如何完成此Scratch代码的翻译
How might I want to finish the translation of this Scratch code

487
00:23:11,710 --> 00:23:13,370
到右侧的C？
to C on the right-hand side?

488
00:23:13,369 --> 00:23:16,367
你能说出什么缺失？
What is missing from what you can tell?

489
00:23:16,367 --> 00:23:18,909
如果你之前进行过编程，则很有可能会立即跳出来。
If you've programmed before, odds are it will jump right out.

490
00:23:18,910 --> 00:23:20,500
如果你以前从未编程过，
If you've never programmed before, you'll

491
00:23:20,500 --> 00:23:22,250
必须回想一下我之前说的话。
have to think back on what I said earlier.

492
00:23:22,250 --> 00:23:23,919
雅各布，你怎么看？
Jacob, what do you think?

493
00:23:23,920 --> 00:23:24,995
听众：分号？
AUDIENCE: Semicolon?

494
00:23:24,994 --> 00:23:25,869
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

495
00:23:25,869 --> 00:23:28,959
只有一个愚蠢的分号
There's just one single, stupid semicolon

496
00:23:28,960 --> 00:23:32,980
该行末尾缺少的内容，这对于向计算机表明是必须的
missing at the end of the line, which is necessary to make clear to the computer

497
00:23:32,980 --> 00:23:34,810
到此为止。
that this is the end of this thought.

498
00:23:34,809 --> 00:23:36,532
我觉得这很愚蠢。
And I sort of impugn it as stupid.

499
00:23:36,532 --> 00:23:39,699
老实说，这是学习编码的最大挫败之一，
Because honestly, one of the biggest frustrations when learning how to code,

500
00:23:39,700 --> 00:23:42,730
正如今天，本周及以后发生的那样，
as will now happen today and this week and beyond,

501
00:23:42,730 --> 00:23:46,510
最初，你会忘记分号之类的愚蠢事物，
is initially you're going to forget stupid things like the semicolon,

502
00:23:46,509 --> 00:23:49,569
否则你将忘记单引号或括号，
or you're going to forget a single quote mark, or a parenthesis,

503
00:23:49,569 --> 00:23:50,539
或类似的东西。
or things like this.

504
00:23:50,539 --> 00:23:52,779
我今天能提供的最重要的建议
And the most important advice I can give today

505
00:23:52,779 --> 00:23:57,009
只是不要让那些愚蠢的事情感到沮丧。
is just try not to get frustrated by those kinds of stupid things.

506
00:23:57,009 --> 00:23:58,879
有趣得多。
It's a lot more interesting.

507
00:23:58,880 --> 00:24:01,900
在生活中，了解功能和循环非常有用
It's a lot more useful in life to understand functions and loops

508
00:24:01,900 --> 00:24:04,600
和条件，不要让自己沮丧
and conditions and not to let yourself get frustrated

509
00:24:04,599 --> 00:24:08,869
老实说，随着实践的发展，会出现一些次要的美学问题。
by the more minor aesthetic things that honestly will just come with practice.

510
00:24:08,869 --> 00:24:11,889
因此，如果你犯的第一个错误是缺少分号，
So if the very first mistake you make is missing a semicolon,

511
00:24:11,890 --> 00:24:14,650
这需要10分钟一个小时才能弄清楚
and it takes you 10 minutes, an hour to figure out what

512
00:24:14,650 --> 00:24:16,900
你的代码有错，完全正常。
is wrong with your code, totally normal.

513
00:24:16,900 --> 00:24:21,670
这些挫败感很快就会消失。
And those frustrations go away quite quickly in time.

514
00:24:21,670 --> 00:24:25,330
这样我们就可以将一个功能转换为另一个功能。
So we then have this translation of one function to another.

515
00:24:25,329 --> 00:24:27,549
我们还能从这里拿走它吗？
Where else can we take it from here?

516
00:24:27,549 --> 00:24:29,589
好吧，让我们来看看另一种翻译
Well, let's take a look at one other translation

517
00:24:29,589 --> 00:24:31,599
我们在那个Ask块之后使用的
that we used after that ask block.

518
00:24:31,599 --> 00:24:34,119
上周，在我们问了人类的名字之后，
Last week, after we asked the human their name,

519
00:24:34,119 --> 00:24:37,629
例如，通过为函数提供输入并获得一些输出，
as by providing an input to the function and getting some output,

520
00:24:37,630 --> 00:24:44,050
然后，我们继续对Ask的返回值或输出进行处理。
we then proceeded to do something with the return value or output of ask.

521
00:24:44,049 --> 00:24:46,029
再次，我们问了人类他们的名字。
Again, we asked the human their name.

522
00:24:46,029 --> 00:24:50,809
上周神奇地从头开始，将名称放入了答案变量。
Scratch magically, last week, put the name into the answer variable.

523
00:24:50,809 --> 00:24:52,519
但是后来我做了一些事情。
But then I did something with it.

524
00:24:52,519 --> 00:24:56,709
这就是我要区别副作用的意思，这种情况只是在发生
And this is what I mean to distinguish side effects, which just kind of happen

525
00:24:56,710 --> 00:24:58,900
对你来说，就像在屏幕上打印的东西一样，
to you, like something printing on the screen,

526
00:24:58,900 --> 00:25:04,400
就像猫从嘴里说出一些话，而不是返回值，
like the cat saying something out of its mouth, versus a return value,

527
00:25:04,400 --> 00:25:07,780
这是一条信息，就像人类键入的名字一样
which is a piece of information, like a name a human has typed

528
00:25:07,779 --> 00:25:13,309
存放在程序员可以稍后使用的地方。
in being stored somewhere where you, the programmer, can make use of it later.

529
00:25:13,309 --> 00:25:14,409
这不是发生在你身上。
It's not happening to you.

530
00:25:14,410 --> 00:25:16,840
它正交给你以后使用。
It's being handed to you for subsequent use.

531
00:25:16,839 --> 00:25:20,649
上周，为了一口气打个招呼逗号世界，
And last week, in order to say hello comma world all in one breath,

532
00:25:20,650 --> 00:25:23,560
可以这么说，我们有点不得不堆叠这些拼图
so to speak, we kind of had to stack these puzzle pieces

533
00:25:23,559 --> 00:25:27,699
在彼此的顶部，使输出连接到say的输入。
on top of one another, making the output of join the input of say.

534
00:25:27,700 --> 00:25:31,810
在C语言中，尽管这是一些新语法，但实际上要容易一些。
In C, this is actually a little easier even though it's some new syntax.

535
00:25:31,809 --> 00:25:34,449
同样，printf将成为类似的说法。
Again, printf is going to be the analog for say.

536
00:25:34,450 --> 00:25:36,660
我们刚才已经看到了。
And we've seen that a moment ago.

537
00:25:36,660 --> 00:25:38,410
我们仍然要加上括号。
We're still going to have the parentheses.

538
00:25:38,410 --> 00:25:40,077
我们仍然要使用分号。
We're still going to have the semicolon.

539
00:25:40,076 --> 00:25:42,039
那么现在输入里面有什么呢？
So what goes inside now the input?

540
00:25:42,039 --> 00:25:46,119
我如何提供问候，回答C？
How do I provide hello, answer to C?

541
00:25:46,119 --> 00:25:50,499
好吧，我将继续用双引号打个招呼，但是，
Well, I'm going to go ahead and do hello, in double quotes, but then,

542
00:25:50,500 --> 00:25:54,669
这种奇怪的新语法，％s。
this strange new syntax here, %s.

543
00:25:54,670 --> 00:25:59,170
这就是我们所说的格式代码，格式代码，因此
This is what we're going to call a format code, a format code, and hence

544
00:25:59,170 --> 00:26:01,125
printf中的f。
the f in printf.

545
00:26:01,125 --> 00:26:02,500
Printf不仅打印东西。
Printf doesn't just print things.

546
00:26:02,500 --> 00:26:04,879
它也可以打印格式代码。
It can print format codes as well.

547
00:26:04,880 --> 00:26:09,880
这只是在这里说出一些实际值而已的花哨语法。
And this is just fancy syntax for saying plug in some actual value here.

548
00:26:09,880 --> 00:26:12,010
不要从字面上打印出来。
Don't print out s literally.

549
00:26:12,009 --> 00:26:16,142
这是字符串s的占位符。
This is a placeholder for what will be s, a string.

550
00:26:16,143 --> 00:26:17,560
好吧，我想放什么呢？
Well, what do I want to put there?

551
00:26:17,559 --> 00:26:18,699
这也是新的东西。
Here's something new, too.

552
00:26:18,700 --> 00:26:21,250
在Scratch中，如果一个函数有两个输入，
In Scratch, if you had two inputs to a function,

553
00:26:21,250 --> 00:26:24,009
你将有两个这样的椭圆形，而另一个
you would have two ovals like this and this one

554
00:26:24,009 --> 00:26:28,059
在这里，你可以在其中输入单词或数字，也可以将变量拖动到其中。
here that you could either type words or numbers into or drag variables into.

555
00:26:28,059 --> 00:26:31,659
在C语言中，根本没有椭圆或图形的概念。
In C, there's no notion of ovals or graphics at all.

556
00:26:31,660 --> 00:26:34,900
因此，我们只是去上学，只用逗号。
So instead, we're just going to go old school and just use a comma.

557
00:26:34,900 --> 00:26:39,580
如果在括号之间使用逗号作为参数
If you use a comma in between the parentheses as the arguments

558
00:26:39,579 --> 00:26:43,029
或功能的输入，这会将左侧的功能分开
or inputs to a function, that's going to separate the one on the left

559
00:26:43,029 --> 00:26:45,969
从右边的那个开始，因此类似于
from the one on the right, thereby being analogous to having

560
00:26:45,970 --> 00:26:48,400
在Scratch世界中有两个椭圆形
two ovals in the world of Scratch now there's

561
00:26:48,400 --> 00:26:51,220
在这里可能在视觉上有些混乱。
something that's potentially a little visually confusing here.

562
00:26:51,220 --> 00:26:54,980
当然，这里和这里实际上有两个逗号。
There's actually two commas here, of course, and here.

563
00:26:54,980 --> 00:26:56,560
但是请注意重要的细节。
But notice the important detail.

564
00:26:56,559 --> 00:26:59,709
第一个是英文语法逗号
That first one, that's an English grammatical comma

565
00:26:59,710 --> 00:27:04,900
我已经在加引号的字符串（加引号的文本短语）中添加了内容。
that I've put inside of my quoted string, my quoted phrase of text.

566
00:27:04,900 --> 00:27:06,817
这与编程无关。
That has nothing to do with programming.

567
00:27:06,817 --> 00:27:08,650
那只是与英语有关。
That just has everything to do with English.

568
00:27:08,650 --> 00:27:11,440
这个逗号不在双引号中，
The fact that this comma is outside of those double quotes,

569
00:27:11,440 --> 00:27:14,620
但是，这意味着它在称为C的语言中非常重要。
though, means it's significant in this language called C.

570
00:27:14,619 --> 00:27:18,709
它将第一个参数与第二个参数分开。
And it separates first argument from second argument.

571
00:27:18,710 --> 00:27:20,770
这样，我们现在有能力
And so in this way do we have the ability now

572
00:27:20,769 --> 00:27:28,259
也以这种稍微新颖的方式使用printf在屏幕上说些什么。
to also say something on the screen using printf in this slightly new way.

573
00:27:28,259 --> 00:27:31,899
因此，让我继续前进，并真正做到这一点。
So let me go ahead then and do this for real.

574
00:27:31,900 --> 00:27:34,930
让我回到CS50 IDE。
Let me go back to CS50 IDE.

575
00:27:34,930 --> 00:27:37,780
我将继续进行该程序
And I'm going to go ahead and go back into this program

576
00:27:37,779 --> 00:27:39,969
在这里考虑片刻，我们如何
here and consider for just a moment how we

577
00:27:39,970 --> 00:27:43,780
可以改进这个最初打印的程序
can improve upon this very first program which literally just prints

578
00:27:43,779 --> 00:27:44,499
你好，世界。
hello, world.

579
00:27:44,500 --> 00:27:45,486
没那么有趣。
Not that interesting.

580
00:27:45,487 --> 00:27:46,570
我可以整天运行它。
I can run it all day long.

581
00:27:46,569 --> 00:27:48,169
它会说同样的话。
It's going to say the same thing.

582
00:27:48,170 --> 00:27:50,710
现在如何从用户那里获得输入？
How do I now get input from the user?

583
00:27:50,710 --> 00:27:55,040
好吧，事实证明，我可以简单地对此代码进行一点增强。
Well, it turns out that I can simply enhance this code a little bit.

584
00:27:55,039 --> 00:27:59,289
让我继续，先进行Scratch的翻译，
Let me go ahead and per the translation of Scratch earlier,

585
00:27:59,289 --> 00:28:05,649
让我做类似字符串的回答，等于get_string（“你叫什么名字？”）。
let me do something like string answer equals get_string("What's your name?").

586
00:28:08,319 --> 00:28:11,379
因此，我实际上是在键入我们刚才在C中看到的内容。
So I'm literally typing out what we saw in C a moment ago.

587
00:28:11,380 --> 00:28:13,940
我要记住我在这里的分号。
I'm going to remember my semicolon over here.

588
00:28:13,940 --> 00:28:17,630
然后，我现在必须更改第二行代码，不要打招呼，
And then I have to change this second line of code now to not say hello,

589
00:28:17,630 --> 00:28:21,350
世界，而是向％s打个招呼。
world, but instead to say hello, %s.

590
00:28:21,349 --> 00:28:24,619
然后，在双引号之外，我要用逗号
And then, outside of the double quotes, I'm going to do a comma

591
00:28:24,619 --> 00:28:28,069
然后从字面上提供答案一词，
and then provide literally the word answer, which

592
00:28:28,069 --> 00:28:29,749
是该变量的名称。
is the name of that variable.

593
00:28:29,750 --> 00:28:30,953
但是我还没有完成。
But I'm not quite done.

594
00:28:30,952 --> 00:28:32,119
这有点微妙。
And this is a little subtle.

595
00:28:32,119 --> 00:28:34,384
而且，在某些时候，你总是会忘记这一点。
And invariably, you'll forget this at some point, too.

596
00:28:34,384 --> 00:28:37,609
为了使用get_string，我必须使用这个东西
In order to use get_string, I have to use this thing

597
00:28:37,609 --> 00:28:40,729
称为CS50库，是工作人员编写的代码
called the CS50 library, code that the staff wrote

598
00:28:40,730 --> 00:28:42,470
你没有默认访问权限。
that you don't have default access to.

599
00:28:42,470 --> 00:28:45,230
为了做到这一点，我需要添加一行代码
And in order to do that, I need to add one line of code

600
00:28:45,230 --> 00:28:47,400
我们将稍作详细解释。
that we'll explain in more detail in a little bit.

601
00:28:47,400 --> 00:28:51,230
但就目前而言，只需相信通过添加以下代码行即可
But for now, just take it on faith that by adding this line of code

602
00:28:51,230 --> 00:28:55,370
在最顶部，包括CS50.h，现在
at the very top, include CS50.h, that will now

603
00:28:55,369 --> 00:28:59,359
允许我访问get_string函数，否则
give me access to the get_string function, which I otherwise

604
00:28:59,359 --> 00:29:00,411
将无法访问。
wouldn't have access to.

605
00:29:00,412 --> 00:29:02,870
好吧，现在我要回到终端窗口。
All right, now I'm going to go back to the terminal window.

606
00:29:02,869 --> 00:29:04,369
并注意这里的二分法。
And notice the dichotomy here.

607
00:29:04,369 --> 00:29:07,501
如果我只是运行./hello，那会很热情
If I just run ./hello, sort of enthusiastically,

608
00:29:07,501 --> 00:29:08,959
让我们看看我的新程序做什么。
let's see what my new program does.

609
00:29:08,960 --> 00:29:11,522
不幸的是，我将感到失望。
I'm about to be, unfortunately, disappointed.

610
00:29:11,521 --> 00:29:12,979
因为它仍然向世界问好。
Because it still says hello, world.

611
00:29:12,980 --> 00:29:15,770
你可能会直观地意识到问题所在，
And you might realize intuitively what the problem, of course,

612
00:29:15,769 --> 00:29:19,511
这是我实际上尚未重新编译为代码的地方。
here is I haven't actually recompiled to the code.

613
00:29:19,511 --> 00:29:21,469
因此，每当你更改代码时，
And so any time you make a change to your code,

614
00:29:21,470 --> 00:29:25,370
仅通过文件保存或控制来保存文件是不够的
it does not suffice to just save the file via file save or Control

615
00:29:25,369 --> 00:29:27,769
或Command-s，我需要重新编译。
or Command-s, I need to recompile it.

616
00:29:27,769 --> 00:29:30,539
并重新编译我的代码，没什么大不了的。
And to recompile my code, that's not such a big deal.

617
00:29:30,539 --> 00:29:33,169
我只输入make hello，输入。
I just type make hello, enter.

618
00:29:33,170 --> 00:29:36,050
用手指交叉，没有黄色或红色的恐怖文字。
Cross my fingers that there's no yellow or red scary text.

619
00:29:36,049 --> 00:29:37,429
一切都很好。
This is all good.

620
00:29:37,430 --> 00:29:40,010
看来已经编译成机器码了。
It seems to have compiled into machine code.

621
00:29:40,009 --> 00:29:42,859
现在，我可以重新输入./hello。
Now I can retype ./hello.

622
00:29:42,859 --> 00:29:43,789
然后输入
and enter.

623
00:29:43,789 --> 00:29:46,399
你会看到我的程序正在运行并在等我。
And you'll see now my program is running and waiting for me.

624
00:29:46,400 --> 00:29:50,182
让我继续输入我的名字，大卫打招呼，大卫。
Let me go ahead and type my name, David enter hello, David.

625
00:29:50,182 --> 00:29:52,640
让我继续并在清除屏幕后再次运行它。
Let me go ahead and run it again after clearing the screen.

626
00:29:52,640 --> 00:29:53,473
让我再运行一次。
Let me run it again.

627
00:29:53,472 --> 00:29:55,519
这次，我叫布莱恩。
And this time, let's say my name is Brian.

628
00:29:55,519 --> 00:29:57,507
我问好，布莱恩。
And I say hello, Brian.

629
00:29:57,508 --> 00:29:59,300
与我们在Scratch中所做的非常相似，
So quite similar to what we did in Scratch,

630
00:29:59,299 --> 00:30:05,689
但是到目前为止，到目前为止，我们仅通过键盘就可以更有效地完成所有操作。
but now we're more powerfully doing this all thus far via my keyboard alone.

631
00:30:05,690 --> 00:30:07,490
好吧，所以很多。
All right, so that was a lot.

632
00:30:07,490 --> 00:30:10,190
我们打了招呼，世界超级快离开了我的记忆
We wrote hello, world super quickly off the top of my memory

633
00:30:10,190 --> 00:30:12,650
然后对其进行了增强，现在可以接受用户的输入了。
and then enhanced it to now take input from the user.

634
00:30:12,650 --> 00:30:13,940
让我在这里暂停。
Let me pause here.

635
00:30:13,940 --> 00:30:16,160
如有任何疑问，欢迎你提问
If there are any questions, you're welcome to ask

636
00:30:16,160 --> 00:30:18,950
通过聊天让员工或同学回答。
via chat for either staff or classmates to answer.

637
00:30:18,950 --> 00:30:22,430
但是，如果你想在Zoom中举起虚拟手，
But if you'd like to raise your virtual hand in Zoom,

638
00:30:22,430 --> 00:30:28,990
请随意，以便我可以在此处澄清或说明任何内容。
please feel free so that I can clarify or expound on anything here.

639
00:30:28,990 --> 00:30:31,235
是的，Ryan有问题吗？
Yeah, question from Ryan?

640
00:30:31,234 --> 00:30:32,859
听众：我在聊天中问过这个问题。
AUDIENCE: I had asked this in the chat.

641
00:30:32,859 --> 00:30:37,459
但是答案之前的字符串不是变量的名称。
But so the string before the answer, that's not the name of the variable.

642
00:30:37,460 --> 00:30:44,360
因此，假设你可以使它像字符串A或其他任何字符串。
So hypothetically, you could make it, like, string A or string anything else.

643
00:30:44,359 --> 00:30:47,374
字符串名称后面紧跟着什么是重要的？
It just matters what comes after string is the name of the variable?

644
00:30:47,375 --> 00:30:48,250
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

645
00:30:48,250 --> 00:30:49,180
真的很好的问题。
Really good question.

646
00:30:49,180 --> 00:30:52,390
在Scratch的世界中，你需要
In the world of Scratch, you were required

647
00:30:52,390 --> 00:30:54,310
使用称为“答案”的变量。
to use the variable called "answer."

648
00:30:54,309 --> 00:30:57,979
在C语言中，我们可以完全灵活地完成自己想做的事情。
In C, we have the complete flexibility over what we want to do.

649
00:30:57,980 --> 00:31:02,652
因此，正如瑞安（Ryan）提议的那样，我可以将变量的名称简称为A。
So as Ryan proposed, I could change my variable's name to just A for short.

650
00:31:02,652 --> 00:31:04,360
我也必须在其他地方更改它，
I would have to change it elsewhere, too,

651
00:31:04,359 --> 00:31:06,969
明确说明正在使用的变量
to make clear that the variable being used

652
00:31:06,970 --> 00:31:08,560
是同一个，只是名字不同。
is the same one by a different name.

653
00:31:08,559 --> 00:31:09,759
很好
That's perfectly fine.

654
00:31:09,759 --> 00:31:15,279
但是，这是我们现在要讨论的一种更好的样式的地方。
But here's where we now get into a matter of better style.

655
00:31:15,279 --> 00:31:19,389
拥有一个仅称为A的变量，它实际上并不适合自己
Having a variable called just A, it doesn't really lend itself

656
00:31:19,390 --> 00:31:20,780
代码的可读性。
to the readability of your code.

657
00:31:20,779 --> 00:31:22,571
我现在可以浏览一下我的代码，就像
I might now glance at my code and be, like,

658
00:31:22,571 --> 00:31:24,849
变量A是什么？
what is the variable A. It's a little better when

659
00:31:24,849 --> 00:31:27,909
编写好的代码实际上更加冗长
it comes to writing good code to actually be more verbose

660
00:31:27,910 --> 00:31:31,120
在这种情况下，请使用“ answer”之类的实际字词。
and using an actual word like "answer" in this case.

661
00:31:31,119 --> 00:31:34,029
确实，即使我一直将x和y和z描述为
Indeed, even though I keep describing x and y and z as the go

662
00:31:34,029 --> 00:31:36,159
数学家的变量，那些真的
to variables for a mathematician, those really

663
00:31:36,160 --> 00:31:39,200
在笛卡尔平面的上下文之外什么也没说。
say nothing outside the context of a Cartesian plane.

664
00:31:39,200 --> 00:31:42,880
因此，在用C或Scratch或其他方式编写的程序中，
So in a program that you write in C or Scratch or anything else,

665
00:31:42,880 --> 00:31:48,280
使用描述性变量名也是一个好习惯。
using descriptive variable names is a matter of good style as well.

666
00:31:48,279 --> 00:31:49,664
乔纳森，交给你。
Jonathan, over to you.

667
00:31:49,664 --> 00:31:50,289
听众：是的。
AUDIENCE: Yeah.

668
00:31:50,289 --> 00:31:51,289
只是一个简单的问题。
Just a quick question.

669
00:31:51,289 --> 00:31:54,639
我们为什么必须每次都编译代码？
How come we have to compile the code every single time?

670
00:31:54,640 --> 00:31:57,310
与不同的IDE不同，如果你只运行代码，
And unlike different IDEs, which if you just run the code,

671
00:31:57,309 --> 00:31:59,019
它会自动编译。
it automatically compiles.

672
00:31:59,019 --> 00:32:00,469
为什么我们必须手动执行此操作？
Why do we have to manually do it?

673
00:32:00,470 --> 00:32:00,950
戴维·马兰：是的。
DAVID MALAN: Yeah.

674
00:32:00,950 --> 00:32:01,875
真的很好的问题。
Really good question.

675
00:32:01,875 --> 00:32:03,750
为什么你必须继续重新编译代码？
Why do you have to keep recompiling the code?

676
00:32:03,750 --> 00:32:07,990
简短的答案仅仅是因为这就是C的方式。
The short answer is just because this is the way C is.

677
00:32:07,990 --> 00:32:10,600
这是一种较古老的语言，至今已有数十年历史了。
It's an older language, decades now old.

678
00:32:10,599 --> 00:32:13,299
因此，那时一切都非常有意。
And so back then, everything was very deliberate.

679
00:32:13,299 --> 00:32:15,369
用户界面不是最重要的。
User interface was not the top priority.

680
00:32:15,369 --> 00:32:17,749
例如，性能是这样。
Performance instead was, for instance.

681
00:32:17,750 --> 00:32:21,339
因此，如今，出现了更高级的集成开发环境。
And so nowadays, there are fancier integrated development environments.

682
00:32:21,339 --> 00:32:25,509
你们当中有些人可能已经使用了在线代码学院（codecademy）或co.org等工具，
And some of you might have used things like codecademy online, or co.org,

683
00:32:25,509 --> 00:32:28,449
实际上，通常会有一个播放按钮
where there's very often literally a play button that you can just

684
00:32:28,450 --> 00:32:31,300
在用户界面中单击，它将只播放你的程序
click in the user interface, and it just plays your program

685
00:32:31,299 --> 00:32:32,664
或运行你的程序。
or runs your program.

686
00:32:32,664 --> 00:32:34,539
我们在这堂课上正在向你展示
What we're doing in this class is showing you

687
00:32:34,539 --> 00:32:36,319
这些按钮在做什么。
what those buttons are doing.

688
00:32:36,319 --> 00:32:39,879
因此，如果你确实在这样的环境中使用，似乎可以实现此目的，
So if you do use in an environment like that that seems to automate this,

689
00:32:39,880 --> 00:32:40,755
它仍在发生。
it's still happening.

690
00:32:40,755 --> 00:32:43,463
但是出于我们的目的，当然是在学期开始时，
But for our purposes, certainly at the beginning of the semester,

691
00:32:43,462 --> 00:32:45,399
我们将自己手动进行。
we're going to do it manually ourselves.

692
00:32:45,400 --> 00:32:48,275
在学期末，当我们完全引入另一种语言时，
Later in the term, when we introduce a different language altogether,

693
00:32:48,275 --> 00:32:51,110
例如，Python，然后有点像你
for instance, Python, then kind of, sort of you

694
00:32:51,109 --> 00:32:55,149
不再需要编译了，但是在接下来的几周内会进行更多的编译。
don't need to compile anymore, but more on that in a few weeks.

695
00:32:55,150 --> 00:32:56,050
好问题。
Good question.

696
00:32:56,049 --> 00:32:56,919
索菲亚？
Sophia?

697
00:32:56,920 --> 00:32:57,933
交给你。
Over to you.

698
00:32:57,932 --> 00:32:59,349
听众：我有一个问题-
AUDIENCE: I had a question about--

699
00:32:59,349 --> 00:33:01,057
我在源代码中注意到
I noticed in the source code that there's

700
00:33:01,057 --> 00:33:04,389
字符串末尾的反斜杠（如n）。
a backslash like n at the end of the string.

701
00:33:04,390 --> 00:33:07,503
即使只是一行，每次都需要吗？
Is that necessary for every time, even if it's just one line?

702
00:33:07,502 --> 00:33:08,919
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

703
00:33:08,920 --> 00:33:12,310
你在其他地方看到的反斜杠n有点令人讨厌。
This backslash n that you're seeing elsewhere, a bit of a spoiler.

704
00:33:12,309 --> 00:33:15,369
但是，是的，让我们继续解决我们已经看到的这个问题，
But yeah, let's go ahead and fix this problem that we've seen,

705
00:33:15,369 --> 00:33:16,989
即使我有点无视。
even though I'm kind of ignoring it.

706
00:33:16,990 --> 00:33:18,893
你知道，现在有一点特别之处。
You know, this now gets a little particular.

707
00:33:18,893 --> 00:33:20,560
但是，老实说，这看起来有点愚蠢。
But this looks kind of stupid, honestly.

708
00:33:20,559 --> 00:33:23,619
它打招呼，Brian tilde斜杠美元符号。
It says hello, Brian tilde slash dollar sign.

709
00:33:23,619 --> 00:33:25,629
就像，那不是我想要的输出。
Like, that is not my intended output.

710
00:33:25,630 --> 00:33:28,900
我只是想打个招呼，布莱恩，或者打招呼，大卫。
I literally only wanted to say hello, Brian, or hello, David.

711
00:33:28,900 --> 00:33:32,995
这里的视觉伪像，美元符号，代字号和斜线
This visual artifact here, the dollar sign and the tilde and the slash

712
00:33:32,994 --> 00:33:36,014
与我的终端窗口有关，此命令行环境
have to do with my terminal window, this command line environment

713
00:33:36,015 --> 00:33:36,640
我正在使用。
that I'm using.

714
00:33:36,640 --> 00:33:38,890
老实说，只是有点挑剔，
And honestly, just to be a little nitpicky,

715
00:33:38,890 --> 00:33:40,870
坦白说，它可能应该换上新的一行。
frankly, it should probably be on a new line.

716
00:33:40,869 --> 00:33:45,189
它应该只是在自己的行上，所以不要与我自己的输出混淆。
It should just be on its own line so it's not confused with my own output.

717
00:33:45,190 --> 00:33:48,260
正如索菲（Sophie）所指出的，对此有一个解决方案。
And as Sophie notes, there is a solution to this.

718
00:33:48,259 --> 00:33:51,909
但是，同样，每隔一周，你需要在编写算法时
But, again, per last week, you need to m when writing algorithms

719
00:33:51,910 --> 00:33:54,610
反过来，代码也必须非常精确。
and in turn, code, you have to be super precise.

720
00:33:54,609 --> 00:33:57,639
我没有在代码中告诉计算机
Nowhere in my code have I told the computer

721
00:33:57,640 --> 00:33:59,950
将光标移动到下一行。
to move the cursor to the next line.

722
00:33:59,950 --> 00:34:07,540
因此，我可以通过在％s之后立即执行反斜杠n来明确地执行此操作
So I can do that explicitly by doing backslash n immediately after the %s

723
00:34:07,539 --> 00:34:09,979
但仍在双引号内。
but still inside of the double quotes.

724
00:34:09,980 --> 00:34:13,900
这是告诉计算机的简写形式，
This is shorthand notation for what would be telling the computer,

725
00:34:13,900 --> 00:34:15,860
将光标移动到下一行。
move the cursor to the next line.

726
00:34:15,860 --> 00:34:19,100
现在你可能会认为，好吧，为什么我不像这样按Enter键？
Now you might think that, well, why don't I just hit Enter like this?

727
00:34:19,099 --> 00:34:23,198
即使这对我们大多数人来说都是新事物，只要说
And even though this is all might be new to most of us, suffice it to say

728
00:34:23,199 --> 00:34:25,510
感觉就像很快就会变得混乱。
this just feels like it's going to get messy quickly.

729
00:34:25,510 --> 00:34:27,909
如果你在代码中间点击Enter键，
If you start hitting Enter in the middle of your code,

730
00:34:27,909 --> 00:34:29,659
那可能不是正确的解决方案。
that's probably not the right solution.

731
00:34:29,659 --> 00:34:32,320
因此，程序员几年前决定
So instead, programmers years ago decided

732
00:34:32,320 --> 00:34:35,590
提出反斜杠n之类的速记符号，否则称为
to come up with shorthand notation like backslash n, otherwise known

733
00:34:35,590 --> 00:34:41,800
作为向计算机发出信号的转义字符，请在此处添加新行。
as an escape character that signals to the computer, put a new line here.

734
00:34:41,800 --> 00:34:43,780
所以反斜杠n是换行符。
So backslash n is new line.

735
00:34:43,780 --> 00:34:45,489
让我继续进行重新编译。
And let me go ahead and recompile this.

736
00:34:45,489 --> 00:34:50,230
保存文件后，让我继续打个招呼。
After saving my file, let me go ahead and do make hello.

737
00:34:50,230 --> 00:34:52,210
看来编译OK了。 。/你好。
It seems to compile OK. ./hello.

738
00:34:52,210 --> 00:34:54,400
让我继续输入Brian的名字。
And let me go ahead and type in Brian's name again.

739
00:34:54,400 --> 00:34:58,010
瞧，输出还是一样，但是有点干净。
And voila, still the same output, but it's a little cleaner.

740
00:34:58,010 --> 00:35:00,880
因此，我们现在在管家方面要好一些。
So we're being a little bit better about housekeeping now.

741
00:35:00,880 --> 00:35:03,580
真的很好的问题。
Really good question.

742
00:35:03,579 --> 00:35:06,206
是BJ吗？
BJ is it?

743
00:35:06,206 --> 00:35:06,789
听众：是的。
AUDIENCE: Yes.

744
00:35:06,789 --> 00:35:09,609
所以我有一个问题是为什么你没有
So one question I had is why don't you have

745
00:35:09,610 --> 00:35:13,930
调用函数get string以便你请求输入？
to call the function get string in order for you for it to ask for input?

746
00:35:13,929 --> 00:35:17,484
就像，当你将输入分配给变量答案时，它仍然会询问你的输入。
Like, it still asked your input when you assigned it to the variable answer.

747
00:35:17,485 --> 00:35:19,068
大卫·马兰（David MALAN）：啊，这是一个很好的问题。
DAVID MALAN: Ah, really good question.

748
00:35:19,068 --> 00:35:21,310
例如，为什么我不必调用get字符串，
Why don't I have to call get string, for instance,

749
00:35:21,309 --> 00:35:23,679
通过自己放置一条线？
by putting it on a line of its own?

750
00:35:23,679 --> 00:35:28,149
C和许多编程语言的工作方式是
The way that C and a lot of programming languages work is they

751
00:35:28,150 --> 00:35:31,150
例如，将评估整行代码，
will evaluate an entire line of code, for instance,

752
00:35:31,150 --> 00:35:36,370
至少在这种情况下，我在第6行从右到左的位置。
what I have here on line six from right to left, at least in this context.

753
00:35:36,369 --> 00:35:39,729
当你像我在此处那样在代码中使用等号时，
When you have an equal sign in the code like I do here,

754
00:35:39,730 --> 00:35:43,000
告诉你首先要执行的计算机，
that's telling the computer you first have to execute,

755
00:35:43,000 --> 00:35:45,640
就是按照右边所说的去做。
that is do what is said on the right-hand side.

756
00:35:45,639 --> 00:35:47,799
然后不管那个东西的输出是什么，
And then whatever the output of that thing is,

757
00:35:47,800 --> 00:35:49,880
将其存储在左侧。
store it on the left-hand side.

758
00:35:49,880 --> 00:35:53,470
所以它确实正在执行，我们现在正在散布一些东西
So it is indeed getting executed, we're just now spreading things out

759
00:35:53,469 --> 00:35:57,559
如果可以的话，可以在更长的代码行上这样做。
on longer lines of code, if you will, if that makes sense.

760
00:35:57,559 --> 00:36:02,799
所以get字符串正在执行，因为它出现在该行上。
So get string is getting executed because it appears on that line.

761
00:36:02,800 --> 00:36:03,310
好的。
All right.

762
00:36:03,309 --> 00:36:05,229
坦率地说，我们一直认为是理所当然的，
So we've been taking for granted, frankly,

763
00:36:05,230 --> 00:36:08,110
这些程序的一些细节可能是
a few details of these programs that it's probably

764
00:36:08,110 --> 00:36:09,790
公平地开始开玩笑。
only fair to start teasing apart.

765
00:36:09,789 --> 00:36:11,739
例如，有int，main，void，
For instance, there was that int, main, void,

766
00:36:11,739 --> 00:36:13,209
以及其他许多语法
and a whole bunch of other syntax.

767
00:36:13,210 --> 00:36:15,730
因此，让我们来梳理一下其他一些代码行
So let's tease apart some of these other lines of code

768
00:36:15,730 --> 00:36:18,760
我只是从记忆中敲出了我的头顶，但是有点
that I just typed off the top of my head from memory, but kind of do

769
00:36:18,760 --> 00:36:21,143
需要在你编写的每个C程序中都存在。
need to be there in every C program you write.

770
00:36:21,143 --> 00:36:23,560
让我们至少开始理解其中的一些细节。
Let's at least start to make sense of some of that detail.

771
00:36:23,559 --> 00:36:27,249
回想一下，在Scratch中，我们一开始总是启动我们的程序
Recall that in Scratch, we always started our programs initially

772
00:36:27,250 --> 00:36:29,319
单击绿色标志时。
with when green flag clicked.

773
00:36:29,320 --> 00:36:34,000
最终，我们看到了其他拼图碎片，例如当你听到某个事件时，
We eventually saw some other puzzle pieces, like when you hear an event,

774
00:36:34,000 --> 00:36:36,160
或摄像机运动时。
or when there's camera motion.

775
00:36:36,159 --> 00:36:40,329
但这确实开始了我们在Scratch中编写的大多数程序。
But this really kick started most of the programs that we wrote in Scratch.

776
00:36:40,329 --> 00:36:45,339
绿旗单击拼图时的C中的类似物是什么？
What is the analog in C of the when green flag clicked puzzle piece?

777
00:36:45,340 --> 00:36:46,540
本质上就是这个。
It's essentially this.

778
00:36:46,539 --> 00:36:49,119
今天我们将不花时间详细解释
We won't spend time in detail today explaining

779
00:36:49,119 --> 00:36:53,169
为什么是int，为什么是void，为什么有花括号，为什么有括号。
why it's int, why it's void, why there's curly braces, why there's parentheses.

780
00:36:53,170 --> 00:36:55,870
仅出于今天的目的，让我规定
For today's purposes only, let me just stipulate

781
00:36:55,869 --> 00:37:00,159
这是绿色标记单击拼图时的模拟结果。
that this is the analog for this when green flag clicked puzzle piece.

782
00:37:00,159 --> 00:37:02,259
你刚开始要启动程序
You've just got to start your programs initially

783
00:37:02,260 --> 00:37:04,750
可以这么说。
with this kind of boilerplate code, so to speak.

784
00:37:04,750 --> 00:37:07,092
我们将开始更详细地解释这一点。
We will start to explain this in much more detail.

785
00:37:07,092 --> 00:37:08,800
但就目前而言，只要相信这一点
But for now, just take on faith that this

786
00:37:08,800 --> 00:37:10,630
是你开始编写程序的方式。
is how you start writing a program.

787
00:37:10,630 --> 00:37:14,260
但是，到目前为止，我们当然已经编写了一些程序。
But there's, of course, a little more to the programs we've written thus far.

788
00:37:14,260 --> 00:37:17,780
特别是，我们已经看到了称为标头文件的两件事。
And particularly, we've seen a couple of things called header files.

789
00:37:17,780 --> 00:37:22,480
这是另一个艺术术语，指的是用该语言编写的文件
This is another term of art that refers to a file written in the language

790
00:37:22,480 --> 00:37:27,580
名为C，名称的后缀不是.c，而是.h。
called C whose name ends with not .c, but with .h.

791
00:37:27,579 --> 00:37:30,739
因此，我们之前已经看到了以下内容。
So we've seen these before as follows.

792
00:37:30,739 --> 00:37:33,909
回想一下，这是我们上周在Scratch中编写的最简单的程序。
Here, recall, was the simplest program we wrote last week in Scratch.

793
00:37:33,909 --> 00:37:37,029
当你单击绿色标志时，它只是打个招呼，世界。
It just says hello, world when you clicked on the green flag.

794
00:37:37,030 --> 00:37:40,270
这是模拟，右侧是更完整的模拟，
This is the analog, the more complete analog on the right,

795
00:37:40,269 --> 00:37:42,189
该程序的今天。
of that program today.

796
00:37:42,190 --> 00:37:43,540
但是有一些缺失。
But there's something missing.

797
00:37:43,539 --> 00:37:45,949
而且可能在你们当中有些人跳出来了，
And it's probably jumping out at some of you,

798
00:37:45,949 --> 00:37:48,849
因为该程序比以前短了一点。
because the program is a little shorter than it was before.

799
00:37:48,849 --> 00:37:51,169
缺少的东西，这是这里的线。
Something's missing, which is this line here.

800
00:37:51,170 --> 00:37:54,490
我刚才是从内存中写出来的，但是它指的是一个文件
And I just wrote that from memory earlier, but it's referring to a file

801
00:37:54,489 --> 00:38:00,759
称为stdio.h，代表标准输入输出点h。
called stdio.h, which stands for standard input output dot h.

802
00:38:00,760 --> 00:38:03,190
io是计算机世界的首字母缩写
So io is an acronym in the computer world

803
00:38:03,190 --> 00:38:05,360
通常只是指输入和输出。
that just generally refers to input and output.

804
00:38:05,360 --> 00:38:10,150
因此标准io.h只是一个非常流行的文件
So standard io.h is just a very popular file

805
00:38:10,150 --> 00:38:12,910
在C程序中使用的功能
that is used in C programs that gives you the ability

806
00:38:12,909 --> 00:38:15,369
从用户那里获取输入和输出。
to get input and output from the user.

807
00:38:15,369 --> 00:38:17,501
它通过为你提供printf来实现，
And it does so by providing you with printf,

808
00:38:17,501 --> 00:38:19,209
例如，哪个当然可以让你
for instance, which of course, allows you

809
00:38:19,210 --> 00:38:22,270
通过这些副作用产生某种形式的输出
to generate some form of output via those side effects

810
00:38:22,269 --> 00:38:23,769
我们之前介绍过的
that we described earlier.

811
00:38:23,769 --> 00:38:25,779
但是当我编写其他程序时，回想一下，
But when I wrote my other program, recall,

812
00:38:25,780 --> 00:38:28,630
正如BJ先前指出的那样，实际上得到了字符串，
that actually had get string, as BJ noted earlier,

813
00:38:28,630 --> 00:38:31,270
我可以从用户那里获得一行文字，
where I can get a line of text from the user,

814
00:38:31,269 --> 00:38:33,129
我完全需要其他东西。
I needed something else altogether.

815
00:38:33,130 --> 00:38:37,570
刚才我们添加了第二个头文件CS50.h。
And that's when we added, a moment ago, a second header file called CS50.h.

816
00:38:37,570 --> 00:38:41,770
因此，这些头文件仅使你可以访问更多功能
So these header files just give you access to more functions

817
00:38:41,769 --> 00:38:45,589
比你可能会自动从使用的语言中得到的，
than you might automatically get from the language you're using,

818
00:38:45,590 --> 00:38:46,840
这是C。
which here is C.

819
00:38:46,840 --> 00:38:48,880
精神上很相似，上周回想一下，
It's similar in spirit, recall last week,

820
00:38:48,880 --> 00:38:51,850
当我开始在Scratch的扩展菜单中随意拨弄时
when I started poking around Scratch's extension menu

821
00:38:51,849 --> 00:38:55,419
我使用了翻译块和语音块，
and I used the translate block and the voice block,

822
00:38:55,420 --> 00:38:59,230
扩展菜单下隐藏的一种更高级的功能。
the sort of fancier features that were buried under the extensions menu.

823
00:38:59,230 --> 00:39:04,240
在Scratch中使用扩展名类似于在C中使用头文件。
Using an extension in Scratch is similar to using a header file in C.

824
00:39:04,239 --> 00:39:08,139
它使我可以使用比你以前获得的功能更多的功能
It's giving me access to a bit more functionality than you otherwise get

825
00:39:08,139 --> 00:39:12,319
可以说是免费的。
for free out of the box, so to speak.

826
00:39:12,320 --> 00:39:14,680
好吧，让我继续提出
All right, well, let me go ahead and propose

827
00:39:14,679 --> 00:39:17,739
我有很多不同的方式
that there are so many different ways in which I

828
00:39:17,739 --> 00:39:22,239
在编写这些程序的过去几分钟中可能搞砸了。
could have screwed up over the past few minutes of writing these programs.

829
00:39:22,239 --> 00:39:24,789
正如我暗示的那样，我可能省略了分号。
I might have omitted a semicolon, as I implied.

830
00:39:24,789 --> 00:39:26,649
我可能没有关闭报价。
I might have not closed my quotes.

831
00:39:26,650 --> 00:39:28,450
我可能把括号弄错了。
I might have gotten my parentheses wrong.

832
00:39:28,449 --> 00:39:30,429
我可能完全拼错了单词。
I might have misspelled words altogether.

833
00:39:30,429 --> 00:39:33,339
我有很多方法可以搞砸该程序。
There's many different ways I could have screwed that program up.

834
00:39:33,340 --> 00:39:36,673
坦率地说，从记录上来说，我有点像我没拧螺丝一样
And frankly, off the record, I'm sort of crossing my fingers that I didn't screw

835
00:39:36,672 --> 00:39:38,229
一起建立我们的第一个程序。
up our very first program together.

836
00:39:38,230 --> 00:39:41,950
但总是在某个时候，也许不是你的第一个程序，
But invariably, at some point, maybe not your first program,

837
00:39:41,949 --> 00:39:45,999
但是在学习如何编程或学习如何用C编程的早期，
but early on in learning how to program or learning how to program in C,

838
00:39:46,000 --> 00:39:47,050
你会搞砸的。
you will screw up.

839
00:39:47,050 --> 00:39:48,730
而且你将要打错字。
And you're going to make some typo.

840
00:39:48,730 --> 00:39:51,758
你的理解之间会有一些脱节
There's going to be some disconnect between what your understanding is

841
00:39:51,757 --> 00:39:53,799
以及你要让计算机执行的操作。
and what you're trying to get the computer to do.

842
00:39:53,800 --> 00:39:56,710
这就是说，有一些工具，谢天谢地，
And this is to say there are tools, thankfully,

843
00:39:56,710 --> 00:39:59,260
可以帮助你解决这些问题。
that can help you solve those problems.

844
00:39:59,260 --> 00:40:01,060
其中第一个称为help50。
And the first of which is called help50.

845
00:40:01,059 --> 00:40:04,149
名称以50结尾的任何工具都是专门为
Any of the tools whose names end with 50 are specifically

846
00:40:04,150 --> 00:40:07,930
由CS50员工撰写的面向教育的临时培训
educationally oriented, written by CS50 staff, that are temporary training

847
00:40:07,929 --> 00:40:10,519
我们上课的前几个星期要使用的轮子
wheels that we'll use for the first several weeks of the class

848
00:40:10,519 --> 00:40:13,359
但最终，可选地，从某种意义上讲
but then eventually, optionally, take away in the sense

849
00:40:13,360 --> 00:40:15,470
你将不再需要它们。
that you won't need them anymore.

850
00:40:15,469 --> 00:40:17,619
所以help50是一个正在执行的命令
And so help50 is one command that's going

851
00:40:17,619 --> 00:40:20,919
使你可以解决你可能无法解决的问题
to allow you to troubleshoot problems that you might not otherwise

852
00:40:20,920 --> 00:40:24,020
显然可以在你自己的代码中看到。
see obviously in your own code.

853
00:40:24,019 --> 00:40:27,439
让我去模拟如下。
And let me go and simulate this as follows.

854
00:40:27,440 --> 00:40:29,980
让我回到我们的第一个程序
Let me go back to the very first program that we

855
00:40:29,980 --> 00:40:34,583
用C编写，这很简单，它只说了一个世界。
wrote in C, which was quite simply this one whereby it only said hello, world.

856
00:40:34,583 --> 00:40:37,250
我可能在这里有几个不同的地方。
And there's a few different places I could have screwed up here.

857
00:40:37,250 --> 00:40:39,939
例如，假设我有点超前
For instance, suppose I was getting a little ahead of myself

858
00:40:39,940 --> 00:40:45,250
我在程序顶部承认了标准的io.h文件。
and I admitted the standard io.h file at the top of my program.

859
00:40:45,250 --> 00:40:48,819
意思是现在我的电脑不
The implication is that now my computer is not

860
00:40:48,820 --> 00:40:54,370
将要知道什么是printf，因为标准io.h中并未包含它。
going to know what printf is, because it hasn't been included via standard io.h.

861
00:40:54,369 --> 00:40:56,529
因此，让我们看看错误消息是什么。
So let's see what the error message is.

862
00:40:56,530 --> 00:40:58,810
希望这将是一个非常不言自明的信息
Hopefully, it'll be a very self-explanatory message

863
00:40:58,809 --> 00:41:00,259
完全有道理。
that makes perfect sense.

864
00:41:00,260 --> 00:41:02,260
让我继续重新编译该程序，
Let me go ahead and recompile this program,

865
00:41:02,260 --> 00:41:04,300
知道它已经不正确了。
knowing it already to be incorrect.

866
00:41:04,300 --> 00:41:05,320
哦，天哪。
And oh, my God.

867
00:41:05,320 --> 00:41:10,310
就像，我的错误行多于实际的代码行。
Like, I have more lines of errors than I actually have lines of code.

868
00:41:10,309 --> 00:41:15,009
这是编程的现实。
And this is kind of a reality of programming.

869
00:41:15,010 --> 00:41:17,410
很多编程语言，很多工具，
A lot of programming languages, a lot of tools,

870
00:41:17,409 --> 00:41:20,469
坦率地说，在设计时并没有考虑到易用性，
frankly, were not designed with ease of use in mind,

871
00:41:20,469 --> 00:41:22,119
或用户友好的想法。
or user-friendliness in mind.

872
00:41:22,119 --> 00:41:25,149
他们在设计时确实考虑了简洁性和精确性。
They were really designed with succinctness and precision in mind.

873
00:41:25,150 --> 00:41:28,420
不幸的是，他们倾向于假设观众是
And they tend, unfortunately, to assume that the audience is

874
00:41:28,420 --> 00:41:30,702
和编写程序的人一样技术。
as technical as the person who wrote the program.

875
00:41:30,702 --> 00:41:33,160
当然，这可能会适得其反，当你只是学习如何
This, of course, can backfire when you're just learning how

876
00:41:33,159 --> 00:41:34,951
首先编程
to program in the first place, and you have

877
00:41:34,952 --> 00:41:37,810
这样可以理解疯狂的神秘输出。
to make sense of crazy cryptic output like this.

878
00:41:37,809 --> 00:41:40,569
今天，我们不必专注于每个单词
Today we don't have to focus on every single word that's

879
00:41:40,570 --> 00:41:43,600
在屏幕上输出，但让我们开始识别模式。
been outputted on the screen, but let's start to recognize patterns.

880
00:41:43,599 --> 00:41:45,669
走进新的空间并认识到
Walking into a new space and just recognizing

881
00:41:45,670 --> 00:41:49,120
物理世界中熟悉的对象，让我们现在用代码来完成。
familiar objects in the physical world, let's now do that with code.

882
00:41:49,119 --> 00:41:53,739
也许最重要的是要注意的是，当你搞砸时
The most important thing, perhaps, to take notice of is that when you mess up

883
00:41:53,739 --> 00:41:56,979
并且你在代码中犯了一些错误，以致你的程序甚至无法
and you make some mistake in your code such that your program doesn't even

884
00:41:56,980 --> 00:41:59,650
从源代码编译成机器代码，
compile from source code into machine code,

885
00:41:59,650 --> 00:42:03,520
很有可能你会看到错误输出顶部的线索
odds are you're going to see a clue toward the top of the erroneous output

886
00:42:03,519 --> 00:42:05,889
告诉你混乱的文件名
that tells you the name of the file where you messed up

887
00:42:05,889 --> 00:42:07,989
以及你搞砸的行号。
and the line number where you messed up.

888
00:42:07,989 --> 00:42:11,349
三个代表第三行，然后五个可能
Three implying line three, and then five might

889
00:42:11,349 --> 00:42:14,529
暗示该行中的哪一列或什么字符，
imply what column or what character in that line,

890
00:42:14,530 --> 00:42:17,900
但这是否有用取决于特定的问题。
but it depends on the particular problem if that's that useful.

891
00:42:17,900 --> 00:42:22,510
所以在第三行，我得到一个错误，隐式声明了库函数
So on line three, I am getting an error, implicitly declaring library function

892
00:42:22,510 --> 00:42:25,090
类型为int const char star的printf。
printf with type int const char star.

893
00:42:25,090 --> 00:42:27,550
我的意思是，像谁知道那意味着什么？
I mean, like, who knows what that even means?

894
00:42:27,550 --> 00:42:29,060
你最终会。
You will eventually.

895
00:42:29,059 --> 00:42:31,779
但是就今天而言，这仅意味着出了一些问题。
But for today, it just means something bad went wrong.

896
00:42:31,780 --> 00:42:32,980
而且你可能看不到它。
And you might not see it.

897
00:42:32,980 --> 00:42:35,050
你可能不知道，如果我没有告诉你，
You might not know, if I hadn't told you,

898
00:42:35,050 --> 00:42:37,135
我故意删除了这一行。
that I intentionally deleted that line.

899
00:42:37,135 --> 00:42:39,760
因此，让我们看看使用此工具是否无法理解这一点。
So let's see if we can't make sense of this by using this tool.

900
00:42:39,760 --> 00:42:42,820
Help50是CS50员工编写的工具，
Help50 is a tool written by CS50 staff that

901
00:42:42,820 --> 00:42:46,570
将有助于翻译奥术秘密计算机
will help translate arcane cryptic computer

902
00:42:46,570 --> 00:42:51,010
传达给更多人性化建议和问题的消息
messages to more human friendly advice and questions

903
00:42:51,010 --> 00:42:54,070
你的教学研究员或助教可能会为你提供帮助，
that you're teaching fellow or teaching assistant might offer you,

904
00:42:54,070 --> 00:42:56,030
例如，在办公时间范围内。
say, in the context of office hours.

905
00:42:56,030 --> 00:42:59,740
因此要使用help50，而不是一次又一次地运行相同的命令
So to use help50, instead of running the same command again and again

906
00:42:59,739 --> 00:43:03,129
并看到相同的错误输出，字面上恰好是正确的帮助50
and seeing the same erroneous output, literally just right help50

907
00:43:03,130 --> 00:43:07,960
首先，在你的终端窗口中，然后编写相同的确切命令
first, at your terminal window, then write the same exact command

908
00:43:07,960 --> 00:43:11,320
你出于任何原因而苦苦挣扎，然后按Enter。
that you're struggling with for whatever reason, and hit Enter then.

909
00:43:11,320 --> 00:43:14,110
将会发生的是将运行同一命令。
And what will happen is the same command will get run.

910
00:43:14,110 --> 00:43:18,340
我们将使用help50程序分析该输出是什么。
We will analyze, using the help50 program, what that output is.

911
00:43:18,340 --> 00:43:20,950
我们将尝试以黄色突出显示我们所识别的内容。
And we'll try to highlight in yellow the stuff we recognize.

912
00:43:20,949 --> 00:43:23,289
然后将其翻译为更人性化的语言。
And then translate it to more human friendly language.

913
00:43:23,289 --> 00:43:27,459
例如，在运行help50之后，我们要求获得帮助，点对点。
For instance, after running help50, we're asking for help, dot dot dot.

914
00:43:27,460 --> 00:43:29,170
这是黄色，这是我们认识的东西，
In yellow here is the thing we recognize,

915
00:43:29,170 --> 00:43:31,660
哦，工作人员以前见过这个问题。
oh, the staff have seen this problem before.

916
00:43:31,659 --> 00:43:36,699
然后在这里，你是否忘了包含stdio.h，其中printf
And then down here, did you forget to include stdio.h, in which printf

917
00:43:36,699 --> 00:43:38,709
被声明为文件的顶部？
is declared atop of your file?

918
00:43:38,710 --> 00:43:41,440
所以希望，如果我们认识到这个问题，
So hopefully, if we recognize the problem,

919
00:43:41,440 --> 00:43:43,690
我们可以指导你解决这种反问
we can guide you with this sort of rhetorical question

920
00:43:43,690 --> 00:43:45,250
这使你意识到，哦，是的。
that makes you realize, oh, yes.

921
00:43:45,250 --> 00:43:46,639
那是我做错的事。
That's what I did wrong.

922
00:43:46,639 --> 00:43:50,379
现在，我可以回到这里，移至文件顶部，
So now I can go back up here, move to the top of my file,

923
00:43:50,380 --> 00:43:53,980
并添加include stdio.h。
and add include stdio.h.

924
00:43:53,980 --> 00:43:59,373
现在注意，如果我重新打个招呼，瞧，问题就完全消失了。
And now notice, if I rerun make hello, voila, the problem is gone altogether.

925
00:43:59,373 --> 00:44:00,790
我们可以整天这样做。
And we could do this all day long.

926
00:44:00,789 --> 00:44:02,206
有很多地方要弄乱。
There's so many places to mess up.

927
00:44:02,206 --> 00:44:04,119
例如，我现在省略分号。
For instance, I omit the semicolon now.

928
00:44:04,119 --> 00:44:06,909
让我继续，不用分号立即打个招呼。
Let me go ahead and make hello now without the semicolon.

929
00:44:06,909 --> 00:44:09,049
现在，我们将获得不同的错误消息。
Now we're going to get a different error message.

930
00:44:09,050 --> 00:44:12,610
你会再次看到我搞砸的文件名hello.c。
And you'll see, again, the name of the file where I messed up, hello.c.

931
00:44:12,610 --> 00:44:14,680
这次是在第五行。
This time it's on line five.

932
00:44:14,679 --> 00:44:16,989
这是真的，因为行号向下移动
And that's true because the line numbers moved down

933
00:44:16,989 --> 00:44:18,639
在我在那里添加更多东西之后。
after I added more stuff up there.

934
00:44:18,639 --> 00:44:21,636
你可以在表达后看到预期的分号。
And you can see expected semicolon after expression.

935
00:44:21,637 --> 00:44:23,470
所以这有点简单。
So this one's a little more straightforward.

936
00:44:23,469 --> 00:44:25,209
但是你可以在此命令上运行help50，
But you could run help50 on this command,

937
00:44:25,210 --> 00:44:29,050
同样，只是为了获得一些更明确的建议。
too, just to get back a little more explicit advice.

938
00:44:29,050 --> 00:44:31,960
所以help50随时会成为你的朋友
So help50 will be your friend any time you

939
00:44:31,960 --> 00:44:36,220
使你的代码无法实际编译时遇到了麻烦。
are having trouble getting your code to actually compile.

940
00:44:36,219 --> 00:44:39,009
好吧，让我现在做其他不好的事情。
Well, let me do something else that's bad now.

941
00:44:39,010 --> 00:44:43,060
我一直在刻意编写相当漂亮的代码。
I've very deliberately been writing fairly pretty code.

942
00:44:43,059 --> 00:44:45,129
我已经缩进了printf这个词。
I've indented the word printf.

943
00:44:45,130 --> 00:44:47,320
我在这里包括一些空白行。
I included some blank line up here.

944
00:44:47,320 --> 00:44:49,700
为了清楚起见，我放了这些花括号，
Just to make it clear, I've put these curly braces,

945
00:44:49,699 --> 00:44:51,519
可以这么说。
so to speak, on their own lines.

946
00:44:51,519 --> 00:44:56,079
但是坦率地说，我的计算机或CS50 IDE并不是那么特别。
But frankly, my computer, or CS50 IDE is not so particular.

947
00:44:56,079 --> 00:44:58,569
从技术上讲，我可以摆脱这一空白行。
I could technically get rid of this blank line.

948
00:44:58,570 --> 00:45:00,580
我可以将花括号移到这里。
I could move this curly brace way up here.

949
00:45:00,579 --> 00:45:04,659
我可以完全摆脱这种压痕，并按自己的方式移动它。
I could get rid of this indentation altogether and move it on its own line.

950
00:45:04,659 --> 00:45:06,999
然后我可以将花括号移到这里。
And then I could just move this curly brace up here.

951
00:45:07,000 --> 00:45:12,339
因此，编写的程序现在只有两行，而不是六行。
Thereby writing a program that's now only two lines long, not six.

952
00:45:12,340 --> 00:45:15,040
但希望已经，即使你以前从未编程过，
But hopefully already, even if you've never programmed before,

953
00:45:15,039 --> 00:45:17,619
这可能应该以错误的方式摩擦你。
this should probably rub you the wrong way.

954
00:45:17,619 --> 00:45:19,509
就像现实世界中的人一样
This is like people in the real world that

955
00:45:19,510 --> 00:45:21,910
不要在他们的社交媒体帖子中使用标点符号
don't use punctuation in their social media posts

956
00:45:21,909 --> 00:45:23,499
或他们的电子邮件或短信。
or their emails or the text messages.

957
00:45:23,500 --> 00:45:25,169
他们只是不断地进行下去。
They just kind of go on and on and on.

958
00:45:25,170 --> 00:45:27,168
是的，信息在那里。
And yes, the information is there.

959
00:45:27,168 --> 00:45:29,460
你可以收集他们正在尝试交流的内容。
You can glean what it is they're trying to communicate.

960
00:45:29,460 --> 00:45:31,200
但是，天哪，这很烦人。
But my God, is it annoying.

961
00:45:31,199 --> 00:45:32,629
很难读。
It's hard to read.

962
00:45:32,630 --> 00:45:35,130
发生错误的可能性更高
There's probably a higher probability that there's a mistake

963
00:45:35,130 --> 00:45:38,560
而且很难找到它，因为事情没有很好地平衡
and it's going to be harder to find it because things aren't nicely balanced

964
00:45:38,559 --> 00:45:41,199
在左侧，右侧，顶部和底部。
on the left and on the right and on the top and the bottom.

965
00:45:41,199 --> 00:45:43,739
因此，这就是糟糕的风格。
So this is what would be described as bad style.

966
00:45:43,739 --> 00:45:45,269
我的程序仍然正确。
My program is still correct.

967
00:45:45,269 --> 00:45:49,029
我有stdio.h，我有分号，以及其他所有内容。
I've got the stdio.h, I've got the semicolon, and everything else.

968
00:45:49,030 --> 00:45:50,310
但这真的很糟糕。
But it's really bad style.

969
00:45:50,309 --> 00:45:51,719
因为这很丑。
Because it's just ugly.

970
00:45:51,719 --> 00:45:53,429
没有太多的空白。
There's not much white space.

971
00:45:53,429 --> 00:45:55,559
没有很多空白行或缩进
There's not a lot of blank lines or indentation

972
00:45:55,559 --> 00:46:00,189
这使你和我更容易从上到下阅读此内容。
that just make it easier for you and I to read this thing from top to bottom.

973
00:46:00,190 --> 00:46:02,400
因此请注意，它确实可以编译。
So notice, it does compile.

974
00:46:02,400 --> 00:46:06,840
所以help50不会帮助我解决此问题，因为它可以编译。
So help50 is not going to help me fix this problem because it compiles OK.

975
00:46:06,840 --> 00:46:11,610
但是它可以运行另一个我们称为style50的程序。
But it can run another program that we're going to call style50.

976
00:46:11,610 --> 00:46:13,470
这是另一种以教育为导向的工具
This is another educationally oriented tool

977
00:46:13,469 --> 00:46:17,609
安装在CS50 IDE中，可以让你找出
that's installed in CS50 IDE that allows you to figure out

978
00:46:17,610 --> 00:46:19,810
如何改善代码风格。
how to improve the style of your code.

979
00:46:19,809 --> 00:46:24,759
因此，当我在此更漂亮的代码上运行style50时，它的确看起来不错。
So when I run style50 on this prettier code, it indeed looks good.

980
00:46:24,760 --> 00:46:26,130
但是它仍然在给我建议。
But it's still giving me advice.

981
00:46:26,130 --> 00:46:28,050
它告诉我添加一些称为“注释”的内容。
It's telling me to add something called comments.

982
00:46:28,050 --> 00:46:30,210
一群人在Scratch的世界中发现了这一点。
And a bunch of you figured this out in the world of Scratch.

983
00:46:30,210 --> 00:46:32,370
你可以添加一些便利贴或便利贴
You can add little sticky notes or post-it notes

984
00:46:32,369 --> 00:46:34,529
刮擦那些自我的笔记
to Scratch that are sort of notes to self

985
00:46:34,530 --> 00:46:38,310
会提醒你某事，或者向你的讲师解释
that remind you what something does, or maybe explains to your teaching fellow

986
00:46:38,309 --> 00:46:40,169
或助教什么事情。
or teaching assistant what something does.

987
00:46:40,170 --> 00:46:41,890
C也支持这些。
C supports these as well.

988
00:46:41,889 --> 00:46:45,269
举例来说，如果我只是想在这里做个学究的人，
So for instance, if I just wanted to be really pedantic here and make

989
00:46:45,269 --> 00:46:49,169
清楚人类正在阅读我的代码，我正在尝试做的事情，
clear to the human reading my code what I'm trying to do,

990
00:46:49,170 --> 00:46:52,140
我可以说一些问候用户的话。
I could say something like greet user.

991
00:46:52,139 --> 00:46:53,789
并注意此处的语法。
And notice the syntax here.

992
00:46:53,789 --> 00:46:56,999
我在现有代码行的上方添加了新行，
I've put a new line above my existing line of code,

993
00:46:57,000 --> 00:46:59,609
而且我已经缩进了，所以一切都排队了
and I've similarly indented it so everything lines up

994
00:46:59,610 --> 00:47:01,260
外观精美。
visually beautifully.

995
00:47:01,260 --> 00:47:05,520
我已经完成了斜杠斜杠，说，嘿，编译器，这是一条评论。
I've done slash slash, which says, hey, compiler, this is a comment.

996
00:47:05,519 --> 00:47:07,269
这仅适用于人眼。
This is for human eyes only.

997
00:47:07,269 --> 00:47:09,689
本质上，这不是实际的C代码。
This is not actual C code, per se.

998
00:47:09,690 --> 00:47:10,917
然后我按空格键。
Then I hit the spacebar.

999
00:47:10,916 --> 00:47:12,749
然后我只输入了一个英语短语。
And then I just typed out an English phrase.

1000
00:47:12,750 --> 00:47:14,610
这可以是任何口头语言。
And this could be any spoken language.

1001
00:47:14,610 --> 00:47:16,350
但是我继续打招呼用户。
But I went ahead and typed greet user.

1002
00:47:16,349 --> 00:47:16,861
为什么？
Why?

1003
00:47:16,862 --> 00:47:18,570
好吧，这只是在提醒我自己
Well, it's just a reminder to myself what

1004
00:47:18,570 --> 00:47:22,330
以下代码行的目的是向用户致意。
the purpose of the following line of code is, to greet the user.

1005
00:47:22,329 --> 00:47:28,454
例如，这比打个招呼世界更好。
This is marginally better, for instance, than saying print hello, world.

1006
00:47:28,454 --> 00:47:30,329
让我问你，即使你从来没有
And let me just ask you, even if you've never

1007
00:47:30,329 --> 00:47:34,349
为什么在第一个评论更好之前编程
programmed before why is the first comment a better

1008
00:47:34,349 --> 00:47:36,479
比第二个评论好吗？
comment than the second?

1009
00:47:36,480 --> 00:47:40,650
就像，为什么我要说（如果有的话）向用户打招呼而不是打印
Like, why should I say, if anything, greet user instead of print

1010
00:47:40,650 --> 00:47:43,800
你好，世界以这些评论的形式出现。
hello, world in the form of these comments.

1011
00:47:43,800 --> 00:47:46,558
是的，Olivia，你如何看待？
Yeah, Olivia, what do you think?

1012
00:47:46,557 --> 00:47:47,099
听众：好的。
AUDIENCE: OK.

1013
00:47:47,099 --> 00:47:48,806
它告诉你代码的目的。
It tells you the purpose of the code.

1014
00:47:48,806 --> 00:47:51,389
DAVID MALAN：是的，代码的目的是什么？
DAVID MALAN: Yeah, the purpose of the code as opposed to what?

1015
00:47:51,389 --> 00:47:53,669
你在区分什么？
What distinction are you making?

1016
00:47:53,670 --> 00:47:56,475
听众：准确地告诉你它在做什么。
AUDIENCE: Versus telling you exactly what it's doing.

1017
00:47:56,474 --> 00:47:57,599
戴维·马兰（David MALAN）：好的，是的。
DAVID MALAN: Yeah, exactly.

1018
00:47:57,599 --> 00:48:00,696
如果你的注释与实际代码几乎相同，
If your comment is almost identical to the actual code,

1019
00:48:00,697 --> 00:48:03,780
你并没有真正向读者传达更多的信息，更不用说了
you're not really conveying much more information to the reader, let alone

1020
00:48:03,780 --> 00:48:05,460
将来自己。
yourself in the future.

1021
00:48:05,460 --> 00:48:09,120
更概括地说，这行代码的目的是做什么，
Explaining it more generally, what the purpose of this line of code is to do,

1022
00:48:09,119 --> 00:48:11,729
是向用户打招呼，这更具描述性。
is to greet the user, that's a little more descriptive.

1023
00:48:11,730 --> 00:48:14,070
老实说，现在这个程序超级公平
Now to be super fair, honestly, this program

1024
00:48:14,070 --> 00:48:16,650
太短了，即使style50是的，
is so short that even though style50, yes, would

1025
00:48:16,650 --> 00:48:20,250
宁愿你添加一些注释，如果你的程序确实
prefer that you add some comment, if your program really

1026
00:48:20,250 --> 00:48:23,729
简化为一行代码，你可能不需要在此处添加注释。
reduces to one line of code, you probably don't need a comment here.

1027
00:48:23,730 --> 00:48:26,037
但是，几乎所有其他程序
However, pretty much every other program we're

1028
00:48:26,036 --> 00:48:28,619
以后要在这里写的不只是一个
going to write here on after is going to be more than just one

1029
00:48:28,619 --> 00:48:30,689
主代码行，例如此printf。
main line of code, like this printf.

1030
00:48:30,690 --> 00:48:32,850
所以很快就会有意义
So it's going to make much more sense soon

1031
00:48:32,849 --> 00:48:35,999
来，我们将要实际添加
to come that we're going to want to actually add

1032
00:48:36,000 --> 00:48:38,459
给我们的代码一些实际的注释。
to our code some actual comments.

1033
00:48:38,460 --> 00:48:40,920
好吧，让我在这里介绍一个最后的工具
Well, let me introduce one final tool here

1034
00:48:40,920 --> 00:48:43,260
这将有助于我们解决目前的问题
that will help us solve problems as we proceed now

1035
00:48:43,260 --> 00:48:45,000
编写更复杂的程序。
to write more sophisticated programs.

1036
00:48:45,000 --> 00:48:46,080
这是check50。
And this is check50.

1037
00:48:46,079 --> 00:48:50,789
该工具专门用于实验室或问题集中，
This is a tool specifically that you'll use either in labs or in problem sets,

1038
00:48:50,789 --> 00:48:53,159
该课程的编程作业，以实际检查
the course's programming assignments, to actually check

1039
00:48:53,159 --> 00:48:54,909
你代码的正确性。
the correctness of your code.

1040
00:48:54,909 --> 00:48:58,529
因此，尽管help50只能帮助你通常地编译代码，
So whereas help50 just helps you compile your code typically,

1041
00:48:58,530 --> 00:49:01,410
当根本不编译时，style50会有所帮助
when it's not compiling at all, style50 helps

1042
00:49:01,409 --> 00:49:04,559
你改善了代码风格，请检查50
you improve the style of your code, check50

1043
00:49:04,559 --> 00:49:09,059
会对照一些自动化测试来检查代码的正确性
will check the correctness of your code against some automated tests

1044
00:49:09,059 --> 00:49:12,689
我们员工写的与任何东西都一致的
that we, the staff, have written that are consistent with whatever

1045
00:49:12,690 --> 00:49:14,202
作业问题实际上是。
the homework problem actually is.

1046
00:49:14,202 --> 00:49:17,160
因此，我们编写了一些测试以确保你的代码正常运行
So we write some tests to make sure that your code is working correctly

1047
00:49:17,159 --> 00:49:19,199
根据我们自己的规格。
as per our own specifications.

1048
00:49:19,199 --> 00:49:22,079
那么我应该如何运行check50？
So how might I run check50?

1049
00:49:22,079 --> 00:49:25,439
这将完全取决于问题集或实验室。
This will totally depend on the problem set or the lab.

1050
00:49:25,440 --> 00:49:28,170
而且，我们将始终在问题集或实验中，
And we will always, in the problem set or lab,

1051
00:49:28,170 --> 00:49:30,543
告诉你键入哪个命令以进行check50。
tell you what command to type for check50.

1052
00:49:30,543 --> 00:49:33,210
你不一定要自己弄清楚这件事。
It's not something you could necessarily figure out on your own.

1053
00:49:33,210 --> 00:49:35,580
我碰巧记得我们有一张支票，
I happen to remember that we have a check, that

1054
00:49:35,579 --> 00:49:40,559
是一项测试，称为CS50 /问题/你好。
is a test, called CS50/problems/hello.

1055
00:49:40,559 --> 00:49:42,869
奇怪的是你将永远不会运行相同的命令。
Odds are you will never run this identical command.

1056
00:49:42,869 --> 00:49:46,919
同样，在问题集或实验中，我们将始终告诉你键入什么。
Again, in the problem set or lab, we will always tell you what to type.

1057
00:49:46,920 --> 00:49:50,970
除非我们告诉你要使用哪种测试，否则你将不知道要键入什么内容。
You won't know what otherwise to type unless we tell you what test to use.

1058
00:49:50,969 --> 00:49:55,499
这将现在将我的文件hello.c上载到名为
This is going to now upload my file hello.c to a service called

1059
00:49:55,500 --> 00:49:58,049
GitHub，再次是共享代码的流行工具。
GitHub, which again is a popular tool for sharing code.

1060
00:49:58,050 --> 00:50:00,150
我们使用它来收集提交的信息。
We use it to collect submissions for this.

1061
00:50:00,150 --> 00:50:02,160
然后输入密码。
I'm going to then type in my password.

1062
00:50:02,159 --> 00:50:02,879
你不会看到它。
You won't see it.

1063
00:50:02,880 --> 00:50:05,940
相反，你会在网页中看到星号或项目符号。
You'll instead see asterisks or, like, bullets in a web page.

1064
00:50:05,940 --> 00:50:07,650
我要继续，然后按Enter。
I'm going to go ahead and hit Enter then.

1065
00:50:07,650 --> 00:50:09,240
这将验证我的代码。
It's going to verify my code.

1066
00:50:09,239 --> 00:50:10,559
它会做一些思考。
It's going to do some thinking.

1067
00:50:10,559 --> 00:50:13,217
现在正在上传，点对点。
It's uploading now, dot dot dot.

1068
00:50:13,217 --> 00:50:15,839
现在，我们只是在等待互联网做出回应。
And now we're just waiting for the internet to respond.

1069
00:50:15,840 --> 00:50:18,390
因为在CS50服务器上的某个地方，
Because somewhere on CS50 servers, we are

1070
00:50:18,389 --> 00:50:22,979
在编译代码后运行代码，在本例中为我的代码，
running your code after compiling your code, or in this case mine,

1071
00:50:22,980 --> 00:50:26,830
并确保是的，它的实际行为应有的表现。
and making sure, yes, it actually behaved as it should have.

1072
00:50:26,829 --> 00:50:30,059
希望你通常会看到一堆绿色的笑脸
And what you'll typically see, hopefully, are a bunch of green smiley

1073
00:50:30,059 --> 00:50:33,989
面对的是，你的代码存在，是的，你的代码可以编译，
faces saying yes, that your code exists, yes, that your code compiles,

1074
00:50:33,989 --> 00:50:36,449
是的，例如，它可以打印世界。
and yes, for instance, it prints hello, world.

1075
00:50:36,449 --> 00:50:38,609
有时你可能会看到红色的皱眉面孔，
Sometimes you might see red frowny faces,

1076
00:50:38,610 --> 00:50:42,840
这表示不可以，根据实验，你的代码无法正常运行
which means no, your code did not work exactly as it should, per the lab,

1077
00:50:42,840 --> 00:50:43,830
或问题集。
or of the problem set.

1078
00:50:43,829 --> 00:50:47,189
在这一点上，它回到你所需要的绘图板上
At which point, it's back to the drawing board on your part to figure out

1079
00:50:47,190 --> 00:50:49,450
到底需要在这里修复什么。
exactly what needs to be fixed up here.

1080
00:50:49,449 --> 00:50:52,829
有时你会看到黄色的输出，只是一张黄色的笔直的脸
Sometimes you'll see yellow output with just a straight yellow face, which

1081
00:50:52,829 --> 00:50:55,709
只是意味着我们甚至无法运行特定测试
just means we weren't even able to run a certain test

1082
00:50:55,710 --> 00:50:57,620
因为其他一些测试已经失败。
because some other test already failed.

1083
00:50:57,619 --> 00:51:00,629
所以它是相对快速的反馈
So it's meant to be relatively quick feedback

1084
00:51:00,630 --> 00:51:05,440
甚至在提交并称呼它之前，先检查代码的正确性。
on the correctness of your code before you even submit it and call it a day.

1085
00:51:05,440 --> 00:51:10,770
而check50指令将始终伴随着问题本身
And check50 instructions will always be accompanied by the problem itself

1086
00:51:10,769 --> 00:51:13,149
在实验室或问题集中。
in the lab or problem set.

1087
00:51:13,150 --> 00:51:15,420
因此，这里有一些最终命令。
So some final commands here now.

1088
00:51:15,420 --> 00:51:21,450
在此终端窗口中，我不仅可以运行make和./hello，还可以做更多的事情，
Within this terminal window, I can do more than just run make and ./hello,

1089
00:51:21,449 --> 00:51:23,219
或我程序的名称是什么。
or whatever my program's name is.

1090
00:51:23,219 --> 00:51:26,039
我可以做的不只是help50和style50
And I can do more than help50 and style50

1091
00:51:26,039 --> 00:51:30,509
而Check50证明我确实以CS50 IDE的形式使用了
and Check50 it turns out that I'm really using, in the form of CS50 IDE,

1092
00:51:30,510 --> 00:51:32,280
我自己的服务器在云中。
my own server in the cloud.

1093
00:51:32,280 --> 00:51:34,150
是的，我正在使用一个网站。
So yes, I'm using a website.

1094
00:51:34,150 --> 00:51:37,920
但是CS50 IDE的真正含义是，就像你自己的服务器
But what CS50 IDE really is, it's like your own server

1095
00:51:37,920 --> 00:51:40,080
或你在云端的计算机。
or your own computer in the cloud.

1096
00:51:40,079 --> 00:51:43,739
在互联网上的某个地方，你拥有自己的用户名和密码
Somewhere out there on the internet, you have your own username and password

1097
00:51:43,739 --> 00:51:45,449
以CS50 IDE的形式。
in the form of CS50 IDE.

1098
00:51:45,449 --> 00:51:49,829
而且只有你可以访问你编写的文件，你所使用的程序
And only you can access the files that you write, the programs that you

1099
00:51:49,829 --> 00:51:51,899
写入存储在此IDE中的内容。
write that are stored in this IDE.

1100
00:51:51,900 --> 00:51:54,660
现在，我将吸引其他一些功能。
And there's a few more features I'll now draw our attention to.

1101
00:51:54,659 --> 00:51:58,349
也许最友好的一个是左上角的这个小文件夹图标。
Perhaps the most friendly one is this little folder icon at top left.

1102
00:51:58,349 --> 00:52:00,569
如果我单击此小文件夹图标，你将
If I click this little folder icon, you'll

1103
00:52:00,570 --> 00:52:03,120
现在查看通常称为文件浏览器的文件
now see what's generally called a file browser

1104
00:52:03,119 --> 00:52:06,209
或文件树，仅是图形表示
or a file tree, which is just a graphical representation

1105
00:52:06,210 --> 00:52:10,680
在这种情况下，我的帐户或IDE中文件的大小。
of the files in my account, or in my IDE, in this case.

1106
00:52:10,679 --> 00:52:12,089
它看起来类似于Mac OS。
It looks similar to Mac OS.

1107
00:52:12,090 --> 00:52:13,410
它看起来类似于Windows。
It looks similar to Windows.

1108
00:52:13,409 --> 00:52:16,859
这只是内置在IDE中的图形用户界面
And this is just a graphical user interface built into the IDE

1109
00:52:16,860 --> 00:52:20,970
这样，例如，如果我通过单击此x小按钮关闭我的标签
so that, for instance, if I close my tab by clicking this little x button up

1110
00:52:20,969 --> 00:52:23,759
在这里，我想重新打开文件，就像你一样
here, and I want to reopen the file, much like you

1111
00:52:23,760 --> 00:52:25,860
可以想象在Mac或PC上就这么简单
would imagine on a Mac or PC, it's as simple

1112
00:52:25,860 --> 00:52:28,710
双击左侧的文件。
as double clicking the file on the left-hand side.

1113
00:52:28,710 --> 00:52:31,800
但是请注意，我没有点击“ hello”。
But notice I didn't click on hello.

1114
00:52:31,800 --> 00:52:33,150
因为请注意会发生什么。
Because notice what happens.

1115
00:52:33,150 --> 00:52:38,550
如果我打招呼，我的天哪，这是怎么回事？
If I open hello, my gosh, like, what is going on here?

1116
00:52:38,550 --> 00:52:39,810
这真是一团糟。
This is kind of a mess.

1117
00:52:39,809 --> 00:52:40,709
有发红。
There's redness.

1118
00:52:40,710 --> 00:52:41,790
有圆点。
There's dots.

1119
00:52:41,789 --> 00:52:47,864
有人对我为什么要看到自己看到的东西有任何想法吗？
Any thoughts from someone on why I'm seeing what I'm seeing?

1120
00:52:47,864 --> 00:52:50,249
因为在某些时候，你很可能会偶然，
Because odds are you will, accidentally, at some point,

1121
00:52:50,250 --> 00:52:56,519
单击诸如hello的文件，而不是单击诸如hello.c的文件。
click on a file like hello instead of on a file like hello.c.

1122
00:52:56,519 --> 00:52:58,259
莎拉，你怎么看？
Sara, what do you think?

1123
00:52:58,260 --> 00:52:59,850
听众：这是一个二进制代码。
AUDIENCE: It's a binary code.

1124
00:52:59,849 --> 00:53:01,739
这就是机器语言。
So it's the machine language.

1125
00:53:01,739 --> 00:53:05,384
因此，除了他们用C编写的代码外，它不允许用户看到它们。
So it doesn't allow the user to see them, besides the code they write in C.

1126
00:53:05,385 --> 00:53:06,510
戴维·马兰（David MALAN）：好的，是的。
DAVID MALAN: Yeah, exactly.

1127
00:53:06,510 --> 00:53:11,410
你试图在此选项卡中查看的是二进制代码0和1。
What you're trying to look at in this tab is binary code, 0's and 1's.

1128
00:53:11,409 --> 00:53:14,219
但是，从技术上讲，这些0和1是
However, those 0's and 1's are technically

1129
00:53:14,219 --> 00:53:18,059
目前被误解为ASCII字符，
being misinterpreted at the moment as ASCII characters,

1130
00:53:18,059 --> 00:53:19,259
或Unicode字符。
or Unicode characters.

1131
00:53:19,260 --> 00:53:24,090
因此回想一下上周，ASCII是数字和字母之间的映射。
So recall from last week, ASCII is this mapping between numbers and letters.

1132
00:53:24,090 --> 00:53:26,850
当然，数字只是0和1的模式。
And numbers, of course, are just patterns of 0's and 1's.

1133
00:53:26,849 --> 00:53:32,099
这看起来很神秘，因为我们试图误解0和
And this looks super cryptic, because we're trying to misinterpret 0's and

1134
00:53:32,099 --> 00:53:34,229
1代表它们是ASCII字符。
1's as though they're ASCII characters.

1135
00:53:34,230 --> 00:53:37,830
回想一下，还有更多的ASCII和Unicode字符
And recall that there's many more characters in ASCII and Unicode

1136
00:53:37,829 --> 00:53:41,819
而不是A到Z。还有数字，其中有一些无法打印的字符。
than A through Z. And the numbers, there's some unprintable characters.

1137
00:53:41,820 --> 00:53:44,160
确实，我们在这里看到的所有时髦之处
And indeed, all the funkiness we're seeing here

1138
00:53:44,159 --> 00:53:47,189
只是对0和1的误解
is just a misinterpretation of 0's and 1's that

1139
00:53:47,190 --> 00:53:51,780
是计算机的指令，计算机的机器代码是
are instructions to the computer, machine code for the computer being

1140
00:53:51,780 --> 00:53:53,130
被误解为文本。
misinterpreted as text.

1141
00:53:53,130 --> 00:53:56,130
因此，如果你无法编辑这样的二进制文件，可以这么说，
So if you can't edit a binary file like this, so to speak,

1142
00:53:56,130 --> 00:53:58,680
当你做这样的事情时，你应该关闭你好
you should just close hello when you do something like that

1143
00:53:58,679 --> 00:54:02,189
并确保你双击并打开了实际的源代码
and make sure you've double clicked on and opened your actual source code

1144
00:54:02,190 --> 00:54:04,420
文件。
file as well.

1145
00:54:04,420 --> 00:54:06,450
因此，我们已经看到了字符串。
So we've seen strings.

1146
00:54:06,449 --> 00:54:08,099
还有其他数据类型。
And there's other data types.

1147
00:54:08,099 --> 00:54:09,299
还有其他功能。
And there's other functions.

1148
00:54:09,300 --> 00:54:11,730
还有循环和条件等等。
And there's loops and conditions and so much more.

1149
00:54:11,730 --> 00:54:15,000
我认为我们现在是时候休息一下，让我们沉浸在一个好时机。
I think we're at a good point now to perhaps take a break, let this sink in.

1150
00:54:15,000 --> 00:54:18,270
我们为什么不继续休息七分钟呢？
Why don't we go ahead and take a seven minute break?

1151
00:54:18,269 --> 00:54:20,909
当我们继续时，我们将介绍C的其他一些功能
And when we resume, we'll introduce a few more features of C

1152
00:54:20,909 --> 00:54:23,789
并将它们与上周在Scratch中看到的进行比较。
and compare them against what we saw last week in Scratch.

1153
00:54:23,789 --> 00:54:25,499
所以我们七分钟后见。
So we'll see you in seven minutes.

1154
00:54:25,500 --> 00:54:28,259
好吧，我们回来了。
All right, we are back.

1155
00:54:28,260 --> 00:54:32,190
所以回想一下，我们是在看这个图形用户的
So recall where we left off was we were looking at this graphical user

1156
00:54:32,190 --> 00:54:33,390
界面在左上方。
interface at top left.

1157
00:54:33,389 --> 00:54:36,959
文件浏览器，即文件树，仅提供给我们更多图形访问
The file browser, the file tree, that just gives us more graphical access

1158
00:54:36,960 --> 00:54:38,450
到我们帐户中的文件。
to the files in our account.

1159
00:54:38,449 --> 00:54:44,729
但是，现在让我们在终端窗口中以老式的命令行方式进行操作。
But let's now do this the old school command line way in my terminal window.

1160
00:54:44,730 --> 00:54:47,040
事实证明，使用我们的终端窗口，
So it turns out that using our terminal window,

1161
00:54:47,039 --> 00:54:51,089
我们不仅可以编译代码并运行代码并运行check50样式，help50，
can we not only compile code and run code and run check50 style, help50,

1162
00:54:51,090 --> 00:54:53,850
等等，我们也可以操作文件
and the like, we can also manipulate files

1163
00:54:53,849 --> 00:54:57,479
和文件夹，甚至碰巧都存在于我的IDE中。
and folders, even, that happen to exist in my IDE.

1164
00:54:57,480 --> 00:55:01,060
那是我可以访问云中计算机的位置。
That is in the computer I have access to here in the cloud.

1165
00:55:01,059 --> 00:55:04,619
我建议的第一个命令是键入ls。
And the first command I've proposed is that we type ls.

1166
00:55:04,619 --> 00:55:07,019
Ls是list的简写形式。
Ls is shorthand notation for list.

1167
00:55:07,019 --> 00:55:12,039
很简单，ls列出了当前文件夹中的文件或文件夹。
And quite simply, ls lists the files or folders in your current folder.

1168
00:55:12,039 --> 00:55:15,539
因此，这就像双击Windows中的“我的文档”文件夹，
So this would be like double clicking on your My Documents folder in Windows,

1169
00:55:15,539 --> 00:55:17,009
或Mac OS中的文档。
or documents in Mac OS.

1170
00:55:17,010 --> 00:55:19,000
Ls仅列出内容。
Ls just lists the contents.

1171
00:55:19,000 --> 00:55:20,580
现在，你好，你好有点奇怪。
Now, notice hello is a little weird.

1172
00:55:20,579 --> 00:55:25,359
它以绿色突出显示，并且后面有一个星号。
It's highlighted in green and there's an asterisk after it.

1173
00:55:25,360 --> 00:55:28,830
这只是该文件可执行的视觉提示。
And that's just a visual cue that that file is executable.

1174
00:55:28,829 --> 00:55:32,579
也就是说，该程序可以与./hello一起运行。
That is, that is a program that you can run with ./hello.

1175
00:55:32,579 --> 00:55:34,709
星号不是文件名的一部分。
The star is not part of the file name.

1176
00:55:34,710 --> 00:55:36,570
当然，我们会看到hello.c。
And of course, we see hello.c.

1177
00:55:36,570 --> 00:55:40,620
现在，假设我想重命名我的文件。
Now, suppose that I wanted to maybe rename my file.

1178
00:55:40,619 --> 00:55:43,049
好吧，就像在Mac OS或Windows中一样，
Well, I could, much like in Mac OS or Windows,

1179
00:55:43,050 --> 00:55:45,000
我可以在这里浏览文件浏览器。
I could go up to the file browser up here.

1180
00:55:45,000 --> 00:55:46,830
我可以控制单击或右键单击。
I could Control click or Right click.

1181
00:55:46,829 --> 00:55:49,109
并注意有很多菜单选项
And notice there's a whole bunch of menu options

1182
00:55:49,110 --> 00:55:51,220
就像在你自己的计算机上一样弹出。
that pop up just like on your own computer.

1183
00:55:51,219 --> 00:55:53,279
我可以在此处重命名该文件。
And I could rename the file right up here.

1184
00:55:53,280 --> 00:55:56,113
但总的来说，我们将在命令行中执行操作
But generally speaking, we're going to do things at the command line

1185
00:55:56,112 --> 00:55:58,709
只是因为，像今天这样的一些行动简陋
only because, rudimentary as some of these operations today

1186
00:55:58,710 --> 00:56:02,700
是的，对我来说它将是一个功能更强大的命令行界面。
are, it's going to be a much more powerful command line interface for me.

1187
00:56:02,699 --> 00:56:04,919
因此，假设我改变主意，你知道吗？
So suppose I change my mind, and you know what?

1188
00:56:04,920 --> 00:56:06,570
我不喜欢这个版本的你好。
I don't like this version of hello.

1189
00:56:06,570 --> 00:56:08,790
我想删除该程序并重新开始。
I want to delete that program and start over.

1190
00:56:08,789 --> 00:56:11,069
严格来说，我不需要删除任何问候。
Strictly speaking, I don't need to delete hello ever.

1191
00:56:11,070 --> 00:56:14,620
我可以重新编译它，它会不断变化和变化。
I can just recompile it, and it will keep getting changed and changed.

1192
00:56:14,619 --> 00:56:19,049
但是，如果确实要删除它，则可以键入rm hello，然后按Enter。
But if I do want to remove it, I can type rm hello, and then hit Enter.

1193
00:56:19,050 --> 00:56:22,140
然后会问我，删除常规文件你好吗？
And then I'll be asked, remove regular file hello?

1194
00:56:22,139 --> 00:56:25,169
这只是我确实要删除的视觉确认。
That's just a visual confirmation that I do indeed want to delete.

1195
00:56:25,170 --> 00:56:28,500
我可以输入y或yes或类似的答复。
And I can type y or yes or some such reply.

1196
00:56:28,500 --> 00:56:31,830
如果我按y再按Enter，似乎什么也没发生，
And if I hit y and Enter, nothing seems to happen,

1197
00:56:31,829 --> 00:56:34,989
但请注意左上方的情况。
but notice what happened up here at top left.

1198
00:56:34,989 --> 00:56:38,699
请注意，hello现在不见了，只剩下hello.c。
Notice that hello is now gone, leaving only hello.c.

1199
00:56:38,699 --> 00:56:42,622
而且，如果我再次键入ls，现在我只会看到我的代码文件。
And if I type ls again, now I see only my code file.

1200
00:56:42,623 --> 00:56:44,790
也许现在我想更改此程序，但我不
Maybe now I want to change this program, and I don't

1201
00:56:44,789 --> 00:56:47,759
想写hello.c，但是再见。
want to write hello.c, but goodbye.c.

1202
00:56:47,760 --> 00:56:49,860
好吧，让我关闭那里的标签。
Well, let me close the tab up there.

1203
00:56:49,860 --> 00:56:52,560
是的，我可以去右键单击它或按Control键单击它，
And yes, I could go and Right click or Control click on it,

1204
00:56:52,559 --> 00:56:54,959
但是同样，我们不需要使用图形界面。
but, again, we don't need to use the graphical interface.

1205
00:56:54,960 --> 00:57:00,990
让我继续，转而做mv hello.c再见。
Let me go ahead and instead do mv hello.c goodbye.c.

1206
00:57:00,989 --> 00:57:03,149
Mv是移动命令。
Mv is the move command.

1207
00:57:03,150 --> 00:57:06,260
即使将其称为“重命名”而不是“ move”会很好，
And even though it would be nice if it's called rename instead of move,

1208
00:57:06,260 --> 00:57:10,750
移动只是将一个文件移动到另一个位置或另一个名称。
move just moves one file to another location or to another name.

1209
00:57:10,750 --> 00:57:12,839
所以，如果我做mv hello.c再见。
So if I do mv hello.c goodbye.c.

1210
00:57:12,840 --> 00:57:15,910
注意发生在左上角的事情。
Notice what happened at top left.

1211
00:57:15,909 --> 00:57:18,209
现在，我的同一个文件称为goodbye.c。
Now my same file is called goodbye.c.

1212
00:57:18,210 --> 00:57:23,248
如果再次输入ls，我可以看到它确实已重命名。
And if, again, I type ls, I can see that it's indeed renamed.

1213
00:57:23,248 --> 00:57:25,290
现在，让我继续并将其移回，因为我
Now, let me go ahead and move that back because I

1214
00:57:25,289 --> 00:57:27,809
希望继续使用我的hello.c程序。
want to stay on my hello.c program.

1215
00:57:27,809 --> 00:57:29,969
但是，假设我想开始整理文件。
But suppose I want to start organizing my files.

1216
00:57:29,969 --> 00:57:32,261
稍后，我们将开始编写更多程序，
In a moment we're going to start writing more programs,

1217
00:57:32,262 --> 00:57:34,200
所以我的帐户会有所增加
and so my account is going to get a little bit

1218
00:57:34,199 --> 00:57:36,899
在今天的过程中，越来越多的文件杂乱无章。
messy with more and more files over the course of today.

1219
00:57:36,900 --> 00:57:41,050
因此，假设你要创建一个文件夹，也称为目录。
So suppose you want to create a folder, otherwise known as a directory.

1220
00:57:41,050 --> 00:57:45,598
我将继续输入make目录的mkdir。
I'm going to go ahead and type mkdir for make directory.

1221
00:57:45,597 --> 00:57:48,639
然后是我要制作的目录的名称，例如演讲。
And then the name of the directory I want to make, for instance, lecture.

1222
00:57:48,639 --> 00:57:51,764
你可以随心所欲地调用它，但是如果我在演讲中，我正在编写代码，
You can call it anything you want, but if I'm in lecture, I'm writing code,

1223
00:57:51,764 --> 00:57:54,909
也许我想将今天的所有文件存储在演讲目录中。
maybe I want to store all of today's files in a lecture directory.

1224
00:57:54,909 --> 00:57:58,629
当我在其中单击Enter时，请注意此处的文件树中发生了什么。
When I hit Enter there, notice what happens in my file tree up here.

1225
00:57:58,630 --> 00:58:00,620
我现在看到一个演讲文件夹。
I now see a lecture folder.

1226
00:58:00,619 --> 00:58:04,309
如果单击三角形，则该三角形为空，因为我没有在其中放置任何东西。
If I click the triangle, it's empty because I haven't put anything in it.

1227
00:58:04,309 --> 00:58:08,169
因此，让我继续并将hello.c移到演讲文件夹中。
So let me go ahead and move hello.c into the lecture folder.

1228
00:58:08,170 --> 00:58:13,090
MV hello.c讲座，现在让我按Enter。
Mv hello.c lecture, and now let me hit Enter.

1229
00:58:13,090 --> 00:58:17,800
瞧，现在注意它嵌套在此演讲文件夹中。
And voila, now notice that it's nested inside of this lecture folder.

1230
00:58:17,800 --> 00:58:22,210
实际上，如果我现在输入ls作为列表，我只会看到演讲文件夹。
And indeed, if I now type ls for list, I only see the lecture folder.

1231
00:58:22,210 --> 00:58:24,730
不幸的是，我现在没有访问权限
Unfortunately, I kind of now don't have access

1232
00:58:24,730 --> 00:58:27,730
到此命令行环境中的hello.c
to hello.c within this command line environment

1233
00:58:27,730 --> 00:58:29,620
除非我进入那个目录。
unless I change into that directory.

1234
00:58:29,619 --> 00:58:32,019
现在，在Mac和PC的世界中，很明显，
Now, in the world of Macs and PCs we, obviously,

1235
00:58:32,019 --> 00:58:35,139
只需双击一个文件夹，瞧，我们就在其中。
would just double click on a folder and voila we're inside of it.

1236
00:58:35,139 --> 00:58:37,809
在命令行界面中，你需要更加谨慎。
In a command line interface you need to be more deliberate.

1237
00:58:37,809 --> 00:58:40,959
所以我要做cd，用于更改目录，
So I'm going to do cd, for change directory,

1238
00:58:40,960 --> 00:58:43,840
然后讲课，然后我要继续并按Enter。
then lecture, and then I'm going to go ahead and hit Enter.

1239
00:58:43,840 --> 00:58:46,180
现在注意，现在可能更有意义
And now notice, and now it might make more sense

1240
00:58:46,179 --> 00:58:50,814
为什么在这整个过程中，我们一直看到蓝色的波浪号斜线。
why this whole time we've been seeing in blue this tilde lecture slash.

1241
00:58:50,815 --> 00:58:53,650
代字号仅表示我所谓的主目录。
The tilde just means my so-called home directory.

1242
00:58:53,650 --> 00:58:57,970
就像我自己的帐户一样，我自己的默认文件夹（例如我的文档和窗口）
Like my own account, my own default folder, like my documents and windows,

1243
00:58:57,969 --> 00:58:59,499
或Mac OS上的文档。
or documents on Mac OS.

1244
00:58:59,500 --> 00:59:02,140
这就是代字号（tilde）的简写形式。
That's what tilde represents in shorthand notation.

1245
00:59:02,139 --> 00:59:05,769
演讲是我现在所在的文件夹的名称。
Lecture is the name of the folder that I am now inside.

1246
00:59:05,769 --> 00:59:09,849
就像我双击Mac OS或Windows上的讲座一样
So it's as though I double clicked on lecture in Mac OS or Windows

1247
00:59:09,849 --> 00:59:11,049
打开一个文件夹。
to open a folder.

1248
00:59:11,050 --> 00:59:15,140
现在，我在终端窗口中的该演讲目录中。
Now I'm inside this lecture directory in my terminal window.

1249
00:59:15,139 --> 00:59:18,939
因此，如果我现在键入ls enter，我应该看到瞧，
So if I now type ls enter, I should see voila,

1250
00:59:18,940 --> 00:59:23,775
我移入的hello.c文件。
the hello.c file that I moved into it.

1251
00:59:23,775 --> 00:59:25,900
现在，让我撤消此操作，因为我要继续
Now, let me undo this because I'm going to go ahead

1252
00:59:25,900 --> 00:59:27,730
并暂时简化一些操作。
and keep things a little simpler for now.

1253
00:59:27,730 --> 00:59:32,650
并假设我想将hello.c移至以前的位置。
And suppose that I want to move hello.c into where it previously was.

1254
00:59:32,650 --> 00:59:34,120
最后一段语法。
Last piece of syntax.

1255
00:59:34,119 --> 00:59:37,669
我们将其称为上级文件夹的简称。
There's this shorthand notation for what we'll call a parent folder.

1256
00:59:37,670 --> 00:59:40,930
因此，就像在家谱中一样，有父母和孩子的概念，
So just like in family trees, there's the notion of parents, and children,

1257
00:59:40,929 --> 00:59:42,489
和孙子等等。
and grandchildren, and so forth.

1258
00:59:42,489 --> 00:59:45,129
在具有文件夹的计算机系统中也是如此。
That's also true in computer systems that have folders.

1259
00:59:45,130 --> 00:59:46,840
和文件夹内的文件夹。
And folders inside of folders.

1260
00:59:46,840 --> 00:59:49,360
和文件夹里面的文件夹里面的文件夹。
And folders inside of folders inside of folders.

1261
00:59:49,360 --> 00:59:52,220
有一个层次结构，就像一棵家谱。
There's a hierarchy there much like a family tree.

1262
00:59:52,219 --> 00:59:55,959
因此，如果我想将hello.c上移一个级别，
So if I want to move hello.c one level up,

1263
00:59:55,960 --> 01:00:00,250
我实际上可以做mv hello.c空格点。
I can actually do mv hello.c space dot dot.

1264
01:00:00,250 --> 01:00:04,299
就像说将文件移到上方的文件夹中一样。
And that's like saying move this file to the folder up above.

1265
01:00:04,300 --> 01:00:07,270
当我这样做时，请注意左上方发生的情况。
When I do that, notice what happened at top left.

1266
01:00:07,269 --> 01:00:11,919
现在hello.c不在演讲文件夹中，而是在它下面。
Now hello.c is not inside of the lecture folder, but below it.

1267
01:00:11,920 --> 01:00:16,090
确实，如果我现在在演讲文件夹中键入ls，那么这里什么也没有。
And indeed, if I type ls now in the lecture folder, there's nothing there.

1268
01:00:16,090 --> 01:00:21,130
我如何在这些文件夹的家族树中上移自己的一级？
How do I move myself up one level in the family tree that are these folders?

1269
01:00:21,130 --> 01:00:24,270
让我继续，然后键入cd空格点。
Let me go ahead and type cd space dot dot.

1270
01:00:24,269 --> 01:00:26,649
因此，将目录更改为我的父母。
So change directory to my parent.

1271
01:00:26,650 --> 01:00:28,180
点点只是意味着你的父母。
Dot dot just means your parent.

1272
01:00:28,179 --> 01:00:30,159
在上方的文件夹中，输入。
The folder up above, Enter.

1273
01:00:30,159 --> 01:00:33,249
而现在，我显然只是在波浪号之间
And now, I'm apparently in just tilde slash,

1274
01:00:33,250 --> 01:00:37,240
同样，这是你自己的主目录的隐喻速记符号-
which is, again, cryptic shorthand notation for your own home directory--

1275
01:00:37,239 --> 01:00:40,009
你的“我的文档”或“文档”文件夹。
your My Documents or documents folder.

1276
01:00:40,010 --> 01:00:43,647
最后，如果我在此处输入ls，则说明课程文件夹已经完成。
And if, lastly, I type ls here, I'm done with this lecture folder.

1277
01:00:43,646 --> 01:00:45,729
我不想麻烦将内容存储在文件夹中。
I don't want to bother storing things in a folder.

1278
01:00:45,730 --> 01:00:50,560
我不能删除，就像我打过招呼一样，
I can do not rm for remove, like I did to get rid of hello,

1279
01:00:50,559 --> 01:00:53,679
但是rmdir删除目录。
but rmdir to remove a directory.

1280
01:00:53,679 --> 01:00:55,299
瞧，它不见了。
And voila, it's gone.

1281
01:00:55,300 --> 01:00:59,050
而且，我撤消了之前所做的所有各种更改。
And I've undone all of the various changes that I made earlier.

1282
01:00:59,050 --> 01:01:01,510
但也许现在更有意义了
But perhaps now it makes a little more sense

1283
01:01:01,510 --> 01:01:03,220
为什么我早些做某事。
why I was doing something earlier.

1284
01:01:03,219 --> 01:01:05,509
让我打开我的hello.c文件。
Let me open up my hello.c file.

1285
01:01:05,510 --> 01:01:08,860
让我再次打招呼，那是我们离开的地方。
Let me make hello again, which is way back where we left off.

1286
01:01:08,860 --> 01:01:13,060
回想一下，我一直都在打点斜线打招呼。
And recall that all this time I've been doing dot slash hello.

1287
01:01:13,059 --> 01:01:14,499
好吧，为什么呢？
Well, why is that?

1288
01:01:14,500 --> 01:01:18,189
就像点点指向你的父目录一样，
Well, just as dot dot refers to your parent directory,

1289
01:01:18,190 --> 01:01:21,380
单点表示你的当前目录。
a single dot refers to your current directory.

1290
01:01:21,380 --> 01:01:23,350
因此，即使这看起来有点愚蠢，
So even though this looks a little silly,

1291
01:01:23,349 --> 01:01:26,949
点斜杠打招呼只是一种非常明确的方式
dot slash hello is just a very explicit way

1292
01:01:26,949 --> 01:01:30,609
告诉计算机，运行名为hello的程序
of telling the computer, run the program called hello

1293
01:01:30,610 --> 01:01:33,430
就在我当前目录中
that's right here in my current directory.

1294
01:01:33,429 --> 01:01:35,199
点表示当前目录。
Dot means current directory.

1295
01:01:35,199 --> 01:01:37,179
点点表示父目录。
Dot dot means parent directory.

1296
01:01:37,179 --> 01:01:39,999
因此，我们终于看到了为什么我去过
And so there we see, finally, why I've been

1297
01:01:40,000 --> 01:01:41,979
一直打点斜杠打招呼。
typing dot slash hello all this time.

1298
01:01:41,980 --> 01:01:45,310
再次，这只是做某事的文字模拟
But again, it's just the textual analog of doing something

1299
01:01:45,309 --> 01:01:50,529
例如在Mac OS或Windows中双击图标。
like double clicking on an icon in Mac OS or Windows.

1300
01:01:50,530 --> 01:01:53,740
因此，还有其他命令，随着时间的流逝，你将接触到这些命令。
So there's other commands too, and over time you'll get exposed to these

1301
01:01:53,739 --> 01:01:55,449
并将其用于各种问题。
and use them for various problems.

1302
01:01:55,449 --> 01:01:58,909
例如，用于复制的Cp是另一个。
Cp for copy, for instance, is yet another.

1303
01:01:58,909 --> 01:02:01,629
还有许多其他命令，但这只是标准命令。
And many others, but these are all just standard commands.

1304
01:02:01,630 --> 01:02:03,610
它们不是CS50特有的。
They are not CS50 specific.

1305
01:02:03,610 --> 01:02:07,900
允许我们操作文件和文件夹的标准命令
Standard commands that allow us to manipulate files and folders

1306
01:02:07,900 --> 01:02:10,150
在这样的计算机上。
in a computer like this.

1307
01:02:10,150 --> 01:02:12,508
还有马克斯的问题。
And question from Max.

1308
01:02:12,507 --> 01:02:13,049
听众：嗨。
AUDIENCE: Hi.

1309
01:02:13,050 --> 01:02:13,660
是的，对不起。
Yeah, sorry.

1310
01:02:13,659 --> 01:02:14,289
我只是想知道。
I was just wondering.

1311
01:02:14,289 --> 01:02:16,599
我不太了解hello程序之间的区别
I don't really understand the difference between the hello program

1312
01:02:16,599 --> 01:02:17,799
和hello.c程序。
and the hello.c program.

1313
01:02:17,800 --> 01:02:21,830
似乎上面没有点c的那个东西什么也没用。
It seems like the one that doesn't have dot c on it isn't used for anything.

1314
01:02:21,829 --> 01:02:23,079
戴维·马兰：哦，是的。
DAVID MALAN: Oh, it is though.

1315
01:02:23,079 --> 01:02:25,811
所以回想一下，我们在故事中有两件事。
So recall that we have two things in the story.

1316
01:02:25,811 --> 01:02:28,269
我们有源代码，这就是我一直在编写的C代码。
We have source code, which is the C code I've been writing.

1317
01:02:28,269 --> 01:02:30,009
然后是机器码，即零
And then machine code, which is the zeros

1318
01:02:30,010 --> 01:02:31,790
以及计算机可以理解的内容。
and ones that the computer understands.

1319
01:02:31,789 --> 01:02:35,859
我已经在名为hello.c的文件中编写了所有代码。
I have been writing all of my code in the file called hello.c.

1320
01:02:35,860 --> 01:02:39,790
但是用make编译之后，make程序
But after I compile it with make, the make program

1321
01:02:39,789 --> 01:02:44,319
创建一个名为hello的新文件，该文件在技术上仅包含零
creates a new file called hello that technically contains only zeros

1322
01:02:44,320 --> 01:02:45,100
和一个。
and ones.

1323
01:02:45,099 --> 01:02:47,409
那就是我实际上的机器代码
And that is the machine code that I'm actually

1324
01:02:47,409 --> 01:02:50,109
当我做点斜线问好时运行。
running when I do dot slash hello.

1325
01:02:50,110 --> 01:02:53,710
再说一次，我可以使用rm，并且可以摆脱hello程序
So again, I can use rm and I can get rid of the hello program

1326
01:02:53,710 --> 01:02:54,820
就像我以前一样。
just like I did before.

1327
01:02:54,820 --> 01:02:57,028
现在我们回到故事的开始
And now we're back at the very beginning of the story

1328
01:02:57,027 --> 01:02:58,749
我们从头开始编写此代码的地方。
where we wrote this code from scratch.

1329
01:02:58,750 --> 01:03:01,870
如果我现在输入make，现在让我这样做，请ls。
If I now type make, and let me do this now, ls.

1330
01:03:01,869 --> 01:03:03,679
注意，我只有一个文件。
Notice I've only got one file.

1331
01:03:03,679 --> 01:03:05,409
现在让我打个招呼。
Let me now do make hello.

1332
01:03:05,409 --> 01:03:09,249
我看到了神秘的输出，但是如果我再次输入ls，现在我有两个文件。
I see that cryptic output, but if I type ls again, now I have two files.

1333
01:03:09,250 --> 01:03:14,019
那是因为只有带有星号的绿色是可执行的。
And that's because only the green one with the asterisk is executable.

1334
01:03:14,019 --> 01:03:18,292
那就是编译器为我创建的机器代码。
That is the machine code that the compiler has created for me.

1335
01:03:18,293 --> 01:03:21,460
我应该说并拒绝，我一直在讲一个白色的谎言
And I should say and disclaim, I've been telling a little bit of a white lie

1336
01:03:21,460 --> 01:03:21,960
今天。
today.

1337
01:03:21,960 --> 01:03:23,890
Make本身实际上不是编译器。
Make itself is not actually a compiler.

1338
01:03:23,889 --> 01:03:26,499
下周我们将确切地了解make的工作。
We'll see next week exactly what make is doing.

1339
01:03:26,500 --> 01:03:30,459
但这使我们更容易实际编译我们的代码，
But it's making it easier for us to actually compile our code,

1340
01:03:30,460 --> 01:03:32,740
但是下一次会更多。
but more on that next time.

1341
01:03:32,739 --> 01:03:33,339
好的。
All right.

1342
01:03:33,340 --> 01:03:37,600
因此，到目前为止，我们仅看到了字符串，但结果却是在C语言中，
So we've seen only strings thus far, but it turns out in C,

1343
01:03:37,599 --> 01:03:41,379
在许多语言中，还有其他一些称为类型或数据类型的东西。
and in a lot of languages, there's other things known as types or data types.

1344
01:03:41,380 --> 01:03:43,840
也就是说，你可以拥有变量和值
That is to say, you can have variables and values

1345
01:03:43,840 --> 01:03:47,290
不仅是文本字符串，而且可能是整数，
that aren't just strings of text, but that are maybe integers,

1346
01:03:47,289 --> 01:03:49,059
像数字，一，二，三，四。
like numbers, one, two, three, four.

1347
01:03:49,059 --> 01:03:54,279
或者可能是浮点值（例如3.14159）或其他此类值。
Or maybe floating point values, like 3.14159, or other such values.

1348
01:03:54,280 --> 01:03:58,360
你可以具有布尔值，只能为true或false。
You can have Boolean values, which are only true or false.

1349
01:03:58,360 --> 01:04:02,200
你可以包含单个字符的字符或字符。
You can have characters or chars, which are single characters.

1350
01:04:02,199 --> 01:04:06,009
这就是说，在像C这样的语言中，实际上有很多数据
This is to say, within a language like C there's actually a whole bunch of data

1351
01:04:06,010 --> 01:04:07,660
你可以使用的类型。
types that are available to you.

1352
01:04:07,659 --> 01:04:09,739
字符串只是其中之一。
String is only one of them.

1353
01:04:09,739 --> 01:04:12,069
而且，这里的清单甚至更多，
And there's even more than are on this list here,

1354
01:04:12,070 --> 01:04:16,180
但这只是我们今天将看到的一些最常见的列表
but this is just a list of some of the most common ones that we'll see today

1355
01:04:16,179 --> 01:04:18,819
我们将在下一周的第一个问题集中使用
and we'll use this coming week in the first problem set

1356
01:04:18,820 --> 01:04:22,820
这样你不仅可以告诉计算机将值存储在变量中，
that allow you to tell the computer not only to store a value in a variable,

1357
01:04:22,820 --> 01:04:25,510
但是要在变量中存储哪种类型的值。
but what type of value to store in a variable.

1358
01:04:25,510 --> 01:04:29,740
此外，我们在CS50库中还有很多其他功能。
Moreover, we have in the CS50 library a whole bunch more functions.

1359
01:04:29,739 --> 01:04:31,479
我们已经看过get_string了。
We've seen get_string already.

1360
01:04:31,480 --> 01:04:34,300
但是类似地，我们创建了一些函数
But similarly have we created functions that you

1361
01:04:34,300 --> 01:04:36,700
可以用于问题集，实验等
can use for problem sets, labs, and beyond that

1362
01:04:36,699 --> 01:04:40,179
允许你通过get_char获得单个字符。
allow you to get a single character via a get_char.

1363
01:04:40,179 --> 01:04:43,119
这样可以使你通过get_int获得一个整数。
That can allow you to get an integer via get_int.

1364
01:04:43,119 --> 01:04:45,009
那可以让你得到一个浮点数
That can allow you to get a floating point

1365
01:04:45,010 --> 01:04:47,650
值，这是描述实数的一种好方法，
value, which is a fancy way of describing a real number,

1366
01:04:47,650 --> 01:04:50,440
使用get_float使用小数点。
with a decimal point using get_float.

1367
01:04:50,440 --> 01:04:56,110
但是事实证明，这些数据类型（例如int和float）中的每一个，
But it turns out that each of these data types, like int and float,

1368
01:04:56,110 --> 01:04:58,300
只有有限的位数。
only have a finite number of bits.

1369
01:04:58,300 --> 01:05:01,180
回想一下上周我们玩过的灯泡
And recall from last week that we played around with light bulbs

1370
01:05:01,179 --> 01:05:03,909
然后我们更广泛地使用零位和零位
and we played around with bits and zeros and ones more generally.

1371
01:05:03,909 --> 01:05:06,729
事实证明，这些数据类型中的每一种，
It turns out that every one of these data types,

1372
01:05:06,730 --> 01:05:11,500
char，double，floats，int，long，string等，全部
char, double, floats, int, long, string, and so forth, all

1373
01:05:11,500 --> 01:05:13,930
使用特定数量的位。
use a specific number of bits.

1374
01:05:13,929 --> 01:05:20,379
结果表明int（例如C中的整数）仅使用32位。
And it turns out that int, for instance, integers in C, only use 32 bits.

1375
01:05:20,380 --> 01:05:24,820
直到你希望计数高于大约4的时间之前，这都是很棒的
And that's great until such time as you want to count higher than roughly 4

1376
01:05:24,820 --> 01:05:27,220
十亿，这是你无法做到的。
billion, at which point you can't.

1377
01:05:27,219 --> 01:05:30,609
今天晚些时候，我们将看到，如果你仅使用特定数量的位
We'll see later today that if you're only using a specific number of bits

1378
01:05:30,610 --> 01:05:33,550
你只能进行如此高的计数，因此存在其他数据类型。
you can only count so high, and so there exist other data types.

1379
01:05:33,550 --> 01:05:35,230
例如，很长。
For instance, a long.

1380
01:05:35,230 --> 01:05:39,520
长整数是C中仅使用64位的另一种数字。
A long is another type of number in C that just uses 64 bits.

1381
01:05:39,519 --> 01:05:43,299
因此，它使你更具表达力，并提供更多零和一的模式
So it gives you way more expressiveness, way more patterns of zeros and ones

1382
01:05:43,300 --> 01:05:44,320
甚至更高。
to count even higher.

1383
01:05:44,320 --> 01:05:47,290
同样，双精度值类似于浮点值。
Similarly, a double is like a floating point value.

1384
01:05:47,289 --> 01:05:50,589
带有小数点的实数，其后还有一些数字。
A real number with a decimal point and some number of digits after it.

1385
01:05:50,590 --> 01:05:56,050
双精度字使你可以拥有比浮点数更多的数字。
A double allows you to have even more digits after it than a float would.

1386
01:05:56,050 --> 01:05:59,200
因此，我们稍后将看到并使用其中一些数据类型。
So we'll see and use some of these data types in just a bit.

1387
01:05:59,199 --> 01:06:02,379
同样，Printf不仅可以打印出字符串，还可以打印出字符串
Printf, similarly, has the ability to print out not only strings

1388
01:06:02,380 --> 01:06:06,080
如我们所见，还使用其他数据类型使用了不同的格式代码。
as we saw, but also using different format codes other data types as well.

1389
01:06:06,079 --> 01:06:09,412
这些有点神秘，可以根据需要查找这些东西，
These are a little more cryptic and it's fine to look these things up as needed,

1390
01:06:09,413 --> 01:06:12,385
但最终你会根深蒂固它们以了解常见的用例。
but you'll eventually ingrain them for common use cases.

1391
01:06:12,385 --> 01:06:16,015
百分比c将成为打印单个字符的占位符。
Percent c is going to be the placeholder for printing a single character.

1392
01:06:16,014 --> 01:06:18,309
可以说，百分比c为一个字符。
Percent c for a char, so to speak.

1393
01:06:18,309 --> 01:06:21,054
f的百分比将为浮点值。
Percent f is going to be for a floating point value.

1394
01:06:21,054 --> 01:06:23,679
因此，如果你要打印带小数点的实数，
So if you want to print out a real number with a decimal point,

1395
01:06:23,679 --> 01:06:25,089
你将使用百分比f。
you're going to use percent f.

1396
01:06:25,090 --> 01:06:27,370
如果要使用打印f打印整数，
If you want to print an integer using print f,

1397
01:06:27,369 --> 01:06:29,441
你将使用百分比i作为整数。
you're going to use percent i for integer.

1398
01:06:29,442 --> 01:06:31,900
如果要打印字符串，我们已经看到了percent s。
If you want to print a string we've already seen percent s.

1399
01:06:31,900 --> 01:06:34,840
如果要打印一个长整数，也就是
And if you want to print a long integer, a.k.a.

1400
01:06:34,840 --> 01:06:36,940
很长一段时间，你将要使用百分比li。
long, you're going to use percent li.

1401
01:06:36,940 --> 01:06:39,910
甚至还有其他一些，但是这些也许是最常见的一些。
And there's even others, but these are perhaps some of the most common.

1402
01:06:39,909 --> 01:06:44,049
这就意味着，C确实确实需要你，程序员，
And it just means that, again, C really needs you, the programmer,

1403
01:06:44,050 --> 01:06:44,858
确切地说。
to be precise.

1404
01:06:44,858 --> 01:06:46,150
你不能只是说，打印此。
You can't just say, print this.

1405
01:06:46,150 --> 01:06:50,830
你必须告诉printf如何打印变量或值
You have to tell printf how to print the variable or the value

1406
01:06:50,829 --> 01:06:52,309
你正在传递给它。
that you're passing into it.

1407
01:06:52,309 --> 01:06:54,789
最后，事实证明，在C中
And then lastly, it turns out that in C there's

1408
01:06:54,789 --> 01:06:59,479
一堆运算符，当然是数学运算符，还有其他运算符
a whole bunch of operators, certainly mathematical ones and bunches of others

1409
01:06:59,480 --> 01:06:59,980
也一样
as well.

1410
01:06:59,980 --> 01:07:02,740
就像刮开整个操作员工具包一样。
Just like Scratch out a whole toolkit of operators.

1411
01:07:02,739 --> 01:07:06,919
到目前为止，C还支持加，减，
And suffice it to say for now that C also supports addition, subtraction,

1412
01:07:06,920 --> 01:07:09,430
乘法，除法，甚至余数
multiplication, division, and even the remainder

1413
01:07:09,429 --> 01:07:13,059
运算符，用百分号表示。
operator, which a little cryptically is represented with a percent sign.

1414
01:07:13,059 --> 01:07:15,496
不要与printf的格式代码混淆，
Not to be confused with printf's format codes,

1415
01:07:15,496 --> 01:07:18,579
但这就是说，计算机的某些最早使用，
but this is to say that some of the earliest uses of computers, of course,

1416
01:07:18,579 --> 01:07:21,219
都是在电子表格程序中以数学为导向的。
were all mathematically oriented in spreadsheet programs.

1417
01:07:21,219 --> 01:07:24,879
像Excel和Google之前的VisiCalc之类的程序
Programs like VisiCalc and the like back before there was Excel and Google

1418
01:07:24,880 --> 01:07:25,690
电子表格。
spreadsheets.

1419
01:07:25,690 --> 01:07:29,380
而且他们当然是计算机，他们非常擅长支持数学。
And they certainly, computers, are very good at supporting math.

1420
01:07:29,380 --> 01:07:31,990
因此，这些只是现在将要看到的一些运营商
And so these are just some of the operators that will now see

1421
01:07:31,989 --> 01:07:33,187
可供我们使用。
are available to us.

1422
01:07:33,188 --> 01:07:34,480
因此，让我继续执行此操作。
So let me go ahead and do this.

1423
01:07:34,480 --> 01:07:39,250
让我在清理东西后回到我的IDE
Let me go back to my IDE after cleaning things

1424
01:07:39,250 --> 01:07:44,110
起，然后重新开始，终端窗口中什么也没有，也没有打开任何选项卡。
up, and starting fresh with just nothing in my terminal window and no tabs open.

1425
01:07:44,110 --> 01:07:46,810
让我这次继续写我的下一个程序
And let me go ahead and write my next program this time

1426
01:07:46,809 --> 01:07:48,699
使用更多这些功能。
using some more of these functions.

1427
01:07:48,699 --> 01:07:52,629
我将继续在此处创建一个名为additioning.c的文件。
I'm going to go ahead and create a file up here called addition.c.

1428
01:07:52,630 --> 01:07:55,750
所以additional.c，但是我可以称呼它为我想要的任何东西，
So addition.c, but I could call this anything I want,

1429
01:07:55,750 --> 01:07:58,180
但是添加点c很重要。
but it's important to add the dot c.

1430
01:07:58,179 --> 01:08:00,969
否则，计算机将不会知道其实际来源
Otherwise the computer will not know that it's actual source

1431
01:08:00,969 --> 01:08:02,839
代码而不是机器代码。
code as opposed to machine code.

1432
01:08:02,840 --> 01:08:05,750
让我继续使用CS50库。
And let me go ahead and make use of the CS50 library.

1433
01:08:05,750 --> 01:08:07,779
因此，让我包括cs50.h。
So let me include cs50.h.

1434
01:08:07,780 --> 01:08:13,330
让我包括stdio.h，以便可以使用诸如get_int和printf之类的东西。
Let me include stdio.h, so that I can use things like get_int and printf.

1435
01:08:13,329 --> 01:08:15,139
然后，为了今天的目的，
And then, again, for today's purposes,

1436
01:08:15,139 --> 01:08:19,839
我将先做int main void，然后做花括号。
I'm just going to do int main void, and then the curly braces.

1437
01:08:19,840 --> 01:08:22,750
再说一次，今天，只要相信这一点就可以了。
And again, for today, just take on faith this is necessary.

1438
01:08:22,750 --> 01:08:25,600
但是我们会在一两周内解释为什么
But we'll explain within a week or two exactly why

1439
01:08:25,600 --> 01:08:27,250
我们继续写int main void。
we keep writing int main void.

1440
01:08:27,250 --> 01:08:31,419
但就目前而言，这就像赢得绿色标志的拼图一样。
But for now, it's like the win green flag clicked puzzle piece.

1441
01:08:31,420 --> 01:08:34,227
现在让我继续，从用户那里获取一个整数。
Let me go ahead now and get an integer from the user.

1442
01:08:34,226 --> 01:08:36,309
假设我现在的目标不是编写一个程序
Suppose my goal now is not to write a program that

1443
01:08:36,310 --> 01:08:39,850
获取一串文本并打印出你好，Brian或你好，David。
gets a string of text and prints out hello, Brian, or hello, David.

1444
01:08:39,850 --> 01:08:42,670
让我继续写一个可能会问的程序
Let me go ahead and write a program that maybe asks

1445
01:08:42,670 --> 01:08:46,220
两个整数，两个数字，然后将它们加在一起。
for two integers, two numbers, and then just adds them together.

1446
01:08:46,220 --> 01:08:49,479
因此，让我使用代码使计算器最简单。
So let me make the simplest of calculators using code.

1447
01:08:49,479 --> 01:08:52,990
好吧，我将继续声明一个名为
Well, I'm going to go ahead and declare a variable called

1448
01:08:52,989 --> 01:08:54,909
x，就像数学家一样。
x, just like a mathematician would.

1449
01:08:54,909 --> 01:08:59,259
我将为其分配调用get_int的值。
And I'm going to assign it the value of calling get_int.

1450
01:08:59,260 --> 01:09:01,630
我只说x冒号。
And I'll just say something like x colon.

1451
01:09:01,630 --> 01:09:04,450
我可以说任何我想说的，x是什么？
I could say anything I want, what is x?

1452
01:09:04,449 --> 01:09:06,938
但是我将保持简单，只说x冒号。
But I'm going to keep it simple and just say x colon.

1453
01:09:06,939 --> 01:09:08,740
分号结束了我的想法。
Semicolon to end my thought.

1454
01:09:08,739 --> 01:09:11,919
再说一次，在精神上与我之前对弦乐所做的类似，
So again, similar in spirit to what I did with string before,

1455
01:09:11,920 --> 01:09:16,029
但是现在我正在使用get_int从用户那里获取数字或整数。
but now I'm using get_int to get a number or an integer from the user.

1456
01:09:16,029 --> 01:09:21,279
这里引用的参数或参数是输入
The quoted parameter here or argument is the input

1457
01:09:21,279 --> 01:09:24,520
get_int，这将是人类看到的提示。
to get_int, which is going to be the prompt that the human sees.

1458
01:09:24,520 --> 01:09:27,560
等号，回想，是赋值运算符，
The equals sign, recall, is the assignment operator,

1459
01:09:27,560 --> 01:09:31,810
也就是说，复制右侧的返回值-
which says, copy the return value on the right--

1460
01:09:31,810 --> 01:09:34,149
人类希望输入的整数-
the integer that the human hopefully will type in--

1461
01:09:34,149 --> 01:09:35,800
在左边。
over to the left.

1462
01:09:35,800 --> 01:09:39,430
左边说，给我一个变量x
And the left says, give me a variable called, x,

1463
01:09:39,430 --> 01:09:42,710
并让我在其中存储整数。
and let me store integers in it.

1464
01:09:42,710 --> 01:09:46,128
因此，在此之前，我们在左侧使用string，在右侧使用get_string。
So before, we use string on the left and we used get_string the right.

1465
01:09:46,127 --> 01:09:47,919
现在唯一的区别是左边的int
The only difference now is int on the left,

1466
01:09:47,920 --> 01:09:50,979
因为我要一个数字，右边是get_int。
because I want a number, and get_int on the right.

1467
01:09:50,979 --> 01:09:54,220
然后，让我继续并再次执行此操作，并获得另一个号码。
Then let me go ahead and do this again and get another number.

1468
01:09:54,220 --> 01:09:56,320
Get_int，我只是说，冒号。
Get_int, and I'll just say, y colon.

1469
01:09:56,319 --> 01:10:00,051
但是我可以再说一遍，什么是问号，或者什么是英语。
But again, I could say, what is y question mark, or anything in English.

1470
01:10:00,051 --> 01:10:02,259
但是最后一行将是有趣的。
But the last line is going to be the interesting one.

1471
01:10:02,260 --> 01:10:05,150
现在，我要继续进行打印，例如
Now, I'm going to go ahead and print out for instance,

1472
01:10:05,149 --> 01:10:07,209
这两个数字的总和。
the sum of these two numbers.

1473
01:10:07,210 --> 01:10:12,760
但是，printf再次接受一个输入，告诉它确切地打印出什么内容。
But printf, again, takes an input that tells it what to print out exactly.

1474
01:10:12,760 --> 01:10:15,790
所以我现在还不能真正输入数字，因为我不知道
So I can't really type a number here yet because I don't know

1475
01:10:15,789 --> 01:10:17,599
人类将要输入的内容。
what the human is going to type in.

1476
01:10:17,600 --> 01:10:19,030
所以我要放一个占位符。
So I'm going to put a placeholder.

1477
01:10:19,029 --> 01:10:22,029
我要说的是百分之一，在这里放一个数字，
I'm going to percent i, which says, put a number here,

1478
01:10:22,029 --> 01:10:23,724
我只是不知道那是什么。
I just don't know yet what it is.

1479
01:10:23,725 --> 01:10:25,600
然后为了保持清洁，我要
And then just to keep things clean, I'm going

1480
01:10:25,600 --> 01:10:28,690
做反斜杠n（刚才说），也给我换行。
to do backslash n, which just says, give me a new line also.

1481
01:10:28,689 --> 01:10:31,689
这只是将光标移至下一行的美学细节
That's just an aesthetic detail to move the cursor to the next line just

1482
01:10:31,689 --> 01:10:33,279
保持清洁。
to keep things clean.

1483
01:10:33,279 --> 01:10:36,474
但是现在printf将有第二个论点。
But now printf is going to take a second argument.

1484
01:10:36,475 --> 01:10:38,350
而且，无论你之前是否进行过编程，
And whether you've programmed or not before--

1485
01:10:38,350 --> 01:10:40,870
布莱恩，如果可以的话，让我们去找听众中的某人
Brian, let's go to someone in the audience if we could--

1486
01:10:40,869 --> 01:10:44,439
如果此程序的目的，我应该在逗号后面键入什么
what should I type after the comma if the purpose of this program

1487
01:10:44,439 --> 01:10:47,559
只是简单地将两个数字相加？
is quite simply to add two numbers together?

1488
01:10:47,560 --> 01:10:51,310
即使你以前从未编程过，也要根据现有的运算符进行编程
Even if you've never programmed before, based on the operators that exist

1489
01:10:51,310 --> 01:10:53,200
以及到目前为止我们已经看到的一些语法，
and some of the syntax we've seen thus far,

1490
01:10:53,199 --> 01:10:55,074
你在这里输入什么直觉？
what would your instincts have you type here?

1491
01:10:55,074 --> 01:10:57,219
即使你以前从未这样做过。
Even if you've never done this before.

1492
01:10:57,220 --> 01:11:00,160
圣地亚哥，你怎么看？
Santiago, what do you think?

1493
01:11:00,159 --> 01:11:03,459
听众：我会说只写x加y。
AUDIENCE: I would say to just write x plus y.

1494
01:11:03,460 --> 01:11:06,400
戴维·马兰（David MALAN）：是的，它是如此简单和直接。
DAVID MALAN: Yeah, it is simple and as straightforward as that.

1495
01:11:06,399 --> 01:11:08,121
X加y是正确的直觉。
X plus y is the right intuition.

1496
01:11:08,122 --> 01:11:11,080
我将在最后添加一个分号以完成我的想法。
I'm going to add a semicolon to the very end just to finish my thought.

1497
01:11:11,079 --> 01:11:13,659
但是确实，在这种情况下，计算机和C
But indeed, computers, and C in this case,

1498
01:11:13,659 --> 01:11:17,109
完全理解算术和数学运算，所以只需键入
absolutely understand arithmetic and mathematical operations, so just type

1499
01:11:17,109 --> 01:11:17,889
你是什么意思。
what you mean.

1500
01:11:17,890 --> 01:11:20,800
我现在要继续并保存文件，然后在下面进行浏览。
I'm going to go ahead now and save the file and go down below.

1501
01:11:20,800 --> 01:11:22,690
而且我不再输入make hello了。
And I'm not going to type make hello anymore.

1502
01:11:22,689 --> 01:11:26,469
现在，我要键入make add，因为那是我文件的名称
Now I want to type make addition, because that is the name of my file

1503
01:11:26,470 --> 01:11:27,310
隐含地。
implicitly.

1504
01:11:27,310 --> 01:11:28,540
加法c。
Addition.c.

1505
01:11:28,539 --> 01:11:31,869
我想编译成一个名为“加法”的程序。
I want to compile into a program called addition.

1506
01:11:31,869 --> 01:11:35,169
希望这是我的手指，没有犯任何错误。
Hopefully, this is where I cross my fingers, I didn't make any mistakes.

1507
01:11:35,170 --> 01:11:38,350
我将继续进行添加。
And I'm going to go ahead and run make addition.

1508
01:11:38,350 --> 01:11:40,305
一切顺利，没有错误消息。
All this well, no error messages.

1509
01:11:40,305 --> 01:11:42,430
如果我犯了一个错误，甚至没有编译，
If I had made a mistake and it didn't even compile,

1510
01:11:42,430 --> 01:11:44,920
help50可能是我的下一个直觉。
help50 might have been my next instinct.

1511
01:11:44,920 --> 01:11:47,230
现在，我将继续运行点斜杠加法。
Now I'm going to go ahead and run dot slash addition.

1512
01:11:47,229 --> 01:11:49,509
并注意，我首先被提示输入x。
And notice, I'm first prompted for x.

1513
01:11:49,510 --> 01:11:51,130
我要去做一个。
I'm going to go ahead and do one.

1514
01:11:51,130 --> 01:11:52,630
接下来，我提示你输入y。
I'm next prompted for y.

1515
01:11:52,630 --> 01:11:54,460
我要继续做一次。
I'm going to go ahead and do one again.

1516
01:11:54,460 --> 01:11:59,230
瞧，正如圣地亚哥所建议的，我的确在屏幕上看到x加y，
And voila, as Santiago proposed, I indeed see on the screen x plus y,

1517
01:11:59,229 --> 01:12:00,159
或值二。
or the value two.

1518
01:12:00,159 --> 01:12:01,449
而且我没有硬编码两个。
And I didn't hardcode two.

1519
01:12:01,449 --> 01:12:07,599
无论x加y的实际结果如何，我都用i代替。
I substituted in using i whatever the result of x plus y actually is.

1520
01:12:07,600 --> 01:12:11,260
现在注意，get_int函数的某些功能为你服务。
Now notice, some of the features of the get_int function for you.

1521
01:12:11,260 --> 01:12:14,860
假设你不是很合作，请输入cat作为x。
Suppose that you're not being very cooperative and you type in cat for x.

1522
01:12:14,859 --> 01:12:18,099
请注意，get_int只会忽略你并再次提示你。
Notice that get_int just ignores you and prompts you again.

1523
01:12:18,100 --> 01:12:21,760
如果我输入狗，它会忽略我并再次提示我。
If I type in dog it ignores me and prompts me again.

1524
01:12:21,760 --> 01:12:25,450
如果我输入1.23，它将忽略我并再次提示我
If I type in 1.23, it ignores me and prompts me again

1525
01:12:25,449 --> 01:12:27,639
因为在这种情况下，它需要一个整数。
because it wants an integer in this case.

1526
01:12:27,640 --> 01:12:29,140
像一，二，三，四这样的数字。
A number like one, two, three, four.

1527
01:12:29,140 --> 01:12:32,650
或负一，二，三，四或零，或高于或低于此值。
Or negative one, two, three, four, or zero, or anything above or below.

1528
01:12:32,649 --> 01:12:35,349
很好，我现在将合作并给予第一。
So fine, I'll cooperate now and give it the number one.

1529
01:12:35,350 --> 01:12:36,250
与y相同。
Same for y.

1530
01:12:36,250 --> 01:12:38,436
它将忽略任何非整数输入。
It's going to ignore any non-integer input.

1531
01:12:38,436 --> 01:12:40,269
因此，如果这次我给它一个类似两个的数字，
So if I give it a number like two this time,

1532
01:12:40,270 --> 01:12:42,720
我希望得到三个答案。
I'll hopefully get the answer of three.

1533
01:12:42,720 --> 01:12:43,220
好的。
All right.

1534
01:12:43,220 --> 01:12:46,930
所以我们在C中有一个基本的计算器。我们正在使用一些基本的构建
So we have a basic calculator in C. We're using some basic building

1535
01:12:46,930 --> 01:12:47,800
像以前一样阻止。
blocks as before.

1536
01:12:47,800 --> 01:12:52,360
我们已经有了这些头文件，它们使我可以访问get_int和printf
We've got these header files, which just give me access to get_int and printf

1537
01:12:52,359 --> 01:12:53,379
分别。
respectively.

1538
01:12:53,380 --> 01:12:55,497
但是，假设现在我想算得更高。
But suppose now I want to count up even higher.

1539
01:12:55,497 --> 01:12:56,080
你知道吗？
You know what?

1540
01:12:56,079 --> 01:12:57,371
让我尝试这样的事情。
Let me try something like this.

1541
01:12:57,372 --> 01:12:58,930
让我再次运行该程序。
Let me run this program once more.

1542
01:12:58,930 --> 01:13:00,640
让我有点贪心。
And let me get a little greedy.

1543
01:13:00,640 --> 01:13:05,540
大约40亿。
How about 4,000,000,000.

1544
01:13:05,539 --> 01:13:07,329
大概-好吧-确切地说-
So roughly-- well, exactly--

1545
01:13:07,329 --> 01:13:08,799
40亿。
4 billion.

1546
01:13:08,800 --> 01:13:10,750
那是我要输入的号码。
That's the number I want to type in.

1547
01:13:10,750 --> 01:13:13,629
请注意，x不喜欢那样。
Notice that x does not like that.

1548
01:13:13,630 --> 01:13:16,420
因此，get_int不接受40亿。
So get_int does not accept 4 billion.

1549
01:13:16,420 --> 01:13:20,500
好吧，让我尝试一下30亿。
Well, let me try it maybe 3 billion.

1550
01:13:20,500 --> 01:13:21,062
嗯。
Uh-huh.

1551
01:13:21,061 --> 01:13:21,769
不喜欢那样
Didn't like that.

1552
01:13:21,770 --> 01:13:23,960
二十亿左右呢？
How about 2 billion?

1553
01:13:23,960 --> 01:13:25,610
好，那个工作了。
OK, that one worked.

1554
01:13:25,609 --> 01:13:27,319
让我在这里暂停。
Let me pause here.

1555
01:13:27,319 --> 01:13:29,599
可能是怎么回事？
What's going on perhaps?

1556
01:13:29,600 --> 01:13:32,450
再一次，我们的工作人员写了get_int，所以我们
Now again, we the staff wrote get_int, so we

1557
01:13:32,449 --> 01:13:36,859
是那些拒绝猫，拒绝狗和拒绝的人
are the ones that are rejecting cats, and rejecting dogs, and rejecting

1558
01:13:36,859 --> 01:13:39,079
40亿甚至30亿。
4 billion, and even 3 billion.

1559
01:13:39,079 --> 01:13:41,209
但是在这种情况下，它还不太清楚。
But in this case, it's a little less clear.

1560
01:13:41,210 --> 01:13:45,260
为什么我们拒绝40亿和30亿呢？
Why did we reject 4 billion and 3 billion do you think?

1561
01:13:45,260 --> 01:13:48,780
基于迄今为止的一些定义。
Based on some of the definitions thus far today.

1562
01:13:48,779 --> 01:13:49,619
为什么会这样呢？
Why might this be?

1563
01:13:49,619 --> 01:13:52,259
纳撒尼尔，你怎么看？
Nathaniel, what do you think?

1564
01:13:52,260 --> 01:13:54,540
听众：号码大小有上限
AUDIENCE: There's a cap on the size of the number

1565
01:13:54,539 --> 01:13:59,094
因为20亿的大小之后会占用太多的位和字节。
since it would take too many bits and bytes after the size of 2 billion.

1566
01:13:59,095 --> 01:13:59,970
大卫·马兰（David MALAN）：完美。
DAVID MALAN: Perfect.

1567
01:13:59,970 --> 01:14:03,900
因此，整数又在C中实现为这些整数。
So integers, again, are implemented in C as these things ints.

1568
01:14:03,899 --> 01:14:06,581
事实证明，整数仅使用32位。
Ints only use, it turns out, 32 bits total.

1569
01:14:06,582 --> 01:14:08,790
而且你只会知道，通过教它
And you would only know that by having been taught it

1570
01:14:08,789 --> 01:14:10,959
或查找特定的计算机系统。
or looked it up for a particular computer system.

1571
01:14:10,960 --> 01:14:15,842
但是在CS50 IDE和大多数现代系统上，它们的整数只有32位。
But they on CS50 IDE, and most modern systems, an integer is only 32 bits.

1572
01:14:15,841 --> 01:14:17,549
然后，这引发了一个问题，
And that then invites the question, well,

1573
01:14:17,550 --> 01:14:20,550
如果你有32位或灯泡，你能算多高？
if you've got 32 bits or light bulbs, how high can you count?

1574
01:14:20,550 --> 01:14:23,400
嗯，结果是有32个灯泡或比特，
Well, it turns out with 32 light bulbs, or bits,

1575
01:14:23,399 --> 01:14:26,039
你大约可以算出40亿。
you can count roughly as high as 4 billion.

1576
01:14:26,039 --> 01:14:28,949
你绝对可以算出高达30亿。
You can absolutely count as high as 3 billion.

1577
01:14:28,949 --> 01:14:31,139
但是，get_int仍然拒绝它。
And yet, get_int still rejecting it.

1578
01:14:31,140 --> 01:14:35,640
但这是因为get_int函数广泛支持整数
But that's because the get_int function supports integers broadly

1579
01:14:35,640 --> 01:14:38,340
讲，不仅包括正数，
speaking, which includes not only positive numbers,

1580
01:14:38,340 --> 01:14:41,040
而且还有负数和零。
but also negative numbers and zero.

1581
01:14:41,039 --> 01:14:44,189
而且要注意的是，如果你想同时支持两个正数
And the catch is that if you want to support both positive numbers

1582
01:14:44,189 --> 01:14:49,899
和负数，则可以代表40亿左右的可能总值。
and negative numbers, you can represent 4 billion or so total possible values.

1583
01:14:49,899 --> 01:14:53,819
但是，如果你想在数字上向左偏右
But if you want to go as far to the left and as far to the right on the number

1584
01:14:53,819 --> 01:14:55,199
我正在描述的行。
line that I'm describing.

1585
01:14:55,199 --> 01:14:58,709
你只能算出正面向上的数字高达20亿
You can only really count as high as 2 billion in the positive direction

1586
01:14:58,710 --> 01:15:01,560
负向则为负20亿。
and negative 2 billion in the negative direction.

1587
01:15:01,560 --> 01:15:03,900
因为那仍然可以给你40亿，
Because that still gives you a total of 4 billion,

1588
01:15:03,899 --> 01:15:06,839
但不超过30亿或40亿。
but not nearly as high as 3 billion or 4 billion.

1589
01:15:06,840 --> 01:15:08,760
那么，这里的解决方案是什么？
So what might the solution here be?

1590
01:15:08,760 --> 01:15:12,040
好吧，我记得前面曾提到过，还有其他数据类型。
Well, I recall earlier noting that there's other data types.

1591
01:15:12,039 --> 01:15:14,789
不仅是整数和字符串，而且还有长整数，从字面上看
Not just ints and strings, but also longs, which literally

1592
01:15:14,789 --> 01:15:17,729
是较长的整数，即64位。
are longer integers, namely 64 bit.

1593
01:15:17,729 --> 01:15:19,399
因此，让我继续尝试。
So let me go ahead and try this.

1594
01:15:19,399 --> 01:15:21,719
让我继续，将get_int更改为get_long。
Let me go ahead and change get_int to get_long.

1595
01:15:21,720 --> 01:15:23,740
此get_int到get_long。
This get_int to get_long.

1596
01:15:23,739 --> 01:15:26,819
让我将此int更改为long，并将此int更改为long。
Let me change this int a long, and this int to a long.

1597
01:15:26,819 --> 01:15:29,189
所以相同的程序，相同的计算器，但我
So same program, same calculator, but I'm

1598
01:15:29,189 --> 01:15:31,199
现在使用另一种数据类型
now using a different data type that's just

1599
01:15:31,199 --> 01:15:33,379
将使用更多的位来存储值。
going to use more bits to store values.

1600
01:15:33,380 --> 01:15:36,420
让我再次运行make add以重新编译程序。
Let me run make addition again to recompile my program.

1601
01:15:36,420 --> 01:15:37,590
而且，该死。
And, oh, damn it.

1602
01:15:37,590 --> 01:15:39,040
我搞砸了。
I screwed up.

1603
01:15:39,039 --> 01:15:41,579
因此，让我们看看是否无法在这里收集出什么问题。
So let's see if we can't glean what's wrong here.

1604
01:15:41,579 --> 01:15:42,389
让我向上滚动。
Let me scroll up.

1605
01:15:42,390 --> 01:15:43,920
而且我对此不够强调。
And I can't emphasize this enough.

1606
01:15:43,920 --> 01:15:47,010
有时-我在这里很幸运，但我只犯了一个错误，
Sometimes-- I got lucky here and I only have one mistake, apparently,

1607
01:15:47,010 --> 01:15:51,150
在错误消息中-这并不少见
in the error messages-- it is not going to be uncommon

1608
01:15:51,149 --> 01:15:55,829
就像两行代码一样，你将遇到两个错误（10个错误）。
for you to have two errors, 10 errors, in like two lines of code.

1609
01:15:55,829 --> 01:15:58,679
这是因为有时当你的代码中有错误时，
This is because sometimes when you have errors in your code,

1610
01:15:58,680 --> 01:16:01,228
编译器有时会感到困惑。
the compiler sometimes just gets confused.

1611
01:16:01,228 --> 01:16:04,020
如果弄得很困惑，它就会开始思考一切
And if it gets sufficiently confused, it starts thinking everything

1612
01:16:04,020 --> 01:16:06,010
是你实际代码中的错误。
is an error in your actual code.

1613
01:16:06,010 --> 01:16:08,520
因此，最重要的要点是，无论
So the most important takeaway is that no matter

1614
01:16:08,520 --> 01:16:13,230
你似乎有多少错误，请始终向上滚动到输出的顶部
how many errors you seem to have, always scroll up to the top of the output

1615
01:16:13,229 --> 01:16:15,209
并首先解决第一个错误。
and address the first error first.

1616
01:16:15,210 --> 01:16:18,680
这就是为什么我在窗口中向上滚动以立即在所键入内容的下方查看，
So that's why I scrolled up in my window to look immediately below what I typed,

1617
01:16:18,680 --> 01:16:20,430
进行加法，这是第一个错误。
make addition, and here's the first error.

1618
01:16:20,430 --> 01:16:21,910
第10行的Addition.c
Addition.c on line 10.

1619
01:16:21,909 --> 01:16:22,409
好的。
All right.

1620
01:16:22,409 --> 01:16:24,899
我看不到第10行，所以让我向上滚动代码。
I can't see line 10, so let me scroll my code up.

1621
01:16:24,899 --> 01:16:28,199
这是关于格式的一些说明，它指定类型为int，
And it's saying something about format specifies type int,

1622
01:16:28,199 --> 01:16:30,359
但是该参数的类型为long。
but the argument has type long.

1623
01:16:30,359 --> 01:16:33,569
我们之前从未见过此错误，但我想我可以从中推断出这一错误。
We haven't seen this error before, but I think I can infer from this.

1624
01:16:33,569 --> 01:16:36,899
即使不熟悉，也不是超级神秘。
It's not super cryptic even though it's unfamiliar.

1625
01:16:36,899 --> 01:16:40,649
我认为这意味着我记得的百分比是整数。
I think what this means is that percent i recall was for integers.

1626
01:16:40,649 --> 01:16:46,199
我认为我需要的是用于长整数的不同格式代码，其中
I think what I need is a different format code for long integers, which

1627
01:16:46,199 --> 01:16:48,509
会变成李。
is going to be li instead.

1628
01:16:48,510 --> 01:16:50,620
那是我早些时候的小备忘单。
And that was from my little cheat sheet earlier.

1629
01:16:50,619 --> 01:16:52,202
因此，让我继续尝试一下。
So let me go ahead and try this again.

1630
01:16:52,203 --> 01:16:54,360
将i更改为li后进行加法。
Make addition after changing the i to an li.

1631
01:16:54,359 --> 01:16:55,469
确实有效。
That indeed works.

1632
01:16:55,470 --> 01:16:56,850
现在让我做-
Now let me do--

1633
01:16:56,850 --> 01:16:57,720
哎呀，错字。
oops, typo.

1634
01:16:57,720 --> 01:16:59,610
现在让我加点斜杠。
Now let me dot slash addition.

1635
01:16:59,609 --> 01:17:04,107
现在，我输入4,000,000,000。
And now I'll type in 4,000,000,000.

1636
01:17:04,108 --> 01:17:05,340
40亿。
4 billion.

1637
01:17:05,340 --> 01:17:10,440
现在get_long很高兴，它将接受这么长的整数
Now get_long is happy, and it will accept such a long integer

1638
01:17:10,439 --> 01:17:13,649
因为它有足够的位。
because it has enough bits.

1639
01:17:13,649 --> 01:17:19,559
好吧，关于整数和长整型的问题，
All right, questions on types like ints and longs,

1640
01:17:19,560 --> 01:17:22,080
或类似get_int或get_long的函数。
or functions like get_int or get_long.

1641
01:17:22,079 --> 01:17:23,819
是的，彼得。
Yeah, Peter.

1642
01:17:23,819 --> 01:17:24,779
听众：是的。
AUDIENCE: Yeah.

1643
01:17:24,779 --> 01:17:30,089
当我输入20亿并且都是整数时，
When I typed 2 billion and both were integers, well,

1644
01:17:30,090 --> 01:17:32,130
最终，它只会给你错误的答案。
eventually it just gives you the wrong answer.

1645
01:17:32,130 --> 01:17:33,160
一些负数。
Some negative numbers.

1646
01:17:33,159 --> 01:17:34,806
那是因为位和字节吗？
Is that because of the bits and bytes?

1647
01:17:34,806 --> 01:17:35,639
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

1648
01:17:35,640 --> 01:17:36,640
答案是一样的。
It's the same answer.

1649
01:17:36,640 --> 01:17:39,330
所以我没有证明，但是如果你同时输入了20亿
So I didn't demonstrate that, but if you inputed both 2 billion

1650
01:17:39,329 --> 01:17:45,659
x和y的20亿，然后尝试将它们加在一起，
for x and 2 billion for y and then you try to add those together,

1651
01:17:45,659 --> 01:17:48,089
从数学上讲，这将为你带来40亿美元。
that would give you mathematically 4 billion.

1652
01:17:48,090 --> 01:17:52,170
但同样，一个int不足以存储40亿个
But again, an int is not big enough to store 4 billion

1653
01:17:52,170 --> 01:17:55,360
如果我们也想代表负数
if we want to also be able to represent negative numbers.

1654
01:17:55,359 --> 01:17:58,589
彼得，你看到的是你无法适应
So Peter what you're seeing is that you can't fit

1655
01:17:58,590 --> 01:18:01,440
所允许的数据类型中的结果。
the result in the data type allowed.

1656
01:18:01,439 --> 01:18:02,849
一会儿我们会看到-
And we'll see in a moment--

1657
01:18:02,850 --> 01:18:05,657
实际上，在今天的那一刻，
in a little bit today, actually, what the ramifications of that

1658
01:18:05,657 --> 01:18:07,740
是，但是你所描述的症状是完全正确的。
are, but the symptom you're describing is exactly.

1659
01:18:07,739 --> 01:18:13,019
你试图将太大的数字填入有限的32位中。
That you tried to cram too big of a number into finitely many bits, 32.

1660
01:18:13,020 --> 01:18:16,990
当然，你可以通过切换到较长时间来避免该问题。
You can avoid that problem though, of course, by switching over to long.

1661
01:18:16,989 --> 01:18:19,089
让我尝试另一件事，这有点奇怪。
Let me try one other thing that's a bit curious.

1662
01:18:19,090 --> 01:18:21,690
让我继续，现在编写一个略有不同的程序。
Let me go ahead and write a slightly different program now.

1663
01:18:21,689 --> 01:18:25,561
我将其描述为truncation.c。
And I'm going to describe this as truncation.c.

1664
01:18:25,561 --> 01:18:28,019
花哨的词，但是我们马上就会知道这意味着什么。
Fancy term, but we'll see what this means in just a moment.

1665
01:18:28,020 --> 01:18:30,450
我要把自己放在首位，cs50.h。
I'm going to give myself at the top, cs50.h.

1666
01:18:30,449 --> 01:18:32,874
我要给自己stdio.h。
And I'm going to give myself stdio.h.

1667
01:18:32,875 --> 01:18:36,000
一旦开始第一个实验或问题，就可以了
And it's certainly fine, once you get started with the first lab or problem

1668
01:18:36,000 --> 01:18:39,270
设置，如果你需要更长的时间才能输入其中的一些内容。
set, if it takes you much longer to type some of these things out.

1669
01:18:39,270 --> 01:18:41,130
我只是为了增强肌肉记忆力。
I'm just doing it for muscle memory.

1670
01:18:41,130 --> 01:18:42,450
Int主要无效。
Int main void.

1671
01:18:42,449 --> 01:18:46,559
现在，我们可以在名为truncation.c的文件中使用新程序了。
And now we're good to go with a new program in a file called truncation.c.

1672
01:18:46,560 --> 01:18:49,690
我将继续，提示用户再次输入int。
I'm going to go ahead and prompt a user for an int, again.

1673
01:18:49,689 --> 01:18:51,379
所以就像以前一样。
So just like before.

1674
01:18:51,380 --> 01:18:55,760
我将像以前一样提示用户输入另一个int。
I'm going to prompt the user for another int, just like before.

1675
01:18:55,760 --> 01:18:57,580
然后，我将继续执行此操作。
And then I'm going to go ahead and do this.

1676
01:18:57,579 --> 01:18:58,929
这次我想做分割。
I want to do division this time.

1677
01:18:58,930 --> 01:19:00,790
因此，不仅仅是添加，这有点太容易了。
So not just a addition, that was a little too easy.

1678
01:19:00,789 --> 01:19:01,789
让我做个除法。
Let me do a division.

1679
01:19:01,789 --> 01:19:08,139
因此，让我给自己一个变量，z等于x除以y。
So let me give myself another variable, z equals x divided by y.

1680
01:19:08,140 --> 01:19:10,270
让我在这里停留片刻，然后问
And let me pause here for a moment and just ask

1681
01:19:10,270 --> 01:19:14,530
问题是，z应该使用哪种数据类型？
the question, what data type should I perhaps use for z?

1682
01:19:14,529 --> 01:19:17,469
这行代码尚不正确，因为你随时都可以回想起
This line of code is not yet correct, because recall that any time you

1683
01:19:17,470 --> 01:19:20,440
在左侧创建一个新变量，我是
create a new variable on the left here, I'm

1684
01:19:20,439 --> 01:19:24,429
需要在该变量名称的左侧添加一些内容
going to need to put something to the left of that variable's name

1685
01:19:24,430 --> 01:19:27,370
这样C就能知道我想要什么类型的变量。
so that C knows what type of variable I want.

1686
01:19:27,369 --> 01:19:30,379
到目前为止，我们已经看到了string和int以及long。
And thus far we've seen string and int and long.

1687
01:19:30,380 --> 01:19:34,510
那么，你是否建议对z使用其中之一？
So would you propose we use one of those or something else for z?

1688
01:19:34,510 --> 01:19:35,330
杰克呢。
How about Jack.

1689
01:19:35,329 --> 01:19:37,359
你怎么认为？
What do you think?

1690
01:19:37,359 --> 01:19:38,889
听众：会是浮标吗？
AUDIENCE: Would it be a float?

1691
01:19:38,890 --> 01:19:40,090
大卫·马兰：是的，所以浮动。
DAVID MALAN: Yeah, so float.

1692
01:19:40,090 --> 01:19:44,050
因此，float是浮点值的缩写，它是程序员的
So float, which is short for floating point value, which is the programmer's

1693
01:19:44,050 --> 01:19:45,640
描述实数的方式。
way of describing a real number.

1694
01:19:45,640 --> 01:19:46,480
让我继续做。
Let me go ahead and do that.

1695
01:19:46,479 --> 01:19:46,989
一个浮点数。
A float.

1696
01:19:46,989 --> 01:19:51,039
而且我猜你对浮动的直觉是，
And I'm guessing your instincts for float were that, well,

1697
01:19:51,039 --> 01:19:53,859
如果你为x输入一个数字，为y输入另一个数字
if you type in one number for x and another for y

1698
01:19:53,859 --> 01:19:56,284
结果只是某种程度的一部分，所以
and the result is a fraction of some sort, so something

1699
01:19:56,284 --> 01:19:57,159
带小数点
with a decimal point.

1700
01:19:57,159 --> 01:20:01,059
我们需要将其存储在一个浮动中，以便我们实际上可以
We need to store it in a float so that we can actually

1701
01:20:01,060 --> 01:20:05,030
存储小数点后的数字。
store whatever the numbers are after the decimal point.

1702
01:20:05,029 --> 01:20:06,279
因此，让我们继续执行此操作。
So let's go ahead and do this.

1703
01:20:06,279 --> 01:20:08,439
现在让我继续进行打印。
Let me now go ahead and print this out.

1704
01:20:08,439 --> 01:20:11,739
f反斜杠n的百分数，因为这次我要打印浮点数。
Percent f backslash n, because I'm printing a float this time.

1705
01:20:11,739 --> 01:20:14,739
然后让我继续打印z的值。
And then let me go ahead and print out the value of z.

1706
01:20:14,739 --> 01:20:15,489
你知道吗？
And you know what?

1707
01:20:15,489 --> 01:20:19,049
只是为了好措施，让我也开始在这里练习良好的风格。
Just for good measure, let me start practicing good style here too.

1708
01:20:19,050 --> 01:20:21,502
因此从用户那里获得一个号码。
So get a number from user.

1709
01:20:21,502 --> 01:20:22,960
让我再给我自己评论。
Let me give myself another comment.

1710
01:20:22,960 --> 01:20:24,952
从用户那里获得另一个号码。
Get another number from user.

1711
01:20:24,952 --> 01:20:25,660
或者你知道吗？
Or you know what?

1712
01:20:25,659 --> 01:20:26,829
这似乎有点愚蠢。
This seems a little silly.

1713
01:20:26,829 --> 01:20:28,059
我可以合并这些行。
I can combine these lines.

1714
01:20:28,060 --> 01:20:31,420
我为什么不说，例如，从用户那里获得数字。
And why don't I just say, get, for instance, numbers from user.

1715
01:20:31,420 --> 01:20:33,640
这是注释你的代码的一种合理方法。
That's a reasonable way to comment your code.

1716
01:20:33,640 --> 01:20:37,740
然后让我们继续将x除以y。
And then let's just go ahead and divide x by y.

1717
01:20:37,739 --> 01:20:39,489
但这甚至有点学究
But even this is getting a little pedantic

1718
01:20:39,489 --> 01:20:41,539
因为你可以从代码中读取该信息。
because you can kind of read that from the code.

1719
01:20:41,539 --> 01:20:44,899
因此，在某些时候，我们甚至可能不需要对此发表评论。
So at some point we might not even need a comment for that.

1720
01:20:44,899 --> 01:20:47,049
因此，我们就这样简化一下。
So let's just simplify as such.

1721
01:20:47,050 --> 01:20:49,780
现在让我们继续进行编译。
Let's go ahead now and compile this.

1722
01:20:49,779 --> 01:20:51,879
让-来吧-
Make-- come on--

1723
01:20:51,880 --> 01:20:54,520
截断。
make truncation.

1724
01:20:54,520 --> 01:20:56,020
好的，它编译就可以了。
All right, it compiles OK.

1725
01:20:56,020 --> 01:20:57,580
我喜欢我们在这里使用浮子的方式。
And I like how we used a float here.

1726
01:20:57,579 --> 01:20:58,749
这确实是正确的。
That does feel correct.

1727
01:20:58,750 --> 01:21:00,340
因此，让我运行截断。
So let me run truncation.

1728
01:21:00,340 --> 01:21:04,690
让我继续输入例如x的4和y的2。
And let me go ahead and type in, for instance, 4 for x and 2 for y.

1729
01:21:04,689 --> 01:21:05,709
好，我喜欢
OK, I like that.

1730
01:21:05,710 --> 01:21:09,580
它是2.000，所以这是正确的数学计算。
It's 2.000, so that's the correct math calculation.

1731
01:21:09,579 --> 01:21:11,289
1除以2怎么样
How about 1 divided by 2.

1732
01:21:11,289 --> 01:21:17,934
因此x为1，y为2，为0.000000。
So x is 1, y is 2, and it's 0.000000.

1733
01:21:17,935 --> 01:21:19,810
好吧，也许那只是a幸。
All right, well, maybe that was just a fluke.

1734
01:21:19,810 --> 01:21:22,000
让我尝试再次运行它。
Let me try running it again.

1735
01:21:22,000 --> 01:21:23,229
2/3呢？
How about 2/3?

1736
01:21:23,229 --> 01:21:26,559
2除以3。
2 divided by 3.

1737
01:21:26,560 --> 01:21:28,610
那也不对。
That's not right either.

1738
01:21:28,609 --> 01:21:29,109
好的。
All right.

1739
01:21:29,109 --> 01:21:30,759
4/3呢？
How about 4/3?

1740
01:21:30,760 --> 01:21:35,060
让我们为x设置一个更大的数字，即4/3。
Let's put a bigger number for the x, so 4/3.

1741
01:21:35,060 --> 01:21:37,570
好的，离右边更近了。
OK, it's closer to right.

1742
01:21:37,569 --> 01:21:40,999
但这是本周的一个示例错误。
But this is an example, this week, of a bug.

1743
01:21:41,000 --> 01:21:42,979
这样我的代码就可以编译了。
So my code compile.

1744
01:21:42,979 --> 01:21:46,179
因此，从语法上讲这很好，但这是一个逻辑错误。
So syntactically it's fine, but this is a logical bug.

1745
01:21:46,180 --> 01:21:49,460
就像我以某种方式不正确地使用了C代码一样。
Like I've somehow used C code improperly.

1746
01:21:49,460 --> 01:21:51,860
那么这可能是怎么回事？
So what might be going on here?

1747
01:21:51,859 --> 01:21:56,859
为什么1除以2和2除以3都明显为零，
Why is 1 divided by 2 and 2 divided by 3 both apparently zero,

1748
01:21:56,859 --> 01:22:00,199
小数点后跟六个零。
followed by six zeros after the decimal point.

1749
01:22:00,199 --> 01:22:08,289
甚至4/3给我1.000000而不是1.33333。
And even 4/3 gives me 1.000000 instead of 1.33333.

1750
01:22:08,289 --> 01:22:10,299
妮娜，你觉得呢？
Nina, what do you think?

1751
01:22:10,300 --> 01:22:15,160
听众：因为使用int，它们无法识别小数。
AUDIENCE: Because with int they don't recognize decimals.

1752
01:22:15,159 --> 01:22:20,739
因此4/3问题3仅一次进入4，因此返回1。
So 4/3 question three only goes into 4 one time, so it returns a 1.

1753
01:22:20,739 --> 01:22:23,469
而且你需要使用其他类型的字符，
And you need to use other types of character,

1754
01:22:23,470 --> 01:22:27,145
如浮点数或双精度数（如果需要实际的小数）。
like a float or a double if you want the actual decimal.

1755
01:22:27,145 --> 01:22:28,270
戴维·马兰（David MALAN）：好的，是的。
DAVID MALAN: Yeah, exactly.

1756
01:22:28,270 --> 01:22:30,850
比我以前犯的错误更微妙。
This one's more subtle than the mistakes I've made before.

1757
01:22:30,850 --> 01:22:34,900
但是C和大多数编程语言一样，将带你真正地了解你。
But C, like most programming languages, is going to take you literally.

1758
01:22:34,899 --> 01:22:38,499
因此，如果在此表达式的右侧，在第11行
So if on the right hand side of this expression, on line 11,

1759
01:22:38,500 --> 01:22:41,649
我实际上是在做x除以y。
I am literally doing x divided by y.

1760
01:22:41,649 --> 01:22:44,859
你首先要问自己，好，x的类型是什么？
You first have to ask yourself, well, what is the type of x?

1761
01:22:44,859 --> 01:22:46,689
y的类型是什么？
What is the type of y?

1762
01:22:46,689 --> 01:22:51,019
如果它们都是整数，那么根据C的定义，
If they are both ints, by definition of how C works,

1763
01:22:51,020 --> 01:22:54,260
你将获得一个整数作为答案。
you are going to get back an integer as your answer.

1764
01:22:54,260 --> 01:22:56,080
因此，如果你将1除以2。
So if you do 1 divided by 2.

1765
01:22:56,079 --> 01:23:00,819
是的，数学上为0.50000。
Yes, mathematically that's 0.50000.

1766
01:23:00,819 --> 01:23:06,159
但是，如果将其转换为int形式，则x和y均为int形式，
However, if you convert that to an int, in so far as x and y are ints,

1767
01:23:06,159 --> 01:23:09,979
C的工作方式是截断小数点后的所有内容。
the way C works is it truncates everything after the decimal point.

1768
01:23:09,979 --> 01:23:14,139
因此它可以正确执行数学运算，但是因为你无法拟合浮点数
So it does the math correctly, but because you cannot fit floating point

1769
01:23:14,140 --> 01:23:18,280
值，则此后不能将小数点和数字都放在整数中，
values, you cannot fit decimal points and numbers thereafter in an integer,

1770
01:23:18,279 --> 01:23:23,139
你会失去小数点后的所有这些数字，因为你可以
you get you lose all of those digits after the decimal point because you can

1771
01:23:23,140 --> 01:23:27,550
仅将答案的整数部分放入整数中。
only fit the integer part of the answer into an integer.

1772
01:23:27,550 --> 01:23:32,020
我最终将结果保存在浮动中并不重要
It's not relevant that I'm saving the result ultimately in a float

1773
01:23:32,020 --> 01:23:33,160
因为为时已晚。
because that's too late.

1774
01:23:33,159 --> 01:23:36,109
数学已经在右侧完成。
The math has already been done on the right hand side.

1775
01:23:36,109 --> 01:23:40,219
所以是的，我在浮点数中存储一个整数，以便可以将其打印为浮点数，
And so yes, I'm storing an integer in a float so I can print it as a float,

1776
01:23:40,220 --> 01:23:40,990
但是为时已晚。
but it's too late.

1777
01:23:40,989 --> 01:23:44,389
小数点后的所有内容都已被丢弃。
Everything after the decimal point has already been thrown away.

1778
01:23:44,390 --> 01:23:46,780
那么这意味着什么，或者我该如何解决？
So what are the implications of this, or how could I fix?

1779
01:23:46,779 --> 01:23:49,899
好吧，我可以仔细检查并更改所有这些权利。
Well, I could go through and just change all of this right.

1780
01:23:49,899 --> 01:23:52,072
好吧，如果问题是x和y是整数，
Well, if the problem is that x and y are ints,

1781
01:23:52,073 --> 01:23:53,740
好吧，让我将它们更改为浮点数。
well, let me just change them to floats.

1782
01:23:53,739 --> 01:23:57,879
然后将其更改为此处，将x更改为浮点数，将y更改为浮点数，
And change this up here, change x to a float, change y to a float,

1783
01:23:57,880 --> 01:23:58,780
等等。
and so forth.

1784
01:23:58,779 --> 01:24:00,071
这样可以解决问题。
That would fix the problem.

1785
01:24:00,072 --> 01:24:02,530
但这是解决此问题的繁重解决方案。
But that's kind of a heavy handed solution to this problem.

1786
01:24:02,529 --> 01:24:04,299
遍历并更改所有代码。
Go through and change all of your code.

1787
01:24:04,300 --> 01:24:07,210
你可以变得更加聪明，然后
You can instead be a little more clever, and you

1788
01:24:07,210 --> 01:24:11,590
可以说服计算机将整数转换为浮点数
can convince the computer to convert an integer to a float

1789
01:24:11,590 --> 01:24:13,240
被称为铸造的东西。
by something known as casting.

1790
01:24:13,239 --> 01:24:17,389
所以我实际上可以进入这里，并使用新的语法我可以说float y。
So I can actually go in here, and using a new syntax I can say float y.

1791
01:24:17,390 --> 01:24:20,140
我什至可以做到，但并非绝对必要，
And I can even, for good measure, but it's not strictly necessary,

1792
01:24:20,140 --> 01:24:21,670
也对x做。
also do it to x.

1793
01:24:21,670 --> 01:24:27,190
你可以在C中将一种数据类型强制转换或类型转换为另一种数据类型
You can in C, cast or typecast one data type to another

1794
01:24:27,189 --> 01:24:31,069
只需在括号内加上所需的新数据类型即可。
by literally in parentheses just putting the new data type that you want.

1795
01:24:31,069 --> 01:24:35,589
如果将一个转换为另一个在数学上有意义，
And if it makes mathematical sense for one to be converted into the other,

1796
01:24:35,590 --> 01:24:37,340
电脑会帮你做。
the computer will do it for you.

1797
01:24:37,340 --> 01:24:41,320
所以我以这种方式告诉计算机，将x转换为浮点数，
So in this way I'm telling the computer, convert x to a float,

1798
01:24:41,319 --> 01:24:43,989
将y转换为浮点数，然后进行数学运算。
convert y to a float, then do the math.

1799
01:24:43,989 --> 01:24:48,009
因此，在我分别为x和y输入一和二之前，
And so before when I typed in one and two respectively for x and y,

1800
01:24:48,010 --> 01:24:53,140
现在就像我输入1.0和2.0。
now it's like I typed in 1.0 and 2.0.

1801
01:24:53,140 --> 01:24:59,080
1.0除以2.0在数学上将是0.5，
And 1.0 divided by 2.0 is going to be mathematically 0.5,

1802
01:24:59,079 --> 01:25:03,159
但是由于x和y现在已经提前转换为浮点数，
but because x and y now were converted in advance to floats,

1803
01:25:03,159 --> 01:25:06,519
答案将保持在0.5的浮动范围内。
the answer is going to remain a float, 0.5.

1804
01:25:06,520 --> 01:25:10,400
这就是将要存储在z中并最终打印出来的内容。
And that's what's going to get stored in z and ultimately printed.

1805
01:25:10,399 --> 01:25:14,019
因此，如果我重新运行截断功能，现在已经解决了此问题。
So if I rerun truncation having now fixed this problem.

1806
01:25:14,020 --> 01:25:15,760
让我做点斜杠截断。
Let me do dot slash truncation.

1807
01:25:15,760 --> 01:25:17,530
输入一，输入二。
Type in one, type in two.

1808
01:25:17,529 --> 01:25:19,479
我不必自己输入0.0。
I don't have to type the 0.0 myself.

1809
01:25:19,479 --> 01:25:23,559
计算机通过括号中的这些强制转换为我执行此操作。
The computer's doing that for me via these casts in parentheses.

1810
01:25:23,560 --> 01:25:27,910
现在我看到答案的确是0.5。
Now I see that the answer is indeed 0.5.

1811
01:25:27,909 --> 01:25:29,019
好的。
All right.

1812
01:25:29,020 --> 01:25:32,410
所以我们现在似乎有了一些非常基本的低级控制
So we seem to have now some very basic low level control

1813
01:25:32,409 --> 01:25:34,309
你可以使用该程序做什么。
over what you can do with the program.

1814
01:25:34,310 --> 01:25:36,247
现在让我们重新添加所有精美功能
Let's now add back all of the fancy features

1815
01:25:36,247 --> 01:25:38,080
上周我们从Scratch获得的
that we had from Scratch last week so we can

1816
01:25:38,079 --> 01:25:40,329
开始制作更多有趣的程序。
start making more interesting programs.

1817
01:25:40,329 --> 01:25:44,739
因此，变量和另一个称为语法糖的技术术语也是
So variables and another term of art called syntactic sugar is also

1818
01:25:44,739 --> 01:25:46,219
在C的功能中。
among C's features here.

1819
01:25:46,220 --> 01:25:49,150
所以回想一下上周，当我们想要一个名为
So recall from last week when we wanted to have a variable called

1820
01:25:49,149 --> 01:25:50,979
计数器设置为零。
counter set equal to zero.

1821
01:25:50,979 --> 01:25:52,959
我们可以像这样定义它。
We can go ahead and define it like this.

1822
01:25:52,960 --> 01:25:56,080
从今天开始，在C语言中，我们将改为说些什么
In C, starting today, we're going to instead say something

1823
01:25:56,079 --> 01:25:57,729
例如，计数器等于零。
like, counter equals zero.

1824
01:25:57,729 --> 01:26:01,419
但是我们还需要指定该变量的数据类型，
But we additionally need to specify the data type of that variable,

1825
01:26:01,420 --> 01:26:04,860
我们需要以分号结束我们的思想。
and we need to end our thought with a semicolon.

1826
01:26:04,859 --> 01:26:08,019
因此，尽管我们上周将计数器设置为零，但现在
So whereas we set counter to zero like this last week, now

1827
01:26:08,020 --> 01:26:11,170
它将在右侧非常简单地转换为此。
it's going to translate quite simply to this on the right hand side.

1828
01:26:11,170 --> 01:26:12,400
好吧，那之后呢？
Well, what comes after that?

1829
01:26:12,399 --> 01:26:16,119
好吧，如果我们想在上周将计数器变量加1，
Well, if we wanted to increment a counter variable last week by one,

1830
01:26:16,119 --> 01:26:18,789
在其中添加一个，我们非常简单地使用了这个拼图。
adding one to it, we used quite simply this puzzle piece.

1831
01:26:18,789 --> 01:26:23,199
这周我们需要更加明确，说出这样的话。
This week we need to be a little more explicit and say something like this.

1832
01:26:23,199 --> 01:26:27,729
Counter等于counter加1，并用分号结束思考。
Counter equals counter plus one, and semicolon to finish the thought.

1833
01:26:27,729 --> 01:26:30,669
现在，这在数学上似乎很矛盾。
Now, this might seem very mathematically paradoxical.

1834
01:26:30,670 --> 01:26:34,030
例如，计数器如何等于计数器加一？
Like, how can counter equal counter plus one?

1835
01:26:34,029 --> 01:26:36,699
就像，这在逻辑上是行不通的。
Like, that just doesn't work logically.

1836
01:26:36,699 --> 01:26:39,819
但是，在这种情况下，这不是等号。
But that's not the equal sign in this case.

1837
01:26:39,819 --> 01:26:42,939
与其他语言一样，在C语言中，
In C, as with other languages we'll encounter,

1838
01:26:42,939 --> 01:26:46,879
等号是从右到左的赋值运算符。
the equals sign is the assignment operator from right to left.

1839
01:26:46,880 --> 01:26:49,210
这就是说，加计数器加一，
So this is saying, take counter plus one,

1840
01:26:49,210 --> 01:26:52,300
并将该数学结果存储在左侧。
and store that mathematical result on the left.

1841
01:26:52,300 --> 01:26:57,550
因此，无论计数器是多少，都加一个，然后将结果存储在计数器中。
So whatever counter is, add one, store the result in counter thereafter.

1842
01:26:57,550 --> 01:26:59,950
有效地，将总数增加一倍。
Effectively, increasing its total by one.

1843
01:26:59,949 --> 01:27:02,169
现在，这是程序中非常常见的操作
Now this is a very common operation in programs

1844
01:27:02,170 --> 01:27:04,150
我们会在整个学期中看到你只想添加一些内容的地方
we'll see over the term where you just want to add something up

1845
01:27:04,149 --> 01:27:06,609
因为你想跟踪某物的数量。
because you want to keep track of the count of something.

1846
01:27:06,609 --> 01:27:09,459
事实证明，有一些语法糖，
So it turns out there's some syntactic sugar, which

1847
01:27:09,460 --> 01:27:12,850
意味着有一种不同的语法实现方式
means there's a different way of doing this syntactically that doesn't give

1848
01:27:12,850 --> 01:27:15,010
你尚未拥有的任何新功能
you any new capabilities that you didn't already

1849
01:27:15,010 --> 01:27:19,510
在C中使用。它只是使键入稍微更愉快或更快速。
have in C. It just makes it marginally more pleasant or quicker to type.

1850
01:27:19,510 --> 01:27:24,100
因此，C语言中的这一行代码与说这行代码相同
So this line of code in C is identical to saying this line of code

1851
01:27:24,100 --> 01:27:30,130
在C中。Counter加号等于一个分号表示在左边取变量
in C. Counter plus equals one semicolon means take the variable on the left

1852
01:27:30,130 --> 01:27:31,417
并添加一个。
and just add one to it.

1853
01:27:31,417 --> 01:27:33,250
而且它更加简洁，它只是
And it's slightly more succinct, and it just

1854
01:27:33,250 --> 01:27:36,549
使你的代码更具可读性，因为对于我们来说，事情变得更少了
makes your code a little more readable because it's just fewer things for us

1855
01:27:36,550 --> 01:27:38,290
人类必须阅读。
humans to have to read.

1856
01:27:38,289 --> 01:27:40,149
但是，你甚至可以更进一步。
But you can even do one step further.

1857
01:27:40,149 --> 01:27:42,584
存在其他语法糖，从而
Additional syntactic sugar exists, whereby

1858
01:27:42,585 --> 01:27:43,960
你甚至不需要键入此内容。
you don't even need to type this.

1859
01:27:43,960 --> 01:27:46,990
你可以改为只做计数器加号。
You can instead just do counter plus plus.

1860
01:27:46,989 --> 01:27:49,519
计数器加号是最短的手写符号
Counter plus plus is the shortest hand notation

1861
01:27:49,520 --> 01:27:53,320
在C中仅向变量添加一个。
in C for just adding one to a variable.

1862
01:27:53,319 --> 01:27:54,039
好的。
All right.

1863
01:27:54,039 --> 01:27:58,359
除变量外，截至上周，我们的工具包还包含哪些内容？
Besides variables, what else do we have in our toolkit as of last week?

1864
01:27:58,359 --> 01:28:01,269
好吧，上周我们在工具包中也有了这个概念，
Well, we also had in our toolkit last week the notion, of course,

1865
01:28:01,270 --> 01:28:02,230
条件。
of conditions.

1866
01:28:02,229 --> 01:28:04,064
情况就像路边的叉子
A condition was like a fork in the road that

1867
01:28:04,064 --> 01:28:06,939
可能会让你做这件事，这件事或其他事情
could allow you to do this thing, this other thing, or something else

1868
01:28:06,939 --> 01:28:07,629
共。
altogether.

1869
01:28:07,630 --> 01:28:11,570
例如，在Scratch中，如果我们想上周比较两个变量，
In Scratch for instance, if we wanted last week to compare two variables,

1870
01:28:11,569 --> 01:28:13,779
x和y用于不等式。
x and y for inequality.

1871
01:28:13,779 --> 01:28:15,009
x小于y吗？
Is x less than y?

1872
01:28:15,010 --> 01:28:17,800
如果是这样，则说x小于y。
And if so, say x is less than y.

1873
01:28:17,800 --> 01:28:19,780
我们如何将其转换为C？
How can we translate this to C?

1874
01:28:19,779 --> 01:28:23,139
好吧，语法将非常简单。
Well, the syntax is going to be quite simply this.

1875
01:28:23,140 --> 01:28:24,010
一些新东西。
Some new stuff.

1876
01:28:24,010 --> 01:28:26,500
还有更多的括号，还有更多的花括号。
Some more parentheses, some more curly braces.

1877
01:28:26,500 --> 01:28:29,830
但是，尽管是文本形式，但外观上看起来还是一样的。
But it kind of visually looks the same, albeit in text form.

1878
01:28:29,829 --> 01:28:33,129
我从字面上说，如果是空格，则在括号中我
I literally say, if a space, then in parentheses I

1879
01:28:33,130 --> 01:28:36,160
包括我的布尔表达式，回想一下上周的内容。
include my Boolean expression, recall those from last week.

1880
01:28:36,159 --> 01:28:38,679
X小于y是我的布尔表达式。
X less than y is my Boolean expression.

1881
01:28:38,680 --> 01:28:42,100
然后注意，我使用了一个开放的花括号和一个封闭的花括号。
Then notice I use an open curly brace and a close curly brace.

1882
01:28:42,100 --> 01:28:45,460
然后我只为一行或多行代码留空行
And then I'm just leaving a blank line for one or more lines of code

1883
01:28:45,460 --> 01:28:47,260
就像我上周一样。
just like I might of last week.

1884
01:28:47,260 --> 01:28:49,750
实际上，让我们在此处放置等效的代码行。
And in fact, let's put the equivalent line of code here.

1885
01:28:49,750 --> 01:28:55,030
使用printf打印出来，x小于y，反斜杠n。
Print out using printf, x is less than y, backslash n.

1886
01:28:55,029 --> 01:28:56,949
因此，我们之前已经完成了该翻译。
So we've already done that translation before.

1887
01:28:56,949 --> 01:29:01,389
说就像printf，就像现在就好像如果。
Say is just like printf, just like if now is like if.

1888
01:29:01,390 --> 01:29:04,090
严格来说，尤其是如果你已经编程过，
Strictly speaking, especially if you've programmed before,

1889
01:29:04,090 --> 01:29:07,690
如果你只需要这两个花括号，
you do not need these two curly braces if you only

1890
01:29:07,689 --> 01:29:10,819
条件中只有一行代码。
have one line of code inside of the condition.

1891
01:29:10,819 --> 01:29:14,409
但是，从样式上考虑，为了CS50和style50，
However, stylistically for CS50 and for style50's sake,

1892
01:29:14,409 --> 01:29:19,419
无论如何，总是在自己的行上包括这些花括号。
always include these curly braces nonetheless, and on their own lines.

1893
01:29:19,420 --> 01:29:21,190
好吧，我们在Scratch还能做什么？
All right, what else can we do in Scratch?

1894
01:29:21,189 --> 01:29:23,139
回想一下，如果没有的话，我们可以做。
Recall that we can do if else.

1895
01:29:23,140 --> 01:29:27,130
我们可以在叉子中选择一种方式，也可以在叉子中选择另一种方式。
And we can go either one way in the fork or the other way in the fork.

1896
01:29:27,130 --> 01:29:29,990
在C语言中，相应的代码将如下所示。
In C, the corresponding code is going to look like this.

1897
01:29:29,989 --> 01:29:31,599
所以它几乎和以前一样。
So it's almost the same as before.

1898
01:29:31,600 --> 01:29:35,470
我刚刚添加了其他内容，然后添加了另一个花括号和一个紧密的花括号。
I've just added else, and then another curly brace and a close curly brace.

1899
01:29:35,470 --> 01:29:37,240
而且，我只添加printf的内容。
And let me just add in the printf's.

1900
01:29:37,239 --> 01:29:40,029
你会发现在C语言中，这真的很像黑色和白色，
And you can see that in C this is really like the black and white,

1901
01:29:40,029 --> 01:29:43,299
上周非常图形化的基于文本的版本，
the text based version of what was very graphical last week,

1902
01:29:43,300 --> 01:29:44,430
但想法是一样的。
but the idea is the same.

1903
01:29:44,430 --> 01:29:46,930
你只需要开始认识括号的位置，
You just got to start to recognize where the parentheses go,

1904
01:29:46,930 --> 01:29:48,850
花括号在哪里，分号，
where the curly braces go, the semicolons,

1905
01:29:48,850 --> 01:29:51,100
以及所有类似的视觉内容。
and all that sort of visual stuff.

1906
01:29:51,100 --> 01:29:54,940
好吧，让我们再进行一次Scratch比较。
All right, let's make one more Scratch comparison.

1907
01:29:54,939 --> 01:29:58,869
这是我说过的，如果x小于y，则x小于y。
Here is one where I said if x is less than y, say x is less than y.

1908
01:29:58,869 --> 01:30:02,469
否则，如果x大于y，则说x大于y。
Else if x is greater than y, say x is greater than y.

1909
01:30:02,470 --> 01:30:06,490
否则，如果x等于y，则说x等于y。
Else if x equals y, then say x equal to y.

1910
01:30:06,489 --> 01:30:08,589
现在，这是Scratch和C分叉的地方。
Now, here is where Scratch and C diverge.

1911
01:30:08,590 --> 01:30:10,810
因为Scratch的意图是非常用户友好
Because Scratch is meant to be very user friendly

1912
01:30:10,810 --> 01:30:15,460
不需要对赋值运算符进行详细说明，MIT for Scratch
and not require long explanations of assignment operators, MIT for Scratch

1913
01:30:15,460 --> 01:30:18,550
只需使用等号进行相等即可。
just use the equal sign for equality.

1914
01:30:18,550 --> 01:30:22,120
而C使用等号从左到右进行分配，
Whereas C uses the equal sign for assignment from left to right,

1915
01:30:22,119 --> 01:30:24,909
但这意味着像以前一样平等。
but this means equality as before.

1916
01:30:24,909 --> 01:30:25,629
好的。
All right.

1917
01:30:25,630 --> 01:30:27,930
现在，请注意此处的区别。
Now, notice the difference here.

1918
01:30:27,930 --> 01:30:30,990
一切都是逐行翻译，
Everything is a line by line translation,

1919
01:30:30,989 --> 01:30:34,139
尽管我们可以将else如果放在同一行上，或者else在同一行上。
although we can put else if on the same line and else if on the same line.

1920
01:30:34,140 --> 01:30:36,540
除了这里是一种愚蠢的解决方法，对吗？
Except here is kind of a stupid workaround, right?

1921
01:30:36,539 --> 01:30:40,199
从某种意义上说，数十年前的人类一次意识到了射击。
In some sense humans decades ago realized, oh, shoot, at one point.

1922
01:30:40,199 --> 01:30:42,869
我们已经使用等号进行分配。
We've already used the equal sign for assignment.

1923
01:30:42,869 --> 01:30:45,179
我们现在使用什么来实现平等？
What do we use now for equality?

1924
01:30:45,180 --> 01:30:49,590
好吧，麻省理工学院忽略了这个问题，只使用了一个等号来表示相等性。
Well, MIT ignored that problem and just used a single equal sign for equality.

1925
01:30:49,590 --> 01:30:53,100
发明C语言和后续语言的计算机科学家
Computer scientists inventing C and subsequent languages

1926
01:30:53,100 --> 01:30:56,460
比较左右两个值是否相等时
when comparing two values on the left and right for equality

1927
01:30:56,460 --> 01:30:59,400
使用两个等号只是因为。
used two equal signs just because.

1928
01:30:59,399 --> 01:31:01,949
一个等号是从右到左的赋值。
One equal sign is assignment from right to left.

1929
01:31:01,949 --> 01:31:04,799
两个相等的符号是相等的比较。
Two equal signs is equality comparisons.

1930
01:31:04,800 --> 01:31:06,870
这两个值相等吗？
Are these two values equal?

1931
01:31:06,869 --> 01:31:08,219
但是你知道吗？
But you know what?

1932
01:31:08,220 --> 01:31:10,890
这不一定设计得很好。
This is not necessarily well designed.

1933
01:31:10,890 --> 01:31:11,760
它是正确的。
It is correct.

1934
01:31:11,760 --> 01:31:15,360
从逻辑上讲，我的临时代码和C代码都是正确的，
Logically both my scratch code and my C code is correct,

1935
01:31:15,359 --> 01:31:19,559
但是任何人都可以观察为什么代码不是
but can anyone make an observation as to why the code is not

1936
01:31:19,560 --> 01:31:21,300
设计得好吗？
necessarily well designed?

1937
01:31:21,300 --> 01:31:24,090
我的工作量超出了我的需要。
I'm doing a little more work than I need to.

1938
01:31:24,090 --> 01:31:26,730
我可以收紧这段代码。
I could tighten this code up a little bit.

1939
01:31:26,729 --> 01:31:29,789
我可以输入少一些的字符并完成
I could type slightly fewer characters and accomplish

1940
01:31:29,789 --> 01:31:34,119
同样正确的决策。
the same correct decision making.

1941
01:31:34,119 --> 01:31:39,819
在某种意义上，这段代码的设计不是很完美吗？
Any thoughts on in what sense this code is not perfectly designed?

1942
01:31:39,819 --> 01:31:41,639
[听不清]，交给你。
[INAUDIBLE], over to you.

1943
01:31:41,640 --> 01:31:45,450
听众：是的，所以你两次使用过别的方法。
AUDIENCE: Yeah, so you used else if two times.

1944
01:31:45,449 --> 01:31:48,827
你最终可能没有条件就使用了else。
You could have used else in the end and without the condition.

1945
01:31:48,828 --> 01:31:50,370
大卫·马兰（David MALAN）：很好的观察。
DAVID MALAN: Really good observation.

1946
01:31:50,369 --> 01:31:53,259
我使用else两次，这在逻辑上是可以的。
I'm using else if twice, which logically is fine.

1947
01:31:53,260 --> 01:31:54,210
该代码是正确的。
This code is correct.

1948
01:31:54,210 --> 01:31:58,050
它在询问并回答正确的问题，但请考虑一下。
It's asking and answering the right questions, but consider this.

1949
01:31:58,050 --> 01:32:02,460
如果x小于y，则一种可能是在道路上一叉。
If x is less than y, is one possibility, one fork in the road.

1950
01:32:02,460 --> 01:32:05,100
否则，如果x大于y是第二个。
Else if x greater than y is the second.

1951
01:32:05,100 --> 01:32:08,610
从逻辑上讲，数学世界中唯一的其他可能性是什么？
What's the only other possibility logically in the world of math?

1952
01:32:08,609 --> 01:32:11,729
小于或大于或等于。
Either it's less than or greater than or equal to.

1953
01:32:11,729 --> 01:32:16,379
没有理由对这一点感到困惑，并明确提出第三个问题。
There's no reason to belabor the point and ask that third question explicitly.

1954
01:32:16,380 --> 01:32:20,820
让我们简化代码，并以此更好地进行设计。
Let's simplify the code and marginally better design it as this.

1955
01:32:20,819 --> 01:32:23,339
如果你建议的话，就摆脱其他。
Just get rid of the else if as you proposed.

1956
01:32:23,340 --> 01:32:26,580
没有那么干净，没有那么短，
Which isn't that much cleaner, isn't that much shorter,

1957
01:32:26,579 --> 01:32:29,169
但这确实避免了提出其他问题。
but it does avoid asking an additional question.

1958
01:32:29,170 --> 01:32:32,497
因此，现在可能只有两个，而不是问三个问题。
So instead of maybe three questions being asked, now there's only two.

1959
01:32:32,497 --> 01:32:35,580
坦率地说，如果你要编写大量代码或一次又一次地执行此操作
And frankly, if you're writing a lot of code or doing this again and again

1960
01:32:35,579 --> 01:32:39,779
再一次，这种差异很可能加起来，实际上
and again, that kind of difference might very well add up and indeed

1961
01:32:39,779 --> 01:32:42,129
现在给我们一些更好的代码。
give us now some better code.

1962
01:32:42,130 --> 01:32:44,910
因此，现在我可以使用这些条件了。
So now that I have the ability to use these conditions.

1963
01:32:44,909 --> 01:32:47,336
让我们实际尝试将其转换为程序。
Let's actually try converting this into a program.

1964
01:32:47,337 --> 01:32:49,170
让我继续并打开一个程序，
Let me go ahead and open up a program that I

1965
01:32:49,170 --> 01:32:51,590
事先写的叫做conditions.c。
wrote in advance called conditions.c.

1966
01:32:51,590 --> 01:32:55,170
和往常一样，我在两个文件的开头都有文件。
And I have at the top of the file my two includes as usual.

1967
01:32:55,170 --> 01:32:58,110
然后在这里，我几乎可以看到幻灯片上的内容，
And then down here, I have pretty much what we just saw on the slide,

1968
01:32:58,109 --> 01:33:02,219
加上两次对get_int的调用或使用。
plus two calls, or uses, of get_int.

1969
01:33:02,220 --> 01:33:05,730
然后我只是在这里问这个问题，如果x小于y。
And then I'm just asking this question down here, if x less than y.

1970
01:33:05,729 --> 01:33:07,259
否则，如果x大于y。
Else if x greater than y.

1971
01:33:07,260 --> 01:33:09,400
否则，请继续执行以下操作。
Else go ahead and do the following.

1972
01:33:09,399 --> 01:33:13,409
因此，这只是Scratch翻译的大部分内容的复制粘贴。
So it's just a copy paste pretty much of the Scratch translation.

1973
01:33:13,409 --> 01:33:16,409
让我继续做条件，再说条件。c
Let me go ahead and make conditions, which again, conditions.c

1974
01:33:16,409 --> 01:33:17,489
是文件名。
is the name of the file.

1975
01:33:17,489 --> 01:33:18,839
没有明显的错误。
No apparent mistakes.

1976
01:33:18,840 --> 01:33:22,200
因此，让我继续运行点斜杠条件，然后按Enter。
So let me go ahead and run dot slash conditions, Enter.

1977
01:33:22,199 --> 01:33:24,329
x将为1，y为2。
And x will be 1, y is 2.

1978
01:33:24,329 --> 01:33:26,609
实际上，x小于y。
And indeed, x is less than y.

1979
01:33:26,609 --> 01:33:31,559
如果我继续进行此操作，例如这次是10和5。
If I go ahead and run this, this time for instance, with how about 10 and 5.

1980
01:33:31,560 --> 01:33:33,060
X大于y。
X is greater than y.

1981
01:33:33,060 --> 01:33:36,170
最后，如果我继续使用4和4进行此操作。
And then lastly, if I go ahead and run this with 4 and 4.

1982
01:33:36,170 --> 01:33:37,410
X等于y。
X is equal to y.

1983
01:33:37,409 --> 01:33:40,079
所以我现在有一个添加条件的C程序
So I now have a C program that is adding conditions

1984
01:33:40,079 --> 01:33:43,649
对我来说，这实际上使我能够做出决定并打印出来
for me, which is actually then allowing me to make decisions and print out

1985
01:33:43,649 --> 01:33:46,409
一件事可能或另一件事。
one thing potentially or the other.

1986
01:33:46,409 --> 01:33:49,049
但是，让我做些更奇特的事情。
But let me do something slightly fancier.

1987
01:33:49,050 --> 01:33:51,720
让我继续开放另一个-
Let me go ahead and open up another--

1988
01:33:51,720 --> 01:33:53,640
让我从头开始编写此程序。
let me write this program from Scratch.

1989
01:33:53,640 --> 01:33:56,820
假设我要编写一个名为“ concept.c”的程序
Suppose I want to write a program called agree.c

1990
01:33:56,819 --> 01:33:59,009
激发了像这些愚蠢形式的想法
that stimulates the idea of like these stupid forms

1991
01:33:59,010 --> 01:34:02,100
使用某个软件时必须同意的
that you have to agree to when using a piece of software

1992
01:34:02,100 --> 01:34:03,480
第一次或类似。
for the first time or the like.

1993
01:34:03,479 --> 01:34:07,529
甚至在我不得不按顺序键入yes或y之前删除文件时
Or even when I deleted a file before I had to type in yes or y in order

1994
01:34:07,529 --> 01:34:08,339
继续。
to proceed.

1995
01:34:08,340 --> 01:34:12,240
让我继续，并在顶部包含cd50.h。
Let me go ahead and include cd50.h at the top.

1996
01:34:12,239 --> 01:34:15,419
让我继续前进，并在顶部包含stdio.h。
Let me go ahead and include stdio.h at the top.

1997
01:34:15,420 --> 01:34:18,480
然后是我的int main void，它是以前的复制粘贴。
And then my int main void, which is copy paste from before.

1998
01:34:18,479 --> 01:34:19,499
现在让我来做。
And now let me do this.

1999
01:34:19,500 --> 01:34:22,541
让我继续前进，获取用户的输入，甚至不说一个字。
Let me go ahead and get, not an input from the user, and not even a word.

2000
01:34:22,542 --> 01:34:27,060
让我们保持简单，只要求用户输入y或n，是或否。
Let's keep it simple and just ask the user for y or n, for yes or no.

2001
01:34:27,060 --> 01:34:30,660
让我继续给自己一个字符，我称它为c。
Let me go ahead and give myself a char, and I'll call it c.

2002
01:34:30,659 --> 01:34:32,789
但我可以称呼它为“答案”。
But I could call it anything, like answer.

2003
01:34:32,789 --> 01:34:35,579
但是如果我只有一个字符，c似乎是合理的。
But c seems reasonable if I only have one char.

2004
01:34:35,579 --> 01:34:38,519
让我继续调用函数get_char。
Let me go ahead and call the function, get_char.

2005
01:34:38,520 --> 01:34:42,120
让我问问，你是否同意，问号。
And let me just ask, do you agree, question mark.

2006
01:34:42,119 --> 01:34:43,869
然后让我继续进行比较。
And then let me go ahead and compare this.

2007
01:34:43,869 --> 01:34:52,889
因此，如果c等于y，那么让我继续打印出同意的反斜杠n。
So if c equals y, then let me go ahead and print out agreed backslash n.

2008
01:34:52,890 --> 01:35:01,590
否则，如果c等于n，那么让我继续进行打印，例如，不同意。
Else if c equals n, let me go ahead and print out for instance, not agreed.

2009
01:35:01,590 --> 01:35:07,108
现在很不幸，我在这里犯了几个错误，至少有一个
Now unfortunately, I've made a couple of mistakes here that at least one

2010
01:35:07,108 --> 01:35:09,400
其中一个可能比另一个更明显。
of which might be a little more obvious than the other.

2011
01:35:09,399 --> 01:35:13,949
关于我可能已经引入的错误或错误的任何想法
Any thoughts on what mistakes or bugs I might have introduced already

2012
01:35:13,949 --> 01:35:16,259
进入这个程序？
into this program?

2013
01:35:16,260 --> 01:35:17,100
有人吗
Anyone at all?

2014
01:35:17,100 --> 01:35:19,020
是的，奥利维亚（Olivia）。
Yeah, how about, Olivia.

2015
01:35:19,020 --> 01:35:20,460
你怎么认为？
What do you think?

2016
01:35:20,460 --> 01:35:23,580
听众：布尔的一件事
AUDIENCE: For one thing that for the Boolean

2017
01:35:23,579 --> 01:35:27,329
你确实使用了一个单一的等号而不是双重的。
you did use a single equals sign instead of the double.

2018
01:35:27,329 --> 01:35:28,079
戴维·马兰（David MALAN）：很好。
DAVID MALAN: Good.

2019
01:35:28,079 --> 01:35:31,649
所以我使用单等号而不是双，所以我需要解决这个问题。
So I use the single equal sign instead of double, so I need to fix that.

2020
01:35:31,649 --> 01:35:34,069
还有另一个更细微的错误。
And there's another even more subtle bug.

2021
01:35:34,069 --> 01:35:38,389
这是因为C在涉及其数据类型时非常具体。
And this is because C is very specific when it comes to its data types.

2022
01:35:38,390 --> 01:35:41,330
一直以来，我一直在对字符串使用双引号，
All this time I've been using double quotes for strings,

2023
01:35:41,329 --> 01:35:45,229
但是事实证明，在C中，当
but it turns out in C you have to use single quotes when

2024
01:35:45,229 --> 01:35:47,029
你正在比较单个字符。
you're comparing individual characters.

2025
01:35:47,029 --> 01:35:51,439
所以我要去这里，只更改y和n周围的引号
So I'm going to go in here and change only the quotes around y and n

2026
01:35:51,439 --> 01:35:52,319
用单引号引起来。
to be single quotes.

2027
01:35:52,319 --> 01:35:52,819
为什么？
Why?

2028
01:35:52,819 --> 01:35:55,099
因为我现在正在处理字符的世界。
Because I'm now dealing with the world of chars.

2029
01:35:55,100 --> 01:35:58,400
字符是单个字符，例如y或n。
Chars are individual characters like y or n.

2030
01:35:58,399 --> 01:36:00,559
当你谈论角色时，
And when you are talking about characters,

2031
01:36:00,560 --> 01:36:03,060
你需要像这样逐字地引用它们。
you need to quote them literally like this.

2032
01:36:03,060 --> 01:36:05,060
变量名c不需要用引号引起来。
The variable name, c, doesn't need to be quoted.

2033
01:36:05,060 --> 01:36:07,100
但是y和n确实需要用引号引起来。
But y and n do need to be quoted.

2034
01:36:07,100 --> 01:36:09,860
但是我不需要更改文件中的其他任何引号
But I don't need to change any of my other quotes in the file

2035
01:36:09,859 --> 01:36:14,809
因为这些仍然是实际的短语或句子的文本字符串。
because those are still strings of text that is actual phrases or sentences.

2036
01:36:14,810 --> 01:36:17,420
因此，让我继续尝试运行以达成共识。
So let me go ahead and try running make agree.

2037
01:36:17,420 --> 01:36:18,590
编译就可以了。
It compiles OK.

2038
01:36:18,590 --> 01:36:20,870
让我继续并运行点斜线表示同意。
Let me go ahead and run dot slash agree.

2039
01:36:20,869 --> 01:36:21,679
我同意吗？
Do I agree?

2040
01:36:21,680 --> 01:36:23,210
让我继续输入y。
Let me go ahead and type in y.

2041
01:36:23,210 --> 01:36:24,540
同意，我喜欢那样。
Agreed, I like that.

2042
01:36:24,539 --> 01:36:26,509
因此，让我尝试一下，不。
So let me try n, no.

2043
01:36:26,510 --> 01:36:27,620
不，我同意。
Not I agreed.

2044
01:36:27,619 --> 01:36:31,549
我省略了一个反斜杠n，所以让我来修复一下
And I left off a backslash n, so let me fix that real quick just

2045
01:36:31,550 --> 01:36:32,780
为了保持一致性。
for consistency.

2046
01:36:32,779 --> 01:36:35,329
让我重新编译我的程序，并假装从未发生过。
Let me recompile my program and pretend that never happened.

2047
01:36:35,329 --> 01:36:37,019
但是，现在让我非常合理地做到这一点。
But let me very reasonably now do this.

2048
01:36:37,020 --> 01:36:38,330
点斜线表示同意。
Dot slash agree.

2049
01:36:38,329 --> 01:36:39,169
我要同意。
I want to agree.

2050
01:36:39,170 --> 01:36:41,656
是的，资本y。
And yes, capital y.

2051
01:36:41,655 --> 01:36:43,019
没事
Huh, nothing happened.

2052
01:36:43,020 --> 01:36:45,480
那n大写N呢？
What about n, capital N?

2053
01:36:45,479 --> 01:36:46,412
没啥事儿。
Nothing happened.

2054
01:36:46,412 --> 01:36:47,579
但是该程序仍然有效。
But the program still works.

2055
01:36:47,579 --> 01:36:49,559
如果我做小写的话，它可以工作。
If I do lower case it works.

2056
01:36:49,560 --> 01:36:51,390
如果我在这里做小写的话，那就行了。
And if I do lower case there it works.

2057
01:36:51,390 --> 01:36:52,388
发生什么了？
So what's going on?

2058
01:36:52,387 --> 01:36:54,929
好吧，再一次，计算机只会带你一字不漏。
Well, again, the computer's only going to take you literally.

2059
01:36:54,930 --> 01:36:57,013
即使我们人类可能是，哦，这很好。
And even though we humans might be, oh, it's fine.

2060
01:36:57,012 --> 01:36:58,439
它是大写或小写。
It's upper case or a lower case.

2061
01:36:58,439 --> 01:37:00,699
你必须更加明确。
You have to be more explicit.

2062
01:37:00,699 --> 01:37:03,009
因此，我们可以提出以下两个问题。
So we can ask two questions as follows.

2063
01:37:03,010 --> 01:37:05,400
如果c等于我们可以做其他事情
We could do something like else if c equals

2064
01:37:05,399 --> 01:37:08,459
等于单引号中的资本Y。
equals capital Y in single quotes.

2065
01:37:08,460 --> 01:37:11,880
你可以再次想象，说出这样的同意。
You could imagine, again, saying agreed like this.

2066
01:37:11,880 --> 01:37:15,740
但是就像上周我开始复制和粘贴Scratch块一样，
But just like last week when I started copying and pasting Scratch blocks,

2067
01:37:15,739 --> 01:37:17,729
那可能不是很好的设计。
that's probably not very good design.

2068
01:37:17,729 --> 01:37:24,149
类似地，此代码块（第11至14行）几乎与第7行相同
Similarly, this block of code, lines 11 through 14, is almost identical to 7

2069
01:37:24,149 --> 01:37:25,019
到10
through 10.

2070
01:37:25,020 --> 01:37:26,590
让我们摆脱其中之一。
Let's just get rid of one of them.

2071
01:37:26,590 --> 01:37:28,632
让我们看看我们是否无法融合这些想法。
And let's see if we can't combine these thoughts.

2072
01:37:28,631 --> 01:37:34,169
让我表达一下，如果c等于y，或者c等于等于资本Y。
Let me express if c equals equals y, or c equals equals capital Y.

2073
01:37:34,170 --> 01:37:36,480
实际上，你可以使用此竖线
And indeed, you can use this vertical bar

2074
01:37:36,479 --> 01:37:39,959
运算符，这是逻辑或运算符，
operator, which is the logical or operator,

2075
01:37:39,960 --> 01:37:43,290
并同时说两个问题。
and actually say two questions at once.

2076
01:37:43,289 --> 01:37:46,319
事实证明，你可以使用and的概念来做到这一点，
It turns out you can do this with the notion of and, a logical

2077
01:37:46,319 --> 01:37:48,329
并使用＆符号。
and, by using ampersand ampersand.

2078
01:37:48,329 --> 01:37:49,749
还有更多时间。
More on those another time.

2079
01:37:49,750 --> 01:37:52,319
但是两条竖线等同于说，
But two vertical bars is the equivalent of just saying,

2080
01:37:52,319 --> 01:37:55,649
如果是在左侧还是在右侧
if this on the left or this on the right.

2081
01:37:55,649 --> 01:37:58,229
现在，如果我使用make保存并重新编译程序，
And now if I save and recompile the program with make

2082
01:37:58,229 --> 01:38:00,599
同意，点斜线也同意。
agree, and dot slash agree.

2083
01:38:00,600 --> 01:38:05,910
你会看到我可以以小写形式输入y或以大写形式键入Y，
You'll see that I can type in y in lowercase, or Y in uppercase,

2084
01:38:05,909 --> 01:38:07,659
现在就可以了。
and now it works.

2085
01:38:07,659 --> 01:38:10,499
再说一次，添加
So again, it would have been correct to just add

2086
01:38:10,500 --> 01:38:12,239
如果另一个，如果另一个。
another else if and another else if.

2087
01:38:12,239 --> 01:38:15,809
但是同样，这不是必须的，因为我可以将这些想法结合起来
But again, not necessary because I can combine these thoughts

2088
01:38:15,810 --> 01:38:17,730
并使我的程序设计得更好。
and make my program better designed.

2089
01:38:17,729 --> 01:38:21,809
还要注意，所有这些时间我一直都很虔诚
And notice too, all this time I've been very religiously

2090
01:38:21,810 --> 01:38:25,380
每次缩进花括号时都会缩进。
indenting every time I'm inside of curly braces.

2091
01:38:25,380 --> 01:38:29,130
每次我有一个if条件或else if时都缩进。
Indenting every time I have an if condition or an else if.

2092
01:38:29,130 --> 01:38:34,600
因此，我也希望表现出良好的风格美学。
So I'm manifesting, hopefully, good style aesthetics as well.

2093
01:38:34,600 --> 01:38:35,290
好的。
All right.

2094
01:38:35,289 --> 01:38:37,979
好吧，现在让我们考虑一下我们有没有能力
Well, now let's consider that we have the ability not

2095
01:38:37,979 --> 01:38:41,729
仅用于表达条件，但这些称为循环的东西又如何呢？
only to express conditions, but how about also these things called loops.

2096
01:38:41,729 --> 01:38:44,339
好吧，事实证明，在Scratch中，我们有非常简单的循环。
Well, turns out in Scratch we had very straightforward loops.

2097
01:38:44,340 --> 01:38:45,810
永远执行以下操作。
Do the following forever.

2098
01:38:45,810 --> 01:38:47,070
C有点笨。
C is a little clunkier.

2099
01:38:47,069 --> 01:38:51,869
C语言中没有永远的关键字，但是我们可以按照以下方式模仿这个想法。
There's no forever keyword in C, but we can mimic this idea as follows.

2100
01:38:51,869 --> 01:38:54,959
在C语言中永远翻译的最接近方法
The closest way to translate forever in C

2101
01:38:54,960 --> 01:38:58,410
实际上是在说一句，哪种具有正确的英语语义。
is actually to say while, which kind of has the right semantics in English.

2102
01:38:58,409 --> 01:39:01,499
就像，虽然确实如此，但要这样做，
Like, while something is the case, do this,

2103
01:39:01,500 --> 01:39:03,120
但你必须更加明确。
but you have to be even more explicit.

2104
01:39:03,119 --> 01:39:06,549
你不能只说一会儿，然后再说printf，世界。
You can't just say while and then say printf hello, world.

2105
01:39:06,550 --> 01:39:10,470
在C中发现，虽然类似于条件，
It turns out in C that while, similar to a condition,

2106
01:39:10,470 --> 01:39:15,180
一直在问一个问题，以决定是否继续。
is constantly asking a question to decide whether or not to continue.

2107
01:39:15,180 --> 01:39:18,970
再次非常类似于具有其自己的布尔表达式的条件。
Very similar, again, to a condition with its own Boolean expression.

2108
01:39:18,970 --> 01:39:23,970
因此，在C语言中使用while时，你必须在while一词后加上括号，
So with while in C, you have to have parentheses after the word while,

2109
01:39:23,970 --> 01:39:26,670
并且你必须在这些括号中提出一个问题。
and you have to ask a question in those parentheses.

2110
01:39:26,670 --> 01:39:30,240
你必须说类似x大于y，x小于y，
You have to say something like, x greater than y, x less than y,

2111
01:39:30,239 --> 01:39:31,119
或类似的东西。
or the like.

2112
01:39:31,119 --> 01:39:33,119
但这在某种意义上来说是一个极端的情况
But this is a bit of a corner case in the sense

2113
01:39:33,119 --> 01:39:35,129
如果你想永远做某事，
that if you want to do something forever,

2114
01:39:35,130 --> 01:39:36,765
谁在乎问题是什么。
who cares what the question is.

2115
01:39:36,765 --> 01:39:39,450
你只希望答案始终是肯定的。
You just want the answer always to be yes.

2116
01:39:39,449 --> 01:39:42,059
或用计算机术语来说，始终是真实的。
Or in computer terms, always to be true.

2117
01:39:42,060 --> 01:39:46,050
最直截了当地表达真实的方式
And the most blunt way to express true always

2118
01:39:46,050 --> 01:39:48,250
字面上写的是“真”。
is literally to write the word true.

2119
01:39:48,250 --> 01:39:50,431
因此，即使这看起来有些怪异，但在C语言中
So even though this looks a little weird, this in C

2120
01:39:50,431 --> 01:39:52,139
就是你故意诱导我们做些什么
is how you deliberately induce what we'll

2121
01:39:52,140 --> 01:39:57,300
调用一个永不停止的无限循环，因为根据定义始终为true
call an infinite loop that never stops because true is always by definition

2122
01:39:57,300 --> 01:39:57,960
真的。
true.

2123
01:39:57,960 --> 01:40:00,420
你甚至不必问一个更复杂的问题。
You don't even have to ask a more complicated question.

2124
01:40:00,420 --> 01:40:03,490
你可以放置小于号，大于号等。
You could put a less than sign, a greater than sign, or the like.

2125
01:40:03,489 --> 01:40:05,531
但是，如果你只希望某些事情永远发生，
But if you just want something to happen forever,

2126
01:40:05,532 --> 01:40:09,450
这是永远表达某些东西的最规范的方法。
this is the most canonical way to express something forever.

2127
01:40:09,449 --> 01:40:12,119
好吧，如果你想有限次地做某事怎么办？
Well, what if you want to do something finitely many times?

2128
01:40:12,119 --> 01:40:14,849
好吧，我们也可以在C语言中使用
Well, we can do that in C as well using what's

2129
01:40:14,850 --> 01:40:18,120
将被称为for循环或while循环。
going to be called a for loop, or a while loop.

2130
01:40:18,119 --> 01:40:21,069
好吧，让我们依次考虑这两个方面。
Well, let's consider both of these in turn.

2131
01:40:21,069 --> 01:40:25,919
因此，如果我想做50次操作，那是最机械的手动方式
So if I want to do something 50 times, the most mechanical manual way

2132
01:40:25,920 --> 01:40:28,620
我能想到的就像只是依靠我的手指，对不对？
I can think of is like just count on my fingers, right?

2133
01:40:28,619 --> 01:40:31,199
就像一，二，三一样，一直到50。
Like, one, two, three, all the way up to 50 somehow.

2134
01:40:31,199 --> 01:40:34,049
或我手上最多10个。
Or 10 maximally on my hands.

2135
01:40:34,050 --> 01:40:37,260
那么，如何在C语言中执行有限次的操作呢？
So how can I do something finitely many times in C?

2136
01:40:37,260 --> 01:40:39,300
好吧，我可以使用变量。
Well, I have at my disposal variables.

2137
01:40:39,300 --> 01:40:41,610
因此，让我给自己一个称为计数器的变量。
So let me give myself a variable called counter.

2138
01:40:41,609 --> 01:40:44,024
将其初始化为零分号。
Initialize it to zero semicolon.

2139
01:40:44,024 --> 01:40:45,899
数据类型将为int，因为我只是
And the data type will be int, because I just

2140
01:40:45,899 --> 01:40:47,639
需要像我的手指一样数数。
need to count much like on my fingers.

2141
01:40:47,640 --> 01:40:48,390
但是你知道吗？
But you know what?

2142
01:40:48,390 --> 01:40:50,310
Counter有点冗长。
Counter is a little verbose.

2143
01:40:50,310 --> 01:40:54,150
程序员在频繁计数时，从零开始递增计数
Programmers whenever they're counting frequently, just counting up from zero

2144
01:40:54,149 --> 01:40:58,679
然后，他们通常只会将i用作整数，或将c用作字符，
on up, they'll often just use i for integer, or c for character,

2145
01:40:58,680 --> 01:41:00,000
或s表示字符串。
or s for string.

2146
01:41:00,000 --> 01:41:02,109
你不想总是在你的代码中这样做。
You don't want to do that always in your code.

2147
01:41:02,109 --> 01:41:05,279
有时最好用更具描述性的名称来命名变量，
It's sometimes better for your variables to be more descriptively named,

2148
01:41:05,279 --> 01:41:08,229
但是对于一个愚蠢的变量，它只会从零开始计数，
but for a stupid variable that's just going to count from zero on up,

2149
01:41:08,229 --> 01:41:10,091
让我们保持简单并称之为i。
let's just keep it simple and call it i.

2150
01:41:10,091 --> 01:41:12,201
我现在可以再次做一会儿循环，但是现在我
I can now do a while loop again, but now I

2151
01:41:12,202 --> 01:41:14,910
不得不问一个问题，因为我不想让它永远运行下去。
have to ask a question because I don't want this running forever.

2152
01:41:14,909 --> 01:41:16,199
我希望它运行50次。
I want it running 50 times.

2153
01:41:16,199 --> 01:41:17,541
我可以问什么问题？
What question could I ask?

2154
01:41:17,542 --> 01:41:18,750
好吧，我为什么不检查一下。
Well, why don't I just check.

2155
01:41:18,750 --> 01:41:20,970
虽然我还不到50岁。
While i is less than 50.

2156
01:41:20,970 --> 01:41:23,010
这就好比数了50个手指。
So it's like counting up on 50 fingers.

2157
01:41:23,010 --> 01:41:27,300
让我从零开始计数，但不等于i等于50。
Let me start at zero and count up to, but not through i equals 50.

2158
01:41:27,300 --> 01:41:30,870
因此，只要我小于50，请执行以下操作。
So so long as i is less than 50, do the following.

2159
01:41:30,869 --> 01:41:31,799
我要怎么办
What do I want to do?

2160
01:41:31,800 --> 01:41:33,300
我想继续打印你好，世界。
I want to keep printing out hello, world.

2161
01:41:33,300 --> 01:41:33,870
你好，世界。
Hello, world.

2162
01:41:33,869 --> 01:41:34,979
你好，世界。
Hello, world.

2163
01:41:34,979 --> 01:41:36,209
但是我还没有完成。
But I'm not done.

2164
01:41:36,210 --> 01:41:40,830
因为在该循环的每个迭代中，在该循环的每个循环中，
Because on every iteration of this loop, on every cycle of this loop,

2165
01:41:40,829 --> 01:41:42,749
我需要在数学上再做一件事。
I need to do one more thing mathematically.

2166
01:41:42,750 --> 01:41:45,330
我需要添加另一个手指，添加另一个手指。
I need to add another finger, add another finger.

2167
01:41:45,329 --> 01:41:48,269
换句话说，我需要在i上加一个。
Or in other words, I need to add one to i.

2168
01:41:48,270 --> 01:41:52,410
因此，让我继续进行设置，使我等于现在的状态，再加上一个。
So let me go ahead and set i equal to whatever it is now, plus one.

2169
01:41:52,409 --> 01:41:54,299
但同样，我们有一些语法糖
But again, we have some syntactic sugar just

2170
01:41:54,300 --> 01:41:56,680
使它更清洁，更紧密。
to make this a little cleaner, a little tighter.

2171
01:41:56,680 --> 01:41:58,140
我可以做到我加等于一。
I could do i plus equals one.

2172
01:41:58,140 --> 01:42:01,410
或更简洁地说，我加加。
Or even more succinctly, i plus plus.

2173
01:42:01,409 --> 01:42:05,309
因此，即使比Scratch实施起来更令人讨厌
So even though this is way more annoying to implement than in Scratch

2174
01:42:05,310 --> 01:42:09,840
麻省理工学院只是在为你提供所需的内容，在C语言中，我们拥有所有的构建基块
where MIT just gives you what you want, in C we have all of the building blocks

2175
01:42:09,840 --> 01:42:16,920
现在具有变量和循环以实现重复的概念
now with variables and with loops to implement the notion of repeating

2176
01:42:16,920 --> 01:42:18,540
一些有限的次数。
some finite number of times.

2177
01:42:18,539 --> 01:42:20,207
但是还有另一种方法可以做到这一点。
But there's another way to do this.

2178
01:42:20,207 --> 01:42:22,499
正如你可能发现问题集为零，
And as you might have discovered with problem set zero,

2179
01:42:22,500 --> 01:42:25,439
在Scratch中有不同的方法可以实现相同的目标。
there's different ways to achieve the same goals in Scratch.

2180
01:42:25,439 --> 01:42:27,599
同样在C语言中，我可以做到这一点。
Similarly in C, I could do this.

2181
01:42:27,600 --> 01:42:31,650
我可以从1开始数到50。
I could just start counting at one and count up through 50.

2182
01:42:31,649 --> 01:42:34,559
因此键盘上没有大于或等于符号的键，
So there's no greater than or equal sign key on your keyboard,

2183
01:42:34,560 --> 01:42:36,570
最有可能，或小于或等于。
most likely, or less than or equal to.

2184
01:42:36,569 --> 01:42:40,079
因此，与其他语言一样，在C语言中，你仅使用两个字符。
So in C, as with other languages, you just use two characters.

2185
01:42:40,079 --> 01:42:43,289
你执行的操作少于符号，后跟等号。
You do less than sign followed by the equals sign.

2186
01:42:43,289 --> 01:42:45,569
表示小于或等于。
And that expresses less than or equal to.

2187
01:42:45,569 --> 01:42:46,799
所以这也是正确的。
So this is also correct.

2188
01:42:46,800 --> 01:42:49,870
如果我从一开始数，我需要数到50。
If I start counting at one I need to count through 50.

2189
01:42:49,869 --> 01:42:51,219
你可以这样做。
You can do this.

2190
01:42:51,220 --> 01:42:51,885
不要这样
Don't do this.

2191
01:42:51,885 --> 01:42:53,370
这是非常规的。
This is unconventional.

2192
01:42:53,369 --> 01:42:55,799
就像程序员通常一样，
And like programmers will conventionally,

2193
01:42:55,800 --> 01:42:58,590
上周开始的时候，我们总是从零开始
per last week when we started always counting from zero with all

2194
01:42:58,590 --> 01:43:03,480
灯泡熄灭，它们将从零开始，最多计数50。
the light bulbs off, they'll instead start at zero and count up to 50.

2195
01:43:03,479 --> 01:43:06,759
这将使你隐式获得零到49。
Which gives you zero through 49 implicitly.

2196
01:43:06,760 --> 01:43:08,350
这样做，而不是那样。
So do this, not that.

2197
01:43:08,350 --> 01:43:10,440
但这确实表明你可以解决
But this does speak to the fact that you can solve

2198
01:43:10,439 --> 01:43:12,789
问题有很多不同的方式。
problems in so many different ways.

2199
01:43:12,789 --> 01:43:14,489
从根本上讲，还有另一种方法。
There's another way, fundamentally, too.

2200
01:43:14,489 --> 01:43:18,089
我们可以从50减少到零。
We could start counting from 50 down to zero.

2201
01:43:18,090 --> 01:43:22,650
唯一的区别是我们必须做我减去减号而不是我加号。
The only difference being we have to do i minus minus instead of i plus plus.

2202
01:43:22,649 --> 01:43:25,409
同样，这是解决同一问题的三种不同方法。
So again, that's three different ways to solve the same problem.

2203
01:43:25,409 --> 01:43:28,326
再一次，你将开始拥有正确的直觉和肌肉记忆，
And again, you'll start to have the right instincts and muscle memory,

2204
01:43:28,327 --> 01:43:31,260
而且你还将开始在讲座代码中看到常见的模式，即TF
and you'll also start to see common patterns in lecture code, your TF

2205
01:43:31,260 --> 01:43:34,410
或在线的助教代码，书籍和参考资料。
or teaching assistants code, books and references online.

2206
01:43:34,409 --> 01:43:38,129
尽管所有这些都倾向于有做事的方法
There just tend to be the ways to do things even though all of these

2207
01:43:38,130 --> 01:43:39,520
还是对的。
are still right.

2208
01:43:39,520 --> 01:43:40,050
好的。
All right.

2209
01:43:40,050 --> 01:43:42,000
这里还有另一种循环方法。
One more approach to loops here.

2210
01:43:42,000 --> 01:43:45,060
事实证明，还有另外一个循环结构，它有点神秘，
It turns out there's another loop construct that's a little more cryptic,

2211
01:43:45,060 --> 01:43:46,500
它被称为for循环。
and it's called a for loop.

2212
01:43:46,500 --> 01:43:48,899
它使你可以自动化-或更确切地说，
And it allows you to automate-- or rather,

2213
01:43:48,899 --> 01:43:52,559
使你可以更简洁地表达所有这些步骤。
allows you to express all of those steps a little more concisely.

2214
01:43:52,560 --> 01:43:57,720
所以对于printf大家好，世界将使我们离印刷更近一步
So for printf hello, world is going to get us one step closer to printing

2215
01:43:57,720 --> 01:43:59,340
你好，世界50次。
hello, world 50 times.

2216
01:43:59,340 --> 01:44:03,090
但是for语句和while语句一样，
But the for statement, just like the while statement,

2217
01:44:03,090 --> 01:44:05,580
后面附有必要的括号，
comes with necessary parentheses after it,

2218
01:44:05,579 --> 01:44:08,129
但这一次你可以在括号中放入更多内容。
but this time you can put more stuff in the parentheses.

2219
01:44:08,130 --> 01:44:10,050
这不仅是布尔表达式。
It's not just a Boolean expression.

2220
01:44:10,050 --> 01:44:12,630
首先，括号中的第一件事
First, the first thing in the parentheses

2221
01:44:12,630 --> 01:44:16,110
你可以将想要的任何变量初始化为某个值。
is you can initialize any variable you want to some value.

2222
01:44:16,109 --> 01:44:18,829
我可能会说相遇等于零，或更简洁地说，
I might say encounter equals zero, or more succinctly,

2223
01:44:18,829 --> 01:44:21,449
int我等于零分号。
int i equals zero semicolon.

2224
01:44:21,449 --> 01:44:23,859
但是for循环的外观有点时髦。
But the way the for loop looks, it's a little funky.

2225
01:44:23,859 --> 01:44:25,989
你可以在一行上执行多项操作。
You can do multiple things on one line.

2226
01:44:25,989 --> 01:44:29,039
括号内的第二件事是for循环
The second thing inside of the parentheses to a for loop

2227
01:44:29,039 --> 01:44:32,369
是你要一次又一次地检查的条件。
is a condition that you want to check again and again and again.

2228
01:44:32,369 --> 01:44:35,219
还有for循环括号中的最后一件事
And the last thing in the parentheses of a for loop

2229
01:44:35,220 --> 01:44:38,790
是更新，还是递增或递减
is an update, or an incrementation or decrementation

2230
01:44:38,789 --> 01:44:41,489
由此你可以做到我等于我加一。
whereby you can do i equals i plus one.

2231
01:44:41,489 --> 01:44:44,009
或更确切地说，让我们做我加等于1的事情。
Or rather, let's just do i plus equals one.

2232
01:44:44,010 --> 01:44:46,830
或更简洁地说，我加加。
Or even more succinctly, i plus plus.

2233
01:44:46,829 --> 01:44:49,709
这也许是最传统的方式
This is perhaps the most conventional way

2234
01:44:49,710 --> 01:44:54,540
用C和其他编程语言执行50次操作，
in C and in other programming languages to do something 50 times,

2235
01:44:54,539 --> 01:44:56,041
或有限次数。
or a finite number of times.

2236
01:44:56,042 --> 01:44:58,500
到目前为止，我们所看到的情况与众不同。
It's different looking from the things we've seen thus far.

2237
01:44:58,500 --> 01:45:00,540
在怪异的地方有分号。
There's semicolons in weirder places.

2238
01:45:00,539 --> 01:45:02,019
括号中还有更多内容。
There's more stuff in parentheses.

2239
01:45:02,020 --> 01:45:04,200
再次重申，你将全面发展肌肉记忆。
So again, you'll develop the muscle memory overall.

2240
01:45:04,199 --> 01:45:08,429
但是现在，只要意识到这就是说，将i初始化为零即可。
But for now just realize this says, initialize i to zero.

2241
01:45:08,430 --> 01:45:09,540
检查条件。
Check the condition.

2242
01:45:09,539 --> 01:45:12,419
如果我的打印量少于50，则为世界。
And if i is less than 50 print hello, world.

2243
01:45:12,420 --> 01:45:14,460
然后更新我。
Then update i.

2244
01:45:14,460 --> 01:45:16,060
然后检查条件。
Then check the condition.

2245
01:45:16,060 --> 01:45:18,420
如果小于50，请打个招呼，世界。
If it's less than 50, print hello, world.

2246
01:45:18,420 --> 01:45:20,190
然后增加i。
Then increment i.

2247
01:45:20,189 --> 01:45:21,689
然后检查条件。
Then check the condition.

2248
01:45:21,689 --> 01:45:24,339
然后，如果不是那么，请打个招呼，世界。
Then if it's less then, print hello, world.

2249
01:45:24,340 --> 01:45:27,660
因此，变量的初始化只发生一次。
So the initialization of the variable happens once.

2250
01:45:27,659 --> 01:45:29,969
一切都一次又一次地发生
Everything else happens again and again and again

2251
01:45:29,970 --> 01:45:33,810
直到完成此操作约50次为止。
until you've done this some 50 times.

2252
01:45:33,810 --> 01:45:34,530
好的。
All right.

2253
01:45:34,529 --> 01:45:36,779
因此，有了这些构建基块，就可以了
So with those building blocks, that's kind of it

2254
01:45:36,779 --> 01:45:40,109
我们将Scratch转换为C。现在开始
for our translation of Scratch into C. Let's now start

2255
01:45:40,109 --> 01:45:44,129
在实践中建立一些更有趣的程序
to build up some more interesting programs in practice

2256
01:45:44,130 --> 01:45:45,450
例如抽象。
for instance, abstraction.

2257
01:45:45,449 --> 01:45:48,569
因此，回想一下，这就是解决问题的原则
So abstraction, recall, was this problem solving principle

2258
01:45:48,569 --> 01:45:53,249
从而可以简化其他更复杂的细节。
whereby you can simplify otherwise more complicated details.

2259
01:45:53,250 --> 01:45:57,570
抽象是在更复杂的细节之上的简化
And abstraction is a simplification on top of more complicated details

2260
01:45:57,569 --> 01:46:00,479
或程序员可能会说的实现细节。
or implementation details as a programmer might say.

2261
01:46:00,479 --> 01:46:02,429
例如，让我继续写
So for instance, let me go ahead and write

2262
01:46:02,430 --> 01:46:06,690
这里的程序叫做喵，类似于上周，但是这次是C语言。
a program here called meow, similar to last week, but this time in C.

2263
01:46:06,689 --> 01:46:09,689
为了让猫在文字上发出喵声，
And in order to make a cat meow textually,

2264
01:46:09,689 --> 01:46:12,979
让我在顶部给自己stdio.h。
let me give myself stdio.h at the top.

2265
01:46:12,979 --> 01:46:16,139
Int main void在这里。
Int main void down here.

2266
01:46:16,140 --> 01:46:18,105
同样，我在一个名为meow.c的文件中。
Again, I'm in a file called meow.c.

2267
01:46:18,104 --> 01:46:21,386
而且我包括了stdio.h和int main void。
And I've included stdio.h and int main void.

2268
01:46:21,386 --> 01:46:23,969
现在，我要继续做这样的事情。
And now I'm going to go ahead and just do something like this.

2269
01:46:23,970 --> 01:46:27,810
Printf，引用反引号，“喵”，反斜杠n。
Printf, quote unquote, "meow", backslash n.

2270
01:46:27,810 --> 01:46:31,110
我希望这只猫在文本上发出三声喵叫。
And I want this cat to meow textually three times.

2271
01:46:31,109 --> 01:46:32,699
让我保存该文件。
Let me save that file.

2272
01:46:32,699 --> 01:46:34,149
发出喵声。
Make meow.

2273
01:46:34,149 --> 01:46:34,649
好的。
All right.

2274
01:46:34,649 --> 01:46:36,089
现在，点斜线喵。
Now, dot slash meow.

2275
01:46:36,090 --> 01:46:37,660
喵，喵，喵都在文字上。
Meow, meow, meow all in text.

2276
01:46:37,659 --> 01:46:40,739
所以不像上周的那只猫那样可爱或漂亮，
So not nearly as cute or pretty as the one with the cat last week,

2277
01:46:40,739 --> 01:46:42,629
但这是正确的。
but it's correct.

2278
01:46:42,630 --> 01:46:45,210
但这不是很好的设计，对不对？
But it's not very well designed, right?

2279
01:46:45,210 --> 01:46:46,740
因为我在重复自己。
Because I'm repeating myself.

2280
01:46:46,739 --> 01:46:50,009
我从字面上复制和粘贴，这些都是不好的本能。
I literally copied and pasted, and those are bad instincts.

2281
01:46:50,010 --> 01:46:52,770
但是现在，我们可以使用循环来做事了。
But now we have the ability to do things with loops.

2282
01:46:52,770 --> 01:46:55,530
因此，让我实际删除该功能的这一部分。
So let me actually delete this part of the function.

2283
01:46:55,529 --> 01:46:58,739
让我尝试从前面的示例中记住。
And let me try to remember from the example before.

2284
01:46:58,739 --> 01:47:01,556
如果我想做三遍，可以使用while循环，
If I want to do something three times I could use a while loop,

2285
01:47:01,556 --> 01:47:03,389
但这感觉像是一堆代码。
but that felt like a bunch of lines of code.

2286
01:47:03,390 --> 01:47:04,050
我来做
Let me do this.

2287
01:47:04,050 --> 01:47:06,150
整数i等于零。
Int i equals zero.

2288
01:47:06,149 --> 01:47:07,949
我不到三岁。
i less than three.

2289
01:47:07,949 --> 01:47:09,509
我加加。
i plus plus.

2290
01:47:09,510 --> 01:47:14,850
如此神秘，但这再次是事实上的做某事的方式
So cryptic, but this, again, is the de facto way of doing something

2291
01:47:14,850 --> 01:47:16,290
有限的次数。
a finite number of times.

2292
01:47:16,289 --> 01:47:20,789
初始化一些变量，例如i到零，检查条件，
Initialize some variable, like i to zero, check a condition,

2293
01:47:20,789 --> 01:47:23,489
并不断增加变量一次又一次
and keep incrementing your variable again and again

2294
01:47:23,489 --> 01:47:26,399
因此它总共执行了多次。
so that it executes a total of that many times.

2295
01:47:26,399 --> 01:47:28,829
现在，让我继续打印并喵喵声-
Now, let me go ahead and printf meow--

2296
01:47:28,829 --> 01:47:32,129
柔和-里面发出喵呜声。
mellow-- meow on the inside.

2297
01:47:32,130 --> 01:47:35,280
让我继续，让喵喵重新编译喵喵。
Let me go ahead and recompile meow by make meow.

2298
01:47:35,279 --> 01:47:37,469
让我点点斜线喵叫声，瞧。
Let me dot slash meow, and voila.

2299
01:47:37,470 --> 01:47:40,297
现在可以说该程序的设计更好。
Now the program is arguably better designed.

2300
01:47:40,296 --> 01:47:41,879
但是，让我进一步迈出这一步。
But let me take this one step further.

2301
01:47:41,880 --> 01:47:48,150
回想一下上周的轨迹不仅要实现喵
Recall that the trajectory last week was to not only implement meow

2302
01:47:48,149 --> 01:47:51,381
具有更好的设计，而无需重复自己，从而使用了循环。
with better design, without repeating yourself, thereby using a loop.

2303
01:47:51,381 --> 01:47:53,339
但是请记住，我们介绍了
But remember we introduced the abstraction that

2304
01:47:53,340 --> 01:47:55,350
是一个叫做喵的定制拼图。
was a custom puzzle piece called meow.

2305
01:47:55,350 --> 01:47:59,462
因此，在C语言中，我们也有能力实现自己的功能。
So in C, turns out we have the ability to make our own functions as well.

2306
01:47:59,462 --> 01:48:02,670
语法需要一点时间来适应，但让我继续
And the syntax is going to take a little getting used to, but let me go ahead

2307
01:48:02,670 --> 01:48:03,330
并做到这一点。
and do this.

2308
01:48:03,329 --> 01:48:05,249
让我在这里摆脱我的printf。
Let me get rid of my printf here.

2309
01:48:05,250 --> 01:48:08,640
在文件的底部-实际上，在文件的顶部
And at the bottom of my file-- actually, at the top of my file

2310
01:48:08,640 --> 01:48:13,890
我将继续输入void meow void。
I'm going to go ahead and type void meow void.

2311
01:48:13,890 --> 01:48:16,140
对于今天来说，这是非常神秘的，但是，再次
Which is very cryptic for today, but again, this

2312
01:48:16,140 --> 01:48:19,140
可以用作样板，现在复制粘贴。
is fine to be boilerplate, copy pasted for now.

2313
01:48:19,140 --> 01:48:21,720
让我继续，然后在这里打印一下。
Let me go ahead and just printf meow here.

2314
01:48:21,720 --> 01:48:24,780
即使我们今天没有解释也不会解释
Even though we haven't explained and won't explain today

2315
01:48:24,779 --> 01:48:29,009
这个关键字void意味着什么，我在第三到第六行中做了什么
what this keyword void means, what I've done in lines three through six

2316
01:48:29,010 --> 01:48:31,230
是创建我自己的自定义函数。
is create my own custom function.

2317
01:48:31,229 --> 01:48:33,989
C没有附带名为meow的函数。
C does not come with a function called meow.

2318
01:48:33,989 --> 01:48:37,169
CS50的库没有附带名为meow的函数。
CS50's library does not come with a function called meow.

2319
01:48:37,170 --> 01:48:39,510
但是现在感谢我，存在一个功能
But now thanks to me, there exists a function

2320
01:48:39,510 --> 01:48:43,440
叫喵，生活中唯一的目的就是打印喵。
called meow whose sole purpose in life is just to print out meow.

2321
01:48:43,439 --> 01:48:46,859
但是现在最酷的是在这里
But what's cool about this now is that down here, just

2322
01:48:46,859 --> 01:48:51,629
就像上周使用Scratch一样，我现在可以调用一个名为meow的函数。
like with Scratch last week, I can now call a function called meow.

2323
01:48:51,630 --> 01:48:53,940
而且我的代码更具可读性，因为它宁可
And my code is a little more readable because it rather

2324
01:48:53,939 --> 01:48:58,499
仅通过函数名称来说明它的作用。
says what it does by just by way of the function's name.

2325
01:48:58,500 --> 01:49:01,020
现在让我继续进行编译。
And let me go ahead now and compile this.

2326
01:49:01,020 --> 01:49:02,760
发出喵声。
Make meow.

2327
01:49:02,760 --> 01:49:04,080
到目前为止，一切都很好。
So far so good.

2328
01:49:04,079 --> 01:49:08,009
点斜线喵，它似乎工作正常。
Dot slash meow, and it seems to work OK.

2329
01:49:08,010 --> 01:49:10,950
但我不喜欢我已经实行喵的事实
But I don't love the fact that I've implemented meow

2330
01:49:10,949 --> 01:49:12,119
在文件的顶部。
at the top of the file.

2331
01:49:12,119 --> 01:49:13,289
没什么大不了的。
It's not a big deal.

2332
01:49:13,289 --> 01:49:18,209
按照约定，我们通常将自定义函数放在文件的底部。
By convention we'll typically put custom functions at the bottom of the file.

2333
01:49:18,210 --> 01:49:18,900
为什么？
Why?

2334
01:49:18,899 --> 01:49:21,569
只是因为当一个程序员，或者在我们的情况下，
Only because when a programmer, or in our case,

2335
01:49:21,569 --> 01:49:25,109
一位老师想从上到下理解你的代码。
a teaching fellow wants to understand your code from top to bottom.

2336
01:49:25,109 --> 01:49:29,099
放置主程序（主要功能）只是人类的惯例，
It's just human convention to put the main program, the main function rather,

2337
01:49:29,100 --> 01:49:31,410
在文件的顶部。
at the top of your file.

2338
01:49:31,409 --> 01:49:36,269
问题是，当我这样做时，我会为自己创建一个问题。
The problem is when I do this, I'm going to have created a problem for myself.

2339
01:49:36,270 --> 01:49:38,670
当我跑步时请立即发出声音。
When I run make meow now, darn it.

2340
01:49:38,670 --> 01:49:42,750
生成了两个错误，因此有几个错误需要解决。
Two errors generated, and so there's a couple of bugs to be solved.

2341
01:49:42,750 --> 01:49:44,582
但是首先，布莱恩，这个小组的一个问题。
But first, Brian, a question from the group.

2342
01:49:44,582 --> 01:49:47,374
布莱恩·于（Brian Yu）：聊天中出现一个问题，即为什么
BRIAN YU: There was a question that came in from the chat about why

2343
01:49:47,375 --> 01:49:49,770
例如，在第五行，你没有
it is that on line five, for example, you don't have

2344
01:49:49,770 --> 01:49:51,480
for循环末尾的分号。
a semicolon at the end of the for loop.

2345
01:49:51,479 --> 01:49:53,579
在第11行，你没有分号
And on line 11 you don't have a semicolon

2346
01:49:53,579 --> 01:49:54,939
在函数名称的末尾。
at the end of the function name.

2347
01:49:54,939 --> 01:49:58,402
那么为什么有些行最后需要分号，而另一些行却不需要分号呢？
So why do some lines need semicolons at the end, but other lines don't?

2348
01:49:58,403 --> 01:49:59,820
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

2349
01:49:59,819 --> 01:50:03,339
为什么其中一些行没有分号，而另一些却没有分号？
Why do some of these lines not have semicolons, but others do?

2350
01:50:03,340 --> 01:50:06,990
坦率地说，简短的答案（不要被嘲笑）仅是因为。
The short answer, not to be glib, is honestly just because.

2351
01:50:06,989 --> 01:50:10,709
语言的设计方式是你通常应该
The way the language was designed was that you should generally

2352
01:50:10,710 --> 01:50:15,120
表达动词或动作或功能时完成你的想法
finish your thoughts when expressing verbs or actions or functions

2353
01:50:15,119 --> 01:50:16,109
与分号。
with semicolons.

2354
01:50:16,109 --> 01:50:18,299
例如，在printf之后，我们已经看到了这一点。
And we've seen that after printf for instance.

2355
01:50:18,300 --> 01:50:20,130
喵喵之后，我们刚刚看到了这一点。
We've just seen that after meow.

2356
01:50:20,130 --> 01:50:22,830
但是，当你使用其他编程结构时，
However, when you're using other programming constructs,

2357
01:50:22,829 --> 01:50:28,499
像循环或像自定义函数一样，那里没有分号。
like loops or like custom functions, you don't have semicolons there.

2358
01:50:28,500 --> 01:50:29,069
为什么？
Why?

2359
01:50:29,069 --> 01:50:31,199
几年前，有些人才决定我们
Some humans years ago just decided that we

2360
01:50:31,199 --> 01:50:32,782
在那些地方不需要分号。
don't need semicolons in those places.

2361
01:50:32,783 --> 01:50:36,075
这是需要一段时间才能发展肌肉的事情之一
And this is one of those things that it will take a while to develop the muscle

2362
01:50:36,074 --> 01:50:39,029
记忆和识别这些东西去向的心理模型
memory and the mental model for recognizing where those things go

2363
01:50:39,029 --> 01:50:39,629
而且不要。
and don't.

2364
01:50:39,630 --> 01:50:42,450
但到目前为止，我们唯一见过分号的地方
But thus far the only places we've seen semicolons

2365
01:50:42,449 --> 01:50:46,139
在函数的末尾，例如此处的喵和printf。
are at the ends of functions, like meow and printf here.

2366
01:50:46,140 --> 01:50:51,750
现在，很奇怪的是，在for循环的括号内。
And now, admittedly weirdly, inside of the parentheses for the for loop.

2367
01:50:51,750 --> 01:50:55,740
但是同样，当解决问题时，首先要研究的是第一个实验，依此类推，
But again, when tackling problem sets one and the first lab and so forth,

2368
01:50:55,739 --> 01:50:58,919
你经常会想回头看幻灯片中的此类示例
you'll often want to refer back to examples like these in the slides

2369
01:50:58,920 --> 01:51:01,410
以及本节中的参考，以便你可以
and the references in your section so that you can

2370
01:51:01,409 --> 01:51:03,639
围绕这些模式全神贯注。
wrap your mind around these patterns.

2371
01:51:03,640 --> 01:51:07,320
因此，让我现在继续解决我似乎在这里造成的两个问题。
So let me go ahead now and solve the two problems I seem to have created here.

2372
01:51:07,319 --> 01:51:10,559
这有点不明显，但是让人想起我们以前看到的内容。
It's a little non obvious, but it's reminiscent of what we've seen before.

2373
01:51:10,560 --> 01:51:14,670
函数喵的隐式声明在C99中无效。
Implicit declaration of function meow is invalid in C99.

2374
01:51:14,670 --> 01:51:19,230
C99指的是我们使用的1999年版本的C语言，
C99 is referring to the 1999 version of C the language we're using,

2375
01:51:19,229 --> 01:51:22,499
但是它只是变得令人困惑，C在眼前。
but it's just getting confused, C is right now.

2376
01:51:22,500 --> 01:51:23,250
好吧，为什么呢？
Well, why is that?

2377
01:51:23,250 --> 01:51:27,120
好吧，让我在这里向上滚动，然后我直言不讳地指出C，
Well, let me scroll up here and let me make the point that frankly C,

2378
01:51:27,119 --> 01:51:29,639
反过来，我的编译器也不是那么亮。
and in turn my compiler, they're not that bright.

2379
01:51:29,640 --> 01:51:32,370
就像，他们只会按照我告诉他们的明确去做。
Like, they're only going to do what I tell them to do explicitly.

2380
01:51:32,369 --> 01:51:36,419
现在的问题是，当编译器读取我的代码时
And the problem at the moment is that when the compiler reads my code

2381
01:51:36,420 --> 01:51:41,650
从上到下，向左或向右，直到第11行
from top to bottom, left or right, it is not until line 11

2382
01:51:41,649 --> 01:51:43,959
喵功能甚至存在。
the meow function even exists.

2383
01:51:43,960 --> 01:51:48,880
但是，我目前正在尝试在第7行使用该喵函数。
However, I am trying on line seven at the moment to use that meow function.

2384
01:51:48,880 --> 01:51:51,250
所以坦率地说，我的编译器不知道
So my compiler, frankly, just doesn't know

2385
01:51:51,250 --> 01:51:53,830
叫声是因为它以后不必叫声了。
what meow is because it hasn't gotten to meow later.

2386
01:51:53,829 --> 01:51:56,289
而且编译器不够聪明
And the compiler is not smart enough, or not

2387
01:51:56,289 --> 01:51:59,764
用户友好到足以先阅读所有内容，然后再决定
user friendly enough to read everything first and then decide

2388
01:51:59,765 --> 01:52:00,640
如果有问题。
if there's a problem.

2389
01:52:00,640 --> 01:52:03,310
它只会从上到下阅读一次，
It's only going to read it once through top to bottom,

2390
01:52:03,310 --> 01:52:06,320
遇到问题时，它会大吼大叫。
and it's going to yell at you the moment it encounters the problem.

2391
01:52:06,319 --> 01:52:09,429
所以解决方案很简单，移动功能
So the solution to this is quite simply, move the function

2392
01:52:09,430 --> 01:52:10,507
到文件顶部。
to the top of your file.

2393
01:52:10,506 --> 01:52:13,089
但是同样，这最终会变得令人讨厌，因为那时你
But again, that just gets annoying eventually because then you

2394
01:52:13,090 --> 01:52:15,298
必须去钓鱼才能实现你的主要功能
have to go fishing for your main function which might

2395
01:52:15,297 --> 01:52:17,319
在文件中向下排数十行。
be dozens of lines down in the file.

2396
01:52:17,319 --> 01:52:20,619
或者还有另一种方法，我们也会在适当的时候对此进行解释。
Or there's another way, and we'll explain this in due time too.

2397
01:52:20,619 --> 01:52:26,259
但是，你也可以仅复制自定义函数的第一行。
But you can also copy the very first line only of your custom function.

2398
01:52:26,260 --> 01:52:29,890
将其放在main上方文件的顶部。
Put it at the top of your file above main.

2399
01:52:29,890 --> 01:52:33,710
然后，对布莱恩的问题以分号结束。
And then, to Brian's question end that with a semicolon.

2400
01:52:33,710 --> 01:52:34,840
所以这很奇怪。
So this is weird.

2401
01:52:34,840 --> 01:52:39,490
这就是通常所说的原型，仅是一个提示。
This is what's generally known as a prototype, which is a hint only.

2402
01:52:39,489 --> 01:52:42,249
这是一种告诉编译器在那里的聪明方法
It's sort of a clever way of telling the compiler there

2403
01:52:42,250 --> 01:52:45,430
将存在一个名为喵的函数，但还没有。
will exist a function called meow, but just not yet.

2404
01:52:45,430 --> 01:52:46,720
但是知道会的。
But know that it will.

2405
01:52:46,720 --> 01:52:49,480
这只是一种解决方法，一种常见的解决方法，
And it's just kind of a workaround, a common workaround,

2406
01:52:49,479 --> 01:52:52,039
对于那个特定的问题。
for that particular problem.

2407
01:52:52,039 --> 01:52:52,539
好的。
All right.

2408
01:52:52,539 --> 01:52:56,019
因此，让我继续进行另一项更改，在此进行另一项更改。
So let me go ahead and make one more change, one more change here.

2409
01:52:56,020 --> 01:52:59,440
假设我想真正结束这个喵的例子
Suppose that I want to really finish off this meow example

2410
01:52:59,439 --> 01:53:00,609
就像我们在Scratch中所做的一样。
just like we did in Scratch.

2411
01:53:00,609 --> 01:53:06,109
因此，我们还允许喵将一些喵作为输入。
Whereby we also allow meow to take some number of meows as input.

2412
01:53:06,109 --> 01:53:09,469
所以我不想在我的主要功能中再有这个for循环。
So I don't want to have this for loop anymore in my main function.

2413
01:53:09,470 --> 01:53:15,010
假设我只想在主要功能中说三声。
Suppose I just want to be able to say, meow three, inside of my main function.

2414
01:53:15,010 --> 01:53:17,560
因此，三个是喵功能的输入。
Three thereby being the input to the meow function.

2415
01:53:17,560 --> 01:53:22,810
现在，就像上周一样，我现在需要更改自定义功能，如下所示。
I now need to change my custom function, just like I did last week, as follows.

2416
01:53:22,810 --> 01:53:25,390
事实证明-以及未来几周的更多内容-
It turns out-- and more on this in the weeks to come--

2417
01:53:25,390 --> 01:53:31,150
第11行这里提到的void表示返回值或输出
that this mention a void here on line 11 refers to the return value or output

2418
01:53:31,149 --> 01:53:31,869
此功能。
of this function.

2419
01:53:31,869 --> 01:53:36,399
长话短说，我今天自定义的喵函数没有返回值。
Long story short, my custom meow function today has no return value.

2420
01:53:36,399 --> 01:53:39,519
它本身不输出任何东西，而是仅输出
It doesn't output anything per se, it instead only

2421
01:53:39,520 --> 01:53:42,700
具有在屏幕上视觉打印的副作用。
has a side effect of printing visually on the screen.

2422
01:53:42,699 --> 01:53:44,139
但是它确实有输入。
But it does have an input.

2423
01:53:44,140 --> 01:53:48,850
如果你想在C语言中使用输入或参数，
And if you want to function in C to take input or arguments,

2424
01:53:48,850 --> 01:53:52,128
你可以从字面上做类似你想要的类型的名称
you can literally do something like, the name of the type you want

2425
01:53:52,127 --> 01:53:53,919
以及所需变量的名称。
and the name of the variable that you want.

2426
01:53:53,920 --> 01:53:57,640
因此，假设我想让喵叫输入一些数字，我们将其称为n。
So suppose I want meow to take as input some number, we'll call it n.

2427
01:53:57,640 --> 01:53:59,560
我想循环使用该数字。
And I want to use that number in a loop.

2428
01:53:59,560 --> 01:54:01,060
然后，我可以做这样的事情。
I could then do something like this.

2429
01:54:01,060 --> 01:54:06,940
因为int我为零，所以我小于n，我为加号。
For int i gets zero, i is less than n, i plus plus.

2430
01:54:06,939 --> 01:54:10,479
然后，我可以用花括号将我的printf包围起来。
I can then surround my printf with curly braces.

2431
01:54:10,479 --> 01:54:15,099
现在请注意，就像上周我对喵的最终实现一样，
And now notice just like last week with my final implementation of meow,

2432
01:54:15,100 --> 01:54:19,190
我的自定义函数可以接受输入，如括号所示。一世
my custom function can take input as denoted by the parentheses. i

2433
01:54:19,189 --> 01:54:22,119
本身没有输出，这就是为什么我在这里留下空白。
doesn't have output per se, that's why I'm leaving void here.

2434
01:54:22,119 --> 01:54:25,389
但是，再次，我们将在以后详细解释void。
But again, we'll explain void more in detail down the road.

2435
01:54:25,390 --> 01:54:29,530
但是现在我在for循环中使用了该输入。
But now I'm using that input inside of the for loop.

2436
01:54:29,529 --> 01:54:32,271
因此，即使这是C语言的新实现，
So even though this is a new implementation in C,

2437
01:54:32,271 --> 01:54:33,729
我正在使用相同的构建基块。
I'm using the same building blocks.

2438
01:54:33,729 --> 01:54:37,079
我正在像以前一样使用for循环，但不是硬编码三个，
I'm using a for loop like before, but instead of hard coding three,

2439
01:54:37,079 --> 01:54:41,979
或50个像我之前做的那样，现在我实际上要继续
or 50 like I did earlier, now I'm actually going to go ahead and just

2440
01:54:41,979 --> 01:54:48,175
插件，就像Scratch一样允许我做同样的事情。
plug-in that variable just like Scratch allowed me to do as well.

2441
01:54:48,176 --> 01:54:50,747
好吧，如果我想做更出色的事情该怎么办。
Well, what if I want to do something even fancier.

2442
01:54:50,747 --> 01:54:51,330
你知道吗？
You know what?

2443
01:54:51,329 --> 01:54:52,496
让我继续执行此操作。
Let me go ahead and do this.

2444
01:54:52,497 --> 01:54:55,540
假设我们要从用户那里获得输入，
Suppose that we want to get input from the user,

2445
01:54:55,539 --> 01:54:58,769
但我们确实希望他们提供特定类型的输入。
but we really want them to provide a specific type of input.

2446
01:54:58,770 --> 01:55:01,313
让我继续介绍另一种类型的循环。
Let me go ahead and introduce one other type of loop.

2447
01:55:01,313 --> 01:55:04,230
我将继续从档案库中获取代码
And this one I'm going to go ahead and grab from my archives, the code

2448
01:55:04,229 --> 01:55:06,239
我今天带来的
that I brought with me today.

2449
01:55:06,239 --> 01:55:11,339
我要继续复制一个名为positive.c的文件，
And I'm going to go ahead and copy over a file called positive.c,

2450
01:55:11,340 --> 01:55:14,770
这将坚持要求用户给我一个积极的价值。
which is going to insist that the user give me a positive value.

2451
01:55:14,770 --> 01:55:16,810
这也可以在课程的网站上找到。
So this too is on the course's website.

2452
01:55:16,810 --> 01:55:19,560
让我来介绍一下我已经编写的代码。
And let me just walk us through code that I already wrote.

2453
01:55:19,560 --> 01:55:23,130
在文件的顶部，我包括一些现在很熟悉的标题
Here at the top of my file, I'm including some now familiar header

2454
01:55:23,130 --> 01:55:23,820
文件。
files.

2455
01:55:23,819 --> 01:55:26,849
在这里，我包括一个原型。
And down here, I'm including a prototype.

2456
01:55:26,850 --> 01:55:29,610
这暗示了将要调用的函数，
That is a hint for a function that's going to be called,

2457
01:55:29,609 --> 01:55:31,979
很简单，get_positive_int。
quite simply, get_positive_int.

2458
01:55:31,979 --> 01:55:34,869
所以这是一个只会得到正整数的函数。
So this is a function that's only going to get a positive integer.

2459
01:55:34,869 --> 01:55:37,599
然后在我的主要功能中，请注意我将使用此功能。
Then in my main function, notice I'm going to use this.

2460
01:55:37,600 --> 01:55:40,410
我将在第10行获得一个名为i的变量，
I'm going to get a variable called i on line 10,

2461
01:55:40,409 --> 01:55:43,019
并且我将从用户那里得到积极的理解。
and I'm going to get a positive int from the user.

2462
01:55:43,020 --> 01:55:45,180
然后我将要打印出来。
And then I'm just going to print it out.

2463
01:55:45,180 --> 01:55:48,720
但是现在有趣的是，我有了这个附加的抽象。
But what's interesting now is I have this additional abstraction.

2464
01:55:48,720 --> 01:55:52,050
CS50库没有附带名为get_positive_int的函数，
The CS50 library does not come with a function called get_positive_int,

2465
01:55:52,050 --> 01:55:54,660
但是它确实带有一个名为get_int的函数。
but it does come with a function called get_int.

2466
01:55:54,659 --> 01:55:58,829
并注意我在第15和24行之间所做的事情。
And notice what I've done down here between lines 15 and 24.

2467
01:55:58,829 --> 01:56:03,269
在这里，我声明了一个名为get_positive_int的函数，
Down here I've declared a function called get_positive_int,

2468
01:56:03,270 --> 01:56:06,060
并注意这是我自己的自定义函数名称。
and notice that's my own custom function name.

2469
01:56:06,060 --> 01:56:09,540
它不需要任何输入，只是从人类那里得到一个正整数。
It doesn't take any inputs, it just gets a positive integer from the human.

2470
01:56:09,539 --> 01:56:13,349
但是现在请注意，它确实具有返回值。
But now notice it does have a return value.

2471
01:56:13,350 --> 01:56:16,650
以前我用空这个词来表示没有输入
Previously I used the word void to say the absence of input

2472
01:56:16,649 --> 01:56:17,879
或没有输出。
or the absence of output.

2473
01:56:17,880 --> 01:56:20,130
在这里我使用的是说，没有输入。
Here I'm using it's still to say, no inputs.

2474
01:56:20,130 --> 01:56:22,170
它只是总是得到一个正整数。
It just always gets a positive int.

2475
01:56:22,170 --> 01:56:25,770
但是我在此自定义函数名称的左侧说的是int
But I'm saying int on the left hand side of this custom function's name

2476
01:56:25,770 --> 01:56:28,420
因为此功能确实有输出。
because this function does have output.

2477
01:56:28,420 --> 01:56:29,910
输出将是什么？
What is the output going to be?

2478
01:56:29,909 --> 01:56:33,959
我们将在第17行注意到这一点，我给自己一个变量，并将其称为n。
We'll, notice here on line 17, I give myself a variable and I call it n.

2479
01:56:33,960 --> 01:56:38,340
然后，我今天有了C的最后一个新功能，这个循环称为
Then I have one final new feature of C today, this loop which is called,

2480
01:56:38,340 --> 01:56:41,310
不是while循环，而是do while循环。
not a while loop, but a do while loop.

2481
01:56:41,310 --> 01:56:44,460
do while循环与while循环几乎相同，
A do while loop is almost the same as a while loop,

2482
01:56:44,460 --> 01:56:49,470
除了在检查条件之前先盲目地做一件事。
except that it blindly does one thing first before checking a condition.

2483
01:56:49,470 --> 01:56:51,930
因此请注意，我将执行以下操作。
So notice here I'm going to do the following.

2484
01:56:51,930 --> 01:56:54,960
使用此提示（正整数）调用get_int，
Call get_int with this prompt, positive integer,

2485
01:56:54,960 --> 01:56:58,650
然后将返回值存储到名为n的变量中。
and then store the return value into the variable called n.

2486
01:56:58,649 --> 01:57:03,119
然后在这里，注意我说的是n小于一。
Then down here, notice I'm saying while n less than one.

2487
01:57:03,119 --> 01:57:05,999
所以这是一种怪异的语法，但是如果从数学上讲
So this is kind of a weird syntax, but if mathematically I

2488
01:57:06,000 --> 01:57:08,250
希望用户给我一个正整数，
want the user to give me a positive integer,

2489
01:57:08,250 --> 01:57:11,850
从技术上讲，这与希望用户给我一个整数是一样的
that's technically the same thing as wanting the user to give me an integer

2490
01:57:11,850 --> 01:57:16,368
并确保它不少于一个。
and just make sure that it is not less than one.

2491
01:57:16,368 --> 01:57:19,410
因为如果小于1，则为零或负一，或者为负二，
Because if it's less than one, it's zero or negative one or negative two,

2492
01:57:19,409 --> 01:57:21,219
那显然不是正整数。
that's obviously not a positive integer.

2493
01:57:21,220 --> 01:57:22,890
那么我该如何用代码表达这一点呢？
So how can I express this in code?

2494
01:57:22,890 --> 01:57:24,975
现在唯一的新事物是事实
The only new thing at the moment now is the fact

2495
01:57:24,975 --> 01:57:26,850
存在这个叫做do while的东西。
that there exists this thing called do while.

2496
01:57:26,850 --> 01:57:30,300
再说一次，“做一会儿”的价值在于你至少会做某事
And again, the value of do while is that you will do things at least

2497
01:57:30,300 --> 01:57:32,460
一次，然后检查条件。
once and then check a condition.

2498
01:57:32,460 --> 01:57:36,222
while循环首先检查条件，然后执行一些操作。
A while loop checks the condition first and then does something instead.

2499
01:57:36,221 --> 01:57:37,929
不过，在这种情况下，这就是我想要的。
This is what I want in this case, though.

2500
01:57:37,930 --> 01:57:40,050
我想做这个。
I want to do this.

2501
01:57:40,050 --> 01:57:44,080
从用户获取一个整数，提示他们输入一个正整数。
Get an integer from the user prompting them for a positive integer.

2502
01:57:44,079 --> 01:57:48,089
那么当n小于1时，如果人类
Then while n is less than one-- so if the human

2503
01:57:48,090 --> 01:57:51,810
输入零，或负一，或负二，我要怎么做？
typed in zero, or negative one, or negative two, what do I want to do?

2504
01:57:51,810 --> 01:57:54,750
同一件事一次又一次。
The same thing again and again and again.

2505
01:57:54,750 --> 01:57:56,370
所以它读起来很语法。
So it reads rather grammatically.

2506
01:57:56,369 --> 01:58:00,589
当n小于1时，请执行以下操作。
Do the following while n is less than one.

2507
01:58:00,590 --> 01:58:04,670
然后最后，这里唯一的新行是返回n。
And then lastly, and the only other new line here is return n.

2508
01:58:04,670 --> 01:58:08,880
这是程序实际上可以向你返回一些值的方式。
This is the way that a program can actually return some value to you.

2509
01:58:08,880 --> 01:58:11,570
它可以让你退还价值，而不是通过在屏幕上打印出来，
It can hand you back a value, not by printing it on the screen,

2510
01:58:11,569 --> 01:58:14,269
而不是从猫的嘴里听到或听到它的声音。
not by saying it audibly or visually from a cat's mouth.

2511
01:58:14,270 --> 01:58:17,300
从某种意义上说，它返回了它
It returns it in the sense that what's being returned here

2512
01:58:17,300 --> 01:58:21,410
是n，它是与该函数的输出匹配的整数。
is n, which is an integer that matches the output of this function.

2513
01:58:21,409 --> 01:58:22,829
为什么这有用？
Why is this useful?

2514
01:58:22,829 --> 01:58:24,199
好吧，让我们向上滚动。
Well let's scroll back up.

2515
01:58:24,199 --> 01:58:28,319
现在让我们想当然地认为我们存在get_positive_int函数。
Let's now take for granted that we get_positive_int function exists.

2516
01:58:28,319 --> 01:58:31,609
现在注意我们如何在main中使用它。
And now notice how we can use it in main.

2517
01:58:31,609 --> 01:58:34,069
我在右边叫get_positive_int。
I call get_positive_int on the right.

2518
01:58:34,069 --> 01:58:37,159
它返回一个我声称是整数类型的值。
It returns a value I claim that is of type integer.

2519
01:58:37,159 --> 01:58:41,419
我将返回值存储在名为i的变量的左侧。
I'm storing that return value on the left in this variable called i.

2520
01:58:41,420 --> 01:58:42,830
然后我打印出我。
And then I'm printing out i.

2521
01:58:42,829 --> 01:58:46,009
就像上周在Scratch中的喵喵例子一样，
And just like last week with the meow example in Scratch,

2522
01:58:46,010 --> 01:58:48,590
现在我已经实现了get_positive_int，
now that I have implemented get_positive_int,

2523
01:58:48,590 --> 01:58:50,570
有点看不见，忘了。
it sort of out of sight, out of mind.

2524
01:58:50,569 --> 01:58:53,929
我知道这是可以做到的，我可以抽象出来
I know that it can be done, and I can abstract away

2525
01:58:53,930 --> 01:58:59,090
底层的实现细节只需通过其名称调用即可。
the underlying implementation details by just calling it by its name.

2526
01:58:59,090 --> 01:59:01,610
但我想指出一件事
But there's one weird thing that I do want to point out

2527
01:59:01,609 --> 01:59:03,889
关于这些实施细节。
about these implementation details.

2528
01:59:03,890 --> 01:59:07,640
为什么我在这里宣布n？
Why did I declare n out here?

2529
01:59:07,640 --> 01:59:11,840
每隔一次我创建一个变量，就完成了这一步。
Every other time I've created a variable, I've done this.

2530
01:59:11,840 --> 01:59:14,600
事实证明，我们一直很幸运，
It turns out we've been getting lucky this whole time,

2531
01:59:14,600 --> 01:59:17,540
每当我声明变量时，从技术上讲
and any time I've declared variables they've technically

2532
01:59:17,539 --> 01:59:19,069
在花括号之间。
been in between curly braces.

2533
01:59:19,069 --> 01:59:23,119
属于主要功能或其他功能的花括号
The curly braces belonging to the main function or my other functions

2534
01:59:23,119 --> 01:59:24,739
到目前为止，我已经写过了。
that I've written thus far.

2535
01:59:24,739 --> 01:59:26,839
但是在这种情况下，问题是
But in this case, the problem is when you

2536
01:59:26,840 --> 01:59:30,050
在花括号内声明一个变量，
declare a variable inside of curly braces,

2537
01:59:30,050 --> 01:59:32,390
你遇到了我们称之为范围问题的问题。
you run into what we'll call an issue of scope.

2538
01:59:32,390 --> 01:59:36,800
变量的范围是它所在的代码行。
The scope of a variable is the lines of code in which it exists.

2539
01:59:36,800 --> 01:59:41,510
变量的范围是你可以在其中使用该变量的代码行。
The scope of a variable are the lines of code where you can use that variable.

2540
01:59:41,510 --> 01:59:44,750
今天的经验法则是，如果你
And the rule of thumb for today is that if you

2541
01:59:44,750 --> 01:59:47,149
在花括号内声明一个变量
declare a variable inside of curly braces

2542
01:59:47,149 --> 01:59:49,579
就像第26和28行的内容一样
like those here on line 26 and 28, which you

2543
01:59:49,579 --> 01:59:53,359
必须做一个do while循环，那个变量n
must do for a do while loop, that variable, n,

2544
01:59:53,359 --> 01:59:56,569
仅存在于那些花括号内。
only exists inside of those curly braces.

2545
01:59:56,569 --> 02:00:00,529
这意味着你无法将其与第29行中的一个进行比较。
Which means you cannot compare it against one in line 29.

2546
02:00:00,529 --> 02:00:03,559
这意味着你不能在第30行中返回它。
Which means you cannot return it in line 30.

2547
02:00:03,560 --> 02:00:05,400
它不再存在。
It just no longer exists.

2548
02:00:05,399 --> 02:00:08,839
因此，你正在做所有这些工作，先获取变量n，然后进行繁荣。
So you're doing all of this work getting the variable n, and then boom.

2549
02:00:08,840 --> 02:00:13,650
一旦你从上到下退出这些花括号，它就消失了。
It's gone once you exit top to bottom these curly braces.

2550
02:00:13,649 --> 02:00:16,849
因此，坦白地说，这是很愚蠢的，
So the workaround for that, stupid though it is frankly,

2551
02:00:16,850 --> 02:00:21,020
是你可以在其自己的行25上初始声明n。
is that you can declare n initially on its own line, 25.

2552
02:00:21,020 --> 02:00:23,450
你甚至不需要为其分配值，因为
You don't need to assign it a value even, because you're

2553
02:00:23,449 --> 02:00:25,429
最终将为其分配一个值。
going to assign it a value eventually.

2554
02:00:25,430 --> 02:00:29,180
但是，正如我一直说的那样，创建一个变量就是声明一个变量。
But again, to create a variable, as I keep saying, is to declare a variable.

2555
02:00:29,180 --> 02:00:34,680
你无需将其定义为必须立即具有值。
You don't need to define it as having a value necessarily right away.

2556
02:00:34,680 --> 02:00:39,980
因此，这是解决范围问题的一种方法。
So this is a way to work around what's otherwise known as an issue of scope.

2557
02:00:39,979 --> 02:00:43,769
好吧，现在所有这些拼图都可以使用了，可以这么说，
All right, with all of these puzzle pieces now in place so to speak,

2558
02:00:43,770 --> 02:00:45,650
让我继续并提出解决方案
let me go ahead and propose that we solve

2559
02:00:45,649 --> 02:00:47,149
一些图形化的东西。
something a little more graphical.

2560
02:00:47,149 --> 02:00:51,559
因此，你当然会记得，超级马里奥兄弟是第一个问题
So you'll recall, of course, Super Mario Brothers is one of the first problem

2561
02:00:51,560 --> 02:00:53,130
我们提到上周的场景。
sets that we alluded to last week.

2562
02:00:53,130 --> 02:00:55,100
在这个游戏中，有很多视觉效果。
And within this game there's a whole bunch of visuals.

2563
02:00:55,100 --> 02:00:57,100
例如，早期的视觉效果
For instance, there's this visual early on where

2564
02:00:57,100 --> 02:00:59,030
天空中有四个问号。
there's four question marks in the sky.

2565
02:00:59,029 --> 02:01:02,029
这些问号，如果你跳到上面和下面，
And these question marks, if you jump up and underneath them,

2566
02:01:02,029 --> 02:01:03,231
例如给你硬币。
give you coins for instance.

2567
02:01:03,231 --> 02:01:05,689
因此，让我引起我们的注意，让我问，
So let me draw our attention to that, and let me ask, well,

2568
02:01:05,689 --> 02:01:08,802
我怎么能用C编写一个只打印出四个问号的程序？
how could I write a program in C that just prints out four question marks?

2569
02:01:08,802 --> 02:01:10,219
好吧，让我继续执行此操作。
Well, let me go ahead and do this.

2570
02:01:10,220 --> 02:01:13,040
让我继续编写一个名为mario.c的程序。
Let me go ahead and write a program called mario.c.

2571
02:01:13,039 --> 02:01:19,339
让我继续并将stdio.h包含在名为mario.c的文件中。
Let me go ahead and include stdio.h in a file called mario.c.

2572
02:01:19,340 --> 02:01:21,240
给自己一个主要功能，int main void。
Give myself a main function, int main void.

2573
02:01:21,239 --> 02:01:22,489
我将保持简单。
I'm going to keep this simple.

2574
02:01:22,489 --> 02:01:26,279
Printf一，二，三，四，反斜杠n分号。
Printf one, two, three, four, backslash n semicolon.

2575
02:01:26,279 --> 02:01:29,839
这不像老式游戏那么酷，也不漂亮，
This is not nearly as cool or pretty as the old school game,

2576
02:01:29,840 --> 02:01:34,280
但是如果我运行make mario然后再做点斜杠mario，瞧。
but if I run make mario and then do dot slash mario, voila.

2577
02:01:34,279 --> 02:01:41,029
我对天空中的这四个方块的估计非常差
I get a very poor approximation of these four blocks in the sky

2578
02:01:41,029 --> 02:01:43,904
仅使用Ascii，或真正称为Ascii艺术。
using just Ascii, or really called Ascii art.

2579
02:01:43,904 --> 02:01:45,529
但是我可以做得更好。
But I can do a little better than that.

2580
02:01:45,529 --> 02:01:47,809
回想一下，现在我们可以使用循环了。
Recall that now we have the ability to use loops.

2581
02:01:47,810 --> 02:01:50,180
所以我可以说我为零。
So I could say for int i gets zero.

2582
02:01:50,180 --> 02:01:53,030
我不到四个，我加号。
i is less than four, i plus plus.

2583
02:01:53,029 --> 02:01:57,379
然后我可以一次打印一个问号。
And then I could just print out one question mark at a time.

2584
02:01:57,380 --> 02:01:59,470
然后在程序的最后，我
And then at the very end of my program, I

2585
02:01:59,470 --> 02:02:02,927
可以打印出新行，只是在最后一刻移动光标。
could print out a new line just to move the cursor at the very last moment.

2586
02:02:02,926 --> 02:02:04,759
我不想每个问号都这样
I don't want to do that every question mark,

2587
02:02:04,760 --> 02:02:06,177
因为那样的话它将是垂直的。
because then it would be vertical.

2588
02:02:06,176 --> 02:02:07,679
我只想在最后做。
I want to do it only at the end.

2589
02:02:07,680 --> 02:02:11,000
所以现在如果我做马里奥，我现在就经营马里奥。
So now if I make mario, and I run mario now.

2590
02:02:11,000 --> 02:02:13,850
完全相同的结果，但在某种意义上要好一些
Same exact result, but a little better in the sense

2591
02:02:13,850 --> 02:02:22,550
现在它使用循环而不是硬编码值。
that now it's using a loop instead of a hard coded value.

2592
02:02:22,550 --> 02:02:26,240
但是，现在让我变得更聪明一点，让我来做。
But let me be a little more clever now, and let me do this instead.

2593
02:02:26,239 --> 02:02:29,204
让我借用那个正整数示例的逻辑
Let me borrow the logic of that positive integer example

2594
02:02:29,204 --> 02:02:30,329
并做这样的事情。
and do something like this.

2595
02:02:30,329 --> 02:02:32,929
让我给我自己一个变量，n表示一个数字。
Let me give myself a variable called, n, for a number.

2596
02:02:32,930 --> 02:02:35,240
让我像以前一样做以下事情。
And let me do the following just like before.

2597
02:02:35,239 --> 02:02:37,909
让我从用户那里得到一个整数，然后问用户
Let me get an integer from the user, and ask the user

2598
02:02:37,909 --> 02:02:41,969
我要打印的砖的宽度。
for the width of the bricks that I want to print.

2599
02:02:41,970 --> 02:02:43,250
因此并不总是四个。
So it's not always four.

2600
02:02:43,250 --> 02:02:44,780
也许这是一个可变数字。
Maybe it's a variable number.

2601
02:02:44,779 --> 02:02:48,319
然后让我继续，在n小于1时执行此操作。
And then let me go ahead and do this while n is less than one.

2602
02:02:48,319 --> 02:02:51,329
与我以前的逻辑完全相同。
So identical to my logic before.

2603
02:02:51,329 --> 02:02:52,309
然后你知道吗？
And then you know what?

2604
02:02:52,310 --> 02:02:54,590
一旦我得到n的值-
Once I have a value of n--

2605
02:02:54,590 --> 02:02:57,410
所以让我继续在这里给我自己一个评论。
so let me go ahead up here and give myself a comment.

2606
02:02:57,409 --> 02:03:00,049
从用户处获取正整数。
Get positive integer from user.

2607
02:03:00,050 --> 02:03:02,390
而是说了所有这些代码行的功能。
That rather says what all of these lines of code do.

2608
02:03:02,390 --> 02:03:04,460
我不需要注释每一行。
I don't need to comment every single line.

2609
02:03:04,460 --> 02:03:07,700
如果这样做合乎逻辑，则可以每隔几条发表评论。
You can comment every few if it makes logical sense to do so.

2610
02:03:07,699 --> 02:03:12,439
现在让我继续并打印出许多问号。
Let me go ahead now and print out that many question marks.

2611
02:03:12,439 --> 02:03:13,519
所以我可以做一个循环。
So I can do a loop.

2612
02:03:13,520 --> 02:03:18,740
因为int我为零，所以我这次小于n，我加上加号。
For int i gets zero, i is less than n this time, i plus plus.

2613
02:03:18,739 --> 02:03:22,519
现在，我可以打印出一个问号而无需换行。
And now I can print out a single question mark without a new line.

2614
02:03:22,520 --> 02:03:24,580
然后在程序的最后，我
And then at the very end of my program, I

2615
02:03:24,579 --> 02:03:28,039
可以打印出一个新的换行分号。
can print out a single new line semicolon.

2616
02:03:28,039 --> 02:03:31,589
现在让我继续，增加终端窗口的大小。
Let me go ahead now and increase the size of my terminal window.

2617
02:03:31,590 --> 02:03:33,550
让我做马里奥。
Let me do make mario.

2618
02:03:33,550 --> 02:03:35,470
现在-哦，该死的。
And now-- oh, darn it.

2619
02:03:35,470 --> 02:03:38,140
函数get_int的隐式声明。
Implicit declaration of function get_int.

2620
02:03:38,140 --> 02:03:40,360
在这里help50可能是我的朋友。
Here's where help50 might be my friend.

2621
02:03:40,359 --> 02:03:43,539
因此，让我继续运行help50 make mario。
So let me go ahead and run help50 make mario.

2622
02:03:43,539 --> 02:03:45,489
它会寻求帮助。
It's going to ask for help.

2623
02:03:45,489 --> 02:03:48,189
你似乎在第9行的mario.c中出错。
You seem to have an error in mario.c on line nine.

2624
02:03:48,189 --> 02:03:50,302
通过隐式声明get_int函数，
By implicit declaration of function get_int,

2625
02:03:50,302 --> 02:03:53,469
clang的意思是-这是编译器的名称，我们将在下周看到-
clang means-- which is the name of the compiler, which we'll see next week--

2626
02:03:53,470 --> 02:03:55,390
表示无法识别get_int。
means that it doesn't recognize get_int.

2627
02:03:55,390 --> 02:03:58,540
你是否忘了在其中包含get_int的cs50.h？
Did you forget to include cs50.h in which get_int

2628
02:03:58,539 --> 02:03:59,919
在文件顶部声明。
declared at top of your file.

2629
02:03:59,920 --> 02:04:00,890
确实，我做到了。
And indeed, I did.

2630
02:04:00,890 --> 02:04:02,300
所以让我解决这个问题。
So let me fix this.

2631
02:04:02,300 --> 02:04:06,070
因此包括cs50.h。
So include cs50.h.

2632
02:04:06,069 --> 02:04:07,569
保存文件。
Save the file.

2633
02:04:07,569 --> 02:04:09,729
用make mario重新编译。
Recompile with make mario.

2634
02:04:09,729 --> 02:04:13,749
现在让我继续做点斜杠马里奥，
And now let me go ahead and do dot slash mario,

2635
02:04:13,750 --> 02:04:15,370
我给我自己四个宽度。
and I'll give myself a width of four.

2636
02:04:15,369 --> 02:04:16,149
一样的。
It's the same.

2637
02:04:16,149 --> 02:04:17,919
让我给自己一个40的宽度。
Let me give myself a width of 40.

2638
02:04:17,920 --> 02:04:19,300
现在，我得到了这种动力。
Now I get that dynamism.

2639
02:04:19,300 --> 02:04:22,010
让我给自己一个50的宽度，依此类推。
Let me give myself a width of 50, and so forth.

2640
02:04:22,010 --> 02:04:25,360
所以现在我们有了一个更具动态性的程序，但是你知道吗？
So now we have a program that's much more dynamic, but you know what?

2641
02:04:25,359 --> 02:04:27,939
让我们继续进行进一步的增强。
Let's go ahead and enhance this a little further.

2642
02:04:27,939 --> 02:04:31,059
后来在《超级马里奥兄弟》中，有很多这样的黑社会
Later on in Super Mario Brothers, there's like a lot of this underworld

2643
02:04:31,060 --> 02:04:32,830
在这里，你可以看到这些砖砌的网格，
here where you see these grids of bricks,

2644
02:04:32,829 --> 02:04:34,412
让我引起我们的注意。
and let me draw our attention to this.

2645
02:04:34,412 --> 02:04:38,049
看起来在水平和垂直方向上都是多块砖。
This looks like multiple bricks both horizontally and vertically.

2646
02:04:38,050 --> 02:04:40,130
所以有一个宽度和一个高度。
So there's a width and a height.

2647
02:04:40,130 --> 02:04:43,750
因此，我该如何打印出来，也许是三乘三。
So how can I go about printing out, maybe that's three by three.

2648
02:04:43,750 --> 02:04:46,600
三块砖隔了三块砖。
Three bricks across by three bricks down.

2649
02:04:46,600 --> 02:04:49,450
让我实际上在这里进入我的程序。
Let me actually go into my program here.

2650
02:04:49,449 --> 02:04:52,389
摆脱以前所有的问号内容。
Get rid of all the question mark stuff from before.

2651
02:04:52,390 --> 02:04:56,110
并考虑如何打印出三乘三的网格。
And consider how I could print out a three by three grid.

2652
02:04:56,109 --> 02:05:00,159
好吧，这里的糟糕方法是，如果我回到我的代码中，
Well, the bad approach here, if I go back into my code,

2653
02:05:00,159 --> 02:05:02,619
将打印出其中的三个。
would be to print out three of these.

2654
02:05:02,619 --> 02:05:04,989
然后可能是三个。
And then maybe three more.

2655
02:05:04,989 --> 02:05:07,719
也许再增加三个，然后再增加三个。
Maybe three more, and then three more.

2656
02:05:07,720 --> 02:05:10,383
但是，当然，这种复制粘贴不会长期飞行，
But of course, this copy paste is not going to fly long term,

2657
02:05:10,382 --> 02:05:11,049
没关系
but that's fine.

2658
02:05:11,050 --> 02:05:12,730
让我做马里奥。
Let me do make mario.

2659
02:05:12,729 --> 02:05:14,329
马里奥（Mario）点斜线。
Dot slash mario.

2660
02:05:14,329 --> 02:05:14,829
好的。
All right.

2661
02:05:14,829 --> 02:05:17,799
我有点像这里有一个看起来像这个东西的网格。
I kind of sort of have a grid that looks like this thing here.

2662
02:05:17,800 --> 02:05:20,470
这不完全是，但至少是正确的主意。
It's not exactly, but at least it's the right idea.

2663
02:05:20,470 --> 02:05:23,170
但这不一定是最好的方法。
But this is not necessarily the best way to do this.

2664
02:05:23,170 --> 02:05:26,590
我真的很想跨三下三。
I really want to go three across and three down.

2665
02:05:26,590 --> 02:05:31,850
好吧，事实证明，使用C实际上我们也可以表达这一点。
Well, it turns out using C we can actually express that as well.

2666
02:05:31,850 --> 02:05:33,430
让我继续执行此操作。
Let me go ahead and do this.

2667
02:05:33,430 --> 02:05:38,050
让我继续进行打印，例如，以下内容。
Let me go ahead and print out for instance, the following.

2668
02:05:38,050 --> 02:05:41,380
让我继续打印并不仅仅是散列，散列，散列
Let me go ahead and print out not just hash, hash, hash, again

2669
02:05:41,380 --> 02:05:42,530
一遍又一遍。
and again and again.

2670
02:05:42,529 --> 02:05:43,809
让我继续执行此操作。
Let me go ahead and do this.

2671
02:05:43,810 --> 02:05:46,160
让我一次打印出一行。
Let me print out one row at a time.

2672
02:05:46,159 --> 02:05:49,837
因此，对于int来说，我得到零，我不到三，加上加号。
So for int i gets zero, i less than three, plus plus.

2673
02:05:49,837 --> 02:05:51,879
我尚不知道要做什么，但我知道
I don't know what I'm about to do yet, but I know

2674
02:05:51,880 --> 02:05:53,470
我要去做三遍。
that I'm going to do it three times.

2675
02:05:53,470 --> 02:05:54,845
我想做什么三遍？
What do I want to do three times?

2676
02:05:54,845 --> 02:05:58,480
好吧，我要三行，每行我要三个哈希。
Well, I want three rows, and on every row I want three hashes.

2677
02:05:58,479 --> 02:05:59,829
所以你知道你能做什么？
So you know what you can do?

2678
02:05:59,829 --> 02:06:01,209
你可以嵌套循环。
You can nest loops.

2679
02:06:01,210 --> 02:06:06,662
让我做一下，因为int j变为零，j小于3，并且j加号。
Let me do for int j gets zero, j is less than three, and j plus plus.

2680
02:06:06,662 --> 02:06:08,620
我不知道我要做什么，但是我知道
I don't know what I'm going to do yet, but I do

2681
02:06:08,619 --> 02:06:10,629
知道我要做三遍。
know I'm going to do this three times.

2682
02:06:10,630 --> 02:06:12,490
你也许可以看到前进的方向。
And you can perhaps see where this is going.

2683
02:06:12,489 --> 02:06:15,849
三件事三遍，这将给我全部九块砖头。
Three things three times, that's going to give me all nine bricks.

2684
02:06:15,850 --> 02:06:21,040
可以说，只要在这个内部循环的内部，这个嵌套循环，
So long as inside of this inner loop, so to speak, this nested loop,

2685
02:06:21,039 --> 02:06:22,839
我打印这些哈希值之一。
I print one of those hashes.

2686
02:06:22,840 --> 02:06:27,770
只要循环之后，我就在这里打印出新的一行。
So long as after that loop, I print out a new line over here.

2687
02:06:27,770 --> 02:06:30,700
因此，要明确一点，即使乍一看并不明显，这是什么
So to be clear, even if it's not obvious at first glance what's

2688
02:06:30,699 --> 02:06:35,379
继续，我们已经知道这是你用于执行语法的类型
going on, we already know that this is the type of syntax you use for doing

2689
02:06:35,380 --> 02:06:37,750
有限多次，三次。
something finitely many times, three.

2690
02:06:37,750 --> 02:06:40,520
这是相同的语法，但是我使用了不同的变量名。
This is the same syntax, but I'm using a different variable name.

2691
02:06:40,520 --> 02:06:42,460
因此，我可以跟踪两个不同的值。
So I can keep track of two different values.

2692
02:06:42,460 --> 02:06:45,543
本质上是行和列。
Essentially, rows and columns.

2693
02:06:45,542 --> 02:06:47,709
然后我每次只打印一块砖。
And then I'm just printing a single brick each time.

2694
02:06:47,710 --> 02:06:50,080
但是，当我完成整行打印后，我
But after I'm done printing a whole row, I

2695
02:06:50,079 --> 02:06:53,169
确实要将光标移动到新行。
do want to move the cursor to a new line.

2696
02:06:53,170 --> 02:06:54,230
因此，让我尝试一下。
So let me try this.

2697
02:06:54,229 --> 02:06:56,949
让我继续，并在代码上设置马里奥。
Let me go ahead and do make mario on my code.

2698
02:06:56,949 --> 02:06:59,679
点斜线马里奥和瞧。
Dot slash mario, and voila.

2699
02:06:59,680 --> 02:07:02,453
现在，我正在使用嵌套循环来打印出这样的积木。
Now I'm using a nested loop to print out bricks like this.

2700
02:07:02,453 --> 02:07:03,370
我可以改变这一点。
And I can change this.

2701
02:07:03,369 --> 02:07:06,969
如果我想以10乘10来做，那么我要做的就是将其更改为一个位置。
If I want to do a 10 by 10, all I have to do is change that in one place.

2702
02:07:06,970 --> 02:07:10,390
或者，如果我真的想花哨的话，可以再次使用get_int。
Or if I really wanted to be fancy, I could go use get_int again.

2703
02:07:10,390 --> 02:07:12,550
我可以从用户那里获得宽度和高度
I could get the width and the height from the user

2704
02:07:12,550 --> 02:07:14,110
并完全动态地进行
and do it completely dynamically.

2705
02:07:14,109 --> 02:07:18,691
但是现在，例如，如果我按10乘10进行，至少可以看到更大的网格。
But now if I do 10 by 10 for instance, I can at least see an even bigger grid.

2706
02:07:18,692 --> 02:07:21,400
因此，如果你想知道超级马里奥兄弟（Super Mario Brothers）还是坦率地说
So if you wonder how things like Super Mario Brothers, or frankly

2707
02:07:21,399 --> 02:07:25,449
如今可以在PC或游戏机或手机上制作任何游戏，
any game nowadays on a PC or console or phone are made,

2708
02:07:25,449 --> 02:07:27,399
就是这种类型的地图。
it's with this kind of generation of maps.

2709
02:07:27,399 --> 02:07:30,579
也许早在他们被硬编码的那一天，也许它们是生成的。
Maybe back in the day they were hard coded, maybe they were generated.

2710
02:07:30,579 --> 02:07:34,689
使用代码，你可以完全想象生成一个接一个的积木
Using code you can absolutely imagine generating brick after brick

2711
02:07:34,689 --> 02:07:39,069
像这样的积木，最终，甚至是你的游戏，甚至是你的世界，
after brick like that so that, ultimately, your game even, your world,

2712
02:07:39,069 --> 02:07:41,109
是部分动态生成的。
is partly dynamically generated.

2713
02:07:41,109 --> 02:07:44,769
而且我们已经有了构建的基础。
And we already have the building blocks via which to do that.

2714
02:07:44,770 --> 02:07:51,340
不幸的是，我们还没有真正谈到限制
Unfortunately, we haven't really spoken to the limitations

2715
02:07:51,340 --> 02:07:52,832
计算机可以做什么。
of what computers can do.

2716
02:07:52,832 --> 02:07:55,540
在最后几分钟，我们认为我们已经为事情做好了准备
And in our final minutes we thought we'd set the stage for things

2717
02:07:55,539 --> 02:07:57,339
电脑不是很擅长
that computers aren't very good at.

2718
02:07:57,340 --> 02:08:01,270
实际上，几乎所有方面都存在潜在的问题
And in fact, problems that are latent in pretty much everything

2719
02:08:01,270 --> 02:08:04,630
我们今天已经完成，但是我一直非常小心地避免绊倒。
we've done today, but I've been very carefully avoiding tripping over.

2720
02:08:04,630 --> 02:08:07,930
此图是典型计算机内存的图，
This picture here is a picture of a typical computer's memory,

2721
02:08:07,930 --> 02:08:09,477
或RAM，随机存取存储器。
or RAM, random access memory.

2722
02:08:09,476 --> 02:08:11,559
这只是你要使用的硬件之一
It's just one of the pieces of hardware that you'd

2723
02:08:11,560 --> 02:08:14,410
这些天，你的手机，台式机和笔记本电脑中都有。
have in your phone, your desktop, your laptop these days.

2724
02:08:14,409 --> 02:08:17,179
它是程序运行时的存储位置。
And it's where programs are stored when they're running.

2725
02:08:17,180 --> 02:08:19,630
因此，在Mac或PC中，如果双击某个程序
So in a Mac or PC, if you double click a program

2726
02:08:19,630 --> 02:08:22,570
它最终存储在看起来像这样的硬件中。
it's ultimately stored in a piece of hardware that looks like this.

2727
02:08:22,569 --> 02:08:25,929
当你在斜杠上加点斜杠并在像这样的程序中按Enter键时，
When you dot slash mario and hit Enter in a program like this,

2728
02:08:25,930 --> 02:08:29,830
你使用的是CS50 IDE的RAM，尽管有相同的想法，
you're using CS50 IDE's RAM, but same idea, albeit,

2729
02:08:29,829 --> 02:08:31,749
云中的其他地方。
somewhere else in the cloud.

2730
02:08:31,750 --> 02:08:36,110
因此，事实证明，如果你只有有限的内存，
So it turns out, though, that if you only have a finite amount of memory,

2731
02:08:36,109 --> 02:08:39,199
这样，你只能做很多事情。
like this, you can only do so much with it.

2732
02:08:39,199 --> 02:08:41,589
你无法解决世界上所有的问题
You can't solve all of the world's problems

2733
02:08:41,590 --> 02:08:43,900
如果你只有有限的内存。
if you only have a finite amount of memory.

2734
02:08:43,899 --> 02:08:45,769
那我是什么意思呢？
And what do I mean by that?

2735
02:08:45,770 --> 02:08:51,130
好吧，让我继续在这里创建另一个名为imprecision.c的程序，
Well, let me go ahead and create another program here called imprecision.c,

2736
02:08:51,130 --> 02:08:53,470
我们马上就会知道为什么要如此命名。
and we'll see why I've named it that in just a moment.

2737
02:08:53,470 --> 02:08:57,220
让我继续并再次包含stdio.h和int main void
Let me go ahead and include stdio.h, again, and int main void just

2738
02:08:57,220 --> 02:08:58,990
给自己一些设置。
to give myself some set up here.

2739
02:08:58,989 --> 02:09:01,089
然后让我继续，非常合理地
And then let me go ahead and very reasonably very

2740
02:09:01,090 --> 02:09:05,290
只需向用户询问一个名为x的变量（作为类型float）即可。
simply ask the user for a variable called x as a type float.

2741
02:09:05,289 --> 02:09:07,629
让我像以前一样要求值。
Let me ask for the value just like before.

2742
02:09:07,630 --> 02:09:11,557
让我以y的形式要求另一个，请用引号引起来的“ y”。
Let me ask for another one in the form of y, quote unquote "y."

2743
02:09:11,556 --> 02:09:13,389
然后让我继续前进，你知道吗？
And then let me go ahead, and you know what?

2744
02:09:13,390 --> 02:09:19,085
让我继续，用百分比f打印x的值除以y。
Let me go ahead and print out with percent f the value of x divided by y.

2745
02:09:19,085 --> 02:09:20,710
因此，我很确定我们之前已经这样做了。
So I'm pretty sure we did this earlier.

2746
02:09:20,710 --> 02:09:22,690
我们按照价值观进行了划分。
We did division with values.

2747
02:09:22,689 --> 02:09:25,689
这次我正在使用浮点数，但让我们继续进行一下。
This time I'm using floats, but let's go ahead and just run this.

2748
02:09:25,689 --> 02:09:28,959
不精确-我在这里烦死了。
Make imprecision-- and I goofed here.

2749
02:09:28,960 --> 02:09:32,710
隐式-我一直在做-函数get_float的隐式声明。
Implicit-- I keep doing it-- implicit declaration of function get_float.

2750
02:09:32,710 --> 02:09:34,750
我没有练习我一直在讲的东西。
I didn't practice what I've been preaching.

2751
02:09:34,750 --> 02:09:39,700
我还需要包含cs50.h，这是它定义了get_float的地方。
I also need to include cs50.h, which is where it get_float is defined.

2752
02:09:39,699 --> 02:09:40,899
现在，让我重新编译。
Now, let me recompile.

2753
02:09:40,899 --> 02:09:41,889
现在可以了。
Now it works.

2754
02:09:41,890 --> 02:09:43,900
现在，让我继续不精确。
Now, let me go ahead and run imprecision.

2755
02:09:43,899 --> 02:09:47,319
让我继续输入十分之一。
And let me go ahead and type in one tenth.

2756
02:09:47,319 --> 02:09:47,979
好的。
OK.

2757
02:09:47,979 --> 02:09:51,549
因此，根据我这里非常简单的计算器，结果只有十分之一，
So one tenth it turns out, according to my very simple calculator here,

2758
02:09:51,550 --> 02:09:54,928
是0.100000。
is 0.100000.

2759
02:09:54,927 --> 02:09:56,469
但是我现在有点好奇了。
But I'm getting a little curious now.

2760
02:09:56,470 --> 02:09:59,920
事实证明，printf的功能比我们所见过的还要强大，
It turns out that printf is even more powerful than we've seen,

2761
02:09:59,920 --> 02:10:02,650
而且你实际上可以打印出多个位数。
and you can actually print out more than just single digits.

2762
02:10:02,649 --> 02:10:08,079
假设我要打印的不是六个有效数字，而是十个。
Suppose I want to print out not six significant digits, but maybe 10.

2763
02:10:08,079 --> 02:10:11,349
语法有点时髦，但是与其说百分比f，
It's a little funky the syntax, but instead of saying percent f,

2764
02:10:11,350 --> 02:10:15,550
你可以改写字面意义，用百分号表示数字
you can instead say literally, percent dot the number of digits

2765
02:10:15,550 --> 02:10:17,830
你想看然后按f。
you want to see and then the f.

2766
02:10:17,829 --> 02:10:21,669
因此，让我继续进行重新编译，使其变得不精确。
So let me go ahead and recompile this, make imprecision.

2767
02:10:21,670 --> 02:10:25,225
现在让我做点斜线的不精确度和十分之一
Now let me do dot slash imprecision and one tenth--

2768
02:10:25,225 --> 02:10:26,980
嗯。
uh-huh.

2769
02:10:26,979 --> 02:10:28,869
好吧，这有点好奇。
Well, that's a little curious.

2770
02:10:28,869 --> 02:10:32,919
我不记得知道十分之一的末尾有15。
I don't recall knowing that there's a 15 at the end of one tenth.

2771
02:10:32,920 --> 02:10:34,630
好吧，让我们再好奇一点。
Well, let's get a little more curious.

2772
02:10:34,630 --> 02:10:38,570
让我们打印出50个小数点，以真正了解这里的情况。
Let's print out 50 decimal points to really dig into what's going on here.

2773
02:10:38,569 --> 02:10:40,309
让我重新编译我的代码。
Let me recompile my code.

2774
02:10:40,310 --> 02:10:44,350
让我重新运行点斜线的不精确度，然后将其除以十，
And let me rerun dot slash imprecision and do one divided by ten,

2775
02:10:44,350 --> 02:10:45,610
哦，天哪。
and oh my God.

2776
02:10:45,609 --> 02:10:49,149
我很确定在小学时，我们都学过一除以十，
I am quite sure in grade school when we all learned one divided by ten,

2777
02:10:49,149 --> 02:10:52,119
老师确实告诉我们十分之一或0.1。
the teacher did tell us one tenth or 0.1.

2778
02:10:52,119 --> 02:11:00,049
他们从未提到过它是0.10000000149011的事实，依此类推。
And they never mentioned the fact that it's 0.10000000149011, and so forth.

2779
02:11:00,050 --> 02:11:01,300
那么发生了什么？
So what is going on?

2780
02:11:01,300 --> 02:11:03,940
好吧，事实证明它和计算机一样强大
Well, it turns out as powerful as computers

2781
02:11:03,939 --> 02:11:08,319
与我们今天一直在研究的所有语法一样，并且也是如此复杂
are and is as sophisticated as all of the syntax we've been looking at today

2782
02:11:08,319 --> 02:11:13,219
是的，我的天哪，一台计算机甚至无法正确计算十分之一。
is, my God, a computer can't even calculate one tenth correctly.

2783
02:11:13,220 --> 02:11:15,950
因此，我们在这里遇到了一个基本限制，
And so we're bumping up against a fundamental limitation here,

2784
02:11:15,949 --> 02:11:18,939
也就是说，如果计算机的容量有限。
which is that if computers are finite in their capacity.

2785
02:11:18,939 --> 02:11:23,319
他们只有这么多的RAM，那么多的硬件，那么多的位。
They only have so much RAM, so much hardware, so many bits.

2786
02:11:23,319 --> 02:11:27,249
好吧，这是有原因的，如果你只使用有限数量的位，
Well, it stands to reason that if you only are using a finite number of bits,

2787
02:11:27,250 --> 02:11:29,709
例如32或64。
32 for instance, or 64.

2788
02:11:29,710 --> 02:11:33,520
是的，你可以算得很高或很精确。
Yes, you can count pretty high or pretty precisely.

2789
02:11:33,520 --> 02:11:37,810
你不能无限地计数或无限精确地计数。
You cannot count infinitely high or infinitely precisely.

2790
02:11:37,810 --> 02:11:40,903
在某些时候，你必须开始近似值。
At some point you have to start to approximate values.

2791
02:11:40,903 --> 02:11:42,820
确实，这就是计算机的功能。
And indeed, that's what the computer is doing.

2792
02:11:42,819 --> 02:11:47,769
如果它只有有限数量的位，则32代表一个浮点数。
If it only has a finite number of bits, 32, via which to represent a float.

2793
02:11:47,770 --> 02:11:52,215
世界上有无数个浮点实数。
There's an infinite number of floating point real numbers in the world.

2794
02:11:52,215 --> 02:11:54,340
不幸的是，如果你的位数有限，
Unfortunately, if you have a finite number of bits,

2795
02:11:54,340 --> 02:11:55,900
你必须开始偷工减料。
you've got to start cutting some corners.

2796
02:11:55,899 --> 02:11:57,482
这就是计算机正在执行的操作。
And that's what the computer is doing.

2797
02:11:57,483 --> 02:12:01,030
它代表了尽可能近的十分之一，
It's representing one tenth as closely as it can,

2798
02:12:01,029 --> 02:12:04,209
这就是当你看到足够多的有效数字时所看到的。
and this is what you then see when you look enough significant digits out.

2799
02:12:04,210 --> 02:12:07,820
现在，对于大多数问题而言，这可能并不重要。
Now, for most problems that's probably not a big deal.

2800
02:12:07,819 --> 02:12:10,449
但是如果你在做数学的话，那将是非常大的事情，
But it could very well be a big deal if you're doing math,

2801
02:12:10,449 --> 02:12:14,649
你正在处理金融或货币价值或军事行动
you're dealing with finance or monetary values or military operations

2802
02:12:14,649 --> 02:12:18,429
从科学上讲，很多小数开始真正加起来。
where a lot of small numbers, scientifically, really start to add up.

2803
02:12:18,430 --> 02:12:20,950
实际上，在现实世界中有很多例子
And indeed, there have been many examples in the real world

2804
02:12:20,949 --> 02:12:24,969
由于这种所谓的不精确而在坏事发生的地方。
where bad things happen because of this so-called imprecision.

2805
02:12:24,970 --> 02:12:27,430
而且，计算机还会遇到另一个问题。
And there's another issue that computers run into.

2806
02:12:27,430 --> 02:12:30,940
不仅这种浮点数不精确，甚至整数
Not only this floating point imprecision, even integers

2807
02:12:30,939 --> 02:12:32,529
有其局限性。
have their limitations.

2808
02:12:32,529 --> 02:12:36,819
回想一下，整数当然可以用十进制或二进制表示。
Recall that integers, of course, can be represented in decimal or in binary.

2809
02:12:36,819 --> 02:12:38,829
如果我们有三个灯泡或三个位，
And if we have three light bulbs or three bits,

2810
02:12:38,829 --> 02:12:41,259
让我们考虑如何计算二进制数。
let's consider how we might count in binary.

2811
02:12:41,260 --> 02:12:43,630
零，零，零是我们上周开始的地方。
Zero, zero, zero is where we began last week.

2812
02:12:43,630 --> 02:12:50,060
001、010、011、100、101、110、111。
001, 010, 011, 100, 101, 110, 111.

2813
02:12:50,060 --> 02:12:54,860
现在，上周的召回事件是我们知道的十进制数字7。
And now, this recall from last week is the number we know is seven in decimal.

2814
02:12:54,859 --> 02:12:57,409
我如何算高一位数？
How do I count one digit higher?

2815
02:12:57,409 --> 02:12:59,779
好吧，我可以随身携带一个。
Well, I just carry the one, so to speak.

2816
02:12:59,779 --> 02:13:04,429
但是，如果我只有三个灯泡，或者只有三个灯泡，或者是32位，那么。
But if I only have three light bulbs or in turn three bits, or heck, 32 bits.

2817
02:13:04,430 --> 02:13:08,390
那个额外的进位消失了。
That additional bit, the carry, disappears.

2818
02:13:08,390 --> 02:13:10,820
因此，整数也存在这个问题。
And so there's this problem with integers too.

2819
02:13:10,819 --> 02:13:15,979
有人指出，当你尝试做20亿加20亿时，
And someone noted earlier when you tried to do 2 billion plus 2 billion,

2820
02:13:15,979 --> 02:13:19,039
它不适合结果。那是因为整数
it couldn't fit in the result. That's because integers

2821
02:13:19,039 --> 02:13:24,409
如果它们只有32位或较长的C语言，也是如此。如果只有64位，则它们很大
too if they're only 32 bits or a long in C. If it's only 64 bits, those are big

2822
02:13:24,409 --> 02:13:26,989
数字，但它们不是无限大的。
numbers, but they're not infinitely large.

2823
02:13:26,989 --> 02:13:29,799
我们人类一次又一次地绊倒了。
And we humans have tripped over this again and again.

2824
02:13:29,800 --> 02:13:33,890
你可能会回想起有关是否不能度过Y2K问题的消息。
You might recall hearing about if not living through the Y2K problem.

2825
02:13:33,890 --> 02:13:36,710
世界上有很多东西破裂或曾经在那里
Where a lot of stuff in the world broke or was

2826
02:13:36,710 --> 02:13:40,520
担心在2000年1月1日被打破，因为人类
worried to be broken on January 1st, 2000, because humans

2827
02:13:40,520 --> 02:13:43,790
做出了合理但又不是很长远的眼光
had made the reasonable but not very long sighted

2828
02:13:43,789 --> 02:13:46,699
决定仅使用两位数字存储年份。
decision to store years using just two digits.

2829
02:13:46,699 --> 02:13:52,459
因此1995将代表95、96、97、98、99。
So 1995 would be represented as 95, 96, 97, 98, 99.

2830
02:13:52,460 --> 02:13:56,310
然后是从1999年到2000年的变化，
Then around the change of the year from 1999 to 2000,

2831
02:13:56,310 --> 02:14:00,170
任何仍在使用两位数的计算机程序或系统
any computer program or system that was still using two digits

2832
02:14:00,170 --> 02:14:02,810
当然会在午夜时分加一。
would, of course, add one at the stroke of midnight.

2833
02:14:02,810 --> 02:14:07,370
不幸的是，如果没有可用的第三位数字，它将消失。
Unfortunately, if there's no third digit available it disappears.

2834
02:14:07,369 --> 02:14:12,559
全世界都把2000年和1900年搞混了，
And the entire world confuses the year 2000 for the year 1900,

2835
02:14:12,560 --> 02:14:16,820
因为假定1900为前缀。
because 1900 was assumed as being the prefix.

2836
02:14:16,819 --> 02:14:20,899
如果你可以相信，我们人类将再次这样做
And if you can believe it, we humans are about to do this again

2837
02:14:20,899 --> 02:14:25,349
在2038年，离现在不远了。
in the year 2038, which is not that far off from now.

2838
02:14:25,350 --> 02:14:30,950
我们将用完一些时间来跟踪时间。
We are going to run out of bits via which to keep track of time.

2839
02:14:30,949 --> 02:14:34,219
因为几年前，人类当时做出了合理的决定，
Because years ago, humans decided reasonably at the time,

2840
02:14:34,220 --> 02:14:37,440
他们将使用32位代表数字。
they are going to use 32 bits to represent numbers.

2841
02:14:37,439 --> 02:14:42,109
我们将使用32位来计算秒数
And we are going to use 32 bits to count up the number of seconds

2842
02:14:42,109 --> 02:14:46,519
从年份开始，即1970年1月1日。
from the year a date, January 1st, 1970.

2843
02:14:46,520 --> 02:14:49,500
所以从某种意义上讲，那是时间开始明智地进行计算的时候，
So that's when time began computing wise, in some sense,

2844
02:14:49,500 --> 02:14:51,529
从那时起，我们一直在数秒。
and we've been counting the seconds ever since.

2845
02:14:51,529 --> 02:14:55,489
不幸的是，使用32位，你只能算到40亿
Unfortunately, with 32 bits you can only count as high as 4 billion

2846
02:14:55,489 --> 02:14:56,419
给予或接受。
give or take.

2847
02:14:56,420 --> 02:15:02,210
不幸的是，我们将在1月19日达到40亿秒
And unfortunately, we are going to hit the four billionth second on January 19

2848
02:15:02,210 --> 02:15:03,800
在2038年。
in the year 2038.

2849
02:15:03,800 --> 02:15:07,010
因此，除非我们所有人都升级Mac和PCS，否则，
So unless all of us upgrade our Macs and PCS, and worse,

2850
02:15:07,010 --> 02:15:12,320
嵌入式系统和卫星以及烘焙到各种设备中的任何硬件
embedded systems and satellites and any hardware baked into various devices

2851
02:15:12,319 --> 02:15:14,659
我们现在使用的，我们将要遇到这个问题
that we now use, we're about to run into this problem

2852
02:15:14,659 --> 02:15:19,219
又是突然之间，就像1970年1月1日
again where all of a sudden and it's going to be like January 1st, 1970

2853
02:15:19,220 --> 02:15:19,910
再次。
again.

2854
02:15:19,909 --> 02:15:22,049
除非我们继续解决这个问题。
Unless we stay ahead of this problem.

2855
02:15:22,050 --> 02:15:25,333
因此，借助我们在C语言中看到的所有功能以及所有功能，
So with all the power we've seen in C and all of the capabilities

2856
02:15:25,332 --> 02:15:27,499
我们已经在C和Scratch中看到了
that we've seen in C and in Scratch, there are still

2857
02:15:27,500 --> 02:15:28,800
这些基本限制。
these fundamental limitations.

2858
02:15:28,800 --> 02:15:32,575
因此，在解决你自己的C问题以及CS50问题时，
So when it comes to solving your own problems in C and in turn CS50,

2859
02:15:32,574 --> 02:15:35,449
牢记这些限制将变得非常重要
it's going to be ever so important to be mindful of these constraints

2860
02:15:35,449 --> 02:15:38,599
并最终为这些问题找到解决方案。
and to, ultimately, find solutions even to these problems.

2861
02:15:38,600 --> 02:15:41,330
但是现在，我们将在这里休会，离开你
But for now, we'll adjourn here, and leave you

2862
02:15:41,329 --> 02:15:44,869
针对你在Mario C上的第一个问题以及更多内容。
for your first problem set in C on Mario and more.

2863
02:15:44,869 --> 02:15:47,299
下次见。
We'll see you next time.

2864
02:15:47,300 --> 02:15:50,650
[音乐播放]
[MUSIC PLAYING]

