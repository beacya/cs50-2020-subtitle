1
00:00:00,000 --> 00:00:03,492
[音乐响起--字幕精校中--By Persisan]
[MUSIC PLAYING]

2
00:00:49,420 --> 00:00:51,760
DAVID MALAN：好的，这是CS50。
DAVID MALAN: All right, so this is CS50.

3
00:00:51,759 --> 00:00:55,449
这是第二周，我们将更深入地探讨
And this is week 2, wherein we're going to dive in a little more deeply

4
00:00:55,450 --> 00:00:56,720
来看看这种新语言。
to see this new language.

5
00:00:56,719 --> 00:00:58,719
我们还将回顾一些
And we're also going to take a look back at some

6
00:00:58,719 --> 00:01:02,349
上周我们研究的一些概念，以便您可以更好地了解一些
of the concepts we looked at last week so that you can better understand some

7
00:01:02,350 --> 00:01:04,750
C的功能和一些步骤
of the features of C and some of the steps

8
00:01:04,750 --> 00:01:06,830
您一直在努力使您的代码正常工作。
you've been taking to make your code work.

9
00:01:06,829 --> 00:01:09,879
因此，我们将从上周剥离一些抽象层
So we'll peel back some of the layers of abstraction from last week

10
00:01:09,879 --> 00:01:11,949
以便您更好地了解实际情况
so that you better understand really what's going

11
00:01:11,950 --> 00:01:14,540
在计算机机壳下面。
on underneath the hood of the computer.

12
00:01:14,540 --> 00:01:18,907
因此，当然，上周，我们开始了也许是最经典的程序
So, of course, last week, we began with perhaps the most canonical of programs

13
00:01:18,906 --> 00:01:20,739
在C语言中，您可以使用的最规范的程序
in C, the most canonical of programs you can

14
00:01:20,739 --> 00:01:23,139
几乎可以用任何一种语言写
write pretty much in any language, which is that which

15
00:01:23,140 --> 00:01:25,030
简单地说，“您好，世界”。
says, quite simply, "hello, world."

16
00:01:25,030 --> 00:01:28,600
但是请记住，在实际运行该程序之前，
But recall that before actually running this program,

17
00:01:28,599 --> 00:01:31,599
我们必须将其转换为计算机本身所说的语言，
we have to convert it into the language that computers themselves speak,

18
00:01:31,599 --> 00:01:35,079
我们上周将其定义为二进制，0和1，否则称为
which we defined last week as binary, 0's and 1's, otherwise known

19
00:01:35,079 --> 00:01:37,639
在这种情况下作为机器语言。
as machine language in this context.

20
00:01:37,640 --> 00:01:40,120
所以我们必须以某种方式从源代码转变为某种东西
So we have to go somehow from this source code to something

21
00:01:40,120 --> 00:01:44,380
更像是这样的机器代码，计算机实际上是0和1
more like this machine code, the 0's and 1's that the computer actually

22
00:01:44,379 --> 00:01:45,249
了解。
understands.

23
00:01:45,250 --> 00:01:48,160
现在，您可能还记得我们为此引入了一个命令。
Now, you may recall too that we introduced a command for this.

24
00:01:48,159 --> 00:01:49,839
该命令称为make。
And that command was called make.

25
00:01:49,840 --> 00:01:53,770
实际上，通过此命令“ make hello”，我们可以编写一个程序吗？
And literally via this command, "make hello," could we make a program

26
00:01:53,769 --> 00:01:54,489
打个招呼。
called hello.

27
00:01:54,489 --> 00:01:55,839
而且make有点花哨。
And make was a little fancy.

28
00:01:55,840 --> 00:01:59,140
它假定如果您要编写一个名为hello的程序，
It assumed that if you want to make a program called hello,

29
00:01:59,140 --> 00:02:01,720
它将查找名为hello.c的文件。
it would look for a file called hello.c.

30
00:02:01,719 --> 00:02:03,849
这只是为您自动发生的。
That just happens automatically for you.

31
00:02:03,849 --> 00:02:07,239
当然，最终结果是一个名为hello的附加文件。
And the end result, of course, was an additional file called hello

32
00:02:07,239 --> 00:02:11,389
最终将其放入您的当前目录。
that would end up getting put into your current directory.

33
00:02:11,389 --> 00:02:14,359
这样，您就可以执行./hello并随心所欲了。
So you could then do ./hello and be on your way.

34
00:02:14,360 --> 00:02:17,620
但是事实证明，make实际上是自动化的
But it turns out that make is actually automating

35
00:02:17,620 --> 00:02:20,650
为我们准备的一组更具体的步骤
a more specific set of steps for us that we'll

36
00:02:20,650 --> 00:02:22,510
现在可以更仔细地查看。
see a little more closely now instead.

37
00:02:22,509 --> 00:02:24,639
所以在屏幕上，这是完全相同的代码
So on the screen here is exactly the same code

38
00:02:24,639 --> 00:02:27,369
我们上周写的，很简单地说，“你好，世界”。
that we wrote last week to say, quite simply, "hello, world."

39
00:02:27,370 --> 00:02:31,810
回想一下，任何时候您运行“ make hello”或“ make mario”
And recall that any time you run "make hello" or "make mario"

40
00:02:31,810 --> 00:02:34,120
或“赚钱”或“赚钱”中的任何问题
or "make cash" or "make credit," any of the problems

41
00:02:34,120 --> 00:02:35,890
您可能最近才解决过，
that you might have tackled more recently,

42
00:02:35,889 --> 00:02:38,259
您会在屏幕上看到一些神秘的输出。
you see some cryptic output on the screen.

43
00:02:38,259 --> 00:02:42,039
希望没有红色或黄色错误消息，但即使一切正常，
Hopefully, no red or yellow error messages, but even when all is well,

44
00:02:42,039 --> 00:02:45,769
您会看到白色的文字，表示一切都很好。
you see this white text which is indicative of all having been well.

45
00:02:45,770 --> 00:02:49,240
上周，我们只是忽略了这一点，继续前进，并立即做了
And last week, we just kind of ignored this and moved on and immediately did

46
00:02:49,240 --> 00:02:51,400
诸如./hello之类的东西。
something like ./hello.

47
00:02:51,400 --> 00:02:53,528
但是今天，让我们更好地了解
But today, let's actually better understand

48
00:02:53,527 --> 00:02:55,569
我们一直视而不见的是什么
what it is that we've been turning a blind eye to

49
00:02:55,569 --> 00:03:00,819
这样，随着时间的流逝，每个星期都有越来越少的您不了解的东西
so that each week, as it passes, there's less and less that you don't understand

50
00:03:00,819 --> 00:03:04,219
关于屏幕上显示的内容的全部信息。
the entirety of with respect to what's going on your screen.

51
00:03:04,219 --> 00:03:08,019
再说一次，如果我在这里执行ls，我们不仅会看到hello.c，还会看到
So again, if I do ls here, we'll see not only hello.c, but also

52
00:03:08,020 --> 00:03:12,910
我实际上是通过make创建的名为hello的可执行程序。
the executable program called hello that I actually created via make.

53
00:03:12,909 --> 00:03:14,449
但是看看这个输出。
But look at this output.

54
00:03:14,449 --> 00:03:16,929
这里提到了一些叫Clang的东西。
There's some mention of something called Clang here.

55
00:03:16,930 --> 00:03:21,730
然后还有很多其他单词或神秘短语，在计算机中
And then there's a lot of other words or cryptic phrases, something in computer

56
00:03:21,729 --> 00:03:24,499
在这里说，所有这些连字符都摆在前面。
speak here that has all of these hyphens in front of them.

57
00:03:24,500 --> 00:03:26,770
事实证明，make在为我们做些什么
And it turns out that what make is doing for us

58
00:03:26,770 --> 00:03:31,870
是自动执行更具体地称为clang的命令。
is it's automating execution of a command more specifically called clang.

59
00:03:31,870 --> 00:03:35,860
Clang实际上是我们上周提到的编译器，一个编译器
Clang is actually the compiler that we alluded to last week, a compiler

60
00:03:35,860 --> 00:03:39,010
是将源代码转换为机器代码的程序。
being a program that converts source code to machine code.

61
00:03:39,009 --> 00:03:41,589
实际上，我们一直以来都在使用Clang。
We've actually been using Clang this whole time.

62
00:03:41,590 --> 00:03:44,860
但是请注意，Clang需要更多的技巧。
But notice that Clang requires a bit more sophistication.

63
00:03:44,860 --> 00:03:48,200
为了使用它，您必须进一步了解正在发生的事情。
You have to understand a bit more about what's going on in order to use it.

64
00:03:48,199 --> 00:03:51,189
因此，让我继续删除名为hello的程序。
So let me go ahead and remove the program called hello.

65
00:03:51,189 --> 00:03:54,159
我将使用上次简短看到的rm命令。
I'm going to use the rm command that we saw briefly last time.

66
00:03:54,159 --> 00:03:55,899
我将通过点击y进行确认。
I'm going to confirm by hitting y.

67
00:03:55,900 --> 00:04:00,010
而且，如果我现在再次输入ls，则hello.c是剩下的唯一文件。
And if I type ls again now, hello.c is the only file that remains.

68
00:04:00,009 --> 00:04:04,599
好吧，暂时，让我取消使用make的能力。
Well, temporarily, let me take away the ability to use make.

69
00:04:04,599 --> 00:04:06,999
现在让我们直接使用Clang。
And let's now use Clang directly.

70
00:04:07,000 --> 00:04:10,209
Clang是CS50 IDE中安装的另一个程序。
Clang is another program installed in CS50 IDE.

71
00:04:10,210 --> 00:04:13,540
这是一个非常流行的编译器，您可以将其下载到自己的Mac和PC上
It's a very popular compiler that you can download onto your own Macs and PCs

72
00:04:13,539 --> 00:04:14,319
也一样
as well.

73
00:04:14,319 --> 00:04:16,549
但是运行它有点不同。
But to run it is a little different.

74
00:04:16,550 --> 00:04:19,930
我要继续说clang然后是文件名
I'm going to go ahead and say clang and then the name of the file

75
00:04:19,930 --> 00:04:23,380
我要编译的东西，hello.c是这个。
that I want to compile, hello.c being this one.

76
00:04:23,379 --> 00:04:24,969
我要继续并按Enter。
I'm going to go ahead and hit Enter.

77
00:04:24,970 --> 00:04:27,340
现在看来，什么也没有发生。
And now nothing happens, seemingly.

78
00:04:27,339 --> 00:04:29,409
但坦率地说，正如您可能已经收集到的一样，
But frankly, as you've probably gleaned already,

79
00:04:29,410 --> 00:04:31,698
当似乎没有坏事发生时，那隐含地
when nothing bad seems to happen, that implicitly

80
00:04:31,697 --> 00:04:33,489
往往意味着好事发生了。
tends to mean that something good happened.

81
00:04:33,490 --> 00:04:35,710
您的程序已成功编译。
Your program compiled successfully.

82
00:04:35,709 --> 00:04:39,789
但奇怪的是，如果我现在输入ls，您将看不到该程序，您好。
But curiously, if I type ls now, you don't see the program, hello.

83
00:04:39,790 --> 00:04:42,700
您会看到这个奇怪的文件名，称为a.out。
You see this weird file name called a.out.

84
00:04:42,699 --> 00:04:44,619
这实际上是历史遗留物。
And this is actually a historical remnant.

85
00:04:44,620 --> 00:04:48,220
几年前，当人们使用编译器来编译代码时，
Years ago, when humans would use a compiler to compile their code,

86
00:04:48,220 --> 00:04:51,520
每个程序都被赋予的默认文件名
the default file name that every program was given

87
00:04:51,519 --> 00:04:54,459
是输出汇编输出。
was a.out for assembly output.

88
00:04:54,459 --> 00:04:55,669
稍后再进行更多说明。
More on that in a moment.

89
00:04:55,670 --> 00:04:57,670
但这对于程序来说是一个愚蠢的名字。
But this is kind of a stupid name for a program.

90
00:04:57,670 --> 00:04:59,590
它根本不能描述其功能。
It's not at all descriptive of what it does.

91
00:04:59,589 --> 00:05:05,139
因此事实证明，可以在命令行中配置Clang之类的程序。
So it turns out that programs like Clang can be configured at the command line.

92
00:05:05,139 --> 00:05:08,139
命令行再次指的是闪烁的提示，您可以在其中
The command line, again, refers to the blinking prompt where you can

93
00:05:08,139 --> 00:05:09,279
键入命令。
type commands.

94
00:05:09,279 --> 00:05:14,199
所以的确，我现在要继续删除该文件-rm space a.out，
So indeed, I'm going to go ahead and remove this file now-- rm space a.out,

95
00:05:14,199 --> 00:05:15,549
然后用y确认。
and then confirm with y.

96
00:05:15,550 --> 00:05:18,520
现在，我回到了从hello.c开始的地方。
And now I'm back to where I began with just hello.c.

97
00:05:18,519 --> 00:05:21,139
现在让我继续做一些不同的事情。
And let me go ahead now and do something a little different.

98
00:05:21,139 --> 00:05:27,699
我将执行“ clang -o hello”，然后执行“ hello.c”一词。
I'm going to do "clang -o hello" and then the word "hello.c."

99
00:05:27,699 --> 00:05:29,949
而我在这里所做的实际上是提供
And what I'm doing here is actually providing

100
00:05:29,949 --> 00:05:33,079
我们将要开始调用命令行参数的内容。
what we're going to start calling a command-line argument.

101
00:05:33,079 --> 00:05:37,329
因此，有时这些命令（例如make和rm）
So these commands, like make and rm, sometimes

102
00:05:37,329 --> 00:05:39,459
可以自己全部运行。
can just be run all by themselves.

103
00:05:39,459 --> 00:05:41,499
您只需键入一个单词，然后按Enter。
You just type a single word and hit Enter.

104
00:05:41,500 --> 00:05:44,979
但是，我们经常看到他们在某种意义上接受了投入。
But very often, we've seen that they take inputs in some sense.

105
00:05:44,980 --> 00:05:46,660
您键入“打个招呼”。
You type, "make hello."

106
00:05:46,660 --> 00:05:48,870
您键入“ rm hello”。
You type, "rm hello."

107
00:05:48,870 --> 00:05:51,030
在这种情况下，第二个单词“你好”
And the second word, "hello," in those cases,

108
00:05:51,029 --> 00:05:53,909
是命令的一种输入，否则
is kind of an input to the command, otherwise

109
00:05:53,910 --> 00:05:56,980
现在称为命令行参数。
now known as a command-line argument.

110
00:05:56,980 --> 00:05:58,480
这是命令的输入。
It's an input to the command.

111
00:05:58,480 --> 00:06:01,710
因此，在这里，我们有更多的命令行参数。
So here, we have more command-line arguments.

112
00:06:01,709 --> 00:06:06,299
我们有“ clang”一词，这是我们将要运行的编译器“ -o”
We've got the word "clang," which is the compiler we're about to run, "-o,"

113
00:06:06,300 --> 00:06:09,230
原来是“输出”的简写形式，
which it turns out is shorthand notation for "output,"

114
00:06:09,230 --> 00:06:10,875
因此，请输出以下内容。
so please output the following.

115
00:06:10,875 --> 00:06:12,000
您要输出什么？
What do you want to output?

116
00:06:12,000 --> 00:06:13,830
好吧，下一个词是“你好”。
Well, the next word is "hello."

117
00:06:13,829 --> 00:06:16,209
然后最后一个词是“ hello.c”。
And then the final word is "hello.c."

118
00:06:16,209 --> 00:06:19,529
长话短说，这个命令现在更加冗长
So long story short, this command now more verbose

119
00:06:19,529 --> 00:06:24,209
就是说，运行Clang，输出一个名为hello的文件，
though it is, is saying, run Clang, output a file called hello,

120
00:06:24,209 --> 00:06:27,019
并将其作为输入文件hello.c。
and take as input file called hello.c.

121
00:06:27,019 --> 00:06:30,269
因此，当我按Enter键后运行此命令时，似乎什么也没有发生。
So when I run this command after hitting Enter, nothing again seems to happen.

122
00:06:30,269 --> 00:06:34,559
但是，如果键入ls，则看不到a.out的默认默认文件名。
But if I type ls, I don't see that stupid default file name of a.out.

123
00:06:34,560 --> 00:06:37,590
现在我看到了文件名，你好。
Now I see the file name, hello.

124
00:06:37,589 --> 00:06:41,309
因此，这就是Clang最终如何帮助我编译代码的方式。
So this is how ultimately Clang is helping me compile my code.

125
00:06:41,310 --> 00:06:43,770
这是所有这些过程的自动化。
It's kind of automating all of those processes.

126
00:06:43,769 --> 00:06:48,209
但是请记住，这不是我们上周运行的唯一程序类型
But recall that that's not the only type of program we ran last week

127
00:06:48,209 --> 00:06:49,289
或上周写过。
or wrote last week.

128
00:06:49,290 --> 00:06:52,425
我们宁愿采用这样的代码并开始对其进行增强
We rather took code like this and began to enhance it

129
00:06:52,425 --> 00:06:53,550
还有一些额外的行。
with some additional lines.

130
00:06:53,550 --> 00:06:56,040
因此，《 Hello，World》的第2版实际上涉及
So version 2 of Hello, World actually involved

131
00:06:56,040 --> 00:06:59,730
使用CS50的get_string函数提示用户输入，
prompting the user for input using CS50's get_string function,

132
00:06:59,730 --> 00:07:02,940
将输出存储在名为name的变量中。
storing the output in a variable called name.

133
00:07:02,939 --> 00:07:07,027
但是请记住，我们还必须在文件顶部添加cs50.h。
But recall that we also had to add cs50.h at the top of the file.

134
00:07:07,028 --> 00:07:08,320
因此，让我继续执行该操作。
So let me go ahead and do that.

135
00:07:08,319 --> 00:07:12,059
我继续删除您好，因为这是旧版本。
Let me go ahead and remove hello because that's now the old version.

136
00:07:12,060 --> 00:07:18,510
现在让我进入，开始在此处更新代码，并进入我的hello.c文件，
Let me go in now and start updating my code here and go into my hello.c file,

137
00:07:18,509 --> 00:07:23,009
包括cs50.h，现在给我自己一个名为name的字符串，
include cs50.h, now get myself a string called name,

138
00:07:23,009 --> 00:07:25,889
但是我们可以调用它，调用函数get_string，
but we could call it anything, call the function get_string,

139
00:07:25,889 --> 00:07:30,989
并问“您叫什么名字”，问号末尾有一个空格
and ask, "What's your name," question mark with a space at the very end

140
00:07:30,990 --> 00:07:32,340
只是造成差距。
just to create a gap.

141
00:07:32,339 --> 00:07:36,089
然后在这里，而不是总是打印出“ hello world”，
And then down here, instead of printing out "hello, world" always,

142
00:07:36,089 --> 00:07:40,109
让我打印出“你好，％s”，这是一个占位符，
let me print out "Hello, %s," which is a placeholder recall,

143
00:07:40,110 --> 00:07:41,910
并输出此人的名字。
and output the person's name.

144
00:07:41,910 --> 00:07:44,760
所以上周，我们编译该程序的方式仅仅是
So last week, the way we compiled this program was just

145
00:07:44,759 --> 00:07:47,139
“打个招呼”，与现在没什么不同。
"make hello," no different from now.

146
00:07:47,139 --> 00:07:52,199
但是这个星期，假设我要摆脱制造，
But this week, suppose I were to instead get rid of make, only

147
00:07:52,199 --> 00:07:54,569
因为对于我来说，这对我来说是一种自动化的步骤
because it's sort of automating steps for me that I now

148
00:07:54,569 --> 00:07:56,249
想更详细地了解。
want to understand in more detail.

149
00:07:56,250 --> 00:08:01,379
我可以使用clang -o hello hello.c再次编译该程序，所以
I could compile this program again with clang -o hello hello.c, so just

150
00:08:01,379 --> 00:08:06,599
重新应用了传递三个参数-o，hello的相同想法
a reapplication of that same idea of passing in three arguments, -o, hello,

151
00:08:06,600 --> 00:08:08,130
和你好c。
and hello.c.

152
00:08:08,129 --> 00:08:11,069
但是现在的收获是我实际上要去
But the catch now is that I'm actually going

153
00:08:11,069 --> 00:08:12,879
查看这些红色错误消息之一。
to see one of these red error messages.

154
00:08:12,879 --> 00:08:14,879
让我们考虑一下这实际上是在说什么。
And let's consider what this is actually saying.

155
00:08:14,879 --> 00:08:17,439
这里仍然会有很多神秘的东西。
There's still going to be a bunch of cryptic stuff here.

156
00:08:17,439 --> 00:08:19,991
但是请注意，像往常一样，我们将希望看到，
But notice, as always, we're going to see, hopefully,

157
00:08:19,992 --> 00:08:21,450
有点熟悉的东西。
something that's a little familiar.

158
00:08:21,449 --> 00:08:23,519
因此，“对get_string的未定义引用”。
So "undefined reference to get_string."

159
00:08:23,519 --> 00:08:26,789
我还不知道什么是未定义的引用。
I don't yet know what an undefined reference is, necessarily.

160
00:08:26,790 --> 00:08:28,440
我不知道链接程序命令是什么。
I don't know what a linker command is.

161
00:08:28,439 --> 00:08:31,679
但是我至少认识到get_string发生了一些事情。
But I at least recognize there's something going on with get_string.

162
00:08:31,680 --> 00:08:33,100
这是有原因的。
And there's a reason for this.

163
00:08:33,100 --> 00:08:37,140
事实证明，使用库时，无论是CS50的库还是其他库
It turns out that when using a library, whether it's CS50's library or others'

164
00:08:37,139 --> 00:08:41,158
同样，有时仅包含标头有时是不够的
as well, it's sometimes not sufficient only to include the header

165
00:08:41,158 --> 00:08:43,649
文件放在您自己的代码顶部。
file at the top of your own code.

166
00:08:43,649 --> 00:08:46,229
有时，您还必须告诉计算机
Sometimes, you additionally have to tell the computer

167
00:08:46,230 --> 00:08:52,350
在哪里可以找到某人编写的要实现的0和1
where to find the 0's and 1's that someone has written to implement

168
00:08:52,350 --> 00:08:54,290
像get_string这样的函数。
a function like get_string.

169
00:08:54,289 --> 00:08:58,859
因此，头文件（如cs50.h）仅告诉编译器
So the header file, like cs50.h, just tells the compiler

170
00:08:58,860 --> 00:09:00,540
该功能存在。
that the function exists.

171
00:09:00,539 --> 00:09:02,909
但是直到现在，还有第二种机制，
But there's a second mechanism that, up until now,

172
00:09:02,909 --> 00:09:05,729
对我们来说是自动化的，它告诉计算机在哪里
has been automated for us, that tells the computer where

173
00:09:05,730 --> 00:09:10,560
查找实现该标头中的功能的实际0和1
to find the actual 0's and 1's that implements the functions in that header

174
00:09:10,559 --> 00:09:11,469
文件。
file.

175
00:09:11,470 --> 00:09:15,180
因此，我将需要实际添加另一个命令行
So with that said, I'm going to need to actually add another command line

176
00:09:15,179 --> 00:09:16,709
该命令的参数。
argument to this command.

177
00:09:16,710 --> 00:09:22,140
而且，除了执行clang -o hello hello.c之外，我还要
And instead of doing clang -o hello hello.c, I'm going to additionally,

178
00:09:22,139 --> 00:09:26,249
并坦白地讲，在最后执行-lcs50
and admittedly, cryptically, do -lcs50 at the end

179
00:09:26,250 --> 00:09:31,440
该命令，它很简单地指的是CS50库中的链接。
of this command, which quite simply refers to link in the CS50 library.

180
00:09:31,440 --> 00:09:33,750
因此，“链接”是一个艺术术语，我们将了解它的含义。
So "link" is a term of art that we'll see what it

181
00:09:33,750 --> 00:09:35,560
稍后会详细说明。
means in more detail in just a moment.

182
00:09:35,559 --> 00:09:39,329
但是，这个额外的最终命令行参数告诉Clang，
But this additional final command-line argument tells Clang,

183
00:09:39,330 --> 00:09:42,660
您已经知道像get_string这样的函数已经存在。
you already know that a function like get_string exists.

184
00:09:42,659 --> 00:09:47,099
-lcs50表示在编译hello.c时
-lcs50 means when compiling hello.c, make

185
00:09:47,100 --> 00:09:51,570
确保合并CS50库中的所有机器代码
sure to incorporate all of the machine code from CS50's library

186
00:09:51,570 --> 00:09:53,190
进入您的程序。
into your program as well.

187
00:09:53,190 --> 00:09:56,880
简而言之，当您使用某些库时，这是您必须要做的事情。
In short, it's something you have to do when you use certain libraries.

188
00:09:56,879 --> 00:10:00,609
所以现在当我按Enter键时，一切似乎都很好，因为没有坏处被打印出来。
So now when I hit Enter, all seems to be well because nothing bad got printed.

189
00:10:00,610 --> 00:10:02,520
如果输入ls，我会打招呼。
If I type ls, I see hello.

190
00:10:02,519 --> 00:10:06,299
瞧，我可以做./你好，输入我的名字，大卫。
And voila, I can do ./hello, type in my name, David.

191
00:10:06,299 --> 00:10:08,519
瞧，“你好，大卫。”
And voila, "hello, David."

192
00:10:08,519 --> 00:10:10,739
那么为什么我们上周不做所有这一切呢？
So why didn't we do all of this last week?

193
00:10:10,740 --> 00:10:13,020
坦率地说，我们没有取得任何根本进展。
And frankly, we've made no fundamental progress.

194
00:10:13,019 --> 00:10:15,959
我们所做的只是揭示引擎盖下发生的事情。
All we've done is reveal what's going on underneath the hood.

195
00:10:15,960 --> 00:10:19,650
但坦率地说，我会声明通过键入来编译代码
But I'll claim that, frankly, compiling your code by typing out

196
00:10:19,649 --> 00:10:24,449
所有这些冗长的命令行参数都很快变得乏味。
all of these verbose command-line arguments just gets tedious quickly.

197
00:10:24,450 --> 00:10:27,330
因此，计算机科学家和程序员，更具体地说，
And so computer scientists and programmers, more specifically,

198
00:10:27,330 --> 00:10:29,370
倾向于自动化单调的步骤。
tend to automate monotonous steps.

199
00:10:29,370 --> 00:10:33,360
因此，make最终会发生的事情是，所有这些
So what's happening ultimately with make is that all of this

200
00:10:33,360 --> 00:10:34,800
正在为我们自动化。
is being automated for us.

201
00:10:34,799 --> 00:10:37,589
因此，当您上周输入“打招呼”时，此后，
So when you typed "make hello" last week-- and henceforth,

202
00:10:37,590 --> 00:10:40,030
欢迎您继续使用make，
you're welcome to continue using make as well--

203
00:10:40,029 --> 00:10:43,709
请注意，它会生成此超长命令，其中一些命令
notice that it generates this extra long command, some of which

204
00:10:43,710 --> 00:10:45,000
我们甚至都没有谈论过。
we haven't even talked about.

205
00:10:45,000 --> 00:10:47,399
但是我一开始就承认叮当声。
But I do recognize clang at the beginning.

206
00:10:47,399 --> 00:10:51,169
我认识hello.c请参阅此处。
I recognize hello.c see here.

207
00:10:51,169 --> 00:10:54,329
我在这里认识到-lcs50。
I recognize -lcs50 here.

208
00:10:54,330 --> 00:10:56,490
但是请注意，还有很多其他的东西，
But notice there's a bunch of other stuff as well,

209
00:10:56,490 --> 00:11:00,470
不仅-o你好，而且-lm，其中
not only the -o hello, but also -lm, which

210
00:11:00,470 --> 00:11:03,500
指的是数学库-lcrypt，它指的是
refers to a math library, -lcrypt, which refers

211
00:11:03,500 --> 00:11:05,899
加密或加密库。
to a cryptography or an encryption library.

212
00:11:05,899 --> 00:11:08,809
简而言之，我们的员工已经预先配置好了
In short, we the staff have preconfigured

213
00:11:08,809 --> 00:11:11,449
确保只是在编译代码时
make to just make sure that when you compile your code,

214
00:11:11,450 --> 00:11:15,410
所有必需的依赖项，库等，
all of the requisite dependencies, libraries, and so forth,

215
00:11:15,409 --> 00:11:18,649
可供您使用而不必担心所有
are available to you without having to worry about all

216
00:11:18,649 --> 00:11:20,099
这些命令行参数。
of these command-line arguments.

217
00:11:20,100 --> 00:11:22,700
因此，从此以后，您当然可以编译您的代码
So henceforth, you can certainly compile your code

218
00:11:22,700 --> 00:11:24,650
以这种方式直接使用Clang。
in this way using Clang directly.

219
00:11:24,649 --> 00:11:27,739
或者您可以整周回到我们上周的位置
Or you can come back full circle to where we were last week

220
00:11:27,740 --> 00:11:29,240
然后运行“打个招呼”。
and just run "make hello."

221
00:11:29,240 --> 00:11:33,170
但是我们运行make hello是有原因的，因为执行了所有这些步骤
But there's a reason we run make hello, because executing all of those steps

222
00:11:33,169 --> 00:11:35,899
手动操作往往会很快变得乏味。
manually tends to just get tedious quickly.

223
00:11:35,899 --> 00:11:38,991
因此，的确如此，我们在这里所做的就是编译我们的代码。
And so indeed, what we've done here is compile our code.

224
00:11:38,991 --> 00:11:41,449
编译意味着从源代码到机器代码。
And compiling means going from source code to machine code.

225
00:11:41,450 --> 00:11:44,660
但是今天，我们发现确实还有更多
But today, we revealed that there's a little more, indeed,

226
00:11:44,659 --> 00:11:46,609
在引擎盖下面，这种“联系”
going on underneath the hood, this "linking"

227
00:11:46,610 --> 00:11:49,800
我所提到的以及其他几个步骤。
that I referred to and a couple of other steps as well.

228
00:11:49,799 --> 00:11:53,899
因此，当您将代码从源代码编译为机器代码时，
So it turns out when you compile your code from source code to machine code,

229
00:11:53,899 --> 00:11:56,899
最终还涉及一些其他步骤。
there's a few more steps that are ultimately involved.

230
00:11:56,899 --> 00:11:59,959
当我们说“编译”时，我们实际上是指这四个步骤。
And when we say "compiling," we actually mean these four steps.

231
00:11:59,960 --> 00:12:03,350
而且，我们将不讨论这些底层细节。
And we're not going to dwell on these kinds of low-level details.

232
00:12:03,350 --> 00:12:05,690
但这只是启发性的
But it's perhaps enlightening just to see

233
00:12:05,690 --> 00:12:09,830
简要了解从源代码开始时发生的情况
a brief tour of what's going on when you start with your source code

234
00:12:09,830 --> 00:12:11,680
并最终尝试生成机器代码。
and end up trying to produce machine code.

235
00:12:11,679 --> 00:12:12,637
因此，让我们考虑一下。
So let's consider this.

236
00:12:12,638 --> 00:12:14,660
这是计算机正在执行的步骤1
This is step 1 that the computer is doing

237
00:12:14,659 --> 00:12:17,149
在您编译代码时为您服务。
for you when you compile your code.

238
00:12:17,149 --> 00:12:19,639
因此，第1步采用您自己的源代码
So step 1 takes your own source code that

239
00:12:19,639 --> 00:12:21,259
看起来有点像这样。
looks a little something like this.

240
00:12:21,259 --> 00:12:24,649
并从上到下，从左到右预处理您的代码。
And it preprocesses your code, top to bottom, left to right.

241
00:12:24,649 --> 00:12:27,169
预处理代码本质上意味着
And to preprocess your code essentially means

242
00:12:27,169 --> 00:12:30,499
它会寻找任何以井号符号开头的行，因此
that it looks for any lines that start with a hash symbol, so

243
00:12:30,500 --> 00:12:35,299
#include cs50.h，＃include stdio.h。
#include cs50.h, #include stdio.h.

244
00:12:35,299 --> 00:12:39,229
预处理步骤的作用就像是查找并替换。
And what the preprocessing step does is it's kind of like a find and replace.

245
00:12:39,230 --> 00:12:42,330
它会注意到，哦，这是#include行。
It notices, oh, here's a #include line.

246
00:12:42,330 --> 00:12:49,790
让我继续并将该文件cs50.h的内容复制到您自己的代码中。
Let me go ahead and copy the contents of that file, cs50.h, into your own code.

247
00:12:49,789 --> 00:12:54,289
同样，当我遇到#include stdio.h时，请让我，
Similarly, when I encounter #include stdio.h, let me,

248
00:12:54,289 --> 00:12:58,759
所谓的预处理器，打开该文件stdio.h，然后复制/粘贴
the so-called preprocessor, open that file, stdio.h, and copy/paste

249
00:12:58,759 --> 00:13:04,649
该文件的内容，以便文件中的内容现在看起来更像这样。
the contents of that file so that what's in the file now looks more like this.

250
00:13:04,649 --> 00:13:06,289
因此，这是自动发生的。
So this is happening automatically.

251
00:13:06,289 --> 00:13:08,239
您不必手动执行此操作。
You never have to do this manually.

252
00:13:08,240 --> 00:13:12,290
但是为什么要进行此预处理步骤？
But why is there this preprocessing step?

253
00:13:12,289 --> 00:13:16,879
如果您还记得我们上周关于这些代码行的讨论，
If you recall our discussion last week of these lines of code that

254
00:13:16,879 --> 00:13:19,909
倾向于放在文件的顶部，有人吗
tend to go at the top of your file, does anyone

255
00:13:19,909 --> 00:13:24,579
知道预处理器对我有什么作用，为什么？
perceive what the preprocessor is doing for me and why?

256
00:13:24,580 --> 00:13:29,720
为什么我要编写包含这些哈希符号的代码，例如#include cs50.h
Why do I write code that has these hash symbols, like #include cs50.h

257
00:13:29,720 --> 00:13:33,350
和#include stdio.h，但是这个预处理器显然
and #include stdio.h, but this preprocessor apparently

258
00:13:33,350 --> 00:13:37,415
自动将这些行替换为实际内容
is automatically replacing those lines with the actual contents

259
00:13:37,414 --> 00:13:38,039
这些文件？
of those files?

260
00:13:38,039 --> 00:13:42,739
这些黄色的东西在这里现在是什么？
What are these things here in yellow now?

261
00:13:42,740 --> 00:13:44,168
是的，杰克，你怎么看？
Yeah, Jack, what do you think?

262
00:13:44,168 --> 00:13:46,960
杰克：是否定义了供您在代码中使用的所有功能，
JACK: Is it defining all the functions for you to use in your code,

263
00:13:46,960 --> 00:13:48,740
否则计算机将不知道该怎么办？
otherwise the computer wouldn't know what to do?

264
00:13:48,740 --> 00:13:49,340
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

265
00:13:49,340 --> 00:13:51,065
它定义了我代码中的所有功能
It's defining all of the functions in my code

266
00:13:51,065 --> 00:13:52,648
使计算机知道该怎么办。
so that the computer knows what to do.

267
00:13:52,648 --> 00:13:56,113
因为请记住，上周我们遇到了这种令人讨厌的错误，
Because remember that we ran into that sort of annoying bug last week,

268
00:13:56,113 --> 00:13:58,280
因此我试图实现一个称为
whereby I was trying to implement a function called,

269
00:13:58,279 --> 00:13:59,959
我认为，get_positive_int。
I think, get_positive_int.

270
00:13:59,960 --> 00:14:04,350
回想一下，当我在文件底部实现该功能时，
And recall that when I implemented that function at the bottom of my file,

271
00:14:04,350 --> 00:14:07,610
编译器有点笨，因为它没有意识到
the compiler was kind of dumb in that it didn't realize

272
00:14:07,610 --> 00:14:09,440
之所以存在是因为已经实施了
that it existed because it was implemented

273
00:14:09,440 --> 00:14:11,220
一直到我文件的底部。
all the way at the bottom of my file.

274
00:14:11,220 --> 00:14:16,040
杰克的观点是，通过提及此功能，如果可以的话，一个提示，
So to Jack's point, by putting a mention of this function, a hint, if you will,

275
00:14:16,039 --> 00:14:18,949
在最顶端，就像训练编译器一样
at the very top, it's like training the compiler

276
00:14:18,950 --> 00:14:22,160
提前知道我不知道它是如何实现的，
to know in advance that I don't know how it's implemented yet,

277
00:14:22,159 --> 00:14:23,849
但是我知道get_string将会存在。
but I know get_string is going to exist.

278
00:14:23,850 --> 00:14:27,540
我还不知道它是如何实现的，但是我知道printf将会存在。
I don't know how it's implemented yet, but I know printf is going to exist.

279
00:14:27,539 --> 00:14:31,399
因此，过去一周来我们一直包含的这些头文件
So these header files that we've been including for the past week essentially

280
00:14:31,399 --> 00:14:34,189
包含所有原型
contain all of the prototypes--

281
00:14:34,190 --> 00:14:38,240
也就是说，该库中存在的所有功能的所有提示-
that is, all of the hints for all the functions that exist in the library--

282
00:14:38,240 --> 00:14:42,710
这样，您的代码在编译时就可以自上而下地了解
so that your code, when compiled, know from the top down

283
00:14:42,710 --> 00:14:45,690
这些功能确实会存在。
that those functions will indeed exist.

284
00:14:45,690 --> 00:14:47,690
因此预处理器可以为我们省去麻烦
So the preprocessor just saves us the trouble

285
00:14:47,690 --> 00:14:50,480
如果需要，您必须复制并粘贴所有这些原型，
of having to copy and paste all of these prototypes, if you will,

286
00:14:50,480 --> 00:14:52,830
所有这些提示，我们自己。
all of these hints, ourselves.

287
00:14:52,830 --> 00:14:54,950
那么在那一步之后会发生什么呢？
So what happens after that step there?

288
00:14:54,950 --> 00:14:55,777
接下来是什么？
What comes next?

289
00:14:55,777 --> 00:14:57,860
好吧，可能还有其他头文件。
Well, there might very well be other header files.

290
00:14:57,860 --> 00:15:00,152
这些文件中可能还有其他内容。
There might very well be other contents in those files.

291
00:15:00,152 --> 00:15:03,800
但是现在，让我们假设只有原型。
But for now, let's just assume that only in there is the prototype.

292
00:15:03,799 --> 00:15:06,769
所以现在编译实际上具有更精确的含义
So now compiling actually has a more precise meaning

293
00:15:06,769 --> 00:15:07,999
我们今天要定义。
that we'll define today.

294
00:15:08,000 --> 00:15:11,689
现在要编译您的代码意味着要使用此C代码
To compile your code now means to take this C code

295
00:15:11,690 --> 00:15:17,215
并将其从此处的源代码转换为此处的另一种类型的源代码。
and to convert it from source code here to another type of source code here.

296
00:15:17,215 --> 00:15:20,090
现在，这可能将成为我们所见过的最神秘的东西。
Now, this is probably going to be the most cryptic stuff we ever see.

297
00:15:20,090 --> 00:15:22,190
这不是您需要了解的代码。
And this is not code you need to understand.

298
00:15:22,190 --> 00:15:25,460
但是，屏幕上显示的是汇编代码。
But what's on the screen here is what's called assembly code.

299
00:15:25,460 --> 00:15:28,550
长话短说，世界上有很多不同的计算机。
So long story short, there's a lot of different computers in the world.

300
00:15:28,549 --> 00:15:30,649
具体来说，有很多不同的类型
And specifically, there's a lot of different types

301
00:15:30,649 --> 00:15:35,729
中央处理单元（计算机的大脑）中的CPU数量。
of CPUs in the, Central Processing Units, the brains of a computer.

302
00:15:35,730 --> 00:15:39,680
CPU可以理解某些命令。
And a CPU understands certain commands.

303
00:15:39,679 --> 00:15:43,879
这些命令倾向于以这种语言来表达，即汇编代码。
And those commands tend to be expressed in this language called assembly code.

304
00:15:43,879 --> 00:15:46,596
现在，老实说，我本人并不真正了解其中的大部分内容。
Now, I honestly don't really understand most of this myself.

305
00:15:46,596 --> 00:15:49,679
自从我认真思考汇编代码以来，肯定已经有一段时间了。
It's certainly been a while even since I thought hard about assembly code.

306
00:15:49,679 --> 00:15:53,459
但是，如果我在这里强调几个操作性人物，
But if I highlight a few operative characters here,

307
00:15:53,460 --> 00:15:56,570
注意，这里提到了main，get_string，printf。
notice that there's mention of main, get_string, printf.

308
00:15:56,570 --> 00:16:00,170
因此，这就像main的较低层实现，
So this is of like a lower-level implementation of main,

309
00:16:00,169 --> 00:16:03,419
get_string和printf的代码，称为汇编语言。
of get_string and printf, in a different language called assembly.

310
00:16:03,419 --> 00:16:04,819
因此，您编写了C代码。
So you write the C code.

311
00:16:04,820 --> 00:16:08,630
但是，计算机会将其转换为对计算机更友好的语言
The computer, though, converts it to a more computer-friendly language

312
00:16:08,629 --> 00:16:09,959
称为汇编代码。
called assembly code.

313
00:16:09,960 --> 00:16:12,320
几十年前，人类写下了这些东西。
And decades ago, humans wrote this stuff.

314
00:16:12,320 --> 00:16:14,210
人类编写了汇编代码。
Humans wrote assembly code.

315
00:16:14,210 --> 00:16:17,585
但是如今，我们有了C。如今，我们拥有Python之类的语言-
But nowadays, we have C. And nowadays, we have languages like Python--

316
00:16:17,585 --> 00:16:20,210
几周后还会有更多相关内容-更加人性化，
more on that in a few weeks-- that are just more user friendly,

317
00:16:20,210 --> 00:16:22,310
即使过去一周感觉不是这样。
even if it didn't feel like that this past week.

318
00:16:22,309 --> 00:16:26,179
汇编代码更接近于计算机本身的理解。
Assembly code is a little closer to what the computer itself understands.

319
00:16:26,179 --> 00:16:27,739
但是还有另外一步。
But there's still another step.

320
00:16:27,740 --> 00:16:29,240
有一个步骤称为组装。
There's this step called assembling.

321
00:16:29,240 --> 00:16:31,910
再说一次，所有这些都在您简单运行时发生
And again, all of this is happening when you simply run

322
00:16:31,909 --> 00:16:34,579
make，然后依次执行此命令clang。
make and, in turn, this command, clang.

323
00:16:34,580 --> 00:16:39,350
汇编代码意味着获取该汇编代码并最终将其转换
To assemble your code means to take this assembly code and finally convert it

324
00:16:39,350 --> 00:16:41,720
机器码，0和1。
to machine code, 0's and 1's.

325
00:16:41,720 --> 00:16:43,460
因此，您编写了源代码。
So you write the source code.

326
00:16:43,460 --> 00:16:46,700
编译器将其汇编为汇编代码。
The compiler assembles it into assembly code.

327
00:16:46,700 --> 00:16:49,550
然后将其编译为汇编代码。
Then it compiles it into assembly code.

328
00:16:49,549 --> 00:16:54,649
然后将其汇编为机器代码，直到我们得到实际的0和1。
Then it assembles it into machine code until we have the actual 0's and 1's.

329
00:16:54,649 --> 00:16:56,609
但是实际上还有最后一步。
But there's actually one final step.

330
00:16:56,610 --> 00:17:00,380
仅仅因为您编写的代码已转换为0和1，
Just because your code that you wrote has been converted into 0's and 1's, it

331
00:17:00,379 --> 00:17:04,368
仍然需要与CS50编写的0和1关联
still needs to be linked in with the 0's and 1's that CS50 wrote

332
00:17:04,368 --> 00:17:07,279
以及C语言的设计师几年前写的
and that the designers of the C language wrote years ago

333
00:17:07,279 --> 00:17:09,679
在我们的案例中实施CS50库时，
when implementing the CS50 library in our case,

334
00:17:09,680 --> 00:17:12,470
和printf函数（在这种情况下）。
and the printf function in their case.

335
00:17:12,470 --> 00:17:15,950
所以这就是说，当您拥有这样的代码时，
So this is to say that when you have code like this that's not only

336
00:17:15,950 --> 00:17:20,270
包括功能原型，例如get_string和printf
including the prototypes for functions like get_string and printf at the very

337
00:17:20,269 --> 00:17:24,439
顶部，这些黄色的行是最终转换的行
top, these lines here in yellow are what are ultimately converted

338
00:17:24,440 --> 00:17:27,440
分为0和1。
into 0's and 1's.

339
00:17:27,440 --> 00:17:32,270
现在，我们必须将cs50.c中的0和1与0和1结合起来，
We now have to combine those 0's and 1's with the 0's and 1's from cs50.c,

340
00:17:32,269 --> 00:17:35,029
这是工作人员前一段时间写的，甚至是一个文件
which the staff wrote some time ago, and even a file

341
00:17:35,029 --> 00:17:38,587
叫做stdio.c，是C的设计师几年前写的。
called stdio.c, which the designers of C wrote years ago.

342
00:17:38,587 --> 00:17:40,879
从技术上讲，它可能被称为不同的东西
And technically, it might be called something different

343
00:17:40,880 --> 00:17:41,802
引擎盖下。
underneath the hood.

344
00:17:41,801 --> 00:17:43,759
但是实际上有三个文件
But there's really three files that are getting

345
00:17:43,759 --> 00:17:45,529
编写程序时结合在一起。
combined when you write your program.

346
00:17:45,529 --> 00:17:51,919
我刚刚声称，第一个经过预处理和编译后
The first, I just claimed, once it's preprocessed and compiled

347
00:17:51,920 --> 00:17:55,760
并组装起来，就变成了全0和1的形式。
and assembled, it's then in this form of all 0's and 1's.

348
00:17:55,759 --> 00:17:58,129
在CS50 IDE的某个地方，有一堆
Somewhere on the CS50 IDE, there's a whole bunch

349
00:17:58,130 --> 00:18:00,800
0和1代表cs50.c。
of 0's and 1's representing cs50.c.

350
00:18:00,799 --> 00:18:03,409
在CS50 IDE中的某个地方，还有另一个文件
Somewhere in CS50 IDE, there's another file

351
00:18:03,410 --> 00:18:08,840
代表stdio.c的0和1。
representing the 0's and 1's for stdio.c So this final fourth step, a.k.a.

352
00:18:08,839 --> 00:18:13,279
链接，只需要我所有的0和1，所有CS50 0和1，全部
linking, just takes all of my 0's and 1's, all of CS50 0's and 1's, all

353
00:18:13,279 --> 00:18:18,799
的printf的0和1，并将它们全部链接到一个大的blob中，
of printf's 0's and 1's, and links them all together into one big blob,

354
00:18:18,799 --> 00:18:23,869
如果可以的话，那代表您的程序，您好。
if you will, that collectively represent your program, hello.

355
00:18:23,869 --> 00:18:26,959
因此，我的天哪，这是一个非常艰巨的步骤。
So, my god, like, that's quite a mouthful and so many steps.

356
00:18:26,960 --> 00:18:31,250
而且我所描述的步骤都与您实施的步骤没有任何关系
And none of the steps have I described are really germane to you implementing

357
00:18:31,250 --> 00:18:35,089
马里奥的金字塔或现金或信贷，因为我们真正拥有的是
Mario's pyramid or cash or credit, because what we've really

358
00:18:35,089 --> 00:18:37,339
过去一周一直在做的是全部四个
been doing over the past week is taking all four

359
00:18:37,339 --> 00:18:40,879
这些相当低级的复杂概念，如果您愿意，
of these fairly low-level, sophisticated concepts and, if you will,

360
00:18:40,880 --> 00:18:44,720
将它们抽象化，以便我们仅参考整个过程
abstracting them away so that we just refer to this whole process

361
00:18:44,720 --> 00:18:46,310
作为编译。
as compiling.

362
00:18:46,309 --> 00:18:48,379
因此，即使是，从技术上讲，
So we even though, yes, technically, compiling

363
00:18:48,380 --> 00:18:51,320
只是四个步骤之一，通常是程序员
is just one of the four steps, what a programmer typically

364
00:18:51,319 --> 00:18:54,469
在说编译是他们的时候，只是挥手致意，
does when saying compiling is they're, just with a wave of the hand,

365
00:18:54,470 --> 00:18:58,400
引用所有这些较低级别的细节。
referring to all of those lower-level details.

366
00:18:58,400 --> 00:19:01,700
但是事实是，引擎盖下发生了多个步骤。
But it is the case that there's multiple steps happening underneath the hood.

367
00:19:01,700 --> 00:19:04,610
这就是make以及Clang在为您做的事情，
And this is what make and, in turn, Clang are doing for you,

368
00:19:04,609 --> 00:19:08,809
自动执行从源代码到汇编代码的过程
automating this process of going from source code to assembly code

369
00:19:08,809 --> 00:19:13,152
机器代码，然后将其与您所使用的任何库链接在一起
to machine code and then linking it all together with any libraries you

370
00:19:13,153 --> 00:19:13,820
可能已经用过。
might have used.

371
00:19:13,819 --> 00:19:15,799
因此，不再将正在发生的事情视为理所当然。
So no longer take for granted what's happening.

372
00:19:15,799 --> 00:19:17,989
希望能给您带来更多的了解
Hopefully, that offers you a glimpse a bit more

373
00:19:17,990 --> 00:19:21,860
编译自己的代码时实际发生的情况。
of what's actually happening when you compile your own code.

374
00:19:21,859 --> 00:19:24,799
好吧，让我暂停一下，因为那是一个很大的嘴，
Well, let me pause there, because that's quite a mouthful,

375
00:19:24,799 --> 00:19:29,659
看看是否有关于预处理，编译，
and see if there's any questions on preprocessing, compiling,

376
00:19:29,660 --> 00:19:33,050
或组装或链接
or assembling, or linking, a.k.a.

377
00:19:33,049 --> 00:19:35,119
编译。
compiling.

378
00:19:35,119 --> 00:19:37,549
再说一次，我们不会停留在这个低水平上。
And again, we won't dwell at this low level.

379
00:19:37,549 --> 00:19:40,639
如果我们可以同意的话，我们现在倾向于将所有内容抽象出来
We'll tend to now just abstract this all away if we can sort of agree

380
00:19:40,640 --> 00:19:42,540
好的，是的，有那些步骤。
that, OK, yes, there's those steps.

381
00:19:42,539 --> 00:19:45,289
但是真正重要的是整个过程，而不是细节。
But what's really important is the whole process, not the minutia.

382
00:19:45,289 --> 00:19:46,259
索菲亚？
Sophia?

383
00:19:46,259 --> 00:19:50,059
SOPHIA：我对第一步的问题是什么时候
SOPHIA: I had a question about with the first step, when

384
00:19:50,059 --> 00:19:53,719
我们将替换顶部的所有信息，
we're replacing all the information at the top,

385
00:19:53,720 --> 00:19:56,790
这些信息包含在IDE中吗？
is that information contained within the IDE?

386
00:19:56,789 --> 00:19:58,009
还是我们在哪里-
Or where do we--

387
00:19:58,009 --> 00:20:00,374
是否有文件保存在该IDE中的某个位置，例如
are there files saved somewhere in that IDE, like, where

388
00:20:00,375 --> 00:20:02,000
从所有这些信息？
it's getting all this information from?

389
00:20:02,000 --> 00:20:03,020
大卫·马兰（David MALAN）：是的，这是一个很好的问题。
DAVID MALAN: Yeah, really good question.

390
00:20:03,019 --> 00:20:04,602
这些文件都来自哪里？
Where are all these files coming from?

391
00:20:04,603 --> 00:20:07,320
因此，是的，坦率地说，当您使用CS50 IDE时，
So yes, when you are using CS50 IDE, or frankly,

392
00:20:07,319 --> 00:20:09,829
如果您使用的是自己的Mac或PC，
if you're using your own Mac or your own PC,

393
00:20:09,829 --> 00:20:13,809
就像我们已经将编译器预装到Mac或PC上一样
and you have preinstalled a compiler into your Mac or PC just like we have

394
00:20:13,809 --> 00:20:18,499
到CS50 IDE，您得到的是一堆.h文件
to CS50 IDE, what you get is a whole bunch of .h files somewhere

395
00:20:18,500 --> 00:20:19,699
在计算机系统上。
on the computer system.

396
00:20:19,700 --> 00:20:23,950
您可能还会有一堆.c文件或其编译版本，
You might also have a whole bunch of .c files, or compiled versions thereof,

397
00:20:23,950 --> 00:20:24,950
系统上的某处。
somewhere on the system.

398
00:20:24,950 --> 00:20:28,370
是的，当您下载并安装编译器时，
So yes, when you download and install a compiler,

399
00:20:28,369 --> 00:20:31,279
您正在为您添加所有这些库。
you are getting all of these libraries added for you.

400
00:20:31,279 --> 00:20:35,719
我们预先安装了一个名为CS50的库，
And we preinstalled an additional library called CS50's library that

401
00:20:35,720 --> 00:20:40,180
此外，它还带有自己的.h文件和自己的机器代码。
additionally comes with its own .h file and its own machine code as well.

402
00:20:40,180 --> 00:20:43,250
因此，所有这些文件都在CS50 IDE中的某个位置，
So all of those files are somewhere in CS50 IDE,

403
00:20:43,250 --> 00:20:46,459
或等效地，如果您在本地工作，则在您自己的Mac或PC中。
or equivalently, in your own Mac or PC if you're working locally.

404
00:20:46,460 --> 00:20:48,620
而在这种情况下，编译器Clang只是
And the compiler, Clang, in this case, just

405
00:20:48,619 --> 00:20:52,369
知道如何找到它，因为安装中涉及的步骤之一
knows how to find that because one of the steps involved in installing

406
00:20:52,369 --> 00:20:55,129
您自己的编译器要确保已将其配置为知道
your own compiler is making sure it's configured to know,

407
00:20:55,130 --> 00:20:58,010
根据Sophia的问题，所有这些文件都在哪里。
per Sophia's question, where all those files are.

408
00:21:00,769 --> 00:21:02,989
[？巴斯利？ ？]对不起，我很抱歉。
[? Basili? ?] I'm sorry if I'm mispronouncing it.

409
00:21:02,990 --> 00:21:04,010
[？巴斯利？ ？]
[? Basili? ?]

410
00:21:04,009 --> 00:21:06,799
[？ BASILI：吗？]因此，每当我们编译问候时，
[? BASILI: ?] So whenever we're compiling hello,

411
00:21:06,799 --> 00:21:11,959
例如，编译器是否也在编译CS50？
for example, is the compiler also compiling, for example, CS50?

412
00:21:11,960 --> 00:21:16,387
还是CS50在下面的某个机器代码中已经存在？
Or does CS50 already exist in machine code somewhere beneath?

413
00:21:16,386 --> 00:21:18,219
大卫·马兰（David MALAN）：是的，这也是一个很好的问题。
DAVID MALAN: Yeah, really good question too.

414
00:21:18,220 --> 00:21:20,570
所以我有点避开了索菲亚问题的这一部分
So I was kind of skirting this part of Sophia's question

415
00:21:20,569 --> 00:21:25,639
因为从技术上来讲，系统上可能未安装cs50.c。
because technically speaking, probably cs50.c is not installed on the system.

416
00:21:25,640 --> 00:21:29,550
从技术上讲，stdio.c可能未安装在系统中。
And technically, stdio.c is probably not installed in the system.

417
00:21:29,549 --> 00:21:30,049
为什么？
Why?

418
00:21:30,049 --> 00:21:31,159
只是不需要。
It just doesn't need to be.

419
00:21:31,160 --> 00:21:32,868
这将是一种效率低下的问题，也就是说，
It would be kind of inefficient, that is,

420
00:21:32,867 --> 00:21:35,599
慢，如果每次您编译自己的程序，
slow, if every time you compiled your own program,

421
00:21:35,599 --> 00:21:39,049
您还必须编译CS50的程序和stdio的程序，
you had to additionally compile CS50's program, and stdio's program,

422
00:21:39,049 --> 00:21:40,019
等等。
and so forth.

423
00:21:40,019 --> 00:21:42,739
因此，实际上有理由认为计算机通常会做什么
So it actually stands to reason that what computers typically do

424
00:21:42,740 --> 00:21:46,490
他们为您预编译了所有这些库文件吗？
is they precompile all of those library files for you

425
00:21:46,490 --> 00:21:48,823
以便更有效地将它们链接起来。
so that more efficiently they can just be linked in.

426
00:21:48,823 --> 00:21:50,990
而且您不必保留预处理，编译，
And you don't have to keep preprocessing, compiling,

427
00:21:50,990 --> 00:21:53,330
并汇编第三方代码。
and assembling third-party code.

428
00:21:53,329 --> 00:21:57,559
您只需对自己的代码执行这些步骤，然后将所有内容链接在一起。
You only perform those steps on your own code and then link everything together.

429
00:21:57,559 --> 00:21:59,269
的确如此。
And indeed, that's the case.

430
00:21:59,269 --> 00:22:01,489
这一切都是提前完成的。
It's all done in advance.

431
00:22:01,490 --> 00:22:03,800
虹膜，你的问题。
Iris, question from you.

432
00:22:03,799 --> 00:22:07,069
爱丽丝：当我们用原型替换头文件时，
IRIS: When we replace the header files with prototypes,

433
00:22:07,069 --> 00:22:10,439
我们是否仅将其替换为使用过的原型？
are we only replacing it with the prototypes that get used?

434
00:22:10,440 --> 00:22:12,777
还是所有原型在技术上都得到了替代？
Or are all the prototypes technically substituted?

435
00:22:12,777 --> 00:22:15,110
大卫·马兰（David MALAN）：是的，所以我有点扫兴了
DAVID MALAN: Yeah, so I was kind of sweeping that detail

436
00:22:15,109 --> 00:22:16,534
在地毯下，用我的点，点，点。
under the rug with my dot, dot, dot.

437
00:22:16,535 --> 00:22:18,618
这些文件中还有很多其他内容。
There's a whole lot of other stuff in those files.

438
00:22:18,617 --> 00:22:21,109
您将获得这些文件的全部内容，
You're getting the entire contents of those files,

439
00:22:21,109 --> 00:22:24,709
即使您唯一需要的就是原型。
even if the only thing you need is the prototype.

440
00:22:24,710 --> 00:22:27,710
但是，这就是为什么我从技术上也提到这个事实，
But, and this is why I alluded to the fact too that technically,

441
00:22:27,710 --> 00:22:30,860
可能没有stdio.c文件，因为那里
there probably isn't a stdio.c file, because there

442
00:22:30,859 --> 00:22:32,629
里面会有很多东西。
would be so much stuff in it.

443
00:22:32,630 --> 00:22:36,140
可能不仅只有一个包含所有内容的stdio.h文件。
There's probably not just one stdio.h file with everything in it.

444
00:22:36,140 --> 00:22:40,070
可能还有些魔术般地包含了一些较小的文件。
There's probably some smaller files that get magically included as well.

445
00:22:40,069 --> 00:22:44,299
但是，是的，这些文件中还有更多的代码行。
But yes, there are many more lines of code in those files.

446
00:22:44,299 --> 00:22:47,329
但是没关系。
But that's OK.

447
00:22:47,329 --> 00:22:51,919
您的编译器将仅使用其实际关心的行。
Your compiler is only going to use the lines that it actually cares about.

448
00:22:51,920 --> 00:22:53,120
好问题。
Good question.

449
00:22:53,119 --> 00:22:56,449
好吧，这么说，过去一周
All right, so with that said, this past week

450
00:22:56,450 --> 00:22:58,850
无疑在某些方面有点令人沮丧
undoubtedly was a bit frustrating in some ways

451
00:22:58,849 --> 00:23:00,979
因为您可能会遇到问题。
because you probably ran into problems.

452
00:23:00,980 --> 00:23:03,560
您在自己的代码中遇到了错误和错误。
You ran into bugs, mistakes in your own code.

453
00:23:03,559 --> 00:23:06,164
您可能看到一个或多个黄色或红色错误消息。
You probably saw one or more yellow or red error messages.

454
00:23:06,164 --> 00:23:09,289
您可能只是为了使代码编译而苦苦挣扎。
And you might have struggled a little bit just to get your code to compile.

455
00:23:09,289 --> 00:23:10,669
再说一次，这很正常。
And again, that's normal.

456
00:23:10,670 --> 00:23:12,390
随着时间的流逝，这将消失。
That will go away over time.

457
00:23:12,390 --> 00:23:16,320
但说实话，每当我写C时，假设有20％的时间，
But honestly, whenever I write C, let's say 20% of the time,

458
00:23:16,319 --> 00:23:20,399
我自己的代码中仍然有一个编译错误，更不用说逻辑错误了。
I still have a compilation error, let alone logical errors, in my own code.

459
00:23:20,400 --> 00:23:23,240
因此，这只是编写代码的经验的一部分。
So this is just part of the experience of writing code.

460
00:23:23,240 --> 00:23:25,370
人类在各种形式的生活中都会犯错。
Humans make mistakes in all forms of life.

461
00:23:25,369 --> 00:23:28,129
在代码的上下文中，这一点变得更加正确，在这种情况下，
And that's ever more true in the context of code, where again,

462
00:23:28,130 --> 00:23:32,180
每两个星期的准确性和正确性都很重要。
per our first two weeks precision is important as is correctness.

463
00:23:32,180 --> 00:23:35,520
有时很难同时实现这两个目标。
And it's hard sometimes to achieve both of those goals.

464
00:23:35,519 --> 00:23:38,059
现在让我们考虑一下您可能会变得更多
So let's consider now how you might be more

465
00:23:38,059 --> 00:23:42,589
有权调试您自己的代码-即在您自己的代码中查找问题。
empowered to debug your own code-- that is, find problems in your own code.

466
00:23:42,589 --> 00:23:44,749
这个词实际上有一些词源。
And this word actually has some etymology.

467
00:23:44,750 --> 00:23:46,669
这不一定是第一个错误。
This isn't necessarily the first bug.

468
00:23:46,670 --> 00:23:49,130
但也许最著名的错误是这张照片
But perhaps the most famous bug is this one pictured

469
00:23:49,130 --> 00:23:53,060
这是格雷斯·霍珀（Grace Hopper）的研究笔记本，
here from the research notebook of Grace Hopper,

470
00:23:53,059 --> 00:23:56,089
一位著名的计算机科学家，他发现了
a famous computer scientist, who had discovered

471
00:23:56,089 --> 00:23:59,809
哈佛Mark II电脑出现了一些问题，
that there were some problems with the Harvard Mark II computer, a very

472
00:23:59,809 --> 00:24:03,439
如今名垂青史的计算机，实际上寿命将很快
famous computer nowadays that actually lives over soon

473
00:24:03,440 --> 00:24:05,240
在校园里的新工程学校里
in the new engineering school on campus--

474
00:24:05,240 --> 00:24:06,830
曾经住在科学中心。
used to live in the Science Center.

475
00:24:06,829 --> 00:24:08,329
电脑出现问题。
The computer was having problems.

476
00:24:08,329 --> 00:24:12,769
可以肯定的是，当工程师们浏览这个大型主机时
And sure enough, when the engineers took a look inside of this big mainframe

477
00:24:12,769 --> 00:24:15,769
电脑，实际上有一个错误，如图所示
computer, there was actually a bug, pictured here

478
00:24:15,769 --> 00:24:17,899
并贴在Grace Hopper的笔记本上。
and taped to Grace Hopper's notebook.

479
00:24:17,900 --> 00:24:20,840
因此，这不一定是“错误”一词的首次使用，
So this wasn't necessarily the first use of the term "bug,"

480
00:24:20,839 --> 00:24:25,109
但这是实际计算机中实际错误的一个非常著名的示例。
but it is a very well-known example of an actual bug in an actual computer.

481
00:24:25,109 --> 00:24:27,859
如今，我们比喻多说了一个错误
Nowadays, we speak a little more metaphorically that a bug is just

482
00:24:27,859 --> 00:24:29,759
一个程序中的一个错误。
a mistake in one program.

483
00:24:29,759 --> 00:24:33,019
上周我们确实为您提供了一些工具，用于对错误进行故障排除。
And we did give you a few tools last week for troubleshooting bugs.

484
00:24:33,019 --> 00:24:37,134
Help50使您可以更好地了解一些隐秘的错误消息。
Help50 allows you to better understand some of the cryptic error messages.

485
00:24:37,134 --> 00:24:39,509
那是因为员工写了这个程序
And that's just because the staff wrote this program that

486
00:24:39,509 --> 00:24:41,609
分析了您遇到的问题，我们尝试
analyzed the problem you're having, and we try

487
00:24:41,609 --> 00:24:44,249
将其翻译成更人性化的语言。
to translate it to just more human-friendly speak.

488
00:24:44,250 --> 00:24:47,399
我们看到了一个名为style50的工具，该工具可以帮助您避免准确性问题，
We saw a tool called style50, which helps you not with your correctness,

489
00:24:47,400 --> 00:24:49,470
但只是出于代码美感的考虑，
but just with the aesthetics of your code,

490
00:24:49,470 --> 00:24:52,020
帮助您更好地缩进事物并添加空白-
helping you better indent things and add white space-- that

491
00:24:52,019 --> 00:24:55,049
是空白行或空格字符-因此用户更多了
is, blank lines or space characters-- so it's a little more user

492
00:24:55,049 --> 00:24:56,759
对人类友好的阅读。
friendly to the human to read.

493
00:24:56,759 --> 00:24:59,129
然后检查50，这当然是工作人员
And then check50, which, of course, the staff

494
00:24:59,130 --> 00:25:01,560
请写信以便我们可以立即向您提供反馈
write so that we can give you immediate feedback on

495
00:25:01,559 --> 00:25:05,229
根据问题集或实验室的代码是否正确
whether or not your code is correct per the problem sets or the lab

496
00:25:05,230 --> 00:25:06,450
规格。
specification.

497
00:25:06,450 --> 00:25:09,323
但是，您的工具箱中还应该包含其他一些工具。
But there's some other tools that you should have in your toolkit.

498
00:25:09,323 --> 00:25:10,740
今天，我们会把这些给您。
And we'll give those to you today.

499
00:25:10,740 --> 00:25:14,790
坦率地说，其中之一就是这个通用调试工具，
And one, frankly, is this universal debugging tool just called,

500
00:25:14,789 --> 00:25:16,927
在C的上下文中，printf。
in the context of C, printf.

501
00:25:16,928 --> 00:25:18,720
所以printf当然就是这个功能
So printf, of course, is just this function

502
00:25:18,720 --> 00:25:20,470
将内容打印到屏幕上。
that prints stuff out onto the screen.

503
00:25:20,470 --> 00:25:24,270
但这本身就是一个非常强大的工具
But that in and of itself is a wonderfully powerful tool

504
00:25:24,269 --> 00:25:26,819
通过它您可以查找代码中的问题。
via which you can chase down problems in your code.

505
00:25:26,819 --> 00:25:29,939
即使我们在几周后离开C并介绍
And even after we leave C in a few weeks and introduce

506
00:25:29,940 --> 00:25:33,690
Python和其他语言，几乎所有的编程语言都可以
Python and other languages, almost every programming language out there

507
00:25:33,690 --> 00:25:35,460
具有某种形式的printf。
has some form of printf.

508
00:25:35,460 --> 00:25:36,480
也许叫做打印。
Maybe it's called print.

509
00:25:36,480 --> 00:25:38,940
也许像在Scratch中那样被称为说，
Maybe it's called say, as it was in Scratch,

510
00:25:38,940 --> 00:25:43,780
但具有向人类显示信息或向他人展示信息的能力。
but some ability to display information or present information to a human.

511
00:25:43,779 --> 00:25:47,699
因此，让我们尝试使用这种基本形式，即打印f的概念，
So let's try to use this primitive, this notion of print f,

512
00:25:47,700 --> 00:25:49,760
追查一个人的代码中的错误。
to chase down a bug in one's code.

513
00:25:49,759 --> 00:25:52,949
因此，让我继续并故意编写一个有问题的程序。
So let me go ahead and deliberately write a buggy program.

514
00:25:52,950 --> 00:25:56,570
我什至将文件称为buggy0.c。
I'm going to even call the file buggy0.c.

515
00:25:56,569 --> 00:26:01,229
在此文件的顶部，我将继续执行#include stdio.h。
And at the top of this file, I'm going to go ahead and #include stdio.h.

516
00:26:01,230 --> 00:26:03,810
不需要CS50库。
No need for the CS50 library for this one.

517
00:26:03,809 --> 00:26:06,959
然后我要去做int main（void），这是我们上周看到的，
And then I'm going to do int main(void), which we saw last week,

518
00:26:06,960 --> 00:26:08,700
我们今天将更详细地解释。
and we'll explain in more detail today.

519
00:26:08,700 --> 00:26:10,260
然后我要给自己一个快速循环。
And then I'm going to give myself a quick loop.

520
00:26:10,259 --> 00:26:12,989
我只想继续打印出来，哦，我不知道，就像，
I just want to go ahead and print out, oh, I don't know, like,

521
00:26:12,990 --> 00:26:14,580
屏幕上有10个散列。
10 hashes on the screen.

522
00:26:14,579 --> 00:26:17,429
所以我想打印一个垂直列，有点像
So I want to print a vertical column, kind of like one

523
00:26:17,430 --> 00:26:20,190
超级马里奥兄弟（Super Mario Bros.）而非金字塔的屏幕截图中，
of those screenshots from Super Mario Bros., not a pyramid,

524
00:26:20,190 --> 00:26:23,020
仅一列哈希，其中有10个。
just a single column of hashes, and 10 of them.

525
00:26:23,019 --> 00:26:25,829
所以我要做类似int i = 0的事情，
So I'm going to do something like, int i = 0,

526
00:26:25,829 --> 00:26:28,139
因为我觉得我在课堂上学到一般
because I feel like I learned in class that I generally

527
00:26:28,140 --> 00:26:29,562
应该从0开始计数。
should start counting from 0.

528
00:26:29,561 --> 00:26:31,769
然后，我将在此for循环中获取条件。
Then I'm going to have my condition in this for loop.

529
00:26:31,769 --> 00:26:33,189
我想做10次。
And I want to do this 10 times.

530
00:26:33,190 --> 00:26:35,200
我将执行小于或等于10的操作。
I'm going to do it less than or equal to 10.

531
00:26:35,200 --> 00:26:37,242
然后我要继续增加我的体重，
Then I'm going to go ahead and have my increment,

532
00:26:37,241 --> 00:26:39,477
可以很简单地表示为i ++。
which quite simply can be expressed as i++.

533
00:26:39,478 --> 00:26:42,270
然后在这个循环中，我将继续进行打印
And then inside this loop, I'm just going to go ahead and print out

534
00:26:42,269 --> 00:26:44,969
单个哈希值后接换行。
a single hash followed by a new line.

535
00:26:44,970 --> 00:26:46,680
我要保存程序。
I'm going to save the program.

536
00:26:46,680 --> 00:26:51,870
我将使用clang -o buggy0 buggy0--进行编译
I'm going to compile it with clang -o buggy0 buggy0--

537
00:26:51,869 --> 00:26:52,767
我的意思是
I mean, no.

538
00:26:52,768 --> 00:26:54,810
您不必以这种方式手动使用Clang。
You don't have to use Clang manually in this way.

539
00:26:54,809 --> 00:26:58,452
只是将其抽象化，要简单得多-
It's a lot simpler to just abstract that away--

540
00:26:58,452 --> 00:26:59,369
那不是命令
that's not a command--

541
00:26:59,369 --> 00:27:03,329
将其抽象并运行，使buggy0。
to abstract that away and run make buggy0.

542
00:27:03,329 --> 00:27:07,474
并且make将为您处理调用Clang的过程。
And make will take care of the process of invoking Clang for you.

543
00:27:07,474 --> 00:27:08,849
我要继续运行它。
I'm going to go ahead and run it.

544
00:27:08,849 --> 00:27:12,289
似乎编译成功，因此无需帮助50。
Seems to be compiling successfully, so no need for help50.

545
00:27:12,289 --> 00:27:13,889
它的样式已经很不错了。
It's already pretty well styled.

546
00:27:13,890 --> 00:27:18,420
实际上，如果我在此buggy0上运行style50，则还没有任何评论。
In fact, if I run style50 on this buggy0, I don't have any comments yet.

547
00:27:18,420 --> 00:27:20,490
但是至少它看起来非常缩进。
But at least it looks very nicely indented.

548
00:27:20,490 --> 00:27:22,000
所以我认为我可以。
So I think I'm OK with that.

549
00:27:22,000 --> 00:27:25,529
但让我添加该评论并执行“打印10个散列”
But let me add that comment and do "Print 10 hashes" just

550
00:27:25,529 --> 00:27:27,119
提醒自己我的目标。
to remind myself of my goal.

551
00:27:27,119 --> 00:27:31,289
现在让我继续运行此文件，./buggy0，Enter。
And now let me go ahead and run this, ./buggy0, Enter.

552
00:27:31,289 --> 00:27:32,669
我知道了，好的。
And I see, OK, good.

553
00:27:32,670 --> 00:27:38,147
我认为是1、2、3、4、5、6、7、8、9、10、11。
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, I think.

554
00:27:38,146 --> 00:27:39,479
好的，这是一个愚蠢的错误。
All right, so it's a stupid bug.

555
00:27:39,480 --> 00:27:41,970
也许它明显跳了出来给你们中的一些人。
And maybe it's jumped out obviously to some of you.

556
00:27:41,970 --> 00:27:44,220
但也许对您的其他人来说有些微妙。
But maybe it's a little more subtle to others of you.

557
00:27:44,220 --> 00:27:45,250
但是，您从哪里开始呢？
But where do you begin?

558
00:27:45,250 --> 00:27:46,830
假设我要运行check50。
Suppose I were to run check50.

559
00:27:46,829 --> 00:27:51,569
Check50表示，不，您打印了11个散列而不是10个。
And check50 were to say, nope, you printed out 11 hashes instead of 10.

560
00:27:51,569 --> 00:27:54,209
但是我的代码对我来说似乎是正确的，至少乍一看。
But my code looks right to me, at least at first glance.

561
00:27:54,210 --> 00:27:57,220
好吧，我该如何进行调试或解决呢？
Well, how can I go about debugging this or solving this?

562
00:27:57,220 --> 00:27:58,780
好吧，printf再次是您的朋友。
Well, again, printf is your friend.

563
00:27:58,779 --> 00:28:01,559
如果您想进一步了解自己的程序，
If you want to understand more about your own program,

564
00:28:01,559 --> 00:28:05,459
使用printf将更多信息临时打印到屏幕上，
use printf to temporarily print more information to the screen,

565
00:28:05,460 --> 00:28:08,790
不是我们想要的最终版本，不是您的TF想要看到的，
not that we want in the final version, not that your TF wants to see,

566
00:28:08,789 --> 00:28:11,339
但是您，程序员，可以暂时看到。
but that you, the programmer, can temporarily see.

567
00:28:11,339 --> 00:28:14,039
因此，在我打印此哈希之前，请先打印一些内容
So before I print this hash, let me print something

568
00:28:14,039 --> 00:28:15,899
有点像这样的书呆子
a little more pedantic like this--

569
00:28:15,900 --> 00:28:19,950
“我现在是％i反斜杠n。”
"i is now %i backslash n."

570
00:28:19,950 --> 00:28:25,440
所以我从字面上想知道，仅就我自己的心理数学而言，我的价值是什么
So I literally want to know, just for my own mental math, what is the value of i

571
00:28:25,440 --> 00:28:28,230
在此之前，我打印该哈希？
at this point before I print that hash?

572
00:28:28,230 --> 00:28:30,480
现在，我将继续粘贴i的值。
Now I'm going to go ahead and paste in the value of i.

573
00:28:30,480 --> 00:28:32,640
因此，我将％i用作占位符。
So I'm using %i as a placeholder.

574
00:28:32,640 --> 00:28:35,100
我插入变量i的值。
I'm plugging in the value of the variable i.

575
00:28:35,099 --> 00:28:36,869
我现在要保存我的代码。
I'm going to save my code now.

576
00:28:36,869 --> 00:28:39,749
我将使用make buggy0重新编译它。
I'm going to recompile it with make buggy0.

577
00:28:39,750 --> 00:28:41,379
我现在要重新运行它。
And I'm going to rerun it now.

578
00:28:41,380 --> 00:28:43,680
让我继续增加窗口的大小
And let me go ahead and increase the size of my window

579
00:28:43,680 --> 00:28:46,390
这样我们现在就可以专注于输出了。
just so we can focus now on the output.

580
00:28:46,390 --> 00:28:50,440
我要继续./buggy0，回车。
And I'm going to go ahead and ./buggy0, Enter.

581
00:28:50,440 --> 00:28:53,670
好的，所以现在我不仅看到我的输出，还看到了
OK, so now I see not only my output, but also

582
00:28:53,670 --> 00:28:56,670
与该输出混合，如果需要的话，可以提供一些诊断输出，
commingled with that output, some diagnostic output, if you will,

583
00:28:56,670 --> 00:28:58,080
一些调试输出。
some debugging output.

584
00:28:58,079 --> 00:29:02,429
而且只是在学问上告诉我，“ i现在为0”，“ i现在为1”。
And it's just more pedantically telling me, "i is now 0," "i is now 1,"

585
00:29:02,430 --> 00:29:08,490
“我现在是2，”点，点，点，“我现在是9”，“我现在是10”。
"i is now 2," dot, dot, dot, "i is now 9," "i is now 10."

586
00:29:08,490 --> 00:29:11,040
好吧，我不讨厌我10岁。
OK, I don't hate the fact that i is 10.

587
00:29:11,039 --> 00:29:15,629
但我不喜欢这样的事实：如果我从0开始并打印一个哈希，
But I'm not loving the fact that if I started at 0 and printed a hash,

588
00:29:15,630 --> 00:29:19,140
而且我达到10并打印另一个哈希，很明显，
and I'm hitting 10 and printing another hash, well, obviously,

589
00:29:19,140 --> 00:29:20,180
这是我的问题。
there's my problem.

590
00:29:20,180 --> 00:29:22,620
所以可能还没有那么明显
So it might not have been all that much more obvious

591
00:29:22,619 --> 00:29:24,029
而不是看代码本身。
than looking at the code itself.

592
00:29:24,029 --> 00:29:27,089
但是通过使用printf，您可以更加清楚
But by using printf, you can just be a lot more clear

593
00:29:27,089 --> 00:29:28,899
对自己来说，这是怎么回事。
to yourself what's going on.

594
00:29:28,900 --> 00:29:32,490
因此，如果现在我看到，好吧，如果我从0开始，则必须上升到10。
So if now I see, OK, well, if I start at 0, I have to go up to 10.

595
00:29:32,490 --> 00:29:35,100
我可以更改代码以使其小于10。
I could change my code to do this to be less than 10.

596
00:29:35,099 --> 00:29:38,039
我可以不理会它，从1跳到10。
I could leave that alone and go from 1 through 10.

597
00:29:38,039 --> 00:29:41,919
但同样，程序员的惯例是从0到10。
But again, programmer convention would be to go from 0 up to 10.

598
00:29:41,920 --> 00:29:43,140
所以我认为我现在很好。
So I think I'm good now.

599
00:29:43,140 --> 00:29:46,662
实际上，现在我将继续进行编译，生成buggy0。
And in fact, now I'll go ahead and recompile this, make buggy0.

600
00:29:46,662 --> 00:29:49,620
让我继续并再次增加窗口的大小，以便
Let me go ahead and increase the size of the window again just so I can

601
00:29:49,619 --> 00:29:53,979
暂时看到这个和./buggy0。
temporarily see this and ./buggy0.

602
00:29:53,980 --> 00:29:57,460
好的，我现在从0、1、2，点，点，点开始。
OK, I start now at 0, 1, 2, dot, dot, dot.

603
00:29:57,460 --> 00:29:59,160
现在我停在9点。
Now I stop at 9.

604
00:29:59,160 --> 00:30:01,080
当然，这给了我10个哈希值。
And that, of course, gives me 10 hashes.

605
00:30:01,079 --> 00:30:03,342
再说一遍，我在最终输出中不需要这个。
So again, I don't need this in the final output.

606
00:30:03,343 --> 00:30:05,010
我要继续删除它。
And I'm to go ahead and delete this now.

607
00:30:05,009 --> 00:30:06,509
它是临时输出。
It's temporary output.

608
00:30:06,509 --> 00:30:08,759
但是再说一次，拥有这些直觉-如果您不完全
But again, having those instincts-- if you don't quite

609
00:30:08,759 --> 00:30:12,119
了解为什么您的代码正在编译但无法正常运行，
understand why your code is compiling but not running properly,

610
00:30:12,119 --> 00:30:15,359
而您想更好地了解计算机清楚地看到了什么，
and you want to better see what the computer is clearly seeing,

611
00:30:15,359 --> 00:30:18,929
它的心灵之眼，使用printf只是告诉自己
its mind eye, use printf to just tell yourself

612
00:30:18,930 --> 00:30:23,790
在代码中的任何位置，一个或多个变量的值是多少
what the value of some variable or variables are anywhere in your code

613
00:30:23,789 --> 00:30:26,731
您想了解更多细节。
that you want to see a little more detail.

614
00:30:26,731 --> 00:30:28,439
好吧，让我暂停片刻
All right, let me pause for just a moment

615
00:30:28,440 --> 00:30:32,220
看看仅使用printf的这项技术是否有任何疑问
to see if there's any questions on this technique of just using printf

616
00:30:32,220 --> 00:30:37,830
开始调试代码并查看变量的值
to begin to debug your code and to see the values of variables

617
00:30:37,829 --> 00:30:40,559
在某种程度上更明确。
in a way that's a little more explicit.

618
00:30:43,980 --> 00:30:44,580
不？
No?

619
00:30:44,579 --> 00:30:45,669
好的。
All right.

620
00:30:45,670 --> 00:30:50,130
好吧，让我提出一个更强大的工具
Well, let me propose an even more powerful tool that admittedly

621
00:30:50,130 --> 00:30:51,480
需要一点时间来适应。
takes a little getting used to.

622
00:30:51,480 --> 00:30:54,000
但这只是其中的一课，
But this is kind of one of those lessons,

623
00:30:54,000 --> 00:30:58,349
如果可以的话，请相信我，如果您再花几分钟的时间，甚至
trust me, if you will, that if you spend a few more minutes, maybe even

624
00:30:58,349 --> 00:31:01,319
这个星期一个小时左右，学习以下工具，
an hour or so this week, learning the following tool,

625
00:31:01,319 --> 00:31:04,499
您将节省自己的时间，甚至可以节省多个时间
you will save yourself hours, plural, maybe even

626
00:31:04,500 --> 00:31:07,439
在接下来的几个星期中要花费数十个小时
tens of hours over the course of the next many weeks

627
00:31:07,440 --> 00:31:12,520
因为此工具可以帮助您真正了解代码内部的情况。
because this tool can help you truly see what's going on inside of your code.

628
00:31:12,519 --> 00:31:15,869
因此，我们今天将要添加到列表中的该工具称为debug50。
So this tool we're going to add to the list today is called debug50.

629
00:31:15,869 --> 00:31:20,129
虽然这确实以50结尾，这意味着它是CS50工具，
And while this one does end with 50, implying that it's a CS50 tool,

630
00:31:20,130 --> 00:31:24,450
它建立在称为GDB（即GNU）的行业标准工具之上
it's built on top of an industry standard tool known as GDB, the GNU

631
00:31:24,450 --> 00:31:27,960
DeBugger，这是许多不同计算机系统的标准工具
DeBugger, that's a standard tool that a lot of different computer systems

632
00:31:27,960 --> 00:31:32,520
用于为您提供以更复杂的方式调试代码的功能
use to provide you with the ability to debug your code in a more sophisticated

633
00:31:32,519 --> 00:31:35,529
不仅仅是单独使用printf。
way than just using printf alone.

634
00:31:35,529 --> 00:31:36,779
因此，让我们继续执行此操作。
So let's go ahead and do this.

635
00:31:36,779 --> 00:31:39,359
让我回到该程序的错误版本
Let me go back to the buggy version of this program

636
00:31:39,359 --> 00:31:43,619
回想一下，这让我从0跳到10，这是太多步骤了。
which, recall, had me going from 0 through 10, which was too many steps.

637
00:31:43,619 --> 00:31:47,849
刚才，我建议我们只使用printf来查看i的值。
A moment ago, I proposed that we just use printf to see the value of i.

638
00:31:47,849 --> 00:31:50,639
但坦率地说，我们的程序越大，越复杂
But frankly, the bigger our programs get, the more complicated

639
00:31:50,640 --> 00:31:53,730
他们得到了，他们需要在屏幕上获得更多的输出。
they get, the more output they need to have on the screen.

640
00:31:53,730 --> 00:31:56,250
很快就会变得非常混乱
It's just going to get very messy quickly

641
00:31:56,250 --> 00:31:58,799
如果您要打印出不应该存在的内容，对吗？
if you're printing out stuff that shouldn't be there, right?

642
00:31:58,799 --> 00:31:59,909
回想一下马里奥。
Think back to Mario.

643
00:31:59,910 --> 00:32:03,060
马里奥的金字塔就是这种图形输出。
Mario's pyramid is this sort of graphical output.

644
00:32:03,059 --> 00:32:07,859
而且它很快就会变得丑陋，并且很难理解您的金字塔
And it would very quickly get ugly and kind of hard to understand your pyramid

645
00:32:07,859 --> 00:32:11,519
如果您要将金字塔与printf的实际文本输出混为一谈
if you're comingling that pyramid with actual textual output from printf

646
00:32:11,519 --> 00:32:12,429
也一样
as well.

647
00:32:12,430 --> 00:32:16,560
因此，debug50，然后是任何语言的调试器，
So debug50, and in turn a debugger in any language,

648
00:32:16,559 --> 00:32:20,579
是一个允许您逐步运行代码的工具
is a tool that allows you to run your code step by step

649
00:32:20,579 --> 00:32:26,549
并查看计算机内部的变量和其他内存的内部
and look inside of variables and other pieces of memory inside of the computer

650
00:32:26,549 --> 00:32:28,079
在您的程序运行时。
while your program is running.

651
00:32:28,079 --> 00:32:31,799
现在，几乎我们运行的每个程序都需要一秒钟的时间才能运行。
Right now, pretty much every program we run takes a split second to run.

652
00:32:31,799 --> 00:32:34,169
那对我（人类）来说太快了，我无法全神贯注
That's way too fast for me, the human, to wrap my mind

653
00:32:34,170 --> 00:32:36,330
围绕逐步进行的事情。
around what's going on step by step.

654
00:32:36,329 --> 00:32:38,549
调试器可让您运行程序，
A debugger allows you to run your program,

655
00:32:38,549 --> 00:32:42,969
但要一步一步一步，所以您可以看到发生了什么。
but much more slowly, step by step, so you can see what's going on.

656
00:32:42,970 --> 00:32:48,030
所以我现在要继续并运行debug50 ./hello。
So I'm going to go ahead now and run debug50 ./hello.

657
00:32:48,029 --> 00:32:52,379
不，抱歉，debug50 ./buggy0。
No, sorry, debug50 ./buggy0.

658
00:32:52,380 --> 00:32:54,900
所以我先写一个debug50，一个空格，然后
So I write debug50 first, a space, and then

659
00:32:54,900 --> 00:32:56,910
点斜杠和该程序的名称
dot slash and the name of the program that's

660
00:32:56,910 --> 00:32:59,785
已经编译，我想调试。
already compiled that I want to debug.

661
00:32:59,785 --> 00:33:01,410
因此，我将继续并按Enter。
So I'm going to go ahead and hit Enter.

662
00:33:01,410 --> 00:33:03,240
并请注意，哦，这很聪明。
And notice that, oh, it was smart.

663
00:33:03,240 --> 00:33:05,100
它注意到我更改了代码。
It noticed that I changed my code.

664
00:33:05,099 --> 00:33:06,059
我刚才做了。
And I did a moment ago.

665
00:33:06,059 --> 00:33:07,739
我将其还原为越野车版本。
I reverted it back to the buggy version.

666
00:33:07,740 --> 00:33:10,380
因此，让我解决此问题-制作buggy0。
So let me fix this-- make buggy0.

667
00:33:10,380 --> 00:33:11,620
好的，没有错误。
All right, no errors.

668
00:33:11,619 --> 00:33:13,499
现在让我继续并再次运行debug50。
Now let me go ahead and run debug50 again.

669
00:33:13,500 --> 00:33:17,279
而且，如果您还没有注意到这一点，有时我似乎会快速输入疯子。
And if you haven't noticed this already, sometimes I seem to type crazy fast.

670
00:33:17,279 --> 00:33:19,179
我不一定要打字那么快。
I'm not necessarily typing that fast.

671
00:33:19,180 --> 00:33:21,960
我正在回顾CS50 IDE的历史。
I'm going through my history in CS50 IDE.

672
00:33:21,960 --> 00:33:25,470
使用向上和向下箭头键，可以向后滚动
Using your arrow keys, Up and Down, you can scroll back

673
00:33:25,470 --> 00:33:29,070
及时处理您过去几分钟输入的所有命令
in time for all of the commands you've typed over the past few minutes

674
00:33:29,069 --> 00:33:30,429
甚至数小时甚至数天。
or hours or even days.

675
00:33:30,430 --> 00:33:32,430
这将开始为您节省击键次数。
And this will just start to save you keystrokes.

676
00:33:32,430 --> 00:33:33,870
所以我将继续前进。
So I'm going to go ahead and hit Up.

677
00:33:33,869 --> 00:33:36,494
现在，我不必再打整个命令。
And now I don't have to bother typing this whole command again.

678
00:33:36,494 --> 00:33:38,319
这是节省时间的有用方法。
It's a helpful way to just save time.

679
00:33:38,319 --> 00:33:40,799
我现在要进入并按Enter。
I'm going to go head in now and hit Enter.

680
00:33:40,799 --> 00:33:43,649
现在请注意此错误消息-
And now notice this error message--

681
00:33:43,650 --> 00:33:45,050
我没有设置任何断点。
I haven't set any breakpoints.

682
00:33:45,049 --> 00:33:48,299
“通过单击行号左侧的至少一个断点，然后
"Set at least one breakpoint by clicking to the left of a line number and then

683
00:33:48,299 --> 00:33:49,499
重新运行debug50！”
re-run debug50!"

684
00:33:49,500 --> 00:33:51,419
好吧，这是怎么回事？
Well, what's going on here?

685
00:33:51,420 --> 00:33:55,620
好吧，debug50需要我提前告诉计算机在哪一行
Well, debug50 needs me to tell the computer in advance at what line

686
00:33:55,619 --> 00:33:59,909
我想闯入一步一步来。
I want to break into and step through step by step.

687
00:33:59,910 --> 00:34:01,020
所以，我可以做到。
So, I can do that.

688
00:34:01,019 --> 00:34:03,779
正如我所说的，我将在这里转到文件的一侧。
I'm going to go over to the side of the file here, as it says.

689
00:34:03,779 --> 00:34:04,529
你知道吗？
And you know what?

690
00:34:04,529 --> 00:34:08,459
第一个有趣的行是这里的第6行。
The first interesting line is this one here, line 6.

691
00:34:08,460 --> 00:34:12,060
因此，我点击了屏幕左侧的所谓的装订线，
So I clicked in the so-called gutter, the left-hand side of the screen,

692
00:34:12,059 --> 00:34:13,169
在第6行。
on line 6.

693
00:34:13,170 --> 00:34:16,139
并自动在该处放置一个红点，例如停车标志。
And that automatically put a red dot there, like a stop sign.

694
00:34:16,139 --> 00:34:21,420
现在，最后一次，我要继续运行debug50 ./buggy0并点击
Now, one last time, I'm going to go ahead and run debug50 ./buggy0 and hit

695
00:34:21,420 --> 00:34:21,960
进入。
Enter.

696
00:34:21,960 --> 00:34:25,887
现在请注意，该新面板在右侧打开。
And now notice this fancy new panel opens up on the right-hand side.

697
00:34:25,887 --> 00:34:27,929
首先，它看起来有些神秘。
And it's going to look a little cryptic at first.

698
00:34:27,929 --> 00:34:30,219
但是，让我们考虑一下屏幕上发生了什么变化。
But let's consider what has changed on the screen.

699
00:34:30,219 --> 00:34:34,440
现在注意，以这种黄色以外的颜色突出显示的是第6行。
Notice now that highlighted in this sort of off-yellow color is line 6.

700
00:34:34,440 --> 00:34:37,949
那是因为debug50所做的是正在运行我的程序，
And that's because what debug50 is doing is it's running my program,

701
00:34:37,949 --> 00:34:41,610
但它已在第6行暂停了执行。
but it has paused execution on line 6.

702
00:34:41,610 --> 00:34:44,100
这样就完成了从第1行到第5行的所有操作
So it's done everything from line 1 through 5,

703
00:34:44,099 --> 00:34:46,859
但现在它在6号线上等着我。
but now it's waiting for me on line 6.

704
00:34:46,860 --> 00:34:49,620
这里有趣的是-让
And what's interesting over here is this-- let

705
00:34:49,619 --> 00:34:51,928
我在这里放大此窗口。
me zoom in on this window over here.

706
00:34:51,929 --> 00:34:54,150
诚然，这里发生了很多事情。
And there's a lot going on here, admittedly.

707
00:34:54,150 --> 00:34:59,190
但是，让我们暂时只关注Watch Expressions，而不是Call Stack，
But let's focus for just a moment not on Watch Expressions, not on Call Stack,

708
00:34:59,190 --> 00:35:00,850
但仅适用于局部变量。
but only on Local Variables.

709
00:35:00,849 --> 00:35:04,379
注意，我有一个名为i的变量，其初始值为0，
And notice, I have a variable called i whose initial value is 0,

710
00:35:04,380 --> 00:35:05,820
它是int类型的。
and it's of type int.

711
00:35:05,820 --> 00:35:09,150
现在，这很有趣，因为请注意我可以通过这些图标执行的操作
Now, this is kind of interesting because watch what I can do via these icons

712
00:35:09,150 --> 00:35:09,930
上面这儿。
up here.

713
00:35:09,929 --> 00:35:15,359
我可以单击“跳过”行，然后开始逐步执行我的代码行
I can click on this Step Over line and start to step through my code line

714
00:35:15,360 --> 00:35:16,007
按行。
by line.

715
00:35:16,007 --> 00:35:17,340
因此，让我继续进行缩小。
So let me go ahead and zoom out.

716
00:35:17,340 --> 00:35:18,870
让我继续，然后单击“跳过”。
Let me go ahead and click Step Over.

717
00:35:18,869 --> 00:35:21,179
并观察黄色突出显示会发生什么。
And watch what happens to the yellow highlighting.

718
00:35:21,179 --> 00:35:23,139
它向下移动到下一行。
It moves down to the next line.

719
00:35:23,139 --> 00:35:27,089
但是请注意，如果我在此处再次放大，则i的值没有改变。
But notice, if I zoom in again up here, the value of i has not changed.

720
00:35:27,090 --> 00:35:29,460
现在让我继续前进。
Now let me go ahead and step over again.

721
00:35:29,460 --> 00:35:31,740
并注意黄色突出显示加倍。
And notice the yellow highlighting doubles back.

722
00:35:31,739 --> 00:35:33,789
这是有道理的，因为我处于循环中。
That makes sense because I'm in a loop.

723
00:35:33,789 --> 00:35:36,759
因此它应该来回走动。
So it should be going back and forth, back and forth.

724
00:35:36,760 --> 00:35:38,123
但是接下来会发生什么呢？
But what next happens in a loop?

725
00:35:38,123 --> 00:35:40,290
每当您回到循环的开始，
Every time you go back to the beginning of the loop,

726
00:35:40,289 --> 00:35:43,769
请记住，您的增量发生了，例如i ++。
remember that your incrementation happens, like the i++.

727
00:35:43,769 --> 00:35:46,529
因此，现在在右上角仔细观看，
So watch now closely in the top right-hand corner,

728
00:35:46,530 --> 00:35:52,110
当我现在跳过时，请注意调试器中i的值
when I Step Over now, notice that the value of i in my debugger

729
00:35:52,110 --> 00:35:54,058
刚刚更改为1。
has just been changed to 1.

730
00:35:54,057 --> 00:35:55,349
因此，我不必使用printf。
So I didn't have to use printf.

731
00:35:55,349 --> 00:35:57,399
我不必弄乱屏幕的输出。
I didn't have to mess up the output of my screen.

732
00:35:57,400 --> 00:35:59,850
我可以在这个GUI中看到这个图形用户
I can literally see in this GUI, this Graphical User

733
00:35:59,849 --> 00:36:02,789
在右侧的界面上，i的值是多少。
Interface on the right-hand side, what the value of i is.

734
00:36:02,789 --> 00:36:05,309
现在，如果我开始快速点击一下，
Now if I just start clicking a little more quickly,

735
00:36:05,309 --> 00:36:09,899
请注意，在循环执行一次又一次时，i的值
notice that as the loop is executing, again and again, the value of i

736
00:36:09,900 --> 00:36:11,070
不断更新。
keeps getting updated.

737
00:36:11,070 --> 00:36:11,820
你知道吗？
And you know what?

738
00:36:11,820 --> 00:36:15,930
我敢打赌，即使我们从0开始，如果我做了足够多次，
I bet, even though we started at 0, if I do this enough times,

739
00:36:15,929 --> 00:36:18,989
我将看到该值现在是10，因此
I will see that the value is 10 now, thereby

740
00:36:18,989 --> 00:36:25,109
在底部再给我一个printf，从而解释了11个哈希值
giving me another printf at the bottom, thereby explaining the 11 total hashes

741
00:36:25,110 --> 00:36:25,950
我看到的。
that I saw.

742
00:36:25,949 --> 00:36:28,449
因此，我在这里没有任何新信息。
So I haven't gotten any new information here.

743
00:36:28,449 --> 00:36:30,959
但是请注意，我已经获得了无动于衷的信息。
But notice I've gotten unperturbed information.

744
00:36:30,960 --> 00:36:35,370
我并没有杂乱无章地打印出所有这些printf语句
I've not messily and sloppily printed out all of these printf statements

745
00:36:35,369 --> 00:36:36,099
屏幕上。
on the screen.

746
00:36:36,099 --> 00:36:38,429
我只是有条不紊地看着
I'm just kind of watching a little more methodically

747
00:36:38,429 --> 00:36:43,229
右上角的变量状态发生了什么。
what's happening to the state of my variable over on the top right there.

748
00:36:43,230 --> 00:36:47,700
好吧，我也要在这里暂停一下，看看对什么有任何疑问
All right, let me pause here too to see if there's any questions on what

749
00:36:47,699 --> 00:36:49,229
该调试器可以。
this debugger does.

750
00:36:49,230 --> 00:36:51,150
同样，您可以编译代码。
Again, you compile your code.

751
00:36:51,150 --> 00:36:56,340
您可以在代码上运行debug50，但只有在设置了所谓的断点之后，
You run debug50 on your code, but only after setting a so-called breakpoint,

752
00:36:56,340 --> 00:37:00,575
您在哪里预先决定要在哪里暂停执行代码。
where you decide in advance where do you want to pause execution of your code.

753
00:37:00,574 --> 00:37:03,449
即使我在程序开始时就做了很多，
Even though here I did it pretty much at the beginning of my program,

754
00:37:03,449 --> 00:37:05,241
对于更大的程序，它将是超级
for bigger programs, it's going to be super

755
00:37:05,242 --> 00:37:07,718
方便在代码中途暂停
convenient to be able to pause halfway through your code

756
00:37:07,717 --> 00:37:09,509
而不必经历整个过程。
and not have to go through the whole thing.

757
00:37:09,510 --> 00:37:11,430
彼得，问题。
Peter, question.

758
00:37:11,429 --> 00:37:16,349
PETER：关于调试器，Step Over有什么区别
PETER: About the debugger, what's the difference between Step Over

759
00:37:16,349 --> 00:37:18,812
然后进入并退出，并且-
and Step Into and Step Out and--

760
00:37:18,813 --> 00:37:20,230
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

761
00:37:20,230 --> 00:37:21,980
让我回到片刻，
Let me come back to that in just a moment,

762
00:37:21,980 --> 00:37:25,800
因为我们将再做一个示例，其中实际上是“跳入”和“跳出”
because we'll do one other example where Step Into and Step Out actually

763
00:37:25,800 --> 00:37:27,520
是紧密联系的。
are germane.

764
00:37:27,519 --> 00:37:28,489
但是在我们这样做之前。
But before we do that.

765
00:37:28,489 --> 00:37:33,519
在我们了解Step Into和Step之前，还有其他关于debug50的问题。
Any other questions about debug50 before we reveal what Step Into and Step

766
00:37:33,519 --> 00:37:35,334
为我们做的也结束了吗？
Over do for us as well?

767
00:37:38,940 --> 00:37:39,910
哦那好吧。
Oh, all right.

768
00:37:39,909 --> 00:37:42,309
好吧，让我们来看看彼得的问题。
Well, let's take Peter's question right there.

769
00:37:42,309 --> 00:37:44,704
现在让我继续前进，退出调试器。
Let me go ahead now and get out of the debugger.

770
00:37:44,704 --> 00:37:46,829
老实说，我看不出一种明显的出路
And honestly, I don't see an obvious way to get out

771
00:37:46,829 --> 00:37:48,489
目前的调试器。
of the debugger at the moment.

772
00:37:48,489 --> 00:37:51,239
但是Control-C也是您今天的新朋友。
But Control-C is your new friend today too.

773
00:37:51,239 --> 00:37:53,699
几乎在您失去程序控制权的任何时候
Pretty much any time you lose control of a program

774
00:37:53,699 --> 00:37:56,879
因为调试器正在运行，您对此失去了兴趣。
because the debugger's running, and you've lost interest in it.

775
00:37:56,880 --> 00:37:58,770
也许是上周，您编写了一个程序
Or maybe last week, you wrote a program that

776
00:37:58,769 --> 00:38:01,799
有一个无限循环，不断循环，
has an infinite loop that just keeps going and going and going,

777
00:38:01,800 --> 00:38:04,110
Control-C将退出该程序。
Control-C will break out of that program.

778
00:38:04,110 --> 00:38:07,290
但是，让我们现在快速编写另一个程序，这次，
But let's now write quickly another program that, this time,

779
00:38:07,289 --> 00:38:08,429
有第二个功能。
has a second function.

780
00:38:08,429 --> 00:38:10,799
今天，我们将看到调试器的另一功能。
And we'll see one other feature of the debugger today.

781
00:38:10,800 --> 00:38:14,520
我将继续创建一个新文件，现在称为buggy1.c。
I'm going to go ahead and create a new file now called buggy1.c.

782
00:38:14,519 --> 00:38:16,469
同样，这将是故意存在的缺陷。
Again, it's going to be deliberately flawed.

783
00:38:16,469 --> 00:38:20,279
但这次我将首先进行#includecs50.h。
But I'm going to first going to go ahead and #include cs50.h this time.

784
00:38:20,280 --> 00:38:22,830
我要去#include stdio.h。
And I'm going to #include stdio.h.

785
00:38:22,829 --> 00:38:24,589
我要做int main void。
I'm going to do int main void.

786
00:38:24,590 --> 00:38:27,090
我将继续进行以下操作-给我自己
And I'm going to go ahead and do the following-- give myself

787
00:38:27,090 --> 00:38:28,380
称为i的变量。
a variable called i.

788
00:38:28,380 --> 00:38:31,290
我将尝试通过调用来获取负整数
And I'm going to try to get a negative int by calling

789
00:38:31,289 --> 00:38:33,179
一个名为get_negative_int的函数。
a function called get_negative_int.

790
00:38:33,179 --> 00:38:37,739
然后，很简单，我将打印出该值“％i反斜杠n”，
And then quite simply, I'm going to print out this value, "%i backslash n",

791
00:38:37,739 --> 00:38:39,209
我，分号。
i, semicolon.

792
00:38:39,210 --> 00:38:40,860
现在，只有一个问题-
Now, there's only one problem--

793
00:38:40,860 --> 00:38:43,210
get_negative_int不存在。
get_negative_int does not exist.

794
00:38:43,210 --> 00:38:45,870
因此，就像上周我们在其中实现get_positive_int一样，
So like last week, where we implemented get_positive_int,

795
00:38:45,869 --> 00:38:47,789
这周，我将实现get_negative_int。
this week, I'll implement get_negative_int.

796
00:38:47,789 --> 00:38:49,889
但是我一开始会做的不正确。
But I'm going to do it incorrectly at first.

797
00:38:49,889 --> 00:38:54,299
现在，顾名思义，get_negative_int需要返回一个整数。
Now, get_negative_int, as the name implies, needs to return an integer.

798
00:38:54,300 --> 00:38:57,330
即使我们在上周只花了很短的时间，
And even though we only spent brief time on this last week,

799
00:38:57,329 --> 00:39:00,209
回想一下，您可以指定函数的输出，
recall that you can specify the output of a function,

800
00:39:00,210 --> 00:39:03,720
您编写的自定义函数，即所谓的return
a custom function that you wrote, by putting its so-called return

801
00:39:03,719 --> 00:39:05,554
值首先在此行。
value first on this line.

802
00:39:05,554 --> 00:39:08,429
然后，您可以输入函数名称，例如get_negative_int，
And then you can put the name of the function, like get_negative_int,

803
00:39:08,429 --> 00:39:11,939
然后在括号中，您可以将输入内容放到函数中。
and then in parentheses, you can put the input to the function.

804
00:39:11,940 --> 00:39:15,030
但是，如果不输入任何内容，您可以直接写上“ void”一词，
But if it takes no input, you can literally write the word "void,"

805
00:39:15,030 --> 00:39:17,965
这是一个艺术术语，仅表示没有任何内容。
which is a term of art that just means, nothing goes here.

806
00:39:17,965 --> 00:39:20,340
我现在要继续执行get_negative_int。
I'm going to go ahead now and implement get_negative_int.

807
00:39:20,340 --> 00:39:22,920
坦率地说，我认为这将与上周非常相似。
And frankly, I think it's going to be pretty similar to last week.

808
00:39:22,920 --> 00:39:24,212
但是我的记忆有些朦胧。
But my memory is a little hazy.

809
00:39:24,211 --> 00:39:26,309
再说一次，这将是故意存在的缺陷。
So again, it will be deliberately flawed.

810
00:39:26,309 --> 00:39:29,129
但是我将继续声明一个名为n的变量。
But I'm going to go ahead and declare a variable called n.

811
00:39:29,130 --> 00:39:31,420
然后，我将执行以下操作-
Then I'm going to do the following--

812
00:39:31,420 --> 00:39:34,170
我将设置n等于get_int。
I'm going to set n equal to get_int.

813
00:39:34,170 --> 00:39:39,000
我只是要明确要求用户输入“负整数”
And I'm just going to explicitly ask the user for "Negative integer" followed

814
00:39:39,000 --> 00:39:39,900
一个空格。
by a space.

815
00:39:39,900 --> 00:39:44,220
然后，当n小于0时，我将继续执行此操作。
And then I'm going to keep doing this while n is less than 0.

816
00:39:44,219 --> 00:39:48,539
然后在最后一行，我将返回n。
And then at the very last line, I'm going to return n.

817
00:39:48,539 --> 00:39:51,119
再说一次，我声称这个功能会
So again, I claim that this function will

818
00:39:51,119 --> 00:39:53,339
从用户那里得到负整数。
get me a negative int from the user.

819
00:39:53,340 --> 00:39:57,810
而且它将一直反复进行直到用户合作为止。
And it's going to keep doing it again and again until the user cooperates.

820
00:39:57,809 --> 00:40:00,719
但是，有一个错误。
However, there is a bug.

821
00:40:00,719 --> 00:40:02,729
实际上，有几个错误。
And there's a couple of bugs, in fact.

822
00:40:02,730 --> 00:40:06,720
现在，让我继续犯一个故意的错误-造成越野车1，
Right now, let me go ahead and make a deliberate mistake-- make buggy1,

823
00:40:06,719 --> 00:40:07,739
进入。
Enter.

824
00:40:07,739 --> 00:40:10,019
我在这里看到很多错误。
And I see a whole bunch of errors here.

825
00:40:10,019 --> 00:40:12,299
我可以在此使用help50。
I could use help50 on this.

826
00:40:12,300 --> 00:40:16,290
但是基于上周，有没有人记得这里的错误可能是什么？
But based on last week, does anyone recall what the error here might be?

827
00:40:16,289 --> 00:40:20,099
“错误-函数&#39;get_negative_int&#39;的隐式声明
"Error-- implicit declaration of function 'get_negative_int'

828
00:40:20,099 --> 00:40:21,929
在C99中无效。”
is invalid in C99."

829
00:40:21,929 --> 00:40:24,991
所以我不知道所有这些，而是函数的隐式声明
So I don't know all of that, but implicit declaration of function

830
00:40:24,992 --> 00:40:26,700
是您将开始看到的东西
is something you're going to start to see

831
00:40:26,699 --> 00:40:28,769
如果您犯此错误，则更多。
more often if you make this mistake.

832
00:40:28,769 --> 00:40:35,029
有人回想起这是什么意思，而无需借助help50的解决方法是什么？
Anyone recall what this means and what the fix is without resorting to help50?

833
00:40:35,030 --> 00:40:37,760
是的，茉莉，你觉得呢？
Yeah, Jasmine, what do you think?

834
00:40:37,760 --> 00:40:40,370
贾斯敏：所以基本上，因为你宣布了它
JASMINE: So basically, since you declared it

835
00:40:40,369 --> 00:40:42,829
在代码中使用它之后，
after you already used it in your code, it

836
00:40:42,829 --> 00:40:46,049
不知道在处理它时会读什么。
doesn't know what to read that as when it's processing it.

837
00:40:46,050 --> 00:40:49,825
因此，当您实际启动代码时，必须将第一行移到上方。
So you have to move the first line above when you actually start the code.

838
00:40:49,824 --> 00:40:50,699
大卫·马兰（David MALAN）：完美。
DAVID MALAN: Perfect.

839
00:40:50,699 --> 00:40:53,689
这是我唯一要声明复制/粘贴的时间
And this is the only time I will claim that copy/paste

840
00:40:53,690 --> 00:40:55,730
是可以接受和鼓励的。
is acceptable and encouraged.

841
00:40:55,730 --> 00:40:59,180
我将仅复制该函数的第一行。
I'm going to copy the very first line only of that function.

842
00:40:59,179 --> 00:41:02,839
正如Jasmine提议的那样，我将其粘贴到文件的最顶部，
And as Jasmine proposed, I'm going to paste it at the very top of the file,

843
00:41:02,840 --> 00:41:05,990
从而给自己一个暗示，也就是所谓的原型。
thereby giving myself a hint otherwise known as a prototype.

844
00:41:05,989 --> 00:41:09,289
所以我什至会贴上这样的标签，以提醒自己为什么它在那里-
So I'll even label it as such to remind myself why it's there--

845
00:41:09,289 --> 00:41:11,719
该功能的原型。
prototype of that function.

846
00:41:11,719 --> 00:41:16,789
在这里，我将继续进行“从用户那里获取负整数”。
And here, I'm going to go ahead and "Get negative integer from user."

847
00:41:16,789 --> 00:41:20,719
然后，该功能保持不变。
And then this function is as left as written.

848
00:41:20,719 --> 00:41:23,339
所以我现在最顶部有这个原型
So I now have this prototype at the very top

849
00:41:23,340 --> 00:41:25,840
我的文件，我认为确实可以摆脱此错误。
of my file, which I think will indeed get rid of this error.

850
00:41:25,840 --> 00:41:27,950
让我再去制作越野车1。
Let me go to make buggy1 again.

851
00:41:27,949 --> 00:41:29,959
现在，我看到确实已编译好。
Now I see that indeed compiled OK.

852
00:41:29,960 --> 00:41:33,110
但是当我现在运行它时，./buggy1--
But when I run it now, ./buggy1--

853
00:41:33,110 --> 00:41:36,270
让我继续输入负整数1。
let me go ahead and input a negative integer, negative 1.

854
00:41:36,269 --> 00:41:36,769
嗯
Hm.

855
00:41:36,769 --> 00:41:38,684
负2，负3-
Negative 2, negative 3--

856
00:41:38,684 --> 00:41:41,809
我觉得函数应该对此感到满意，而事实显然并非如此。
I feel like the function should be happy with this, and it's obviously not.

857
00:41:41,809 --> 00:41:42,649
所以有一个错误。
So there's a bug.

858
00:41:42,650 --> 00:41:45,470
我要继续并按Control-C退出程序
I'm going to go ahead and hit Control-C to get out of my program

859
00:41:45,469 --> 00:41:47,809
因为否则，它将永远运行下去。
because otherwise, it would run potentially forever.

860
00:41:47,809 --> 00:41:49,609
现在，我将使用debug50。
And now I'm going to use debug50.

861
00:41:49,610 --> 00:41:53,090
但是，对于Peter的问题，debug50真的很有趣
But debug50 just got really interesting, to Peter's question

862
00:41:53,090 --> 00:41:56,180
更早的时候，因为现在有我可以介入的事情。
earlier, because now I have things I can step into.

863
00:41:56,179 --> 00:41:58,069
我不是在main中编写所有代码。
I'm not writing all of my code in main.

864
00:41:58,070 --> 00:42:00,570
现在有另一个函数称为get_negative_int。
There's this other function now called get_negative_int.

865
00:42:00,570 --> 00:42:02,390
因此，让我们看看现在会发生什么。
So let's see what happens now.

866
00:42:02,389 --> 00:42:05,929
让我继续，在第一个有趣的代码行上设置一个断点，
Let me go ahead and set a breakpoint on the first interesting line of code,

867
00:42:05,929 --> 00:42:06,531
第10行。
line 10.

868
00:42:06,532 --> 00:42:08,990
有趣的是，在其他方面
And it's interesting only in the sense that everything else

869
00:42:08,989 --> 00:42:10,669
在这一点上是样板。
is kind of boilerplate at this point.

870
00:42:10,670 --> 00:42:13,460
您只需要执行此操作即可启动程序。
You just have to do it to get your program started.

871
00:42:13,460 --> 00:42:15,020
我现在要去这里。
I'm going to now go down here.

872
00:42:15,019 --> 00:42:18,769
我将执行debug50 ./buggy1。
And I'm going to do debug50 ./buggy1.

873
00:42:18,769 --> 00:42:22,219
稍后，它将打开侧边栏。
And in a moment, it's going to open up that sidebar.

874
00:42:22,219 --> 00:42:25,639
我现在不仅要关注局部变量
And I'm going to focus now not only on local variables--

875
00:42:25,639 --> 00:42:29,809
就像我之前所做的那样，请注意，默认情况下，我在此处再次等于0。
like I did before, notice that i is again equal to 0 here by default.

876
00:42:29,809 --> 00:42:33,559
但是，我还将在此展示此选项，即调用堆栈。
But I'm also going to reveal this option here, Call Stack.

877
00:42:33,559 --> 00:42:38,119
因此，调用堆栈是引用所有函数的一种理想方式
So Call Stack is a fancy way of referring to all of the functions

878
00:42:38,119 --> 00:42:43,559
此时您的程序已执行但尚未返回。
that your program at this point in time has executed and not yet returned from.

879
00:42:43,559 --> 00:42:45,889
所以现在，调用堆栈上只有一件事
So right now, there's only one thing on the call stack

880
00:42:45,889 --> 00:42:49,699
因为当前正在执行的唯一功能当然是
because the only function that is currently executing is, of course,

881
00:42:49,699 --> 00:42:50,929
主要，因为为什么？
main, because why?

882
00:42:50,929 --> 00:42:55,039
我在第10行设置了一个断点，根据定义，该断点位于main内部。
I set a breakpoint at line 10, which is, by definition, inside of main.

883
00:42:55,039 --> 00:42:59,719
但是，对于彼得早些时候的问题，我觉得第10和11行-
But to Peter's question earlier, I feel like lines 10 and 11--

884
00:42:59,719 --> 00:43:01,549
坦白说，它们看起来很正确，对吧？
frankly, they look pretty correct, right?

885
00:43:01,550 --> 00:43:03,470
在这一点上很难搞砸
It's hard at this point to have screwed up

886
00:43:03,469 --> 00:43:07,399
第10行和第11行除外，因为在语法上，因为我得到的是负整数。
lines 10 and 11 except syntactically, because I'm getting a negative int.

887
00:43:07,400 --> 00:43:10,730
我将其存储在i中，然后打印出i的值
I'm storing it in i, and then I'm printing out the value of i

888
00:43:10,730 --> 00:43:12,230
在这两行上。
on those two lines.

889
00:43:12,230 --> 00:43:16,370
但是，如果相反，我对get_negative_int感到好奇吗？
But what if instead, I'm curious about get_negative_int?

890
00:43:16,369 --> 00:43:18,349
我觉得这是错误-从逻辑上讲，
I feel like the bug-- logically, it's got

891
00:43:18,349 --> 00:43:21,169
之所以加入其中，是因为这是我编写的较难的代码。
to be in there because that's the harder code that I wrote.

892
00:43:21,170 --> 00:43:24,530
请注意这次，不要单击“跳过”，
Notice this time, instead of clicking Step Over,

893
00:43:24,530 --> 00:43:28,640
让我继续并单击“进入”，这是彼得的按钮之一
let me go ahead and click on Step Into, which is one of the buttons Peter

894
00:43:28,639 --> 00:43:29,239
暗指。
alluded to.

895
00:43:29,239 --> 00:43:33,439
当我单击“单步执行”时，请注意，您有点像兔子洞了。
And when I click Step Into, notice that you sort of go down the rabbit hole.

896
00:43:33,440 --> 00:43:38,460
然后debug50跳入函数get_negative_int，
And debug50 jumps into the function get_negative_int,

897
00:43:38,460 --> 00:43:41,460
它着重于第一个有趣的代码行。
and it focuses on the first interesting line of code.

898
00:43:41,460 --> 00:43:44,070
这样做本身并不是一件有趣的事情。
So do, in and of itself, really isn't that interesting.

899
00:43:44,070 --> 00:43:46,160
Int n没那么有趣，因为它不是
Int n isn't that interesting because it's not

900
00:43:46,159 --> 00:43:48,019
甚至给它分配一个值。
assigning a value to it even yet.

901
00:43:48,019 --> 00:43:50,929
多汁的第一行代码似乎是第19行。
The first juicy line of code seems to be line 19.

902
00:43:50,929 --> 00:43:53,149
这就是调试器跳到那条线的原因。
And that's why the debugger has jumped to that line.

903
00:43:53,150 --> 00:43:57,350
现在，n = get_int感觉很正确。
Now, n = get_int feels pretty correct.

904
00:43:57,349 --> 00:43:59,299
很难滥用get_int。
It's hard to misuse get_int.

905
00:43:59,300 --> 00:44:02,420
但是，现在请注意右侧发生了什么。
But notice now on the right-hand side what has happened.

906
00:44:02,420 --> 00:44:06,500
在“调用堆栈”下，您现在看到了两件事，不仅是主要的，
Under Call Stack, you now see two things, not only main,

907
00:44:06,500 --> 00:44:08,930
而且还有堆栈中的get_negative_int。
but also get_negative_int in a stack.

908
00:44:08,929 --> 00:44:11,029
就像自助餐厅里的一堆托盘一样。
It's like a stack of trays in a cafeteria.

909
00:44:11,030 --> 00:44:13,250
底部的第一个纸盘像主纸盘一样。
The first tray at the bottom is like main.

910
00:44:13,250 --> 00:44:17,750
自助餐厅中堆栈上的第二个纸盒现在是get_negative_int。
The second tray on the stack in the cafeteria is now get_negative_int.

911
00:44:17,750 --> 00:44:21,680
最酷的是，请注意，现在，我
And what's cool about this is that notice that right now, I

912
00:44:21,679 --> 00:44:23,629
可以看到我的局部变量
can see my local variables, n.

913
00:44:23,630 --> 00:44:25,380
这确实是我使用的变量。
And that's indeed the variable I used.

914
00:44:25,380 --> 00:44:26,750
所以我不再见我了。
So I no longer see i.

915
00:44:26,750 --> 00:44:30,780
我看到n是因为我正在使用get_negative_int函数。
I see n because I'm into the get_negative_int function.

916
00:44:30,780 --> 00:44:35,030
现在，如果我不断单击“跳过”
And now if I keep clicking Step Over again and again

917
00:44:35,030 --> 00:44:36,140
输入数字后。
after typing in a number.

918
00:44:36,139 --> 00:44:38,209
让我在这里输入负1。
Let me type in negative 1 here.

919
00:44:38,210 --> 00:44:41,540
现在注意在屏幕的右上角，您可以在调试器中看到
Now notice on the top right of the screen, you can see in the debugger

920
00:44:41,539 --> 00:44:43,279
n等于负1。
that n equals negative 1.

921
00:44:43,280 --> 00:44:45,830
我现在要继续，然后单击“跳过”。
I'm going to now go ahead and click Step Over.

922
00:44:45,829 --> 00:44:48,679
我想我将在第22行结束。
And I think I'm going to end up in line 22.

923
00:44:48,679 --> 00:44:51,919
如果人类输入了像负1这样的负整数，
If the human has typed in a negative integer like negative 1,

924
00:44:51,920 --> 00:44:53,480
显然，这是负面的。
obviously, that's negative.

925
00:44:53,480 --> 00:44:55,160
让我们继续第22行。
Let's proceed to line 22.

926
00:44:55,159 --> 00:44:58,309
但是请注意当我单击“跳过”时会发生什么。
But watch what happens when I click Step Over.

927
00:44:58,309 --> 00:45:03,739
它实际上似乎一次又一次地回到do循环
It actually seems to be going back to the do loop again and again

928
00:45:03,739 --> 00:45:06,749
再一次，我将继续提供负整数。
and again, as it will, I keep providing negative integers.

929
00:45:06,750 --> 00:45:10,669
所以我的逻辑应该是，好的，如果n为负1，
So my logic then should be, well, OK, if n is negative 1,

930
00:45:10,670 --> 00:45:17,030
但我的循环仍在运行，您的逻辑要点是什么？
but my loop is still running, what should your logical takeaway here be?

931
00:45:17,030 --> 00:45:20,710
如果n为负1，并且根据定义为负整数，
If n is negative 1, and that is by definition a negative integer,

932
00:45:20,710 --> 00:45:25,720
但我的循环仍在运行，您的诊断结论可能是什么
but my loop is still running, what could be your diagnostic conclusion

933
00:45:25,719 --> 00:45:29,859
如果调试器本质上是向您显示此提示？ n为负1
if the debugger is essentially revealing this hint to you? n is negative 1,

934
00:45:29,860 --> 00:45:31,420
但循环仍在进行。
but the loop is still going.

935
00:45:31,420 --> 00:45:33,730
奥马尔，你会得出什么结论？
Omar, what would you conclude?

936
00:45:33,730 --> 00:45:36,850
OMAR：或者条件错误，或者某种布尔逻辑
OMAR: Either the condition is wrong, or maybe some sort of Boolean logic

937
00:45:36,849 --> 00:45:37,754
可能有缺陷。
could be flawed.

938
00:45:37,755 --> 00:45:38,630
大卫·马兰（David MALAN）：完美。
DAVID MALAN: Perfect.

939
00:45:38,630 --> 00:45:40,463
所以很明显，要么条件不对，
So obviously, either the condition is wrong,

940
00:45:40,463 --> 00:45:42,505
或我的布尔逻辑有问题。
or there's something wrong with my Boolean logic.

941
00:45:42,505 --> 00:45:44,540
布尔逻辑只是指真或假。
And Boolean logic just refers to true or false.

942
00:45:44,539 --> 00:45:46,929
所以在某个地方，我说的是真而不是假，
So somewhere, I'm saying true instead of false,

943
00:45:46,929 --> 00:45:48,849
或者我说的是假而不是真。
or I'm saying false instead of true.

944
00:45:48,849 --> 00:45:52,059
坦白说，这是我唯一拥有代码的地方
And frankly, the only place where I have code

945
00:45:52,059 --> 00:45:56,049
从逻辑上讲，这将使循环一次又一次地进入第21行。
that's going to make this loop go again and again must logically be on line 21.

946
00:45:56,050 --> 00:45:59,350
因此，即使您不太确定如何解决它，只需通过演绎，
So even if you're not quite sure how to fix it yet, just by deduction,

947
00:45:59,349 --> 00:46:02,214
您应该意识到，好吧，负1是变量中的值。
you should realize that, OK, negative 1 is what's in the variable.

948
00:46:02,215 --> 00:46:03,340
但这还不够。
But that's not good enough.

949
00:46:03,340 --> 00:46:04,340
循环仍在进行。
The loop is still going.

950
00:46:04,340 --> 00:46:05,680
我一定搞砸了循环。
I must have screwed up the loop.

951
00:46:05,679 --> 00:46:08,079
确实，让我现在就说出来。
And indeed, let me just now call it out.

952
00:46:08,079 --> 00:46:11,289
第21行确实是该错误的来源。
Line 21 is indeed the source of the bug.

953
00:46:11,289 --> 00:46:12,519
所以我们隔离了它。
So we've isolated it.

954
00:46:12,519 --> 00:46:15,159
在23行中，我们至少找到了一行
Out of 23 lines, we've at least found the one line

955
00:46:15,159 --> 00:46:18,519
我知道解决方案必须在哪里。
where I know the solution has to be.

956
00:46:18,519 --> 00:46:19,609
有什么解决方案？
What's the solution?

957
00:46:19,610 --> 00:46:26,020
得益于调试器，我现在该如何解决逻辑问题？
How do I fix the logic now thanks to the debugger having led me down this road?

958
00:46:26,019 --> 00:46:29,229
如何在此处修复第21行？
How do I fix line 21 here?

959
00:46:29,230 --> 00:46:31,350
解决办法是什么？
What's the fix?

960
00:46:31,349 --> 00:46:33,959
你有什么建议？
What do you propose?

961
00:46:33,960 --> 00:46:35,220
是的，雅各布？
Yeah, Jacob?

962
00:46:35,219 --> 00:46:38,699
JACOB：您必须从n小于0开始对其进行更改
JACOB: You would have to change it from while n is less than 0

963
00:46:38,699 --> 00:46:40,344
当n大于0时。
to while n is greater than 0.

964
00:46:40,344 --> 00:46:41,219
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

965
00:46:41,219 --> 00:46:44,639
因此，我要说的是n大于0，而不是n小于0。
So instead of n less than 0, I want to say n greater than 0.

966
00:46:44,639 --> 00:46:46,859
我认为-稍作澄清，我认为
And I think-- slight clarification, I think

967
00:46:46,860 --> 00:46:50,328
我想在这里包括0，因为0不是负数。
I want to include 0 here because 0 is not negative.

968
00:46:50,327 --> 00:46:52,619
如果我想要一个负整数，我想我可能是
And if I want a negative int, I think what I'm probably

969
00:46:52,619 --> 00:46:56,069
要说的是，当n大于或等于0时，
going to want to say is while n is greater than or equal to 0,

970
00:46:56,070 --> 00:46:57,120
继续做循环。
keep doing the loop.

971
00:46:57,119 --> 00:46:59,969
因此，我很容易理解，只是倒置了逻辑。
So I very understandably sort of just inverted the logic.

972
00:46:59,969 --> 00:47:00,489
没什么大不了。
No big deal.

973
00:47:00,489 --> 00:47:02,322
我在想负面情绪，但我做不到。
I'm thinking negatives, and I did less than.

974
00:47:02,322 --> 00:47:03,669
但是修复很容易。
But the fix is easy.

975
00:47:03,670 --> 00:47:06,300
关键是调试器将您引向了这一点。
The point is the debugger led you to this point.

976
00:47:06,300 --> 00:47:08,730
现在，那些之前已经编程的人
Now, those of you who have programmed before probably

977
00:47:08,730 --> 00:47:10,290
看到虫子向您跳来跳去。
saw the bug jumping out at you.

978
00:47:10,289 --> 00:47:13,122
那些以前可能没有编程的人，
Those of you who haven't programmed before, probably with some time,

979
00:47:13,123 --> 00:47:15,940
会找出错误所在，因为在23行中，
would have figured out what the bug was, because out of 23 lines,

980
00:47:15,940 --> 00:47:17,580
它必须是其中之一。
it's got to be one of those.

981
00:47:17,579 --> 00:47:19,829
但是随着我们的程序变得越来越复杂，
But as our programs get more sophisticated,

982
00:47:19,829 --> 00:47:25,019
我们通常会开始编写更多行代码，debug50和调试器
and we start writing more lines of code, debug50 and debuggers in general

983
00:47:25,019 --> 00:47:26,019
将成为您的朋友。
will be your friend.

984
00:47:26,019 --> 00:47:29,864
我意识到这说起来容易做起来难，因为首先
And I realize that this is easier said than done because at first,

985
00:47:29,864 --> 00:47:32,239
当使用调试器时，您会觉得，啊，我
when using a debugger, you're going to feel like, ah, I'm

986
00:47:32,239 --> 00:47:33,281
只是要使用printf。
just going to use printf.

987
00:47:33,282 --> 00:47:35,700
啊，我要为此奋斗。
Ah, I'm just going to fight through this.

988
00:47:35,699 --> 00:47:37,499
因为有一些学习曲线，
Because there's a bit of a learning curve,

989
00:47:37,500 --> 00:47:41,639
您将获得更多的时间，仅此而已
you will gain back that time and more by just

990
00:47:41,639 --> 00:47:47,489
解决此类问题时，首先将调试器用作本能。
using a debugger as your first instinct when chasing down problems like this.

991
00:47:47,489 --> 00:47:51,659
好的，这就是debug50，它是您工具箱中的新工具
All right, so that's it for debug50, a new tool in your toolkit in addition

992
00:47:51,659 --> 00:47:52,799
打印
to printf.

993
00:47:52,800 --> 00:47:55,730
但是debug50是两者中比较强大的一个。
But debug50 is hands down the more powerful of the two.

994
00:47:55,730 --> 00:47:58,230
现在，你们中有些人想知道过去几周
Now, some of you have wondered over the past couple of weeks

995
00:47:58,230 --> 00:48:00,207
为什么这里有这个小橡皮鸭。
why there's this little rubber duck here.

996
00:48:00,206 --> 00:48:02,039
实际上，这也是有原因的。
And there actually is a reason for this too.

997
00:48:02,039 --> 00:48:05,279
认真地说，有一种最终的调试技术，
And there's one final debugging technique that, in all seriousness,

998
00:48:05,280 --> 00:48:08,390
我们今天将向您介绍被称为橡皮鸭调试。
we'll introduce you today to known as rubber duck debugging.

999
00:48:08,389 --> 00:48:09,389
你可以用谷歌搜索。
And you can google this.

1000
00:48:09,389 --> 00:48:11,287
有整篇维基百科文章。
There's a whole Wikipedia article about it.

1001
00:48:11,288 --> 00:48:14,580
对于计算机科学家来说，这在计算机科学界是一回事
And this is kind of a thing in computer science circles for computer scientists

1002
00:48:14,579 --> 00:48:16,859
或程序员在桌子上放橡皮鸭。
or programmers to have rubber ducks on their desk.

1003
00:48:16,860 --> 00:48:19,290
关键是有时候
And the point here is that sometimes, when

1004
00:48:19,289 --> 00:48:22,709
试图了解代码中的错误，
trying to understand what is wrong in your code,

1005
00:48:22,710 --> 00:48:24,420
进行交谈会有所帮助。
it helps to just talk it through.

1006
00:48:24,420 --> 00:48:28,620
在理想的世界中，我们只需要与我们的同事或合作伙伴交谈
And in an ideal world, we would just talk to our colleague or our partner

1007
00:48:28,619 --> 00:48:29,609
在某些项目上。
on some project.

1008
00:48:29,610 --> 00:48:33,060
只是听到自己发声说出你的代码是什么
And just in hearing yourself vocalize what it is your code

1009
00:48:33,059 --> 00:48:36,809
经常会发生这样的情况，即众所周知的灯泡熄灭。
is supposed to do, very often, that proverbial light bulb goes off.

1010
00:48:36,809 --> 00:48:39,329
你就像，哦，等等，没关系，我明白了，
And you're like, oh, wait a minute, never mind, I got it,

1011
00:48:39,329 --> 00:48:42,599
只是因为您听见自己说话不合逻辑
just because you heard yourself speaking illogically when

1012
00:48:42,599 --> 00:48:44,909
您想要的是真正合乎逻辑的东西。
you intended something actual logical.

1013
00:48:44,909 --> 00:48:49,409
现在，我们并非经常都有同事，合作伙伴或朋友
Now, we don't often all have colleagues or partners or friends with whom we're

1014
00:48:49,409 --> 00:48:50,697
与一个项目一起工作。
working on a project with.

1015
00:48:50,697 --> 00:48:52,739
而且我们经常没有家人或朋友
And we don't often have family members or friends

1016
00:48:52,739 --> 00:48:55,269
谁想知道我们所有事物的代码。
who want to hear about our code of all things.

1017
00:48:55,269 --> 00:48:58,589
因此，是那个伙伴的绝佳代理
And so a wonderful proxy for that conversant partner

1018
00:48:58,590 --> 00:49:00,300
从字面上看是橡皮鸭。
would be literally a rubber duck.

1019
00:49:00,300 --> 00:49:03,900
因此，在更健康的时期，我们将为大家提供橡皮鸭。
And so here in healthier times, we would be giving all of you rubber ducks.

1020
00:49:03,900 --> 00:49:07,080
在舞台上，我们带来了一个更大的供大家共享。
Here on stage, we brought a larger one for us all to share.

1021
00:49:07,079 --> 00:49:09,899
如果您注意到相机上的一些广角镜头，
If you've noticed in some of the wide shots on camera,

1022
00:49:09,900 --> 00:49:12,100
一直有一只鸭子在看
there's a duck who's been watching this whole time.

1023
00:49:12,099 --> 00:49:13,974
因此，无论何时我搞砸了，我都会
So that any time I screw up, I literally have

1024
00:49:13,974 --> 00:49:17,849
在这种情况下，我可以与某人进行非言语交谈。
someone I can sort of talk to nonverbally, in this case.

1025
00:49:17,849 --> 00:49:20,879
但是除了printf之外，我们不能强调得太多
But we can't emphasize enough that in addition to printf, in addition to

1026
00:49:20,880 --> 00:49:25,230
更复杂的debug50，讨论您的代码问题
the more sophisticated debug50, talking through your problems with code

1027
00:49:25,230 --> 00:49:26,940
是一件非常有价值的事情。
is a wonderfully valuable thing.

1028
00:49:26,940 --> 00:49:29,010
如果您的朋友或家人愿意听
And if your friends or family are willing to hear

1029
00:49:29,010 --> 00:49:31,650
关于您正在编写的一些低级代码和一些错误
about some low-level code you're writing and some bug you're

1030
00:49:31,650 --> 00:49:33,000
试图解决，很棒。
trying to solve, great.

1031
00:49:33,000 --> 00:49:36,209
但是如果没有这种情况，请与您房间里的毛绒动物聊天。
But in the absence of that, talk to a stuffed animal in your room.

1032
00:49:36,210 --> 00:49:38,400
如果有的话，请与实际的橡皮鸭交谈。
Talk to an actual rubber duck if you have one.

1033
00:49:38,400 --> 00:49:39,960
大声说话或大声思考。
Talk even aloud or think aloud.

1034
00:49:39,960 --> 00:49:42,120
这只是一个令人信服的好习惯
It's just a wonderful compelling habit to get

1035
00:49:42,119 --> 00:49:46,439
进入，因为只是在听到自己的声音就能表达出您认为合理的内容
into because just in hearing yourself vocalize what you think is logical

1036
00:49:46,440 --> 00:49:51,750
不合逻辑的事情会经常跳出来向你冲来。
will the illogical very often jump out at you instead.

1037
00:49:51,750 --> 00:49:55,620
好的，话虽这么说，这已经很多了。
All right, so with that said, that's been a lot.

1038
00:49:55,619 --> 00:49:57,689
让我们继续在这里休息五分钟，
Let's go ahead here and take a five-minute break,

1039
00:49:57,690 --> 00:49:59,130
给大家一点喘息的机会。
give everyone a bit of a breather.

1040
00:49:59,130 --> 00:50:01,050
当我们回来时，我们现在来看一看
And when we come back, we'll take a look now

1041
00:50:01,050 --> 00:50:02,880
C的一些更强大的功能
at some of the more powerful features of C

1042
00:50:02,880 --> 00:50:05,850
现在我们可以相信我们可以解决所有问题
now that we can trust that we can solve any problems with all

1043
00:50:05,849 --> 00:50:06,729
这些新工具。
of these new tools.

1044
00:50:06,730 --> 00:50:08,700
所以我们将回到五分之一。
So we'll be back in five.

1045
00:50:08,699 --> 00:50:10,439
好吧，我们回来了。
All right, we are back.

1046
00:50:10,440 --> 00:50:13,320
因此，让我们来看一下引擎盖下的情况，可以这么说，
So let's take a look underneath the hood, so to speak,

1047
00:50:13,320 --> 00:50:15,480
一台计算机，因为像这些设备一样花哨
of a computer, because as fancy as these devices

1048
00:50:15,480 --> 00:50:17,460
和看起来一样强大，他们是
are and as powerful as they seem, they're

1049
00:50:17,460 --> 00:50:21,630
他们的能力和实际能力相对较简单。
relatively simple in their capabilities and what they can actually do.

1050
00:50:21,630 --> 00:50:24,570
并且让我们通过上周的类型讨论来揭示更多信息。
And let's reveal as much by way of last week's discussion of type.

1051
00:50:24,570 --> 00:50:27,700
因此，请回想一下C支持不同的数据类型。
So recall that C supports different data types.

1052
00:50:27,699 --> 00:50:31,059
因此，我们看到了char，string，int和依此类推。
So we saw char, and string, and int, and so forth.

1053
00:50:31,059 --> 00:50:32,729
综上所述，我们拥有了所有这些。
So to recap, we had all of these.

1054
00:50:32,730 --> 00:50:35,310
好吧，事实证明，每种数据类型
Well, it turns out that each of these data types

1055
00:50:35,309 --> 00:50:40,799
在典型的计算机系统上被定义为占用固定空间。
is defined on a typical computer system as taking up a fixed amount of space.

1056
00:50:40,800 --> 00:50:44,280
它取决于计算机，无论是Mac或PC，还是旧的还是新的，
And it depends on the computer, whether it's Mac or PC, or old or new,

1057
00:50:44,280 --> 00:50:47,400
这些数据类型通常使用多少空间。
just how much space is used typically by these data types.

1058
00:50:47,400 --> 00:50:51,400
但是在CS50 IDE上，所有这些类型的大小如下：
But on CS50 IDE, the sizes of all of these types are as follows--

1059
00:50:51,400 --> 00:50:54,510
布尔值（true或false）仅使用1个字节。
a bool, true or false, uses just 1 byte.

1060
00:50:54,510 --> 00:50:58,320
现在，这实际上有点浪费，因为1字节是8位，天哪，
Now, that's actually a little wasteful because 1 byte is 8 bits, and gosh,

1061
00:50:58,320 --> 00:51:00,090
对于布尔，您只需要1位。
for a bool, you should only need 1 bit.

1062
00:51:00,090 --> 00:51:04,200
在C语言中，您不能轻松地在单位级别上工作。
You can't work at the single-bit level easily in C.

1063
00:51:04,199 --> 00:51:07,439
因此，我们通常只在布尔上花费1个完整字节。
And so we just typically spend 1 whole byte on a bool.

1064
00:51:07,440 --> 00:51:09,640
Char也将是1个字节。
Char is going to be 1 byte as well.

1065
00:51:09,639 --> 00:51:13,109
这听起来可能很熟悉，因为上周我们谈论ASCII时，
And that might sound familiar, because last week when we talked about ASCII,

1066
00:51:13,110 --> 00:51:15,450
我们建议可能的字符总数
we proposed that the total number of possible characters

1067
00:51:15,449 --> 00:51:20,189
您可以用一个char表示256，因为8位和2
you can represent with a char was 256 because of 8 bits and 2

1068
00:51:20,190 --> 00:51:21,340
到第八力量。
to the eighth power.

1069
00:51:21,340 --> 00:51:23,620
因此，一个字符是1个字节。
So one char is 1 byte.

1070
00:51:23,619 --> 00:51:25,382
不管怎样，这在C语言中都是固定的。
And that's fixed in C, no matter what.

1071
00:51:25,382 --> 00:51:27,299
然后是所有其他这些数据类型。
Then there were all of these other data types.

1072
00:51:27,300 --> 00:51:29,910
有浮点数，是带小数点的实数。
There was float, which is a real number with a decimal point.

1073
00:51:29,909 --> 00:51:31,409
碰巧使用了4个字节。
That happens to use 4 bytes.

1074
00:51:31,409 --> 00:51:33,999
双精度数也是带小数点的实数，
A double is also a real number with a decimal point,

1075
00:51:34,000 --> 00:51:36,819
但是它使用8个字节，因此可以提供更高的精度。
but it uses 8 bytes, which gives you even more precision.

1076
00:51:36,820 --> 00:51:40,450
例如，小数点后可以有更多有效数字。
You can have more significant digits after the decimal point, for instance.

1077
00:51:40,449 --> 00:51:41,829
整数，我们用了一堆。
Ints, we've used a bunch.

1078
00:51:41,829 --> 00:51:43,539
这些通常是4个字节。
Those are 4 bytes, typically.

1079
00:51:43,539 --> 00:51:45,489
长是两倍大，这只允许
A long is twice as big, and that just allows

1080
00:51:45,489 --> 00:51:47,114
您代表更大的数字。
you to represent an even bigger number.

1081
00:51:47,114 --> 00:51:49,779
你们中有些人可能是完全在信用时做到了这一点
And some of you might have done that exactly on credit when

1082
00:51:49,780 --> 00:51:51,400
存储整个信用卡号。
storing a whole credit card number.

1083
00:51:51,400 --> 00:51:54,310
目前，字符串是可变数目的字节。
Strings, for now, are a variable number of bytes.

1084
00:51:54,309 --> 00:51:57,779
它可以是一小段文字，一长段文字，整个段落。
It could be a short string of text, a long string of text, a whole paragraph.

1085
00:51:57,780 --> 00:51:58,780
因此，这将有所不同。
So that's going to vary.

1086
00:51:58,780 --> 00:52:01,870
因此，下一次我们将回到字符串的概念。
So we'll come back to this notion of string next time.

1087
00:52:01,869 --> 00:52:05,379
但是今天，如果您愿意的话，只关注这些原始类型。
But today, focus on just these primitive types, if you will.

1088
00:52:05,380 --> 00:52:08,960
这是您计算机内部内容的图片。
And here is a picture of what is inside of your computer.

1089
00:52:08,960 --> 00:52:12,285
因此，这是一块内存或RAM，即随机存取存储器。
So this is a piece of memory or RAM, Random Access Memory.

1090
00:52:12,284 --> 00:52:13,659
它可能会小一点。
And it might be a little smaller.

1091
00:52:13,659 --> 00:52:15,819
可能会更大一点，具体取决于它是否是笔记本电脑，
It might be a little bigger depending on whether it's a laptop,

1092
00:52:15,820 --> 00:52:17,450
或台式机，手机或类似产品。
or desktop, or phone, or the like.

1093
00:52:17,449 --> 00:52:20,709
但是程序在内存或RAM中
But it's in memory, or RAM, that programs

1094
00:52:20,710 --> 00:52:22,780
在运行时存储。
are stored while they're running.

1095
00:52:22,780 --> 00:52:25,840
这是打开文件时存储文件的位置。
And it's where files are stored when they are open.

1096
00:52:25,840 --> 00:52:29,440
因此，通常，如果您保存，安装程序或保存文件，
So typically, if you save, install programs, or save files,

1097
00:52:29,440 --> 00:52:32,740
这些被保存在通常称为您的硬盘驱动器或硬盘上，
those are saved on what's generally called your hard drive, or hard disk,

1098
00:52:32,739 --> 00:52:37,089
或固态磁盘，CD或其他某种物理介质。
or solid-state disk, or CD, or some other physical medium.

1099
00:52:37,090 --> 00:52:40,450
而且，[听不清]是他们不需要电
And that, the [INAUDIBLE] of which is that they don't require electricity

1100
00:52:40,449 --> 00:52:42,159
长期存储您的数据。
to store your data long term.

1101
00:52:42,159 --> 00:52:43,179
RAM是不同的。
RAM is different.

1102
00:52:43,179 --> 00:52:44,829
可以这么说，它是易变的。
It's volatile, so to speak.

1103
00:52:44,829 --> 00:52:48,499
但这甚至比硬盘或固态磁盘快得多。
But it's much faster than a hard disk or a solid-state disk, even.

1104
00:52:48,500 --> 00:52:50,500
它更快，因为它是纯电子的。
It's much faster because it's purely electronic.

1105
00:52:50,500 --> 00:52:52,300
实际上，没有活动部件。
And indeed, there are no moving parts.

1106
00:52:52,300 --> 00:52:54,640
如图所示，它是纯电子的。
It's purely electronic, as pictured here.

1107
00:52:54,639 --> 00:52:59,409
因此，有了RAM，您就可以打开文件并运行程序
And so with RAM, you have the ability to open files and run programs

1108
00:52:59,409 --> 00:53:02,289
更快，因为当您双击某个程序以运行它时，
more quickly because when you double-click a program to run it,

1109
00:53:02,289 --> 00:53:04,959
或者您打开文件以查看或编辑它，
or you open a file in order to view or edit it,

1110
00:53:04,960 --> 00:53:06,820
它被临时存储在RAM中。
it's stored temporarily in RAM.

1111
00:53:06,820 --> 00:53:11,290
长话短说，如果您的笔记本电脑电池没电了，
And long story short, if your laptop battery has ever died,

1112
00:53:11,289 --> 00:53:13,989
或拔掉计算机的电源，或者手机掉线了，
or your computer's gotten unplugged, or your phone dies,

1113
00:53:13,989 --> 00:53:17,769
您和我倾向于丢失数据的原因，您刚才提到的那段
the reason that you and I tend to lose data, the paragraph that you just

1114
00:53:17,769 --> 00:53:19,959
在文章中写道您尚未保存，
wrote in the essay that you hadn't yet saved,

1115
00:53:19,960 --> 00:53:23,020
是因为RAM（内存）是易失的。
is because RAM, memory, is volatile.

1116
00:53:23,019 --> 00:53:26,359
也就是说，它需要电力才能继续为其供电。
That is, it requires electricity to continue powering it.

1117
00:53:26,360 --> 00:53:30,100
但是出于我们的目的，我们只专注于RAM，
But for our purposes, we're only going to focus on RAM,

1118
00:53:30,099 --> 00:53:33,339
还没有那么多的长期磁盘空间，因为
not so much long-term disk space yet, because when

1119
00:53:33,340 --> 00:53:36,820
您正在用C运行程序，实际上，按照定义，
you're running a program in C, it is indeed, by definition,

1120
00:53:36,820 --> 00:53:38,680
运行在计算机的内存中。
running in your computer's memory.

1121
00:53:38,679 --> 00:53:41,529
但是有趣的是，像这张照片一样简单的东西
But the funny thing about something as simple as this picture

1122
00:53:41,530 --> 00:53:44,290
这些黑色矩形中的每一个都是一种芯片。
is that each of these black rectangles is kind of a chip.

1123
00:53:44,289 --> 00:53:47,709
在这些筹码中，所有的0和1都存储了
And in those chips are stored all of the 0's and 1's, the little

1124
00:53:47,710 --> 00:53:49,690
我们在第0周提到的切换。
switches that we alluded to in week 0.

1125
00:53:49,690 --> 00:53:53,410
因此，让我们集中精力并仅放大这些芯片之一。
So let's focus on and just zoom in on just one of these chips.

1126
00:53:53,409 --> 00:53:57,129
现在，我不知道这根RAM棒有多大是有道理的。
Now, it stands to reason that I don't know how big this stick of RAM is.

1127
00:53:57,130 --> 00:53:59,440
也许是1 GB，十亿字节。
Maybe it's 1 gigabyte, a billion bytes.

1128
00:53:59,440 --> 00:54:01,000
也许是4 GB。
Maybe it's 4 gigabytes.

1129
00:54:01,000 --> 00:54:02,800
也许它更大或更小。
Maybe it's even smaller or bigger.

1130
00:54:02,800 --> 00:54:07,250
该硬件物理上表示一些字节。
There's some number of bytes represented physically by this hardware.

1131
00:54:07,250 --> 00:54:10,228
所以，如果我们进一步放大，让我建议一下，
So if we zoom in further, let me propose that, all right,

1132
00:54:10,228 --> 00:54:11,770
我不知道这里有多少字节。
I don't know how many bytes are here.

1133
00:54:11,769 --> 00:54:15,129
但是如果有一定数量的字节，无论是十亿字节还是20亿字节，
But if there's some number of bytes, whether it's a billion or 2 billion,

1134
00:54:15,130 --> 00:54:17,440
或更少或更多，这是我们合理的理由
or fewer or more, it stands to reason that we

1135
00:54:17,440 --> 00:54:19,240
可以对所有这些字节编号。
could just number all of these bytes.

1136
00:54:19,239 --> 00:54:22,669
我们可以考虑一下这个物理设备，这个内存，
We could sort of think of this physical device, this memory,

1137
00:54:22,670 --> 00:54:24,970
就像是一个网格，从上到下，从左到右。
as just being a grid, top to bottom, left to right.

1138
00:54:24,969 --> 00:54:28,269
而我刚刚覆盖在此物理设备上的每个正方形
And each of the squares I've just overlaid on this physical device

1139
00:54:28,269 --> 00:54:30,056
可能代表一个字节。
might represent an individual byte.

1140
00:54:30,056 --> 00:54:32,139
再说一次，实际上，也许还有更多。
And again, in reality, maybe there's more of them.

1141
00:54:32,139 --> 00:54:33,409
也许他们更少了。
Maybe there's fewer of them.

1142
00:54:33,409 --> 00:54:35,919
但这是有道理的，无论有多少，
But it stands to reason, no matter how many there are,

1143
00:54:35,920 --> 00:54:38,650
我们可以将每个位置都视为一个位置。
we can think of each of these as having a location.

1144
00:54:38,650 --> 00:54:42,200
就像，这是第一个字节，第二个字节，第三个字节，依此类推。
Like, this is the first byte, second byte, third byte, and so forth.

1145
00:54:42,199 --> 00:54:45,939
那么，一个char占用1个字节是什么意思呢？
Well, what does it mean, then, for a char to take up 1 byte?

1146
00:54:45,940 --> 00:54:49,750
这意味着，如果您的计算机内存正在运行某个程序，则可能
That means that if your computer's memory is running a program maybe

1147
00:54:49,750 --> 00:54:53,889
您写的或我写的是在其中某处使用char变量的情况，
that you wrote or I wrote that's using a char variable somewhere in it,

1148
00:54:53,889 --> 00:54:56,499
您存储在该变量中的字符可能很好
the char you're storing in that variable may very well

1149
00:54:56,500 --> 00:55:00,940
实际存储在该RAM的左上角。
be stored in the top left-hand corner physically of this piece of RAM.

1150
00:55:00,940 --> 00:55:01,660
也许在那里。
Maybe it's there.

1151
00:55:01,659 --> 00:55:02,534
也许在别处。
Maybe it's elsewhere.

1152
00:55:02,534 --> 00:55:04,839
但这只是一个物理正方形。
But it's just one physical square.

1153
00:55:04,840 --> 00:55:08,110
如果您要存储一个像int这样的东西，它占用4个字节，
If you're storing something like an int, which takes up 4 bytes,

1154
00:55:08,110 --> 00:55:11,830
好吧，坦率地说，可能会占据那里顶部的所有四个正方形
well, that frankly might take up all four squares along the top there

1155
00:55:11,829 --> 00:55:12,669
或者别的地方。
or somewhere else.

1156
00:55:12,670 --> 00:55:15,610
如果您使用的很长，那将占用两倍的空间。
If you're using a long, that's going to take up twice as much space.

1157
00:55:15,610 --> 00:55:18,250
因此，在您的计算机内存中代表更大的数字
So representing an even bigger number in your computer's memory

1158
00:55:18,250 --> 00:55:21,339
将要求您使用所有0和1
is going to require that you use all of the 0's and 1's

1159
00:55:21,340 --> 00:55:25,030
而是由这8个字节组成。
comprising these 8 bytes instead.

1160
00:55:25,030 --> 00:55:27,170
但是现在让我们远离物理硬件。
but let's now move away from physical hardware.

1161
00:55:27,170 --> 00:55:30,530
如果您愿意的话，让我们抽象一下，现在就开始想起我们的记忆
Let's abstract it away, if you will, and just now start to think of our memory

1162
00:55:30,530 --> 00:55:31,390
就像这个网格一样。
as just this grid.

1163
00:55:31,389 --> 00:55:33,279
从技术上讲，它不是二维结构。
And technically, it's not a two-dimensional structure.

1164
00:55:33,280 --> 00:55:35,860
我可以很容易地从左到右绘制所有这些字节。
I could just as easily draw all of these bytes from left to right.

1165
00:55:35,860 --> 00:55:37,790
我只需要在屏幕上放几个就行了。
I could just fit fewer of them on the screen.

1166
00:55:37,789 --> 00:55:39,831
因此，我们将进一步比喻物理隐喻
So we'll take the physical metaphor a bit further

1167
00:55:39,831 --> 00:55:44,019
并把我们计算机的内存想象成这个网格，这个字节网格。
and just think of our computer's memory as this grid, this grid of bytes.

1168
00:55:44,019 --> 00:55:46,509
这些字节均为8位。
And those bytes are each 8 bits.

1169
00:55:46,510 --> 00:55:48,340
这些位只是0和1。
Those bits are just 0's and 1's.

1170
00:55:48,340 --> 00:55:52,840
因此，我们真正要做的是隐喻地放大计算机的内存
So what we've really done is zoom in metaphorically on our computer's memory

1171
00:55:52,840 --> 00:55:57,460
开始思考当您将事物最终存储在内存中的位置时
to start thinking about where things are going to end up in memory when you

1172
00:55:57,460 --> 00:56:01,030
双击Mac或PC上的程序，或者在CS50 IDE中，
double-click on a program on your Mac or PC or, in CS50 IDE,

1173
00:56:01,030 --> 00:56:04,720
当您执行./hello或./buggy0或./buggy1时，
when you do ./hello or ./buggy0 or ./buggy1,

1174
00:56:04,719 --> 00:56:07,989
这些是计算机内存中的所有字节
it's these bytes in your computer's memory that are filled with all

1175
00:56:07,989 --> 00:56:09,439
变量的值。
of your variables' values.

1176
00:56:09,440 --> 00:56:10,940
因此，让我们在这里考虑一个示例。
So let's consider an example here.

1177
00:56:10,940 --> 00:56:14,800
假设我写了一些涉及声明三个分数的代码。
Suppose I had written some code that involved declaring three scores.

1178
00:56:14,800 --> 00:56:17,680
也许这是一门课，需要进行三项测试。
Maybe it's a class that's got, like, three tests.

1179
00:56:17,679 --> 00:56:23,342
您想在所有这三个测试中平均学生的成绩。
And you want to average the student's grade across all three of those tests.

1180
00:56:23,342 --> 00:56:26,259
好吧，让我们继续编写一个完成此任务的快速程序。
Well, let's go ahead and write a quick program that does exactly this.

1181
00:56:26,260 --> 00:56:30,640
在CS50 IDE中，我将创建一个名为scores.c的程序。
In CS50 IDE, I'm going to create a program called scores.c.

1182
00:56:30,639 --> 00:56:35,919
在scores.c中，我将继续并#include stdio.h。
And in scores.c, I'm going to go ahead and #include stdio.h.

1183
00:56:35,920 --> 00:56:38,703
然后，我将照常做int main（void）。
I'm going to then do my int main(void) as usual.

1184
00:56:38,702 --> 00:56:41,119
然后在这里，我将使其非常简单。
And then inside of here, I'm going to keep it very simple.

1185
00:56:41,119 --> 00:56:43,749
我要给自己一个称为score1的整数。
I'm going to give myself one int called score1.

1186
00:56:43,750 --> 00:56:46,180
只是为了好玩，我要
And just to be a little playful, I'm going

1187
00:56:46,179 --> 00:56:48,241
像上周一样将其设置为72。
to set it equal to 72, like last week.

1188
00:56:48,242 --> 00:56:50,200
我要给自己第二个分数并设定
I'm going to give myself a second score and set

1189
00:56:50,199 --> 00:56:55,119
它等于73，然后是第三个分数，其值为33。
it equal to 73, and then a third score whose value is going to be 33.

1190
00:56:55,119 --> 00:56:59,769
然后让我继续打印这三个值的平均值
And then let me go ahead and print out the average of those three values

1191
00:56:59,769 --> 00:57:03,099
通过插入占位符获取浮点值，对吗？
by plugging in a placeholder for floating point value, right?

1192
00:57:03,099 --> 00:57:07,329
如果您将三个整数相加并除以3，
If you add three integers together and divide them by 3,

1193
00:57:07,329 --> 00:57:10,729
我可能会得到一个带小数点的分数或实数。
I may very well get a fraction or a real number with a decimal point.

1194
00:57:10,730 --> 00:57:14,110
所以我将使用％f代替％i，因为我不想截断
So I'm going to use %f instead of %i because I don't want to truncate

1195
00:57:14,110 --> 00:57:15,010
某人的成绩。
someone's grade.

1196
00:57:15,010 --> 00:57:19,210
否则，如果它们具有99.9％的百分比，则不会将它们四舍五入为100％。
Otherwise, if they have, like, a 99.9%, they're not being rounded up to 100%.

1197
00:57:19,210 --> 00:57:22,880
正如我们上周所讨论的，由于截断，他们将获得99％的收益。
They're going to get the 99% because of truncation, as we discussed last week.

1198
00:57:22,880 --> 00:57:25,030
那么，现在我该如何做平均数学呢？
So how do I do now the math of an average?

1199
00:57:25,030 --> 00:57:27,220
好吧，这很简单-score1
Well, it's pretty straightforward-- score1

1200
00:57:27,219 --> 00:57:30,159
加上圆括号中的score2和score3，
plus score2 plus score3 in parentheses, just

1201
00:57:30,159 --> 00:57:33,609
就像在数学上一样，除以3（分号）。
like in math, divided by 3, semicolon.

1202
00:57:33,610 --> 00:57:35,000
让我保存该文件。
Let me save that file.

1203
00:57:35,000 --> 00:57:36,655
让我在最底端打分。
Let me do make scores at the bottom.

1204
00:57:36,655 --> 00:57:38,530
同样，我们不会手动使用Clang。
Again, we're not going to use Clang manually.

1205
00:57:38,530 --> 00:57:41,230
不需要，因为make的运行要容易得多。
No need to, because it's a lot easier to run make.

1206
00:57:41,230 --> 00:57:42,670
但是我确实搞砸了。
But I did mess up here.

1207
00:57:42,670 --> 00:57:46,420
“格式指定类型为&#39;double&#39;，但参数的类型为&#39;int&#39;。”
"Format specifies type 'double', but the argument has type 'int'."

1208
00:57:46,420 --> 00:57:48,500
所以我不太明白。
So I don't quite understand that.

1209
00:57:48,500 --> 00:57:52,540
但这引起了我对％f的注意，而且我的数学运算看起来像
But it's drawing my attention to the %f and the fact that my math looks like

1210
00:57:52,539 --> 00:57:53,929
这。
this.

1211
00:57:53,929 --> 00:57:56,109
那么这里有什么想法吗？
So any thoughts here?

1212
00:57:56,110 --> 00:57:59,650
我不认为printf会在这里帮助我，因为该错误是
I don't think printf is going to help me here because the bug is

1213
00:57:59,650 --> 00:58:01,810
在printf行中。
within the printf line.

1214
00:58:01,809 --> 00:58:06,159
我认为debug50不会对我有真正的帮助，因为我已经
I don't think that debug50 is going to really help me here because I already

1215
00:58:06,159 --> 00:58:09,129
知道错误所在的代码行。
know what line of code the bug is in.

1216
00:58:09,130 --> 00:58:13,570
感觉就像是与实物鸭说话的机会
This feels like an opportunity to talk to the physical duck

1217
00:58:13,570 --> 00:58:15,280
或其他无生命的物体。
or some other inanimate object.

1218
00:58:15,280 --> 00:58:21,070
或者，也许我们可以考虑一下上周我们遇到了什么错误。
Or we can perhaps think about what errors we ran into even last week.

1219
00:58:21,070 --> 00:58:23,410
[？ Arpan ，?]您怎么看？
[? Arpan, ?] what do you think?

1220
00:58:23,409 --> 00:58:27,519
[？ ARPAN ：?]我想这是在告诉您，因为它是
[? ARPAN: ?] I think it's telling you this because it's

1221
00:58:27,519 --> 00:58:31,389
接收的所有值都是整数类型，
receiving in all the values are integer type,

1222
00:58:31,389 --> 00:58:33,556
但是您告诉它是浮动的。
but you are telling it to be in float.

1223
00:58:33,556 --> 00:58:34,389
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

1224
00:58:34,389 --> 00:58:37,449
所以score1，score2，score3都是整数，
So score1, score2, score3 are all integers,

1225
00:58:37,449 --> 00:58:40,569
而数字3实际上是整数。
and the number 3 is literally an integer.

1226
00:58:40,570 --> 00:58:43,720
因此，这次，编译器足够聪明，可以意识到，等一下，
And so this time, the compiler is smart enough to realize, wait a minute,

1227
00:58:43,719 --> 00:58:48,849
您试图将整数结果强制为浮点值，
you're trying to coerce an integer result into a floating point value,

1228
00:58:48,849 --> 00:58:51,591
但是如果可以的话，您还没有执行任何浮点运算。
but you haven't done any floating point arithmetic, if you will.

1229
00:58:51,592 --> 00:58:52,300
那你知道吗？
So you know what?

1230
00:58:52,300 --> 00:58:53,592
有几种方法可以解决此问题。
There's a few ways to fix this.

1231
00:58:53,592 --> 00:58:56,680
上周，回想一下，我们建议您可以使用演员表，
Last week, recall we proposed that you could use a cast,

1232
00:58:56,679 --> 00:59:00,879
您可以将其中一个或多个这些值显式转换为浮点数。
and you could explicitly cast one or more of those values to a float.

1233
00:59:00,880 --> 00:59:02,830
因此，例如，我可以这样做。
So I could do this, for instance.

1234
00:59:02,829 --> 00:59:06,727
或者我可以将所有这些都转换为浮点数，或者将其中之一转换为浮点数。
Or I could cast all of these to floats or one of these to floats.

1235
00:59:06,728 --> 00:59:08,270
有很多不同的可能性。
There's many different possibilities.

1236
00:59:08,269 --> 00:59:12,249
但坦率地说，最简单的解决方法是例如除以3.0。
But frankly, the simplest fix is just to divide, for instance, by 3.0.

1237
00:59:12,250 --> 00:59:16,262
我可以避免仅仅从一个人投射到另一个人的一些麻烦
I can avoid some of the headaches of casting from one to another by just

1238
00:59:16,262 --> 00:59:18,429
确保至少有一个浮点
making sure that there's at least one floating point

1239
00:59:18,429 --> 00:59:20,679
此算术中涉及的值。
value involved in this arithmetic.

1240
00:59:20,679 --> 00:59:23,019
现在让我重新编译分数。
So now let me recompile scores.

1241
00:59:23,019 --> 00:59:24,459
这次，编译正常。
This time, it compiles OK.

1242
00:59:24,460 --> 00:59:31,810
让我来做./得分，瞧，我的平均值不是很高，59.333333。
Let me do ./scores, and voila, my average isn't so high, 59.333333.

1243
00:59:31,809 --> 00:59:34,749
好吧，所以里面到底发生了什么
All right, so what is actually going on inside

1244
00:59:34,750 --> 00:59:38,980
不论浮点运算是什么，
of the computer irrespective of the floating point arithmetic, which was,

1245
00:59:38,980 --> 00:59:40,760
再次，上个星期的话题？
again, a topic of last week?

1246
00:59:40,760 --> 00:59:44,470
好吧，让我们考虑这三个变量，score1，score2，score3--
Well, let's consider these three variables, score1, score2, score3--

1247
00:59:44,469 --> 00:59:47,499
它们实际存储在计算机内存中的什么位置？
where are they actually being stored in the computer's memory?

1248
00:59:47,500 --> 00:59:49,120
好吧，让我们再次考虑该网格。
Well, let's consider that grid again.

1249
00:59:49,119 --> 00:59:51,549
再说一次，为了方便起见，我将从左上方开始。
And again, I'm going to start at top left for convenience.

1250
00:59:51,550 --> 00:59:53,925
但从技术上讲-我们将在以后看到这一点-
But technically speaking-- we'll see this down the road--

1251
00:59:53,925 --> 00:59:56,410
您计算机的内存就像这张大画布一样。
your computer's memory is just like this big canvas.

1252
00:59:56,409 --> 00:59:59,149
价值可能会出现在所有不同的地方。
And values can end up in all different places.

1253
00:59:59,150 --> 01:00:00,700
但是今天，我们将保持清洁。
But for today, we'll keep it clean.

1254
01:00:00,699 --> 01:00:03,829
我声称第一个变量score1会在这里，
The first variable, score1, I claim is going to be here,

1255
01:00:03,829 --> 01:00:05,419
为了简单起见，左上方。
top left, for simplicity.

1256
01:00:05,420 --> 01:00:08,290
但是，分数1在何处重要？
But what's important about where score1--

1257
01:00:08,289 --> 01:00:13,119
也就是说，正在存储72个，是否要占用其中四个盒子。
that is, 72-- is being stored, is it's taking up four of these boxes.

1258
01:00:13,119 --> 01:00:15,669
回想一下，这些框中的每一个都代表1个字节。
Each of these boxes, recall, represents 1 byte.

1259
01:00:15,670 --> 01:00:19,600
回想一下，CS50 IDE中的整数是4个字节。
And an integer, recall, in CS50 IDE is 4 bytes.

1260
01:00:19,599 --> 01:00:24,249
因此，我使用了4个字节的空间来表示数字72。
Therefore, I have used 4 bytes of space to represent the number 72.

1261
01:00:24,250 --> 01:00:27,430
同样，score2中的数字73
The number 73 in score2 similarly is going

1262
01:00:27,429 --> 01:00:32,149
占据四个盒子，score3也将占据四个盒子。
to take up four boxes, as is score3 going to take up four boxes as well.

1263
01:00:32,150 --> 01:00:34,750
但是，这里的引擎盖下到底发生了什么？
But what's really going on underneath the hood here?

1264
01:00:34,750 --> 01:00:37,450
好吧，如果每个正方形代表一个字节，
Well, if each of these squares represents a byte,

1265
01:00:37,449 --> 01:00:42,069
这些字节中的每一个都是8位，而一位只是0或1，
and each of those bytes is 8 bits, and a bit is just a 0 or 1,

1266
01:00:42,070 --> 01:00:45,130
引擎盖下面真正发生的事情是这样的。
what's really going on underneath the hood is something like this.

1267
01:00:45,130 --> 01:00:47,980
不知何故，这个电子存储器正在存储
Somehow, this electronic memory is storing

1268
01:00:47,980 --> 01:00:50,920
以正确的方式储存电力
electricity in just the right way so that it's storing

1269
01:00:50,920 --> 01:00:53,650
0和1的这种模式，又名
this pattern of 0's and 1's, a.k.a.

1270
01:00:53,650 --> 01:00:57,370
十进制为72，即0和1的模式，又名
72 in decimal, this pattern of 0's and 1's, a.k.a.

1271
01:00:57,369 --> 01:01:01,179
十进制73，即0和1的模式，又名
73 in decimal, this pattern of 0's and 1's, a.k.a.

1272
01:01:01,179 --> 01:01:02,681
小数点后为33。
33 in decimal.

1273
01:01:02,681 --> 01:01:05,139
但是同样，我们不必继续思考或居住
But again, we don't have to keep thinking about or dwelling

1274
01:01:05,139 --> 01:01:06,189
在二进制级别。
on the binary level.

1275
01:01:06,190 --> 01:01:09,100
但这只是说，到目前为止，我们已经讨论过的所有内容
But this is only to say that everything we've discussed thus far

1276
01:01:09,099 --> 01:01:11,559
现在在这张照片中走到一起
is coming together now in this one picture

1277
01:01:11,559 --> 01:01:14,319
因为计算机只是为我们存储了这些模式，
because a computer is just storing these patterns for us,

1278
01:01:14,320 --> 01:01:16,930
由于我们的编程，我们现在正在分配空间
and we are allocating space now thanks to our programming

1279
01:01:16,929 --> 01:01:20,049
语言通过这样的代码。
language via code like this.

1280
01:01:20,050 --> 01:01:26,770
但是此代码虽然正确，但实际上是59.333333，依此类推，依此类推
But this code, correct though it may be, indeed 59.333333 and so forth

1281
01:01:26,769 --> 01:01:31,239
如果我的考试分数分别是72、73和33，则是我的平均值。
was my average if my test scores were 72, 73, and 33.

1282
01:01:31,239 --> 01:01:34,329
但是我觉得这里有机会进行更好的设计。
But I feel like there's an opportunity for better design here.

1283
01:01:34,329 --> 01:01:37,569
因此，回想一下设计，不仅是正确性，还不仅仅是风格
So not just correctness, not just style, recall that design

1284
01:01:37,570 --> 01:01:40,000
这是代码质量的另一个指标。
is this other metric of code quality.

1285
01:01:40,000 --> 01:01:42,100
这有点主观，而且
And it's a little more subjective, and it's

1286
01:01:42,099 --> 01:01:45,489
多一些合理的人之间的辩论。
a little more subject to debate among reasonable people.

1287
01:01:45,489 --> 01:01:50,257
但是我真的不喜欢我使用这种命名方案所做的事情。
But I don't really love what I was doing with this naming scheme.

1288
01:01:50,257 --> 01:01:52,299
实际上，如果我们看一下代码，
And in fact, if we look at the code, there really

1289
01:01:52,300 --> 01:01:55,240
对我的程序而言，仅此三行而已。
wasn't much more to my program than these three lines.

1290
01:01:55,239 --> 01:01:58,839
我担心该程序的设计不是特别好。
I worry this program isn't particularly well designed.

1291
01:01:58,840 --> 01:02:04,360
可能是什么让您对这三行代码有误呢？
What rubs you the wrong way, perhaps, about those three lines of code?

1292
01:02:04,360 --> 01:02:06,255
有什么更好的办法吗？
What could be better?

1293
01:02:06,255 --> 01:02:08,380
即使您不知道解决方案，尤其是
And even if you don't know the solution, especially

1294
01:02:08,380 --> 01:02:13,688
如果您以前从未编程过，那三行的气味是什么？
if you've never programmed before, what kind of smells about those three lines?

1295
01:02:13,688 --> 01:02:14,980
这实际上是一个艺术术语。
This is actually a term of art.

1296
01:02:14,980 --> 01:02:18,820
“代码气味”就像是某种东西-出于某种原因而不喜欢它。
"Code smell" is like something-- not loving that for some reason.

1297
01:02:18,820 --> 01:02:22,270
如果您不能全力以赴，那不是最好的设计。
If you can't put your finger on it, it's not the best design.

1298
01:02:22,269 --> 01:02:23,379
代码闻起来。
The code smells.

1299
01:02:23,380 --> 01:02:26,950
如果您愿意，关于score1，score2，score3会有什么臭味？
What's smelly, if you will, about score1, score2, score3?

1300
01:02:26,949 --> 01:02:28,404
瑞安，你怎么看？
Ryan, what do you think?

1301
01:02:28,405 --> 01:02:30,280
赖安：如果您要进行平均计算，
RYAN: If you're doing an average calculation,

1302
01:02:30,280 --> 01:02:33,170
您无需在代码中将它们全部加在一起。
you don't need to add them up all together in the code.

1303
01:02:33,170 --> 01:02:35,970
您可以预先添加它们并将其存储为一个变量。
You can add them up beforehand and store it as one variable.

1304
01:02:35,969 --> 01:02:36,969
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Absolutely.

1305
01:02:36,969 --> 01:02:39,802
如果要计算平均值，则不需要保持这三个平均值。
If I'm computing the average, I don't need to keep all three around.

1306
01:02:39,802 --> 01:02:42,939
我可以保留一个总和，然后将总和除以总数。
I can just keep a sum and then divide the whole sum by the total number.

1307
01:02:42,940 --> 01:02:45,070
我喜欢那种本能。
I like that, that instinct.

1308
01:02:45,070 --> 01:02:49,480
您现在可能不喜欢该代码的设计吗？
What else might you not like about the design of this code now?

1309
01:02:49,480 --> 01:02:51,340
得分1，得分2，得分3。
Score1, score2, score3.

1310
01:02:54,110 --> 01:02:56,150
得分1，得分2，得分3。
Score1, score2, score3.

1311
01:02:56,150 --> 01:02:59,030
仍有机会进行改进吗？
Might there be opportunity still for improvement?

1312
01:02:59,030 --> 01:03:02,090
我觉得您随时都可以看到这种重复。
I feel like any time you start to see this repetition, maybe.

1313
01:03:02,090 --> 01:03:03,600
安德鲁，你的想法吗？
Andrew, your thoughts?

1314
01:03:03,599 --> 01:03:06,714
ANDREW：不是将三个分数一起硬编码吗？
ANDREW: Not hard code the three scores together?

1315
01:03:06,715 --> 01:03:08,840
DAVID MALAN：好的，所以不要硬编码这三个分数。
DAVID MALAN: OK, so not hard code the three scores.

1316
01:03:08,840 --> 01:03:10,500
而您会怎么做呢？
And what would you do instead?

1317
01:03:10,500 --> 01:03:14,060
ANDREW：也许要输入一个信息，否则我会-
ANDREW: Maybe take an input, or I would--

1318
01:03:14,059 --> 01:03:16,561
是的，我不会自己写下分数。
yeah, I wouldn't write out the scores themselves.

1319
01:03:16,561 --> 01:03:18,269
大卫·马兰（David MALAN）：是的，另一个很好的本能。
DAVID MALAN: Yeah, another good instinct.

1320
01:03:18,269 --> 01:03:21,469
我写了一个程序，编译了一个程序，这有点愚蠢，
It's kind of stupid that I've written a program, compiled a program,

1321
01:03:21,469 --> 01:03:25,846
只能计算某个字面上得到这三个部分的学生的平均值
that only computes the average for some student who literally got those three

1322
01:03:25,847 --> 01:03:26,930
测试成绩，没有其他人。
test scores and no others.

1323
01:03:26,929 --> 01:03:28,489
就像，这里没有动力。
Like, there's no dynamism here.

1324
01:03:28,489 --> 01:03:31,549
而且，我打电话也有点懒
Moreover, it's a little lazy too that I called

1325
01:03:31,550 --> 01:03:33,890
我的变量score1，score2，score3。
my variables score1, score2, score3.

1326
01:03:33,889 --> 01:03:35,449
我的意思是，那之后在哪里结束？
I mean, where does it end after that?

1327
01:03:35,449 --> 01:03:37,789
如果我想在下学期进行第四次考试，现在
If I want to have a fourth test next semester, now

1328
01:03:37,789 --> 01:03:39,139
我必须去并获得评分4。
I have to go and have score4.

1329
01:03:39,139 --> 01:03:40,759
如果我有五分，得分5。
If I've got a fifth, score5.

1330
01:03:40,760 --> 01:03:44,270
这开始让人想起上周的复制/粘贴，
That starts to be reminiscent of last week's copy/paste, which

1331
01:03:44,269 --> 01:03:45,989
确实不是最佳实践。
really wasn't the best practice.

1332
01:03:45,989 --> 01:03:48,589
因此，我建议我们对此进行清理。
And so let me propose that we clean this up.

1333
01:03:48,590 --> 01:03:50,900
事实证明，我们可以通过以下方式进行清理
And it turns out we can clean this up by way

1334
01:03:50,900 --> 01:03:53,210
另一个主题，C的另一个功能是
of another topic, another feature of C that's

1335
01:03:53,210 --> 01:03:56,100
也以其他语言（称为数组）呈现。
also present in other languages, known as arrays.

1336
01:03:56,099 --> 01:03:58,879
如果您碰巧在Scratch中使用了称为列表的内容，
And if you happened to use something called a list in Scratch,

1337
01:03:58,880 --> 01:04:01,760
在精神上与Scratch的清单非常相似。
very similar in spirit to Scratch's lists.

1338
01:04:01,760 --> 01:04:05,060
但是第一周我们在讲座中没有看到这些。
But we didn't see those in lecture that first week.

1339
01:04:05,059 --> 01:04:11,029
与其他语言一样，C语言中的数组是一个序列
An array in C, as in other languages, is a sequence

1340
01:04:11,030 --> 01:04:14,870
背对背存储在内存中的值的数量，
of values stored in memory back to back to back,

1341
01:04:14,869 --> 01:04:19,019
一系列连续值，可以说是背靠背。
a sequence of contiguous values, so to speak, back to back to back.

1342
01:04:19,019 --> 01:04:22,184
因此从某种意义上讲，它就像是从左到右的值列表
So in that sense, it's like a list of values from left to right

1343
01:04:22,184 --> 01:04:24,559
如果我们使用图片的隐喻，我们一直在画画。
if we use the metaphor of the picture we've been drawing.

1344
01:04:24,559 --> 01:04:27,479
那么，这与这里有何关系？
So how might this be germane here?

1345
01:04:27,480 --> 01:04:30,710
好吧，事实证明，如果您要存储一堆值，
Well, it turns out that if you want to store a whole bunch of values,

1346
01:04:30,710 --> 01:04:33,320
但它们都是相互关联的，就像分数一样，
but they're all kind of interrelated, like they're all scores,

1347
01:04:33,320 --> 01:04:37,340
您不必求助于这种懒惰，score1，score2，score3，score4，
you don't have to resort to this sort of lazy, score1, score2, score3, score4,

1348
01:04:37,340 --> 01:04:40,850
score5，最高为99，具体取决于有多少个分数。
score5, up to score99, depending on how many scores there are.

1349
01:04:40,849 --> 01:04:44,629
为什么不把所有这些数字都称为分数
Why don't you just call all of those numbers scores,

1350
01:04:44,630 --> 01:04:46,520
但使用略有不同的语法？
but use a slightly different syntax?

1351
01:04:46,519 --> 01:04:49,549
该语法使您可以访问所谓的数组。
And that syntax gives you access to what are called arrays.

1352
01:04:49,550 --> 01:04:52,730
因此，屏幕上的语法是一个示例
So the syntax here on the screen is an example

1353
01:04:52,730 --> 01:04:56,930
一次声明三个整数的空间
of declaring space for three integers all at once

1354
01:04:56,929 --> 01:05:00,979
并统称为“分数”。
and collectively referring to all of them as the word "scores."

1355
01:05:00,980 --> 01:05:03,320
因此，不再有分数1、2和3。
So there's no more scores 1, 2, and 3.

1356
01:05:03,320 --> 01:05:06,260
所有这三个分数都在一个称为“分数”的变量中。
All three of those scores are in a variable called "scores."

1357
01:05:06,260 --> 01:05:09,830
而这里的新内容是方括号，其中包含
And what's new here is the square brackets, inside of which

1358
01:05:09,829 --> 01:05:14,179
是一个从字面上暗示您有多少个整数的数字
is a number that literally connotes how many integers do you

1359
01:05:14,179 --> 01:05:18,149
想要以“分数”的名称存储。
want to store under the name "scores."

1360
01:05:18,150 --> 01:05:19,940
那这允许我做什么？
So what does this allow me to do?

1361
01:05:19,940 --> 01:05:24,240
它仍然允许我在该数组中定义三个整数。
It allows me still to define three integers in that array.

1362
01:05:24,239 --> 01:05:26,329
所以这个数组将是一块内存
So this array is going to be a chunk of memory

1363
01:05:26,329 --> 01:05:29,029
背对背，我可以输入值。
back to back to back that I can put values in.

1364
01:05:29,030 --> 01:05:32,240
在我看来，这些价值的表达方式将在语法上看起来像这样。
And the way I put those values is going to look syntactically like this.

1365
01:05:32,239 --> 01:05:36,049
我仍然使用数字，但是现在我使用了新的符号。
I still use numbers, but now I'm using a new notation.

1366
01:05:36,050 --> 01:05:39,170
这与我之前所诉的相似，
And it's similar to what I resorted to before,

1367
01:05:39,170 --> 01:05:41,390
但现在更加通用化了，而且更加动态。
but it's a little more generalized now and dynamic.

1368
01:05:41,389 --> 01:05:44,959
现在，如果我想更新该数组中的第一个分数，
Now if I want to update the very first score in that array,

1369
01:05:44,960 --> 01:05:47,540
我从字面上写出可变分数的名称，
I literally write the name of the variable scores,

1370
01:05:47,539 --> 01:05:51,019
方括号[0]，然后为其分配值。
bracket[0] and then assign it the value.

1371
01:05:51,019 --> 01:05:54,199
如果我想获得第二个分数，我会得分[1]。
If I want to get at the second score, I do scores[1].

1372
01:05:54,199 --> 01:05:56,569
如果我想要第三个分数，那就是分数[2]。
If I want the third score, it's scores[2].

1373
01:05:56,570 --> 01:06:00,050
唯一有点奇怪并且需要一些适应的事情是
And the only thing that's a little weird and takes some getting used to is

1374
01:06:00,050 --> 01:06:04,100
我们正在对数组进行“零索引”这一事实。
the fact that we are "zero-indexing" our arrays.

1375
01:06:04,099 --> 01:06:06,979
因此，在过去的示例中，例如for循环和while循环，
So in past examples, like for loops and while loops,

1376
01:06:06,980 --> 01:06:09,680
我有点说，嗯，这是编程中的惯例
I've sort of said, eh, it's a convention in programming

1377
01:06:09,679 --> 01:06:11,179
从0开始计数。
to start counting from 0.

1378
01:06:11,179 --> 01:06:15,139
当涉及到数组时，它们是连续的
When it comes to arrays, which are contiguous

1379
01:06:15,139 --> 01:06:20,291
计算机内存中的值序列必须从0开始。
sequences of values in a computer's memory, they have to start at 0.

1380
01:06:20,291 --> 01:06:22,249
因此，否则，如果您不从0开始计数，
So otherwise, if you don't start counting at 0,

1381
01:06:22,250 --> 01:06:26,280
您实际上会通过忽略一个值来浪费空间。
you're literally going to be wasting space by overlooking one value.

1382
01:06:26,280 --> 01:06:29,100
现在，如果我们要重命名屏幕上的内容，
So now if we were to rename things on the screen,

1383
01:06:29,099 --> 01:06:34,339
而不是调用这三个矩形score1，score2，score3，
instead of calling these three rectangles score1, score2, score3,

1384
01:06:34,340 --> 01:06:35,810
他们都被称为分数。
they're all called scores.

1385
01:06:35,809 --> 01:06:38,269
但是，如果您要专门参考第一个，
But if you want to refer specifically to the first one,

1386
01:06:38,269 --> 01:06:42,139
您使用这个花哨的括号符号，第二个使用这个括号符号，
you use this fancy bracket notation, and the second one, this bracket notation,

1387
01:06:42,139 --> 01:06:44,149
第三个是这个括号符号。
and the third one, this bracket notation.

1388
01:06:44,150 --> 01:06:45,740
但是请注意二分法。
But notice the dichotomy.

1389
01:06:45,739 --> 01:06:51,769
在声明数组时，在创建数组时，说，给我三个整数，
When declaring the array, when creating the array, saying, give me three ints,

1390
01:06:51,769 --> 01:06:56,269
您使用[3]，其中[3]是值的总数。
you use [3] where [3] is the total number of values.

1391
01:06:56,269 --> 01:06:59,299
当您索引到阵列中时
When you index into the array--

1392
01:06:59,300 --> 01:07:03,260
也就是说，当您转到该内存块中的特定位置时-
that is, when you go to a specific location in that chunk of memory--

1393
01:07:03,260 --> 01:07:05,130
您同样使用数字。
you similarly use numbers.

1394
01:07:05,130 --> 01:07:08,510
但是现在这些指的是它们的相对位置，位置0，
But now those are referring to their relative positions, position 0,

1395
01:07:08,510 --> 01:07:10,460
位置1，位置2。
position 1, position 2.

1396
01:07:10,460 --> 01:07:13,160
这是空格总数。
This is the total number of spaces.

1397
01:07:13,159 --> 01:07:17,479
这是第一个，第二个和第三个特定的空间。
This is the specific space first, second, and third.

1398
01:07:17,480 --> 01:07:20,000
好吧，从图片上看，什么都没有改变，
All right, so pictorially, nothing has changed,

1399
01:07:20,000 --> 01:07:21,872
只是我们的命名法真正拥有的。
just our nomenclature really has.

1400
01:07:21,871 --> 01:07:24,079
因此，让我着手开始改进此程序，
So let me go ahead and start to improve this program,

1401
01:07:24,079 --> 01:07:28,219
接受关于如何改进设计的建议
taking in the advice that was offered too on how we can improve the design

1402
01:07:28,219 --> 01:07:30,289
并摆脱它的臭味。
and get rid of the smelliness of it.

1403
01:07:30,289 --> 01:07:32,059
我先来-
Let me take the first--

1404
01:07:32,059 --> 01:07:34,649
让我采取这些方法中最简单的方法
let me take the easiest of these approaches

1405
01:07:34,650 --> 01:07:37,340
首先要摆脱这三个独立的变量
first by just getting rid of these three separate variables

1406
01:07:37,340 --> 01:07:42,590
而是给我一个变量，称为分数，大小为3的数组。
and instead giving me one variable called scores, an array of size 3.

1407
01:07:42,590 --> 01:07:45,710
然后，我不需要声明score1，score2。
And then I don't need to declare score1, score2.

1408
01:07:45,710 --> 01:07:47,420
再说一次，一切都消失了。
Again, that's all going away.

1409
01:07:47,420 --> 01:07:48,453
这一切都消失了。
That's all going away.

1410
01:07:48,452 --> 01:07:49,369
这一切都消失了。
That's all going away.

1411
01:07:49,369 --> 01:07:52,519
现在，如果我要使用这三个值初始化该数组，
Now if I want to initialize that array with these three values,

1412
01:07:52,519 --> 01:07:54,439
我说分数[0]。
I say scores[0].

1413
01:07:54,440 --> 01:07:56,510
在这里，我说分数[1]。
And down here, I say scores[1].

1414
01:07:56,510 --> 01:07:59,060
在这里，我说分数[2]。
And down here, I say scores[2].

1415
01:07:59,059 --> 01:08:01,199
因此，我添加了一行代码。
So I've added one line of code.

1416
01:08:01,199 --> 01:08:02,809
但是现在请注意动态性。
But notice the dynamism now.

1417
01:08:02,809 --> 01:08:05,719
如果我想有第四个，我可以在这里分配，然后
If I want to have a fourth one, I can just allocate here and then

1418
01:08:05,719 --> 01:08:09,741
用另一行代码或5、6、7或8输入值。
put in the value with another line of code, or 5, or 6, or 7, or 8.

1419
01:08:09,742 --> 01:08:11,450
我不必开始复制和粘贴
I don't have to start copying and pasting

1420
01:08:11,449 --> 01:08:13,929
按照惯例，所有这些不同的变量名。
all of these different variable names by convention.

1421
01:08:13,929 --> 01:08:16,929
但是我认为，如果我们接受刚才提供的一些建议，
But I think if we take some of the advice that was offered a moment ago,

1422
01:08:16,930 --> 01:08:20,370
我们也可以通过循环或类似的方式来清理它。
we can also clean this up by way of a loop or such as well.

1423
01:08:20,369 --> 01:08:21,379
因此，让我们做到这一点。
So let's do that.

1424
01:08:21,380 --> 01:08:26,140
让我继续，首先给我自己，首先是CS50库，
Let me go ahead and give myself, actually, first the CS50 library so

1425
01:08:26,140 --> 01:08:27,609
我可以使用get_int。
that I can use get_int.

1426
01:08:27,609 --> 01:08:30,100
让我们采纳第一条建议，那就是，
And let's take this first piece of advice, which is,

1427
01:08:30,100 --> 01:08:33,370
让我们开始使用get_int要求得分。
let's start asking for a score using get_int.

1428
01:08:33,369 --> 01:08:35,949
我将做三遍。
And I'm going to do this three times.

1429
01:08:35,949 --> 01:08:37,749
是的，我有点懒了。
And yeah, I'm getting a little lazy.

1430
01:08:37,750 --> 01:08:38,858
我已经有点无聊了。
I'm getting a little bored already.

1431
01:08:38,859 --> 01:08:40,029
所以我要复制/粘贴。
So I'm going to copy/paste.

1432
01:08:40,029 --> 01:08:41,946
再说一次，这预示着总体上不好。
And again, that does not bode well in general.

1433
01:08:41,945 --> 01:08:44,648
复制和粘贴时，我们可能还会做得更好。
When copying and pasting, we can probably do better still.

1434
01:08:44,649 --> 01:08:47,770
但是现在我想我只需要在这里更改另一件事。
But now I think I need to change just one more thing here.

1435
01:08:47,770 --> 01:08:54,010
在进行数学运算时，我想要分数[0]加分数[1]加分数[2]。
When doing the math, I want scores[0] plus scores[1] plus scores[2].

1436
01:08:54,010 --> 01:08:57,580
但是在我解决这个问题之前-逻辑仍然是一样的，
But before I solve this problem here-- the logic is still the same,

1437
01:08:57,579 --> 01:09:00,309
但我现在要动态地输入三个整数
but I'm now taking in dynamically three integers--

1438
01:09:00,310 --> 01:09:02,740
仍然有一种气味。
there's still a smell to it as well.

1439
01:09:02,739 --> 01:09:04,549
它仍然没有很好的设计。
It's still not as well designed.

1440
01:09:04,550 --> 01:09:10,640
因此，为了明确起见，我现在能做得更好吗？
And so just to make clear, what could I do be doing better now?

1441
01:09:10,640 --> 01:09:14,359
我如何清理此代码，并使其不仅正确，而且不仅仅如此
How could I clean up this code and make it not just correct, not just

1442
01:09:14,359 --> 01:09:17,310
风格不错，但设计更好？
well styled, but better designed?

1443
01:09:17,310 --> 01:09:18,240
这里还剩下什么？
What remains here?

1444
01:09:18,239 --> 01:09:18,739
妮娜
Nina?

1445
01:09:18,739 --> 01:09:20,449
你怎么认为？
What do you think?

1446
01:09:20,449 --> 01:09:24,169
NINA：该代码仅针对三个分数。
NINA: The code is specific for only three scores.

1447
01:09:24,170 --> 01:09:27,859
所以您可以作为输入，[听不清]多少分数
So you could, as an input, [INAUDIBLE] how many scores

1448
01:09:27,859 --> 01:09:30,109
它在一开始就想要。
it wants at the very beginning.

1449
01:09:30,109 --> 01:09:33,735
然后，得分为[1]，而不是得分为[0]，
And then instead of having scores[0], scores[1],

1450
01:09:33,734 --> 01:09:40,559
您可以使用从0到n减去1或更少的for循环
you could use a for loop that goes through from 0 to n minus 1 or less

1451
01:09:40,560 --> 01:09:45,078
比将要询问的n，应改为一行代码。
than n that will ask, and it should be one line of code instead.

1452
01:09:45,078 --> 01:09:46,370
大卫·马兰（David MALAN）：是的，非常好。
DAVID MALAN: Yeah, really good.

1453
01:09:46,369 --> 01:09:48,648
这就是我们拥有get_int，get_int，get_int的事实。
It's the fact that we have get_int, get_int, get_int.

1454
01:09:48,649 --> 01:09:51,649
这是您可能做得不太理想的第一个迹象。
That's the first sign that you're probably doing something suboptimally.

1455
01:09:51,649 --> 01:09:53,510
可能是正确的，但设计可能不正确
It might be correct, but it's probably not well designed

1456
01:09:53,510 --> 01:09:55,682
因为我确实从字面上复制/粘贴。
because I did literally resort to copy/paste.

1457
01:09:55,681 --> 01:09:57,889
我肯定可以在这里找到一种模式
There's sort of a pattern here that I could certainly

1458
01:09:57,890 --> 01:09:59,580
集成到一个循环中。
integrate into something like a loop.

1459
01:09:59,579 --> 01:10:00,469
所以，让我这样做。
So let me do that.

1460
01:10:00,470 --> 01:10:03,830
实际上，让我摆脱其中的两行代码。
Let me actually get rid of two of these lines of code.

1461
01:10:03,829 --> 01:10:08,869
让我上到这里做类似int的事情，我现在得到0，现在我还不到3，
Let me go up here and do something like for int i get 0, i less than 3 for now,

1462
01:10:08,869 --> 01:10:10,099
我++。
i++.

1463
01:10:10,100 --> 01:10:11,600
让我打开这个for循环。
Let me open up this for loop.

1464
01:10:11,600 --> 01:10:14,120
让我缩进剩下的代码行。
Let me indent that remaining line of code.

1465
01:10:14,119 --> 01:10:16,519
而不是分数[0]-
And instead of scores[0]--

1466
01:10:16,520 --> 01:10:18,930
这是阵列变得真正强大的地方-
this is where arrays get really powerful--

1467
01:10:18,930 --> 01:10:22,760
您可以使用变量来索引数组-
you can use a variable to index into an array--

1468
01:10:22,760 --> 01:10:24,740
即去一个特定的位置。
that is, to go to a specific location.

1469
01:10:24,739 --> 01:10:26,779
我要为变量使用什么？
What do I want to use for my variable?

1470
01:10:26,779 --> 01:10:29,399
好吧，我想我在这里。
Well, I would think i here.

1471
01:10:29,399 --> 01:10:33,979
因此，现在我将代码行从所有三个一式三份减少到三个
So now I've whittled my lines of code down from all three triplicate, three

1472
01:10:33,979 --> 01:10:36,139
几乎完全相同的行，实际上是
nearly identical lines, into just one really

1473
01:10:36,140 --> 01:10:39,290
在一个循环中，它将一次又一次地为我做同样的事情。
inside of a loop that's going to do the same thing for me again and again.

1474
01:10:39,289 --> 01:10:42,229
而且正如Nina所提议的那样，我不必硬编码
And as Nina proposed too, I don't have to hard code

1475
01:10:42,229 --> 01:10:43,859
这3个到处都是。
these 3's all over the place.

1476
01:10:43,859 --> 01:10:46,049
也许我可以做这样的事情。
Maybe I could do something like this.

1477
01:10:46,050 --> 01:10:50,240
我可以说类似，int total获得get_int。
I could say something like, int total gets get_int.

1478
01:10:50,239 --> 01:10:53,689
我可能会问，“总分数”。
And I might ask, "Total number of scores."

1479
01:10:53,689 --> 01:10:56,659
我可以从一开始就问人类
And I could literally ask the human from the get-go

1480
01:10:56,659 --> 01:10:58,489
有多少总成绩。
how many total scores are there.

1481
01:10:58,489 --> 01:11:04,679
然后，我甚至可以在多个地方更强大地使用此变量total
Then I can even more powerfully use this variable, total, in multiple places

1482
01:11:04,680 --> 01:11:07,820
这样，我现在可以更加动态地进行数学运算。
so that now, I'm doing my math much more dynamically.

1483
01:11:07,819 --> 01:11:11,299
但是，我怕，妮娜，这有点破裂了。
This, though-- I'm afraid, Nina, this broke a bit.

1484
01:11:11,300 --> 01:11:13,280
我要多一点-
I'm going to be a little more--

1485
01:11:13,279 --> 01:11:16,279
我需要在第14行上付出更多的努力，因为现在我
I need to exert a little more effort here on line 14 because now I

1486
01:11:16,279 --> 01:11:21,499
不能对分数[0]，[1]和[2]进行硬编码，因为如果分数总数
can't hard code scores[0], [1], and [2] because if the total number of scores

1487
01:11:21,500 --> 01:11:23,819
不仅如此，我还需要做更多的事情。
is more than that, I need to do more addition.

1488
01:11:23,819 --> 01:11:26,009
如果少于这个数，那么我需要做的加法运算就更少了。
If it's fewer than that, I need to do less addition.

1489
01:11:26,010 --> 01:11:28,698
因此，我认为我们已经引入了一个错误，但是我们可以修复该错误。
So I think we've introduced a bug, but we can fix that.

1490
01:11:28,698 --> 01:11:30,240
但是，让我提议一会。
But let me propose for just a moment.

1491
01:11:30,239 --> 01:11:33,469
我们不要让它充满活力，因为我担心那只会使我的生活更加艰难。
Let's not make it dynamic because I worry that's just made my life harder.

1492
01:11:33,470 --> 01:11:36,620
让我们至少在这里首先介绍另一个功能。
Let's at least introduce one other feature here first.

1493
01:11:36,619 --> 01:11:41,089
我将继续在这里定义C的新功能，该功能
I'm going to go ahead up here and define a new feature of C today, which

1494
01:11:41,090 --> 01:11:42,290
被称为常数。
is known as a constant.

1495
01:11:42,289 --> 01:11:46,069
如果我事先知道我想声明一个我想要的数字
If I know in advance that I want to declare a number that I want

1496
01:11:46,069 --> 01:11:49,669
一次又一次地使用而无需复制和粘贴
to use again and again and again without copying and pasting

1497
01:11:49,670 --> 01:11:53,180
字面上的数字3，我可以给自己一个常数int
literally that number 3, I can give myself a constant int

1498
01:11:53,180 --> 01:11:58,160
由const int total = 3。
by a const int total = 3.

1499
01:11:58,159 --> 01:12:01,319
这声明了编程中所谓的常量，
This declares what's called a constant in programming,

1500
01:12:01,319 --> 01:12:05,599
这是许多语言的功能，您可以在其中声明各种变量
which is a feature of many languages whereby you declare a variable of sorts

1501
01:12:05,600 --> 01:12:07,370
其价值永远不会改变。
whose value can never change.

1502
01:12:07,369 --> 01:12:09,869
设置后，将无法更改。
Once you set it, you cannot change it.

1503
01:12:09,869 --> 01:12:12,019
那是一件好事，因为它不应该
And that's a good thing because, one, it shouldn't

1504
01:12:12,020 --> 01:12:13,603
在此程序的上下文中进行更改。
change in the context of this program.

1505
01:12:13,603 --> 01:12:16,460
还有两个，以防万一您（人类）容易犯错，
And two, just in case you, the human, are fallible,

1506
01:12:16,460 --> 01:12:19,103
您不想在不想要的时候不小心更改它。
you don't want to accidentally change it when you don't intend.

1507
01:12:19,103 --> 01:12:21,020
这是编程语言的功能
So this is a feature of a programming language

1508
01:12:21,020 --> 01:12:23,850
这样的保护可以保护您免受自己的伤害。
that sort of protects you from yourself.

1509
01:12:23,850 --> 01:12:28,280
所以现在我可以将自己的本能和Nina融合在一起，并使用
So now I can sort of take an amalgam of my instincts and Nina's and use

1510
01:12:28,279 --> 01:12:29,779
这个变量，总计。
this variable, total.

1511
01:12:29,779 --> 01:12:32,569
实际上，在声明常量时的另一种约定
And actually, another convention when declaring constants

1512
01:12:32,569 --> 01:12:35,959
是要大写它们只是为了使视觉上清楚地知道
is to capitalize them just to make visually clear that there's

1513
01:12:35,960 --> 01:12:38,820
关于此变量的某些不同或特殊之处。
something different or special about this variable.

1514
01:12:38,819 --> 01:12:42,319
所以我将其更改为TOTAL，并在这里使用该值
So I'm going to change this to TOTAL, and I'm going to use that value here

1515
01:12:42,319 --> 01:12:45,259
在这里，在这里
and here and also down here.

1516
01:12:45,260 --> 01:12:49,550
但是我怕Nina和我都要做一些清理工作
But I'm afraid both Nina and I have a little bit of cleanup here to do

1517
01:12:49,550 --> 01:12:54,680
因为我仍然有硬编码的分数[0]，分数[1]和分数[2]。
in that I still have hard coded scores[0], scores[1], and scores[2].

1518
01:12:54,680 --> 01:12:58,552
我想将数量不断变化的值加在一起。
And I want to add a changing number of values together.

1519
01:12:58,551 --> 01:12:59,259
那你知道吗？
So you know what?

1520
01:12:59,260 --> 01:13:00,270
我有一个主意。
I've got an idea.

1521
01:13:00,270 --> 01:13:03,260
让我继续创建一个
Let me go ahead and create a function that's

1522
01:13:03,260 --> 01:13:05,070
为我计算一个平均值。
going to compute an average for me.

1523
01:13:05,069 --> 01:13:08,779
因此，如果我想创建自己的计算平均值的函数，
So if I want to create my own function that computes an average,

1524
01:13:08,779 --> 01:13:10,649
我希望它返回一个浮点值，
I want it to return a floating point value,

1525
01:13:10,649 --> 01:13:13,399
只是为了避免截断任何数学运算。
just so that we don't truncate any math.

1526
01:13:13,399 --> 01:13:15,019
我将其称为平均值。
I'm going to call this average.

1527
01:13:15,020 --> 01:13:18,560
这个函数的输入将是长度
And the input to this function is going to be the length

1528
01:13:18,560 --> 01:13:21,710
数组和实际数组的关系。
of an array and the actual array.

1529
01:13:21,710 --> 01:13:24,320
这是目前为止时髦的语法的最后一部分。
And this is the last piece of funky syntax for now.

1530
01:13:24,319 --> 01:13:31,699
事实证明，当您要将数组作为输入传递给自定义函数时，
It turns out that when you want to pass an array as input to a custom function,

1531
01:13:31,699 --> 01:13:35,359
您实际上再次使用了这些方括号，但未指定大小。
you literally use those square brackets again, but you don't specify the size.

1532
01:13:35,359 --> 01:13:37,939
这样做的好处是
And the upside of this is that your function then

1533
01:13:37,939 --> 01:13:42,049
可以支持其中有一个空格，两个空格，三个空格的数组
can support an array that's got one space in it, two spaces, three,

1534
01:13:42,050 --> 01:13:42,800
一百。
a hundred.

1535
01:13:42,800 --> 01:13:45,030
这样更动态。
It's more dynamic this way.

1536
01:13:45,029 --> 01:13:47,089
那么，如何在这里计算平均值？
So how do I compute an average here?

1537
01:13:47,090 --> 01:13:48,590
我可以通过几种不同的方式来做到这一点。
I can do this a few different ways.

1538
01:13:48,590 --> 01:13:50,975
但是我认为早先的建议使
But I think what was suggested earlier makes

1539
01:13:50,975 --> 01:13:52,850
感觉上，我可以进行某种总结。
sense, where I can do some kind of summation.

1540
01:13:52,850 --> 01:13:54,898
所以让我做int sum = 0。
So let me do int sum = 0.

1541
01:13:54,898 --> 01:13:57,440
因为您如何计算一堆数字的平均值？
Because how do you compute the average of a bunch of numbers?

1542
01:13:57,439 --> 01:14:00,169
好吧，您将它们全部加在一起，然后除以总数。
Well, you add them all together, and you divide by the total.

1543
01:14:00,170 --> 01:14:01,670
好吧，让我们看看我该怎么做。
Well, let's see how I might do that.

1544
01:14:01,670 --> 01:14:06,050
让我做一下，我得到0，而我小于-
Let me do for int i gets 0, i less than--

1545
01:14:06,050 --> 01:14:06,920
这应该是什么？
what should this be?

1546
01:14:06,920 --> 01:14:11,990
好吧，如果我作为自定义函数传递数组的长度
Well, if I'm being passed as this custom function the length of the array

1547
01:14:11,989 --> 01:14:16,279
和实际的数组，我想我可以从头到尾进行迭代，
and the actual array, I think I can iterate from i up to length,

1548
01:14:16,279 --> 01:14:18,869
然后在每次迭代中使用i ++。
and then i++ on each iteration.

1549
01:14:18,869 --> 01:14:20,719
然后在每次迭代中，我想
And then on each iteration, I think I want

1550
01:14:20,720 --> 01:14:27,450
求和，再加上数组第i个位置中的任何值，可以这么说。
to do sum plus whatever is in the array's i-th location, so to speak.

1551
01:14:27,449 --> 01:14:31,159
同样，这是上周为此的简写形式。
So again, this is shorthand notation per last week for this.

1552
01:14:31,159 --> 01:14:38,329
总和等于任意总和加上数组i中的任意位置。
Sum equals whatever sum is plus whatever is in location i of the array.

1553
01:14:38,329 --> 01:14:40,669
当我完成所有这些操作后，我想
And once I've done all of that, I think what

1554
01:14:40,670 --> 01:14:47,400
我可以做的是返回总和除以数组的长度。
I can do is return the total sum divided by the length of the array.

1555
01:14:47,399 --> 01:14:50,509
我喜欢整个方法，假设我的代码是正确的，
And what I like about this whole approach-- assuming my code's correct,

1556
01:14:50,510 --> 01:14:54,440
而且我认为这还不是-请注意我可以做的主要工作。
and I don't think it is just yet-- notice what I can do back up in main.

1557
01:14:54,439 --> 01:14:58,399
现在我可以抽象出计算平均值的概念
Now I can abstract away the notion of calculating an average

1558
01:14:58,399 --> 01:15:04,862
并在此处使用此行代码执行类似的操作。
and just do something like this with this line of code here.

1559
01:15:04,863 --> 01:15:05,780
那我刚才做了什么？
So what did I just do?

1560
01:15:05,779 --> 01:15:09,079
发生了很多事情，但让我们在这里重点关注第14行。
A lot's going on, but let's focus for a moment on line 14 here.

1561
01:15:09,079 --> 01:15:12,229
在第14行，我仍然只是打印一些浮点数的平均值
On line 14, I'm still just printing the average of some floating point

1562
01:15:12,229 --> 01:15:13,229
占位符。
placeholder.

1563
01:15:13,229 --> 01:15:17,569
但是我现在作为输入传递的是这个函数，平均值，
But what I'm passing as input now is this function, average,

1564
01:15:17,569 --> 01:15:20,209
其输入将为TOTAL，这又仅仅是
whose inputs are going to be TOTAL, which again is just

1565
01:15:20,210 --> 01:15:23,210
最上层的这个常数-哦，对不起，我真讨厌。
this constant at the very top-- oh, sorry, I goofed.

1566
01:15:23,210 --> 01:15:26,420
我应该大写它，这在最上面就是那个常数。
I should have capitalized it, which is just that constant at the very top.

1567
01:15:26,420 --> 01:15:29,840
我在传递分数，同样，这只是
And I'm passing in scores, which again, is just

1568
01:15:29,840 --> 01:15:32,750
所有这些分数的数组。
this array of all of those scores.

1569
01:15:32,750 --> 01:15:36,180
同时，在函数中，在函数的上下文中，
Meanwhile, in the function, in the context of the function,

1570
01:15:36,180 --> 01:15:39,140
请注意，函数输入的名称
notice that the names of the inputs to a function

1571
01:15:39,140 --> 01:15:41,870
不需要匹配所要变量的名称
do not need to match the names of the variables being

1572
01:15:41,869 --> 01:15:43,409
传递给该函数。
passed into that function.

1573
01:15:43,409 --> 01:15:46,819
因此，即使总的来说，它们被称为TOTAL和得分，
So even though in main, they're called TOTAL and scores,

1574
01:15:46,819 --> 01:15:48,889
在我的职能范围内，平均而言，
in the context of my function, average, I

1575
01:15:48,890 --> 01:15:54,140
可以将它们称为x和y，a和b，或更笼统地说是长度和数组。
can call them x and y, a and b, or more generically, length and array.

1576
01:15:54,140 --> 01:15:56,660
我不知道数组是什么，但这是一个整数数组。
I don't know what the array is, but it's an array of ints.

1577
01:15:56,659 --> 01:16:01,279
我不知道它有多长，但是答案将是冗长的。
And I don't know how long it is, but that answer is going to be in length.

1578
01:16:01,279 --> 01:16:03,559
但是这里仍然有一个错误。
But there's still a bug here.

1579
01:16:03,560 --> 01:16:04,640
仍然有一个错误。
There's still a bug.

1580
01:16:04,640 --> 01:16:07,940
如果暂时忽略main，这是一个微妙的问题。
And if we ignore main for a moment, this is a subtle one.

1581
01:16:07,939 --> 01:16:11,839
有没有人看到我第三次犯的错误
Does anyone see a mistake that I've made probably for the third time

1582
01:16:11,840 --> 01:16:14,330
现在过去两个星期了吗？
now over the past two weeks?

1583
01:16:14,329 --> 01:16:18,489
我在这里用代码做了什么细微的错误
What mistake subtle have I made here with my code

1584
01:16:18,489 --> 01:16:21,849
仅在这种平均功能下？
only in this average function?

1585
01:16:21,850 --> 01:16:23,740
这有点微妙。
This one's a little more subtle.

1586
01:16:23,739 --> 01:16:27,249
但目标是计算整堆整数的平均值
But the goal is to compute the average of a whole bunch of integers

1587
01:16:27,250 --> 01:16:28,459
并返回答案。
and return the answer.

1588
01:16:28,460 --> 01:16:29,770
尼古拉斯？
Nicholas?

1589
01:16:29,770 --> 01:16:33,940
NICHOLAS：您已经在函数中声明了变量。
NICHOLAS: You've declared the variable within the function.

1590
01:16:33,939 --> 01:16:37,419
DAVID MALAN：我已经在函数中声明了变量。
DAVID MALAN: I've declared the variable within the function.

1591
01:16:37,420 --> 01:16:42,460
可以，因为我在这里声明了变量和，我想你的意思是。
That's OK because I've declared my variable sum here, I think you mean.

1592
01:16:42,460 --> 01:16:45,430
但这在平均功能之内。
But that's inside of the average function.

1593
01:16:45,430 --> 01:16:49,870
我在最外面的花括号内使用sum
And I'm using sum inside of the outermost curly braces

1594
01:16:49,869 --> 01:16:50,889
那是定义的。
that was defined.

1595
01:16:50,890 --> 01:16:52,300
这样就可以了。
And so that's OK.

1596
01:16:52,300 --> 01:16:53,590
没关系。
That's OK.

1597
01:16:53,590 --> 01:16:56,650
让我们在这里再考虑一下。
Let's take another thought here.

1598
01:16:56,649 --> 01:17:00,084
奥利维亚（Olivia），该错误可能还会出现在哪里？
Olivia, where might the bug still be?

1599
01:17:00,085 --> 01:17:01,960
OLIVIA：返回类型是浮点数，但是你是
OLIVIA: The return type's a float, but you're

1600
01:17:01,960 --> 01:17:03,425
返回一个整数除以一个整数。
returning an int divided by an int.

1601
01:17:03,425 --> 01:17:04,300
大卫·马兰（David MALAN）：完美。
DAVID MALAN: Perfect.

1602
01:17:04,300 --> 01:17:06,400
所以我又犯了同样的愚蠢错误
So I again made that same stupid mistake that's

1603
01:17:06,399 --> 01:17:08,709
随着时间的流逝会越来越明显
just going to get more obvious as time goes on

1604
01:17:08,710 --> 01:17:12,760
如果我想做浮点运算，就像阿丽亚娜火箭一样
that if I want to do floating point arithmetic, just like the Ariane rocket

1605
01:17:12,760 --> 01:17:15,550
讨论，爱国者导弹-诸如此类的细节
discussion, the Patriot missile-- like, these kinds of details

1606
01:17:15,550 --> 01:17:16,870
程序中的问题。
matter in a program.

1607
01:17:16,869 --> 01:17:18,789
现在是正确的，因为我实际上要去
Now it's correct because I'm actually going

1608
01:17:18,789 --> 01:17:21,999
确保即使此处的上下文
to ensure that even though the context here

1609
01:17:22,000 --> 01:17:24,740
比现实世界中的重要得多，
is much less important than those real-world contexts,

1610
01:17:24,739 --> 01:17:28,959
只是计算分数的平均值，我不会意外地截断
just computing some average of scores, I'm not going to accidentally truncate

1611
01:17:28,960 --> 01:17:30,212
我的任何价值观。
any of my values.

1612
01:17:30,212 --> 01:17:32,170
同样，在此功能的上下文中，
So again, in the context here of this function,

1613
01:17:32,170 --> 01:17:34,540
平均而言，这只是应用上周的一些原则。
average is just applying some of last week's principles.

1614
01:17:34,539 --> 01:17:35,499
我有一个变量。
I've got a variable.

1615
01:17:35,500 --> 01:17:36,310
我有一个循环。
I've got a loop.

1616
01:17:36,310 --> 01:17:39,070
最终，我正在做一些浮点运算。
And I'm doing some floating point arithmetic, ultimately.

1617
01:17:39,069 --> 01:17:42,789
现在，我正在创建一个接受两个输入的函数。
And I'm now creating a function that takes two inputs.

1618
01:17:42,789 --> 01:17:44,889
一个是长度，一个是长度-
One is length, and one is the length--

1619
01:17:44,890 --> 01:17:48,100
一个是数组本身，另一个是返回类型，正如Olivia指出的那样，
one is the array itself, and the return type, as Olivia notes,

1620
01:17:48,100 --> 01:17:51,790
是一个浮点数，因此我的输出也得到了很好的定义。
is a float so that my output is also well defined.

1621
01:17:51,789 --> 01:17:53,589
但是，这又是一件好事，
But what's nice about this is, again, you

1622
01:17:53,590 --> 01:17:55,660
可以将这些功能视为抽象。
can think of these functions as abstractions.

1623
01:17:55,659 --> 01:18:00,759
现在，我不必担心如何计算平均值，因为我现在
Now I don't need to worry about how I calculate an average because I now

1624
01:18:00,760 --> 01:18:03,400
具有此帮助功能，自定义功能
have this helper function, a custom function

1625
01:18:03,399 --> 01:18:05,929
我写的那可以帮助我回答这个问题。
I wrote that can help me answer that question.

1626
01:18:05,930 --> 01:18:09,010
在这里，请注意该平均值函数的输出
And here, notice that the output of this average function

1627
01:18:09,010 --> 01:18:12,842
将成为printf的输入。
will become an input into printf.

1628
01:18:12,841 --> 01:18:15,049
我在这里添加到混合中的唯一其他功能
And the only other feature I've added to the mix here

1629
01:18:15,050 --> 01:18:18,380
现在不仅是数组，这使我们能够创建
now are not only arrays, which allow us to create

1630
01:18:18,380 --> 01:18:21,650
多个变量，可变数量的变量，如果您愿意，
multiple variables, a variable number of variables, if you will,

1631
01:18:21,649 --> 01:18:23,419
而且这个常数的概念。
but also this notion of a constant.

1632
01:18:23,420 --> 01:18:26,960
如果我发现自己一次又一次地使用相同的数字，
If I find myself using the same number again and again and again,

1633
01:18:26,960 --> 01:18:29,570
这个常数可以帮助我保持代码干净。
this constant can help me keep my code clean.

1634
01:18:29,569 --> 01:18:30,439
并注意这一点。
And notice this.

1635
01:18:30,439 --> 01:18:33,709
如果明年（也许是另一个学期）有四个分数或四个测试，
If next year, maybe another semester, there's four scores or four tests,

1636
01:18:33,710 --> 01:18:34,940
我在一处更改。
I change it in one place.

1637
01:18:34,939 --> 01:18:35,869
我重新编译。
I recompile.

1638
01:18:35,869 --> 01:18:37,609
繁荣，我完成了。
Boom, I'm done.

1639
01:18:37,609 --> 01:18:39,979
精心设计的程序不需要您
A well-designed program does not require that you

1640
01:18:39,979 --> 01:18:43,129
仔细阅读全文，在此固定数字，在此固定数字。
go reading through the entirety of it, fixing numbers here, numbers there.

1641
01:18:43,130 --> 01:18:46,010
在一处更改它可以使我改进此程序，
Changing it in one place can allow me to improve this program,

1642
01:18:46,010 --> 01:18:49,520
使其明年支持四个测试，而不仅仅是三个。
make it support four tests next year instead of just the three.

1643
01:18:49,520 --> 01:18:52,760
但我认为最好还是采取
But better still would be to take, I think,

1644
01:18:52,760 --> 01:18:56,900
尼娜之前的建议，也许只是使用get_int并问人类
Nina's advice before, which was to maybe just use get_int and ask the human

1645
01:18:56,899 --> 01:18:58,909
他们实际有多少测试。
for how many tests they actually have.

1646
01:18:58,909 --> 01:19:00,561
那也行得通。
That too would work.

1647
01:19:00,561 --> 01:19:02,269
好吧，让我在这里暂停一下，看看是否有
Well, let me pause here to see if there's

1648
01:19:02,270 --> 01:19:07,460
关于数组或常量的任何问题
any questions then about arrays or about constants

1649
01:19:07,460 --> 01:19:13,770
或以这种方式将它们作为输入和输出传递。
or passing them around as inputs and outputs in this way.

1650
01:19:13,770 --> 01:19:16,740
是的，交给索菲娅。
Yeah, over to Sophia.

1651
01:19:16,739 --> 01:19:21,569
SOPHIA：我对使用浮点数以及为什么使用一个浮点数有疑问
SOPHIA: I had question about the use of float and why the use of one float

1652
01:19:21,569 --> 01:19:23,789
使整个输出为浮点型。
causes the whole output to be a float.

1653
01:19:23,789 --> 01:19:24,869
为什么会发生这种情况？
Why does that occur?

1654
01:19:24,869 --> 01:19:25,919
大卫·马兰（David MALAN）：是的，这是一个很好的问题。
DAVID MALAN: Yeah, really good question.

1655
01:19:25,920 --> 01:19:27,340
这就是C的行为方式。
That's just how C behaves.

1656
01:19:27,340 --> 01:19:30,840
只要涉及一个或多个浮点值
So long as there is one or more floating point values involved

1657
01:19:30,840 --> 01:19:35,820
在数学公式中，它将使用该数据类型，
in a mathematical formula, it is going to use that data type, which

1658
01:19:35,819 --> 01:19:39,609
如果愿意的话，它是功能更强大的工具，而不是冒着被截断的风险。
is the more powerful one, if you will, rather than risk truncating anything.

1659
01:19:39,609 --> 01:19:41,969
所以你只需要一个花车就可以参加
So you just need one float to be participating

1660
01:19:41,970 --> 01:19:44,490
在有关公式中。
in the formula in question.

1661
01:19:44,489 --> 01:19:45,899
好问题。
Good question.

1662
01:19:45,899 --> 01:19:53,549
关于数组或常量的其他问题，或者它们的传递？
Other questions on arrays or constants or this passing around of them?

1663
01:19:53,550 --> 01:19:57,150
是的，到亚历山德拉。
Yeah, over to Alexandra.

1664
01:19:57,149 --> 01:20:03,239
亚历山德拉：我对数组的声明，分数有疑问。
ALEXANDRA: I have a question about the declaring of the array, scores.

1665
01:20:03,239 --> 01:20:08,369
当您在main中声明它时，您说的是int分数。
When you declared it in main, you said int scores.

1666
01:20:08,369 --> 01:20:11,889
在方括号中，您有TOTAL。
And in the brackets, you have TOTAL.

1667
01:20:11,890 --> 01:20:16,313
您能在没有TOTAL的情况下声明它吗？
Can you declare it without the TOTAL--

1668
01:20:16,313 --> 01:20:17,730
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

1669
01:20:17,729 --> 01:20:18,599
亚历山德拉：-仅是括号？
ALEXANDRA: --only the brackets?

1670
01:20:18,600 --> 01:20:19,530
DAVID MALAN：简短的回答，不。
DAVID MALAN: Short answer, no.

1671
01:20:19,529 --> 01:20:21,939
所以我做到的方式就是您要做的方式。
So the way I did it is the way you do have to do it.

1672
01:20:21,939 --> 01:20:25,809
实际上，如果我强调我在这里所做的事情，那么现在它表示的是TOTAL。
And in fact, if I highlight what I did here, now it currently says TOTAL.

1673
01:20:25,810 --> 01:20:29,400
如果我摆脱了这一点，我会回到第一个版本，我说
If I get rid of that, and I go back to our first version where I said

1674
01:20:29,399 --> 01:20:36,359
像3、3和3这样的东西，您不能这样做，我认为，
something like 3 and 3 and 3 over here, you cannot do this, which I think,

1675
01:20:36,359 --> 01:20:38,009
亚历山德拉（Alexandra），是您的建议。
Alexandra, is what you were proposing.

1676
01:20:38,010 --> 01:20:41,640
创建阵列时，计算机需要知道阵列的大小。
The computer needs to know how big the array is when you are creating it.

1677
01:20:41,640 --> 01:20:44,160
唯一的例外是当您
The exception to that is that when you're

1678
01:20:44,159 --> 01:20:47,069
将数组从一个函数传递给另一个函数，
passing an array from one function to another,

1679
01:20:47,069 --> 01:20:49,349
您无需告诉该自定义功能
you do not need to tell that custom function

1680
01:20:49,350 --> 01:20:51,990
数组有多大，因为同样，您事先也不知道。
how big the array is because, again, you don't know in advance.

1681
01:20:51,989 --> 01:20:55,409
您正在编写一个相当通用的动态函数，其作用是实现生命
You're writing a fairly generic, dynamic function whose purpose in life

1682
01:20:55,409 --> 01:21:00,749
将任何数组作为整数和任意长度的输入
is to take any array as input of integers and any length

1683
01:21:00,750 --> 01:21:05,639
并相应地以与该事物的大小相匹配的平均值进行响应。
and respond accordingly with an average that matches the size of that thing.

1684
01:21:05,640 --> 01:21:09,870
顺便提一下，你们当中那些曾经编程的人，尤其是在Java中，
And those of you, as an aside, who have programmed before, especially in Java,

1685
01:21:09,869 --> 01:21:13,889
与Java和某些其他语言不同，数组的长度
unlike in Java and certain other languages, the length of an array

1686
01:21:13,890 --> 01:21:16,320
没有内置到数组本身中。
is not built into the array itself.

1687
01:21:16,319 --> 01:21:20,589
如果您没有将数组的长度传递给另一个函数，
If you do not pass in the length of an array to another function,

1688
01:21:20,590 --> 01:21:24,280
无法确定数组的大小。
there is no way to determine how big the array is.

1689
01:21:24,279 --> 01:21:26,849
这不同于Java和其他语言，
This is different from Java and other languages,

1690
01:21:26,850 --> 01:21:29,880
从某种意义上讲，您可以在哪里询问数组的长度。
where you can ask the array, in some sense, what is its length.

1691
01:21:29,880 --> 01:21:32,490
在C语言中，您必须同时传递两个数组
In C, you have to pass both the array itself

1692
01:21:32,489 --> 01:21:35,609
和它的长度分开。 [？新浪吗？]
and its length around separately. [? Sina? ?]

1693
01:21:35,609 --> 01:21:38,879
[？新浪：？]我只是-我对如何做还有些困惑，
[? SINA: ?] I just-- I'm still a little bit confused about how,

1694
01:21:38,880 --> 01:21:44,740
当我们编写第二个命令时，括号中的内容何时无效？
when we write that second command, when is it void in the parentheses?

1695
01:21:44,739 --> 01:21:47,519
以及何时定义int？
And when do we define the int?

1696
01:21:47,520 --> 01:21:50,918
因为正如我记得我们做的那样-
Because as I remember when we did the--

1697
01:21:50,917 --> 01:21:53,459
得到一个负数，我们得到一个正数，它是无效的，
get a negative number, we get a positive number, it was void,

1698
01:21:53,460 --> 01:21:55,500
但是我们还是给了它一些输入。
but we still kind of gave it an input.

1699
01:21:55,500 --> 01:21:57,705
我只是没有被完全卖掉。
I'm just not completely sold on that.

1700
01:21:57,704 --> 01:21:59,079
戴维·马兰（David MALAN）：好的，很好的问题。
DAVID MALAN: Sure, good question.

1701
01:21:59,079 --> 01:22:01,569
让我继续打开前面的示例，
Let me go ahead and open up that previous example,

1702
01:22:01,569 --> 01:22:04,959
这是一个小问题，但是在这里它具有正确的语法。
which was a little buggy, but it has the right syntax here.

1703
01:22:04,960 --> 01:22:07,620
因此，这是之前的get_negative_int函数。
So here was the get_negative_int function from before.

1704
01:22:07,619 --> 01:22:10,619
和， [？新浪，？]，您知道输入的内容无效。
And, [? Sina, ?] you know it was void as input.

1705
01:22:10,619 --> 01:22:13,169
因此，您发表了一条评论，仍然需要输入。
So there was one comment you made where it still took input.

1706
01:22:13,170 --> 01:22:14,010
事实并非如此。
That was not so.

1707
01:22:14,010 --> 01:22:17,070
因此get_negative_int没有接受任何输入。
So get_negative_int did not take any input.

1708
01:22:17,069 --> 01:22:19,619
举例来说，如果我们向上滚动到main，
And case in point, if we scroll up to main,

1709
01:22:19,619 --> 01:22:22,529
请注意，当我在第10行调用它时，我
notice that when I called it on line 10, I

1710
01:22:22,529 --> 01:22:25,919
get_negative_int表示，右括号，右括号，
said get_negative_int, open parenthesis, close parenthesis,

1711
01:22:25,920 --> 01:22:29,040
这些括号内没有任何输入。
with no inputs inside of those parentheses.

1712
01:22:29,039 --> 01:22:32,219
这个关键字“ void”，上周我们已经见过几次了
This keyword "void," which we've seen a few times now last week

1713
01:22:32,220 --> 01:22:35,880
而本周，这只是C语言中的一个显式关键字，
and this week, is just an explicit keyword in C that says,

1714
01:22:35,880 --> 01:22:41,340
不要在这里放任何东西，也就是说，对我来说这是不正确的
do not put anything here, which is to say, it would be incorrect for me up

1715
01:22:41,340 --> 01:22:44,970
在这里做这样的事情，喜欢传递数字，
here to do something like this, like to pass in a number,

1716
01:22:44,970 --> 01:22:48,990
或传递提示或括号内的任何内容。
or to pass in a prompt, or anything inside of those parentheses.

1717
01:22:48,989 --> 01:22:51,629
事实上，此函数get_negative_int
The fact that this function, get_negative_int

1718
01:22:51,630 --> 01:22:56,340
将void作为其输入意味着它不接受任何输入。
takes void as its input means it does not take any inputs whatsoever.

1719
01:22:56,340 --> 01:22:56,942
没关系。
That's fine.

1720
01:22:56,942 --> 01:22:59,400
对于get_negative_int，函数的名称说明了一切。
For get_negative_int, the name of the function says it all.

1721
01:22:59,399 --> 01:23:02,366
就像，不需要参数化或自定义
Like, there's no need to parameterize or customize

1722
01:23:02,367 --> 01:23:04,200
获得负int本身的行为。
the behavior of getting negative int itself.

1723
01:23:04,199 --> 01:23:06,179
您只想得到一个负整数。
You just want to get a negative int.

1724
01:23:06,180 --> 01:23:09,300
相反，尽管如此，我们刚刚编写的函数
By contrast, though, with the function we just wrote,

1725
01:23:09,300 --> 01:23:14,940
平均而言，此功能确实具有接受输入的概念意义，
average, this function does make conceptual sense to take inputs,

1726
01:23:14,939 --> 01:23:17,489
因为你不能只说，给我平均值。
because you can't just say, give me the average.

1727
01:23:17,489 --> 01:23:18,929
喜欢，平均水平是多少？
Like, average of what?

1728
01:23:18,930 --> 01:23:22,110
就像，它需要接受输入才能为您回答该问题。
Like, it needs to take input so as to answer that question for you.

1729
01:23:22,109 --> 01:23:24,839
在这种情况下，输入是数字数组本身
And the input, in this case, is the array itself of numbers

1730
01:23:24,840 --> 01:23:28,425
以及该数组的长度，以便您可以进行算术运算。
and the length of that array so you can do the arithmetic.

1731
01:23:28,425 --> 01:23:31,050
所以， [？希望可以帮助我们做出区分。
And so, [? Sina, ?] hopefully, that helps make the distinction.

1732
01:23:31,050 --> 01:23:33,930
当您不想接受输入时，可以使用void。
You use void when you don't want to take input.

1733
01:23:33,930 --> 01:23:38,340
您实际上指定了逗号分隔的参数列表
And you actually specify a comma-separated list of arguments

1734
01:23:38,340 --> 01:23:42,000
当您确实想接受输入时。
when you do want to take input.

1735
01:23:42,000 --> 01:23:46,169
好吧，所以到目前为止，我们确实专注于整数。
All right, so we focused up until now on integers, really.

1736
01:23:46,170 --> 01:23:49,020
但是让我们简化一下，因为事实证明
But let's simplify a little bit because it turns out

1737
01:23:49,020 --> 01:23:52,020
数组和内存实际上相交
that arrays and memory actually intersect

1738
01:23:52,020 --> 01:23:55,740
创建大多数任何计算机程序的一些非常熟悉的功能，即
to create some very familiar features of most any computer program, namely

1739
01:23:55,739 --> 01:23:57,969
文本或字符串更一般。
text or strings more generally.

1740
01:23:57,970 --> 01:24:03,010
因此，假设我们进一步简化了，没有更多的整数，没有更多的整数数组。
So suppose we simplify further, no more integers, no more arrays of integers.

1741
01:24:03,010 --> 01:24:05,490
让我们从一个字符开始片刻
Let's just start for a moment with a single character

1742
01:24:05,489 --> 01:24:09,839
并编写一个程序，可以从该马里奥游戏中创建单个积木。
and write a program that just creates a single brick from that Mario game.

1743
01:24:09,840 --> 01:24:13,540
让我继续在这里创建一个名为brick.c的程序。
Let me go ahead and create a program here called brick.c.

1744
01:24:13,539 --> 01:24:15,899
在brick.c中，我要去#include
And in brick.c, I'm just going to #include

1745
01:24:15,899 --> 01:24:21,569
stdio.h，int main（void）还有更多关于此void的信息，请稍后再讨论。
stdio.h, int main(void) And more on this void a little later today.

1746
01:24:21,569 --> 01:24:25,169
字符c得到，用引号引起来，“＃”。
Char c gets, quote unquote, '#'.

1747
01:24:25,170 --> 01:24:29,730
然后在这里，让我继续简单地打印一个占位符，
And then down here, let me just go ahead and print very simply a placeholder,

1748
01:24:29,729 --> 01:24:32,799
％c，反斜杠n，然后输出c。
%c, backslash n, and then output c.

1749
01:24:32,800 --> 01:24:34,380
因此，这是一个非常愚蠢的程序。
So this is a pretty stupid program.

1750
01:24:34,380 --> 01:24:37,530
它的唯一目的是打印单个哈希
Its sole purpose in life is to print a single hash

1751
01:24:37,529 --> 01:24:41,939
正如您可能在高度为1的马里奥金字塔中所看到的那样，非常简单。
as you might have in a Mario pyramid of height 1, so very simple.

1752
01:24:41,939 --> 01:24:44,039
让我继续做砖头。
Let me go ahead and make brick.

1753
01:24:44,039 --> 01:24:45,479
看来编译OK了。
It seems to compile OK.

1754
01:24:45,479 --> 01:24:47,039
让我用./brick运行它。
Let me run it with ./brick.

1755
01:24:47,039 --> 01:24:48,749
瞧，我们得到了一块砖。
And voila, we get a single brick.

1756
01:24:48,750 --> 01:24:54,150
但是，让我们考虑一下这里到底发生了什么
But let's consider for just a moment exactly what just happened here

1757
01:24:54,149 --> 01:24:58,236
引擎盖下到底发生了什么
and what actually was going on underneath the hood.

1758
01:24:58,237 --> 01:24:59,070
好吧，你知道吗？
Well, you know what?

1759
01:24:59,069 --> 01:25:00,029
我很好奇
I'm kind of curious.

1760
01:25:00,029 --> 01:25:03,989
我记得从上周开始，我们可以将价值从一件事投射到另一件事。
I remember from last week, we could cast values from one thing to another.

1761
01:25:03,989 --> 01:25:07,289
如果我有点好奇，但我没有打印出c，该怎么办？
What if I got a little curious, and I didn't print out c,

1762
01:25:07,289 --> 01:25:12,479
哪个哈希字符（如％c）是字符的占位符？
which is this hash character, as %c, which is a placeholder for a character?

1763
01:25:12,479 --> 01:25:15,249
如果我有点发疯说％i怎么办？
What if I got a little crazy and said %i?

1764
01:25:15,250 --> 01:25:21,370
我想我可以通过将其转换为int来强制转换此char
I think I could probably coerce this char by casting it to an int

1765
01:25:21,369 --> 01:25:23,829
所以我可以看到它的十进制等值
so I can see its decimal equivalent.

1766
01:25:23,829 --> 01:25:25,959
我可以看到它的实际ASCII码。
I could see its actual ASCII code.

1767
01:25:25,960 --> 01:25:28,350
因此，让我用制砖块对其进行重建。
So let me rebuild this with make brick.

1768
01:25:28,350 --> 01:25:30,330
现在让我做./brick。
Now let me do ./brick.

1769
01:25:30,329 --> 01:25:32,429
我们会看到多少个数字？
And what number might we see?

1770
01:25:32,430 --> 01:25:36,840
上周，我们看到“ HI！”的数量很多，分别为72和73和33。
Last week, we saw 72 a lot, 73, and 33 for "HI!"

1771
01:25:36,840 --> 01:25:39,000
这周，您可以看到35。
This week, you can see 35.

1772
01:25:39,000 --> 01:25:43,139
事实证明，这是代码和ASCII哈希。
It turns out it's the code for and an ASCII hash.

1773
01:25:43,140 --> 01:25:47,730
例如，如果我访问的网站是-
And you can see this, for instance, if I go to a website like--

1774
01:25:47,729 --> 01:25:52,019
让我们去asciichart.com。
let's go to asciichart.com.

1775
01:25:52,020 --> 01:25:55,170
可以肯定的是，如果我去上周的同一张图表，
And sure enough, if I go to the same chart from last week,

1776
01:25:55,170 --> 01:25:58,560
我在这里寻找井号，它的ASCII码是35。
and I look for the hash symbol here, its ASCII code is 35.

1777
01:25:58,560 --> 01:26:02,340
事实证明，在C语言中，它对于计算机而言非常简单
And it turns out, in C, if it's pretty straightforward to the computer

1778
01:26:02,340 --> 01:26:05,390
那是的，如果这是一个字符，我知道我可以将其转换为int，
that, yes, if this is a character, I know I can convert it to an int,

1779
01:26:05,390 --> 01:26:07,440
您不必显式转换它。
you don't have to explicitly cast it.

1780
01:26:07,439 --> 01:26:12,989
您可以只在上下文中将一种数据类型隐式转换为另一种数据类型。
You can instead implicitly cast one data type to another just from context here.

1781
01:26:12,989 --> 01:26:16,949
所以printf和C在这里足够聪明，知道，你在给我
So printf and C are smart enough here to know, OK, you're giving me

1782
01:26:16,949 --> 01:26:19,049
变量c形式的字符。
a character in the form of variable c.

1783
01:26:19,050 --> 01:26:23,083
但是您想将其显示为％i（整数）。
But you want to display it as a %i, an integer.

1784
01:26:23,082 --> 01:26:23,999
没关系。
That's going to be OK.

1785
01:26:24,000 --> 01:26:25,989
确实，我仍然看到数字35。
And indeed, I still see the number 35.

1786
01:26:25,989 --> 01:26:27,391
所以这只是简单的转换。
So that's just simple casting.

1787
01:26:27,391 --> 01:26:29,849
但是，现在让我们将其放在今天的图片中。
But let's now put this into the context of today's picture.

1788
01:26:29,850 --> 01:26:31,372
这个角色如何布置？
How is that character laid out?

1789
01:26:31,372 --> 01:26:33,330
好吧，很简单，如果这是我的记忆，
Well, quite simply, if this is my memory again,

1790
01:26:33,329 --> 01:26:36,149
我们已经摆脱了所有的数字，
and we've gotten rid of all of the numbers, c,

1791
01:26:36,149 --> 01:26:41,249
否则，存储此散列的数据只是存储在这些字节之一中。
otherwise storing this hash, is just being stored in one of these bytes.

1792
01:26:41,250 --> 01:26:47,370
它仅需要一个平方，因为同样，char是一个字节。
It only requires one square because, again, a char is a single byte.

1793
01:26:47,369 --> 01:26:52,239
但等效地，35是实际存储在此处的数字。
But equivalently, 35 is the number that's actually being stored there.

1794
01:26:52,239 --> 01:26:53,789
但是我想知道，我想知道。
But I wonder, I wonder.

1795
01:26:53,789 --> 01:26:55,889
上周，我们花了很多时间来存储
Last week, we spent quite a bit of time storing

1796
01:26:55,890 --> 01:27:01,060
不仅是单个字符，还包括诸如“ hi”和其他表达式之类的实际单词。
not just single characters, but actual words like "hi" and other expressions.

1797
01:27:01,060 --> 01:27:03,490
那如果我要做这样的事情怎么办？
And so what if I were to do something like this?

1798
01:27:03,489 --> 01:27:04,959
让我回到我的代码。
Let me go back to my code.

1799
01:27:04,960 --> 01:27:07,530
让我还不练习我刚才讲的话。
And let me not quite yet practice what I just preached.

1800
01:27:07,529 --> 01:27:11,909
这次让我给自己三个变量-c1，c2和c3。
And let me give myself three variables this time-- c1, c2, and c3.

1801
01:27:11,909 --> 01:27:16,979
让我故意将这三个变量H，I大写，
And let me deliberately store in those three variables H, I, in all caps,

1802
01:27:16,979 --> 01:27:18,719
其次是感叹号。
followed by an exclamation point.

1803
01:27:18,720 --> 01:27:22,170
在上周，当您处理单个角色时，
And per last week, when you're dealing with individual characters,

1804
01:27:22,170 --> 01:27:24,630
您必须在C语言中使用单引号。
you must, in C, use single quotes.

1805
01:27:24,630 --> 01:27:26,520
当您处理多个字符时，
When you're dealing with multiple characters,

1806
01:27:26,520 --> 01:27:29,080
否则上周称为字符串，请使用双引号。
otherwise known last week as strings, use double quotes.

1807
01:27:29,079 --> 01:27:31,829
但这就是为什么我使用单引号，因为我们只是在玩
But that's why I'm using single quotes, because we're only playing

1808
01:27:31,829 --> 01:27:34,059
目前只有单个字符。
at the moment with single characters.

1809
01:27:34,060 --> 01:27:37,080
现在让我继续打印这些值。
Now let me go ahead and print these values out.

1810
01:27:37,079 --> 01:27:43,319
让我打印出％c，％c，％c，并输出c1，c2，c3。
Let me print out %c, %c, %c, and output c1, c2, c3.

1811
01:27:43,319 --> 01:27:49,589
因此，这也许是最愚蠢的方式，您可以打印出一个完整的单词，例如“ HI！”。
So this is perhaps the stupidest way you could print out a full word like "HI!"

1812
01:27:49,590 --> 01:27:54,360
在C中，通过将每个单个字符存储在其自己的变量中，但事实并非如此。
in C by storing every single character in its own variable, but so be it.

1813
01:27:54,359 --> 01:27:57,089
我只是在这里使用这些首要原则。
I'm just using these first principles here.

1814
01:27:57,090 --> 01:27:58,493
我使用％c作为占位符。
I'm using %c as my placeholder.

1815
01:27:58,493 --> 01:27:59,910
我正在打印这些字符。
I'm printing out these characters.

1816
01:27:59,909 --> 01:28:01,949
所以，现在让我做砖。
So let me do make brick now.

1817
01:28:01,949 --> 01:28:02,999
编译确定。
Compiles OK.

1818
01:28:03,000 --> 01:28:04,677
如果我做点斜线-
And if I do a dot slash--

1819
01:28:04,677 --> 01:28:06,719
你知道，我真的应该重命名了这个文件，
you know, I really should have renamed this file,

1820
01:28:06,720 --> 01:28:08,095
但我们稍后会重命名-
but we'll rename it in a moment--

1821
01:28:08,095 --> 01:28:09,630
./brick，“嗨！”
./brick, "HI!"

1822
01:28:09,630 --> 01:28:11,190
让我继续执行此操作。
And let me go ahead and do this.

1823
01:28:11,189 --> 01:28:14,489
现在让我继续并实际上关闭文件。
Let me go ahead now and actually close the file.

1824
01:28:14,489 --> 01:28:18,819
回想一下上周，如果我想从brick.c重命名我的文件，
And recall from last week, if I want to rename my file from brick.c,

1825
01:28:18,819 --> 01:28:22,619
假设，要访问hi.c，我可以使用move命令mv。
let's say, to hi.c, I can use the move command, mv.

1826
01:28:22,619 --> 01:28:26,729
现在，如果我打开此文件，可以肯定的是，有hi.c。
And now if I open up this file, sure enough, there's hi.c.

1827
01:28:26,729 --> 01:28:29,849
而且我更正了我的重命名错误。
And I've fixed my renaming mistake.

1828
01:28:29,850 --> 01:28:35,040
好吧，再说一次，如果我现在打个招呼，我也打个招呼。
All right, so again, if I now do make hi, and I do ./hi, voila,

1829
01:28:35,039 --> 01:28:35,999
我看到“嗨！”
I see the "HI!"

1830
01:28:36,000 --> 01:28:40,051
但是，这又是一种愚蠢的实现字符串的方式。
But again, this is kind of a stupid way of implementing a string.

1831
01:28:40,051 --> 01:28:41,759
但是，让我们仍然在引擎盖下看。
But let's still look underneath the hood.

1832
01:28:41,760 --> 01:28:43,093
让我继续好奇。
Let me go ahead and get curious.

1833
01:28:43,092 --> 01:28:46,310
让我打印％i，％i和％i。
Let me print out %i, %i, and %i.

1834
01:28:46,310 --> 01:28:48,479
这次让我包括空格
And Let me include spaces this time just so I

1835
01:28:48,479 --> 01:28:51,699
可以看到数字之间的分隔。
can see separation between the numbers.

1836
01:28:51,699 --> 01:28:54,749
让我再打个招呼，。/ hi。
Let me make hi again, ./hi.

1837
01:28:54,750 --> 01:28:56,759
好，那是72。
OK, there's that 72.

1838
01:28:56,760 --> 01:28:57,900
就是73。
There's that 73.

1839
01:28:57,899 --> 01:29:00,339
上周有33个。
And there's that 33 from last week.

1840
01:29:00,340 --> 01:29:01,653
所以这也很有趣。
So that's interesting too.

1841
01:29:01,653 --> 01:29:04,320
那么，计算机内存的底层到底是怎么回事？
So what's going on underneath the hood in the computer's memory?

1842
01:29:04,319 --> 01:29:06,236
好吧，当我存储这三个字符时，
Well, when I'm storing these three characters,

1843
01:29:06,237 --> 01:29:11,040
现在我只是将它们存储在三个不同的盒子中，所以c1，c2，c3。
now I'm just storing them in three different boxes, so c1, c2, c3.

1844
01:29:11,039 --> 01:29:14,969
当您集体看时，它看起来像是一个完整的词
And when you look at it collectively, it kind of looks like a whole word

1845
01:29:14,970 --> 01:29:17,610
即使是这些字符，当然也是如此。
even though it's, of course, just these individual characters.

1846
01:29:17,609 --> 01:29:20,849
因此，引擎盖下面是72、73、33。
So what's underneath the hood, of course, though, is 72, 73, 33.

1847
01:29:20,850 --> 01:29:23,160
或等效地，以二进制形式表示。
Or equivalently, in binary, just this.

1848
01:29:23,159 --> 01:29:25,409
所以故事是一样的，即使我们现在正在谈论
So the story is the same even though we're now talking

1849
01:29:25,409 --> 01:29:28,539
关于字符而不是整数。
about chars instead of integers.

1850
01:29:28,539 --> 01:29:31,109
但是，当我这样做时会发生什么呢？
But what happens when I do this?

1851
01:29:31,109 --> 01:29:35,039
当我执行字符串s时，如果不加引号，“ HI！”，会发生什么情况？
What happens when I do string s gets, quote unquote, "HI!"

1852
01:29:35,039 --> 01:29:36,449
使用双引号？
using double quotes?

1853
01:29:36,449 --> 01:29:38,849
好吧，让我们相应地更改此程序。
Well, let's change this program accordingly.

1854
01:29:38,850 --> 01:29:42,390
让我继续做上周要做的事情，
Let me go ahead and do what we would have done last week, string--

1855
01:29:42,390 --> 01:29:44,760
我称它为s代表字符串-
I'll call it s just for s for string--

1856
01:29:44,760 --> 01:29:45,300
“你好！”
"HI!"

1857
01:29:45,300 --> 01:29:46,410
大写。
in all caps.

1858
01:29:46,409 --> 01:29:47,924
我可以简化下一行。
I can simplify this next line.

1859
01:29:47,925 --> 01:29:52,170
我将使用％s作为字符串s的占位符。
I'm going to use %s as a placeholder for string s.

1860
01:29:52,170 --> 01:29:54,300
但是，现在让我们来揭示一个真正的字符串
But let's, for now, reveal what a string really

1861
01:29:54,300 --> 01:29:55,800
是，因为弦是艺术术语。
is, because string is a term of art.

1862
01:29:55,800 --> 01:29:59,370
每种编程语言都有“字符串”，即使在技术上没有
Every programming language has "strings" even if it doesn't technically

1863
01:29:59,369 --> 01:30:01,259
具有称为字符串的数据类型。
have a data type called string.

1864
01:30:01,260 --> 01:30:04,560
从技术上讲，C没有称为字符串的数据类型。
C does not technically have a data type called string.

1865
01:30:04,560 --> 01:30:08,850
我们通过CS50的库将此类型添加到了C中。
We have added this type to C by way of CS50's library.

1866
01:30:08,850 --> 01:30:12,720
但是现在，如果我打招呼，请注意我的代码可以编译。
But now if I do make hi, notice that my code compiles OK.

1867
01:30:12,720 --> 01:30:17,230
如果我按./hi Enter，瞧，我仍然看到“ HI！”，
And if I do ./hi Enter, voila, I still see "HI!",

1868
01:30:17,229 --> 01:30:19,569
这也是我上周也会看到的。
which is what I would have seen last week as well.

1869
01:30:19,569 --> 01:30:23,699
如果我们在计算机的内存中描述这一点，那是因为“嗨！”是三个字母，
And if we depict this in the computer's memory, because "HI!" is three letters,

1870
01:30:23,699 --> 01:30:26,039
就像在说，好吧，给我三个盒子，
it's kind of like saying, well, give me three boxes,

1871
01:30:26,039 --> 01:30:27,929
让我称这个字符串为s。
and let me call this string s.

1872
01:30:27,930 --> 01:30:30,510
所以这感觉像是一个合理的艺术家的演绎
So this feels like a reasonable artist's rendition

1873
01:30:30,510 --> 01:30:35,070
如果它存储的是三个字母的单词，例如“ HI！”，它是什么
of what s is if it's storing a three-letter word like "HI!"

1874
01:30:35,069 --> 01:30:39,839
但是任何时候我们都有这样的字符序列，
But any time we have sequences of characters like this,

1875
01:30:39,840 --> 01:30:44,190
我觉得我们现在正在看到适当编程的能力
I feel like we're now seeing the capability of a proper programming

1876
01:30:44,189 --> 01:30:44,759
语言。
language.

1877
01:30:44,760 --> 01:30:48,250
之前我们介绍了字符串的概念。
We introduced a little bit ago the notion of a string.

1878
01:30:48,250 --> 01:30:52,189
所以也许有人可以像我们一样重新定义字符串
So maybe could someone redefine string as we've

1879
01:30:52,189 --> 01:30:56,359
根据今天的一些术语使用它吗？
been using it in terms of some of today's nomenclature?

1880
01:30:56,359 --> 01:30:57,859
就像什么是字符串？
Like, what is a string?

1881
01:30:57,859 --> 01:31:02,729
有一个例子“ HI！”，它占用了三个盒子。
There's an example of one, "HI!", taking up three boxes.

1882
01:31:02,729 --> 01:31:06,719
但是我们CS50可能是如何在引擎盖下实现字符串的呢？
But how did we, CS50 maybe implement string underneath the hood,

1883
01:31:06,720 --> 01:31:09,140
你可以说？
would you say?

1884
01:31:09,140 --> 01:31:09,650
它是什么？
What is it?

1885
01:31:09,649 --> 01:31:11,269
塔克？
Tucker?

1886
01:31:11,270 --> 01:31:14,848
TUCKER：嗯，它是一个由字符和整数组成的数组。
TUCKER: Well, it's an array of characters and integers.

1887
01:31:14,847 --> 01:31:16,639
好吧，字符串中使用了整数，
Well, it's integers are used in the string,

1888
01:31:16,640 --> 01:31:19,575
但这是一个基本由单个字符组成的数组。
but it's an array of basically single characters.

1889
01:31:19,574 --> 01:31:20,449
大卫·马兰（David MALAN）：完美。
DAVID MALAN: Perfect.

1890
01:31:20,449 --> 01:31:22,639
如果我们现在有能力表达-
If we now have the ability to express--

1891
01:31:22,640 --> 01:31:23,810
塔克，做得非常好。
very nicely done, Tucker.

1892
01:31:23,810 --> 01:31:27,560
如果我们现在能够表示事物序列，整数，
If we now have the ability to represent sequences of things, integers,

1893
01:31:27,560 --> 01:31:29,360
例如，像乐谱一样
for instance, like scores, well, it stands

1894
01:31:29,359 --> 01:31:33,409
导致我们可以采用另一种原始数据，一种非常基本的数据类型
to reason that we can take another primitive, a very basic data type

1895
01:31:33,409 --> 01:31:34,339
像个字符。
like a char.

1896
01:31:34,340 --> 01:31:38,030
如果我们想用这些字符拼写东西，例如英语单词，
And if we want to spell things with those chars, like English words,

1897
01:31:38,029 --> 01:31:41,179
好吧，让我们将字符串真正视为一个数组
well, let's just think of a string really as an array

1898
01:31:41,180 --> 01:31:43,820
字符，一个字符数组。
of characters, an array of chars.

1899
01:31:43,819 --> 01:31:47,849
确实，这实际上就是字符串。
And indeed, that's exactly what string actually is.

1900
01:31:47,850 --> 01:31:54,180
因此，从技术上来说，这里的“ HI！”是一个名为s的数组。
So this thing here, "HI!", technically speaking is an array called s.

1901
01:31:54,180 --> 01:31:57,080
这是s [0]这是s [1]。
And this is s[0] This is s[1].

1902
01:31:57,079 --> 01:31:58,309
这是s [2]。
This is s[2].

1903
01:31:58,310 --> 01:31:59,878
它只是一个名为s的数组。
It's just an array called s.

1904
01:31:59,877 --> 01:32:01,669
现在，我们上周没有使用单词数组
Now, we didn't use the word array last week

1905
01:32:01,670 --> 01:32:04,610
因为它不像“文本字符串”的概念那样熟悉，
because it's not as familiar as the notion of a "string of text,"

1906
01:32:04,609 --> 01:32:05,569
例如。
for instance.

1907
01:32:05,569 --> 01:32:08,719
但是字符串显然只是一个数组。
But a string is apparently just an array.

1908
01:32:08,720 --> 01:32:12,380
如果它是一个数组，这意味着我们可以访问（如果需要），
And if it's an array, that means we can access, if we want to,

1909
01:32:12,380 --> 01:32:16,610
用方括号将该数组的各个字符
the individual characters of that array by way of the square bracket

1910
01:32:16,609 --> 01:32:18,169
从今天开始。
notation from today.

1911
01:32:18,170 --> 01:32:23,180
但事实证明，弦乐有些特殊之处
But it turns out there's something a little special about strings

1912
01:32:23,180 --> 01:32:24,440
在实施过程中。
as they're implemented.

1913
01:32:24,439 --> 01:32:28,189
回顾我们涉及分数的示例，这是唯一的方法
Recall in our example involving scores, the only way

1914
01:32:28,189 --> 01:32:32,929
我们知道那个数组有多久了，因为我
we knew how long that array was was because I

1915
01:32:32,930 --> 01:32:36,740
还有一个第二个变量，叫做length或TOTAL
had a second variable called length or TOTAL

1916
01:32:36,739 --> 01:32:41,899
在该数组中存储了整数的总数。
that stored the total number of integers in that array.

1917
01:32:41,899 --> 01:32:44,479
也就是说，在我们的分数示例中，我们不仅
That is to say in our scores example, not only did we

1918
01:32:44,479 --> 01:32:45,859
分配数组本身。
allocate the array itself.

1919
01:32:45,859 --> 01:32:51,389
我们还使用两个变量跟踪该数组中有多少东西。
We also kept track of how many things were in that array with two variables.

1920
01:32:51,390 --> 01:32:56,810
但是，到目前为止，每次您和我都使用printf函数时，
However, up until now, every time you and I have used the printf function,

1921
01:32:56,810 --> 01:33:01,040
并且我们已经将诸如s之类的字符串传递给该printf函数，
and we have passed to that printf function a string like s,

1922
01:33:01,039 --> 01:33:05,419
我们只为printf提供了字符串本身。
we have only provided printf with the string itself.

1923
01:33:05,420 --> 01:33:08,030
或者从逻辑上讲，我们只提供了printf
Or logically, we have only provided printf

1924
01:33:08,029 --> 01:33:11,669
与字符数组本身有关。
with the array of characters itself.

1925
01:33:11,670 --> 01:33:17,870
但是，以某种方式，printf神奇地计算出字符串有多长。
And yet somehow, printf is magically figuring out how long the string is.

1926
01:33:17,869 --> 01:33:20,659
毕竟，当printf打印s的值时，
After all, when printf prints the value of s,

1927
01:33:20,659 --> 01:33:23,779
它正在打印H，I，感叹号，仅此而已。
it is printing H, I, exclamation point, and that's it.

1928
01:33:23,779 --> 01:33:27,642
它不会打印4个字符或5或20个字符，对不对？
It's not going and printing 4 characters or 5 or 20, right?

1929
01:33:27,643 --> 01:33:30,560
可以肯定的是，计算机内存中还有其他内容
It stands to reason that there's other stuff in your computer's memory

1930
01:33:30,560 --> 01:33:32,960
如果您正在运行其他变量或其他程序。
if you've got other variables or other programs running.

1931
01:33:32,960 --> 01:33:35,480
但是printf似乎足够聪明，可以知道，
Yet printf seems to be smart enough to know,

1932
01:33:35,479 --> 01:33:39,319
给定一个数组，数组有多长，因为，很简单，它
given an array, how long the array is because, quite simply, it

1933
01:33:39,319 --> 01:33:42,479
只打印出那个单词。
only prints out that single word.

1934
01:33:42,479 --> 01:33:48,439
那么，如果所有的字符串都在，那么计算机如何知道字符串在内存中的结尾
So how then does a computer know where a string ends in memory if all a string

1935
01:33:48,439 --> 01:33:49,909
是一个字符序列？
is is a sequence of characters?

1936
01:33:49,909 --> 01:33:54,499
好吧，事实证明，如果您的字符串长度为3，那么H，I，
Well, it turns out that if your string is length 3, as is this one, H, I,

1937
01:33:54,500 --> 01:34:00,679
感叹号（技术上是字符串）在引擎盖下实现，
exclamation point, technically a string, implemented underneath the hood,

1938
01:34:00,680 --> 01:34:02,390
使用4个字节。
uses 4 bytes.

1939
01:34:02,390 --> 01:34:04,280
它使用4个字节。
It uses 4 bytes.

1940
01:34:04,279 --> 01:34:07,759
它使用第四个字节初始化为
It uses a fourth byte to be initialized to what

1941
01:34:07,760 --> 01:34:11,850
我们将其描述为反斜杠0，这是一种怪异的描述方式。
we would describe as backslash 0, which is a weird way of describing it.

1942
01:34:11,850 --> 01:34:14,870
但这仅代表一个特殊字符，否则称为
But this just represents a special character, otherwise known

1943
01:34:14,869 --> 01:34:18,889
作为空字符，这只是一个特殊的值，
as the null character, which is just a special value that

1944
01:34:18,890 --> 01:34:20,880
表示字符串的结尾。
represents the end of a string.

1945
01:34:20,880 --> 01:34:23,960
这就是说，当您创建一个字符串时，引用
So that is to say when you create a string, quote

1946
01:34:23,960 --> 01:34:26,750
用双引号取消引号，“嗨！”-
unquote with double quotes, "HI!"--

1947
01:34:26,750 --> 01:34:28,399
是的，字符串的长度为3。
yes, the string is length 3.

1948
01:34:28,399 --> 01:34:31,579
但是，您浪费或花费了4个总字节。
But you're wasting or spending 4 total bytes on it.

1949
01:34:31,579 --> 01:34:32,239
为什么？
Why?

1950
01:34:32,239 --> 01:34:36,379
因为这是计算机了解“ HI！”位置的线索。
Because this is a clue to the computer as to where "HI!"

1951
01:34:36,380 --> 01:34:39,800
结束，下一个字符串可能在哪里开始。
ends and where the next string maybe begins.

1952
01:34:39,800 --> 01:34:43,010
仅仅开始在里面打印字符是不够的
It is not sufficient to just start printing characters inside

1953
01:34:43,010 --> 01:34:45,117
一次从左到右打印一次。
of printf one at a time, left to right.

1954
01:34:45,117 --> 01:34:47,450
必须有这种等同的停车标志
There needs to be this sort of equivalent of a stop sign

1955
01:34:47,449 --> 01:34:50,149
在字符串的末尾说，就是这个字符串。
at the end of the string, saying, that's it for this string.

1956
01:34:50,149 --> 01:34:51,539
那么，这些值是什么？
Well, what are these values?

1957
01:34:51,539 --> 01:34:53,289
好吧，让我们将它们转换回十进制-
Well, let's convert them back to decimal--

1958
01:34:53,289 --> 01:34:54,799
72、73、33。
72, 73, 33.

1959
01:34:54,800 --> 01:35:00,560
花式反斜杠0只是一种表示字符形式的方式，它是0。
That fancy backslash 0 was just a way of saying, in character form, it's 0.

1960
01:35:00,560 --> 01:35:06,740
更具体地说，它是该正方形内的八个0位。
More specifically, it is eight 0 bits inside of that square.

1961
01:35:06,739 --> 01:35:09,469
因此，要存储一个字符串，您不知道的计算机，
So to store a string, the computer, unbeknownst to you,

1962
01:35:09,470 --> 01:35:15,260
一直使用一个额外的字节全0位，否则写为反斜杠0，
has been using one extra byte all, 0 bits, otherwise written as backslash 0,

1963
01:35:15,260 --> 01:35:19,340
但实际上也称为值0。
but otherwise known as literally the value 0.

1964
01:35:19,340 --> 01:35:23,180
所以这个东西，俗称null，
So this thing, otherwise colloquially known as null,

1965
01:35:23,180 --> 01:35:24,685
只是一个特殊的角色。
is just a special character.

1966
01:35:24,685 --> 01:35:26,060
我们实际上可以再次看到它。
And we can actually see it again.

1967
01:35:26,060 --> 01:35:30,260
如果我从以前回到我的asciichart.com，
If I go back to my asciichart.com from before,

1968
01:35:30,260 --> 01:35:35,480
注意编号0在所有大写字母中都称为NUL，NUL。
notice number 0 is known as NUL, N-U-L in all caps.

1969
01:35:35,479 --> 01:35:40,579
好了，这么说了，那么关于字符串的强大之处是什么
All right, so with that said, what is powerful then about strings

1970
01:35:40,579 --> 01:35:42,059
一旦我们具备了这种能力？
once we have this capability?

1971
01:35:42,060 --> 01:35:43,640
好吧，让我继续执行此操作。
Well, let me go ahead and do this.

1972
01:35:43,640 --> 01:35:46,130
让我回到刚才的代码中。
Let me go back into my code from a moment ago.

1973
01:35:46,130 --> 01:35:48,830
让我继续进行一些改进
And let me go ahead and enhance this program a little bit

1974
01:35:48,829 --> 01:35:51,964
只是对发生的事情有点好奇。
just to get a little curious as to what's going on.

1975
01:35:51,965 --> 01:35:53,250
你知道我能做什么吗？
You know what I can do?

1976
01:35:53,250 --> 01:35:57,200
我敢打赌，在这个版本中我可以做的就是这个。
I bet what I can do here in this version here is this.

1977
01:35:57,199 --> 01:35:57,799
你知道吗？
You know what?

1978
01:35:57,800 --> 01:36:00,440
如果我要打印出s的所有这些字符，
If I want to print out all of these characters of s,

1979
01:36:00,439 --> 01:36:06,589
我可以再次感到好奇，并打印出％c，％c，％c。
I can get a little curious again and print out %c, %c, %c.

1980
01:36:06,590 --> 01:36:11,340
如果s是一个数组，按照今天的语法，我可以从技术上做s [0]，
And if s is an array, per today's syntax, I can technically do s[0],

1981
01:36:11,340 --> 01:36:14,940
s [1]，s [2]。
s[1], s[2].

1982
01:36:14,939 --> 01:36:21,719
然后，如果我保存了此代码，请使用make hi，OK，。/ hi重新编译我的代码，
And then if I save this, recompile my code with make hi, OK, ./hi,

1983
01:36:21,720 --> 01:36:23,070
我仍然看到“嗨！”
I still see "HI!"

1984
01:36:23,069 --> 01:36:23,819
但是你知道吗？
But you know what?

1985
01:36:23,819 --> 01:36:25,194
让我有点好奇。
Let me get a little more curious.

1986
01:36:25,194 --> 01:36:28,739
让我使用％i，以便实际上可以看到那些ASCII码。
Let me use %i so I can actually see those ASCII codes.

1987
01:36:28,739 --> 01:36:31,949
让我继续并用make hi./hi重新编译。
Let me go ahead and recompile with make hi, ./hi.

1988
01:36:31,949 --> 01:36:35,189
有72、73、33。
There's the 72, 73, 33.

1989
01:36:35,189 --> 01:36:37,089
现在让我变得更加好奇。
Now let me get even more curious.

1990
01:36:37,090 --> 01:36:42,270
让我在这里打印第四个值s [3]，
Let me print a fourth value like this here, s[3],

1991
01:36:42,270 --> 01:36:44,430
请注意，这是第四个位置。
which is the fourth location, mind you.

1992
01:36:44,430 --> 01:36:50,850
因此，如果我现在将hi和./hi设为hi，瞧，现在您看到0。
So if I now do make hi and ./hi, voila, now you see 0.

1993
01:36:50,850 --> 01:36:55,110
这实际上暗示着C的一个非常危险的特性。您知道，
And what this hints at is actually a very dangerous feature of C. You know,

1994
01:36:55,109 --> 01:36:57,749
假设我很好奇看到的还不止于此。
suppose I'm curious at seeing what's beyond that.

1995
01:36:57,750 --> 01:37:01,290
从技术上讲，我可以做s [4]，第五个位置，
I could technically do s[4], the fifth location,

1996
01:37:01,289 --> 01:37:04,829
即使根据我的照片，真的不应该有任何东西
even though according to my picture, there really shouldn't be anything

1997
01:37:04,829 --> 01:37:08,009
在第五位置，至少我现在还不知道。
at the fifth location, at least not that I know about just yet.

1998
01:37:08,010 --> 01:37:10,980
但是我可以在C语言中做到。没有什么可以阻止我。
But I can do it in C. Nothing's stopping me.

1999
01:37:10,979 --> 01:37:13,709
所以，让我打招呼，。/ hi。
So let me do make hi, ./hi.

2000
01:37:13,710 --> 01:37:15,490
这很有趣。
And that's interesting.

2001
01:37:15,489 --> 01:37:17,559
显然有37。
Apparently there's the number 37.

2002
01:37:17,560 --> 01:37:19,110
37是多少？
What is the number 37?

2003
01:37:19,109 --> 01:37:21,149
好吧，让我回到我的ASCII图表。
Well, let me go back to my ASCII chart.

2004
01:37:21,149 --> 01:37:25,101
让我得出结论，数字37是百分号。
And let me conclude that number 37 is a percent sign.

2005
01:37:25,101 --> 01:37:28,059
这有点奇怪，因为我没有打印出明确的百分比。
So that's kind of weird because I didn't print out an explicit percent.

2006
01:37:28,060 --> 01:37:31,290
现在，我在某些地方闲逛着计算机的内存
Now I'm kind of poking around the computer's memory in places

2007
01:37:31,289 --> 01:37:33,369
从某种意义上说，我不应该看。
I shouldn't be looking, in some sense.

2008
01:37:33,369 --> 01:37:36,509
实际上，如果我真的很好奇，那就让我们不要看位置4。
In fact, if I get really curious, let's look not at location 4.

2009
01:37:36,510 --> 01:37:40,140
位置40怎么样，就像进入那张照片一样？
How about location 40, like way off into that picture?

2010
01:37:40,140 --> 01:37:44,400
打个招呼，。/ hi，24，无论是什么。
Make hi, ./hi, 24, whatever that is.

2011
01:37:44,399 --> 01:37:52,469
我可以查看位置400，重新编译代码，打个招呼，。/ hi。
I can look at location 400, recompile my code, make hi, ./hi.

2012
01:37:52,470 --> 01:37:54,090
现在又是0。
And now it's 0 again.

2013
01:37:54,090 --> 01:37:57,060
因此，这对于C语言来说既强大又危险。
So this is what's both powerful and also dangerous about C.

2014
01:37:57,060 --> 01:38:01,088
您可以触摸，查看或更改所需的任何内存。
You can touch, look at, change any memory you want.

2015
01:38:01,087 --> 01:38:02,879
您实际上只是在荣誉系统上
You're essentially just on the honor system

2016
01:38:02,880 --> 01:38:04,838
不要触摸属于您的记忆。
not to touch memory that does it belong to you.

2017
01:38:04,837 --> 01:38:06,959
而且总是，尤其是下周，
And invariably, especially next week, are

2018
01:38:06,960 --> 01:38:10,290
我们将开始不小心触摸不属于您的记忆。
we going to start accidentally touching memory that doesn't belong to you.

2019
01:38:10,289 --> 01:38:13,379
您会发现它实际上可能导致计算机程序崩溃，
And you'll see that it actually can cause computer programs to crash,

2020
01:38:13,380 --> 01:38:18,330
包括您自己的Mac和PC上的程序，这是另一个常见错误的来源。
including programs on your own Mac and PC, yet another source of common bugs.

2021
01:38:18,329 --> 01:38:22,349
但是现在我们有了存储不同字符串的能力
But now that we have this ability to store different strings

2022
01:38:22,350 --> 01:38:24,362
或将字符串视为数组，
or to think about strings as arrays, well,

2023
01:38:24,362 --> 01:38:26,070
让我们继续考虑如何
let's go ahead and consider how you might

2024
01:38:26,069 --> 01:38:27,669
一个程序中有多个字符串。
have multiple strings in a program.

2025
01:38:27,670 --> 01:38:30,900
举例来说，如果您要在程序中存储两个字符串，我们可以调用
So for instance, if you were to store two strings in a program-- let's call

2026
01:38:30,899 --> 01:38:32,676
它们分别是s和t。
them s and t respectively.

2027
01:38:32,676 --> 01:38:35,009
另一个程序员惯例-如果您需要两个字符串，
Another programmer convention-- if you need two strings,

2028
01:38:35,010 --> 01:38:37,110
称第一个为s，第二个为t。
call the first one s then the second one t.

2029
01:38:37,109 --> 01:38:38,399
也许我正在存储“嗨！”
Maybe I'm storing "HI!"

2030
01:38:38,399 --> 01:38:39,279
那么，再见！”
then "BYE!"

2031
01:38:39,279 --> 01:38:41,529
那么，计算机的内存将是什么样的？
Well, what's the computer's memory going to look like?

2032
01:38:41,529 --> 01:38:43,949
好吧，让我们做一些挖掘。
Well, let's do some digging.

2033
01:38:43,949 --> 01:38:46,201
和以前一样，“ HI！”将存储在此处。
"HI!", as before, is going to be stored here.

2034
01:38:46,202 --> 01:38:47,910
所以整个事情都指s，它是
So this whole thing refers to s, and it's

2035
01:38:47,909 --> 01:38:52,079
占用4个字节，因为最后一个是那个特殊的空字符
taking 4 bytes because the last one is that special null character that

2036
01:38:52,079 --> 01:38:55,439
只是划定字符串结尾的停止符号。
just is the stop sign that demarcates the end of the string.

2037
01:38:55,439 --> 01:38:59,759
同时，“再见！”将占据另一个B，Y，E感叹号，
"BYE!", meanwhile, is going to take up another B, Y, E, exclamation point,

2038
01:38:59,760 --> 01:39:04,650
五个字节，因为我需要第五个字节代表另一个空字符。
five bytes because I need a fifth byte to represent another null character.

2039
01:39:04,649 --> 01:39:06,599
而这是故意环绕。
And this one deliberately wraps around.

2040
01:39:06,600 --> 01:39:08,820
再说一次，这只是艺术家的作品。
Though again, this is just an artist's rendition.

2041
01:39:08,819 --> 01:39:11,579
现实中不一定有网格。
There's not necessarily a grid in reality.

2042
01:39:11,579 --> 01:39:16,769
B，Y，E，感叹号，反斜杠0现在表示t。
B, Y, E, exclamation point, backslash 0 now represents t.

2043
01:39:16,770 --> 01:39:21,690
这就是说，如果我有一个像这样的程序，那么我在这里有“ HI！”。
So this is to say, if I had a program like this, where I had "HI!"

2044
01:39:21,689 --> 01:39:25,199
然后是“再见！”，然后我开始在计算机的内存中戳戳
and then "BYE!", and I started poking around the computer's memory

2045
01:39:25,199 --> 01:39:27,359
只是使用方括号符号，我
just using the square bracket notation, I

2046
01:39:27,359 --> 01:39:31,019
打赌我可以开始访问B或Y的值
bet I could start accessing the value of B or Y

2047
01:39:31,020 --> 01:39:34,710
或E，只要稍微看一下字符串s即可。
or E just by looking a little past the string s.

2048
01:39:34,710 --> 01:39:37,380
再说一次，随着我们程序的复杂化，
So again, as complicated as our programs get,

2049
01:39:37,380 --> 01:39:40,320
引擎盖下面发生的所有事情就是您放下东西
all that's going on underneath the hood is you just plop things down

2050
01:39:40,319 --> 01:39:44,069
在这些位置的内存中。
in memory in locations like these.

2051
01:39:44,069 --> 01:39:47,309
因此，现在我们有了这种能力或这种思维模式
And so now that we have this ability or maybe this mental model

2052
01:39:47,310 --> 01:39:49,710
对于计算机内部发生的事情，
for what's going on inside of a computer,

2053
01:39:49,710 --> 01:39:53,490
我们可以考虑您可能需要的一些功能
we can consider some of the features that you might want

2054
01:39:53,489 --> 01:39:55,739
现在可以在您编写的程序中使用。
to now use in programs that you write.

2055
01:39:55,739 --> 01:39:59,189
所以，让我继续这里，快速编写程序，
So let me go ahead here and whip up a quick program,

2056
01:39:59,189 --> 01:40:05,399
例如，这可以继续进行下去，比方说，
for instance, that goes ahead and, let's say,

2057
01:40:05,399 --> 01:40:09,309
打印出字符串的总长度。
prints out the total length of a string.

2058
01:40:09,310 --> 01:40:10,540
让我继续执行此操作。
Let me go ahead and do this.

2059
01:40:10,539 --> 01:40:14,729
我将继续在CS50的IDE中创建一个新程序。
I'm going to go ahead and create a new program here in CS50's IDE.

2060
01:40:14,729 --> 01:40:17,869
我将其称为一个字符串。c。
And I'm going to call this one string.c.

2061
01:40:17,869 --> 01:40:22,079
而且我将像往常一样快速进入顶部cs50.h。
And I'm going to very quickly at the top include as usual cs50.h.

2062
01:40:22,079 --> 01:40:24,734
我将继续并#include stdio.h。
And I'm going to go ahead and #include stdio.h.

2063
01:40:24,734 --> 01:40:27,184
而且我要给自己int main（void）。
And I'm going to give myself int main(void).

2064
01:40:27,185 --> 01:40:29,310
然后在这里，我要给自己一个字符串。
And then in here, I'm going to get myself a string.

2065
01:40:29,310 --> 01:40:32,280
所以string s等于get_string。
So string s equals get_string.

2066
01:40:32,279 --> 01:40:35,219
让我问一下人类，无论它是什么。
Let me just ask the human for some input, whatever it is.

2067
01:40:35,220 --> 01:40:39,270
然后，让我继续并逐字打印“输出”一词
Then let me go ahead and print out literally the word "Output"

2068
01:40:39,270 --> 01:40:41,730
以便我可以实际看到结果。
just so that I can actually see the result.

2069
01:40:41,729 --> 01:40:47,249
然后在这里，让我继续打印该字符串，因为我得到0，
And then down here, let me go ahead and print out that string, for int i get 0,

2070
01:40:47,250 --> 01:40:49,791
我小于-
i is less than--

2071
01:40:49,792 --> 01:40:52,240
呵呵，我还不知道字符串的长度是多少。
huh, I don't know what the length of the string is yet.

2072
01:40:52,239 --> 01:40:54,989
因此，让我在此处输入一个问号，它不是有效的代码，
So let me just put a question mark there, which is not valid code,

2073
01:40:54,989 --> 01:40:57,067
但我们将回到这个问题-i ++。
but we'll come back to this-- i++.

2074
01:40:57,068 --> 01:40:59,610
然后在循环内部，我想继续打印
And then inside of the loop, I want to go ahead and print out

2075
01:40:59,609 --> 01:41:03,431
通过使用我的新数组符号，每个字符每次一次。
every character one at a time by using my new array notation.

2076
01:41:03,431 --> 01:41:05,139
然后在该程序的最后，
And then at the very end of this program,

2077
01:41:05,140 --> 01:41:06,890
我要打印一条新行以使
I'm going to print a new line just to make

2078
01:41:06,890 --> 01:41:08,460
确保光标在自己的行上。
sure the cursor is on its own line.

2079
01:41:08,460 --> 01:41:11,000
这是一个完整的程序，现在，
So this is a complete program that is now,

2080
01:41:11,000 --> 01:41:15,950
从本周开始，将字符串视为数组，所以，第10行中的我的语法
as of this week, going to treat a string as an array, ergo, my syntax in line 10

2081
01:41:15,949 --> 01:41:18,829
那是使用我的新花式方括号表示法。
that's using my new fancy square bracket notation.

2082
01:41:18,829 --> 01:41:21,919
但是我还没有回答的唯一问题是
But the only question I haven't answered yet is this--

2083
01:41:21,920 --> 01:41:25,100
我怎么知道什么时候停止打印字符串？
how do I know when to stop printing the string?

2084
01:41:25,100 --> 01:41:26,390
我怎么知道什么时候停止？
How do I know when to stop?

2085
01:41:26,390 --> 01:41:28,850
好吧，到目前为止，当我们使用for循环时，
Well, it turns out, thus far, when we're using for loops,

2086
01:41:28,850 --> 01:41:34,040
我们通常所做的只是从0开始计数直到某个数字。
we've typically done something like just count from 0 on up to some number.

2087
01:41:34,039 --> 01:41:36,619
但是，此条件是任何布尔表达式。
This condition, though, is any Boolean expression.

2088
01:41:36,619 --> 01:41:39,299
我只需要有一个是/否或一个正确/错误的答案。
I just need to have a yes/no or a true/false answer.

2089
01:41:39,300 --> 01:41:40,850
所以你知道我能做什么？
So you know what I could do?

2090
01:41:40,850 --> 01:41:45,620
只要角色i在位置i上就一直循环播放
Keep looping so long as character at location i

2091
01:41:45,619 --> 01:41:50,029
和s不等于反斜杠0。
and s does not equal backslash 0.

2092
01:41:50,029 --> 01:41:52,169
因此，现在绝对是一些新语法。
So this is now definitely some new syntax.

2093
01:41:52,170 --> 01:41:53,510
让我在这里放大。
Let me zoom in here.

2094
01:41:53,510 --> 01:41:58,700
但是s [i]仅表示s中的第i个字符，或更具体地说，
But s[i] just means the i-th character in s, or more specifically,

2095
01:41:58,699 --> 01:42:01,819
s中位置i处的字符。
the character at position i in s.

2096
01:42:01,819 --> 01:42:04,999
爆炸等于-因此爆炸是程序员的发音
Bang equals-- so bang is how a programmer pronounces

2097
01:42:05,000 --> 01:42:08,149
感叹号，因为它快一点了-砰等于
exclamation point because it's a little faster-- bang equals

2098
01:42:08,149 --> 01:42:09,596
均值不相等。
means does not equal.

2099
01:42:09,596 --> 01:42:12,679
因此，这是在数学中用斜杠将等号切成等号的方式。
So this is how you would do an equal sign with a slash through it in math.

2100
01:42:12,680 --> 01:42:15,920
在代码中，感叹号等于符号。
It's, in code, exclamation point, equals sign.

2101
01:42:15,920 --> 01:42:18,230
然后注意这种时髦-反斜杠
And then notice this funkiness-- backslash

2102
01:42:18,229 --> 01:42:22,099
再次为0，即“空字符”，但用单引号引起来
0 is again, the "null character," but it's in single quotes

2103
01:42:22,100 --> 01:42:24,500
因为根据定义它又是一个字符。
because, again, it is by definition a character.

2104
01:42:24,500 --> 01:42:26,479
由于种种原因，我们将进入另一个时代，
And for reasons we'll get into another time,

2105
01:42:26,479 --> 01:42:28,759
反斜杠0是表达方式。
backslash 0 is how you express it.

2106
01:42:28,760 --> 01:42:32,600
就像反斜杠n在新行中有点怪异的转义字符一样，
Just like backslash n is kind of a weird escape character for the new line,

2107
01:42:32,600 --> 01:42:36,710
反斜杠0是全0的字符。
backslash 0 is the character that is all 0's.

2108
01:42:36,710 --> 01:42:38,570
因此，这是一种不同的for循环。
So this is kind of a different for loop.

2109
01:42:38,569 --> 01:42:41,869
我仍然从0开始。
I'm still starting at 0 for i.

2110
01:42:41,869 --> 01:42:43,879
我仍然像往常一样增加我。
I'm still incrementing i as always.

2111
01:42:43,880 --> 01:42:46,400
但我现在不检查预定长度
But I'm now not checking for some preordained length

2112
01:42:46,399 --> 01:42:50,989
因为就像计算机一样，我不知道这些字符串的结尾是先验的。
because just like a computer, I do not know a priori where these strings end.

2113
01:42:50,989 --> 01:42:55,579
我只知道一旦看到反斜杠0，它们就会结束。
I only know that they end once I see backslash 0.

2114
01:42:55,579 --> 01:42:59,149
所以当我现在下来这里做弦时
So when I now go down here and do make string--

2115
01:42:59,149 --> 01:43:05,569
它会编译OK-- ./string，让我在所有大写字母中输入“ HELLO”之类的内容。
it compiles OK-- ./string, let me type in something like "HELLO" in all caps.

2116
01:43:05,569 --> 01:43:07,459
瞧，输出再次是“ HELLO”。
Voila, the output is "HELLO" again.

2117
01:43:07,460 --> 01:43:08,450
让我再做一次
Let me do it again--

2118
01:43:08,449 --> 01:43:11,029
大写字母为“ BYE”，输出为“ BYE”。
"BYE" in all caps, and the output is "BYE."

2119
01:43:11,029 --> 01:43:13,579
所以这是一个无用的程序，因为它只是打印
So it's kind of a useless program in that it's just printing

2120
01:43:13,579 --> 01:43:15,349
我输入的内容相同。
the same thing that I typed in.

2121
01:43:15,350 --> 01:43:19,490
但是我有条件地使用这个布尔表达式
But I'm conditionally using this Boolean expression

2122
01:43:19,489 --> 01:43:22,169
决定是否继续打印字符。
to decide whether or not to keep printing characters.

2123
01:43:22,170 --> 01:43:25,280
现在，值得庆幸的是，C附带了一个可以为我解答的函数。
Now thankfully, C comes with a function that can answer this for me.

2124
01:43:25,279 --> 01:43:29,209
原来有一个叫做strlen的函数
It turns out there is a function called strlen

2125
01:43:29,210 --> 01:43:31,850
所以我可以从字面上说，好吧，找出来
so I can literally just say, well, figure out

2126
01:43:31,850 --> 01:43:33,500
字符串的长度是多少。
what the length of the string is.

2127
01:43:33,500 --> 01:43:36,109
该函数称为字符串长度的strlen。
The function is called strlen for string length.

2128
01:43:36,109 --> 01:43:40,729
它存在于一个叫做的文件中，也许并不奇怪，
And it exists in a file called, not surprisingly, perhaps,

2129
01:43:40,729 --> 01:43:43,609
string.h，string.h。
string.h, string.h.

2130
01:43:43,609 --> 01:43:47,659
所以现在让我继续在这里做弦-
So now let me go ahead down here and do make string--

2131
01:43:47,659 --> 01:43:50,299
编译OK-- ./string。
compiles OK-- ./string.

2132
01:43:50,300 --> 01:43:52,950
输入“ HELLO”，它仍然有效。
Type in "HELLO," and it still works.

2133
01:43:52,949 --> 01:43:58,399
所以这个函数很奇怪，它确实通过头文件存在于库中
So this function strlen that does exist in a library via the header file

2134
01:43:58,399 --> 01:43:59,522
string.h已经存在。
string.h already exists.

2135
01:43:59,523 --> 01:44:00,440
有人写的。
Someone else wrote it.

2136
01:44:00,439 --> 01:44:01,709
但是他们是怎么写的呢？
But how did they write it?

2137
01:44:01,710 --> 01:44:04,040
奇怪的是他们写了我的第一个版本
Odds are they wrote the first version that I

2138
01:44:04,039 --> 01:44:06,979
通过检查该反斜杠0来完成。
did by checking for that backslash 0.

2139
01:44:06,979 --> 01:44:09,234
但是，让我在这里问一个微妙的问题。
But let me ask a subtle question here.

2140
01:44:09,234 --> 01:44:10,234
这个程序是正确的。
This program is correct.

2141
01:44:10,234 --> 01:44:12,234
遍历字符串的整个长度，
It iterates over the whole length of the string,

2142
01:44:12,234 --> 01:44:14,869
并打印出其中的每个字符。
and it prints out every character therein.

2143
01:44:14,869 --> 01:44:20,509
任何人都可以在此功能中观察到较差的设计决策吗？
Can anyone observe a poor design decision in this function?

2144
01:44:20,510 --> 01:44:24,200
这个人很微妙，但我有一些不喜欢的东西
This one's subtle, but there's something I don't

2145
01:44:24,199 --> 01:44:26,659
特别是关于我的for循环。
like about my for loop in particular.

2146
01:44:26,659 --> 01:44:28,639
我将其隔离到第9行。
And I'll isolate it to line 9.

2147
01:44:28,640 --> 01:44:31,230
我没有在9号线上做一些优化的事情。
I've not done something optimally on line 9.

2148
01:44:31,229 --> 01:44:34,699
有机会进行更好的设计。
There's an opportunity for better design.

2149
01:44:34,699 --> 01:44:40,829
关于我可能会做得更好的任何想法？
Any thoughts here on what I might do better?

2150
01:44:40,829 --> 01:44:42,425
是的，乔纳森？
Yeah, Jonathan?

2151
01:44:42,426 --> 01:44:46,770
JONATHAN：是的，基本上是为字符串长度创建另一个变量
JONATHAN: Yeah, to create basically another variable for the string length

2152
01:44:46,770 --> 01:44:48,455
并记住它。
and to remember it.

2153
01:44:48,454 --> 01:44:50,579
戴维·马兰（David MALAN）：是的，为什么要这样建议呢？
DAVID MALAN: Yeah, and why are you suggesting that?

2154
01:44:50,579 --> 01:44:53,669
JONATHAN：如果您要为字符串长度使用其他值，
JONATHAN: If you want to use a different value for the string length,

2155
01:44:53,670 --> 01:44:55,710
或者如果它可能波动或变化，您想要
or if it might fluctuate or change, you want

2156
01:44:55,710 --> 01:44:59,370
只是拥有一个不同的变量作为它的占位符值。
to just have a different variable as a sort of placeholder value for it.

2157
01:44:59,369 --> 01:45:00,669
DAVID MALAN：好的，可能。
DAVID MALAN: OK, potentially.

2158
01:45:00,670 --> 01:45:03,210
但在这种情况下，我会宣称，因为人类
But I will claim in this case that because the human has

2159
01:45:03,210 --> 01:45:07,090
输入单词，一旦输入单词，它就不会改变。
typed in the word, once you type in the word, it's not going to change.

2160
01:45:07,090 --> 01:45:11,520
但我认为您的方向是正确的，因为
But I think you're going down the right direction because

2161
01:45:11,520 --> 01:45:15,570
在这里的布尔表达式中，我小于s的字符串长度，
in this Boolean expression here, i less than the string length of s,

2162
01:45:15,569 --> 01:45:19,349
回想一下，该表达式一次又一次地被求值。
recall that this expression gets evaluated again and again and again.

2163
01:45:19,350 --> 01:45:22,050
每次通过for循环时，请记住您一直在
Every time through a for loop, recall that you're constantly

2164
01:45:22,050 --> 01:45:23,290
检查条件。
checking the condition.

2165
01:45:23,289 --> 01:45:26,459
在这种情况下，条件i小于s的长度。
The condition in this case is i less than the length of s.

2166
01:45:26,460 --> 01:45:30,382
问题是在这种情况下strlen是一个函数，
The problem is that strlen in this case is a function, which

2167
01:45:30,381 --> 01:45:32,339
意味着有人写了一些代码，
means there's some piece of code someone wrote,

2168
01:45:32,340 --> 01:45:35,593
可能与我几分钟前写的内容相似，
probably similar to what I wrote a few minutes ago, that you're constantly

2169
01:45:35,592 --> 01:45:37,259
问，字符串的长度是多少？
asking, what's the length of the string?

2170
01:45:37,260 --> 01:45:38,593
字符串的长度是多少？
What's the length of the string?

2171
01:45:38,592 --> 01:45:41,879
并从我们的图片中回想起您计算字符串长度的方式
And recall from our picture, the way you figure out the length of a string

2172
01:45:41,880 --> 01:45:44,070
是从字符串的开头开始，然后继续检查，
is you start at the beginning of the string, and you keep checking,

2173
01:45:44,069 --> 01:45:45,299
我在反斜杠0处吗？
am I at backslash 0?

2174
01:45:45,300 --> 01:45:46,020
好的。
OK.

2175
01:45:46,020 --> 01:45:47,700
我在反斜杠0处吗？
Am I at backslash 0?

2176
01:45:47,699 --> 01:45:48,539
好的。
OK.

2177
01:45:48,539 --> 01:45:52,599
因此，要弄清楚“ HI！”的长度，我需要1、2、3、4步，
So to figure out the length of "HI!", it's going to take me 1, 2, 3, 4 steps,

2178
01:45:52,600 --> 01:45:54,600
是的，因为我必须从头开始。
right, because I have to start at the beginning.

2179
01:45:54,600 --> 01:45:57,267
我从位置0一直循环到结束。
And I iterate from location 0 on to the end.

2180
01:45:57,266 --> 01:45:59,099
为了找出“再见！”的长度，
To find out the length of "BYE!", it's going

2181
01:45:59,100 --> 01:46:01,350
我走了五个步骤，因为那是多长时间
to take me five steps because that's how long it's

2182
01:46:01,350 --> 01:46:04,740
从左到右带我找到反斜杠0。
going to take me from left to right to find that backslash 0.

2183
01:46:04,739 --> 01:46:07,079
所以我不喜欢这行代码，
So what I don't like about this line of code is,

2184
01:46:07,079 --> 01:46:10,679
你为什么一次又一次地要求s的字符串长度
why are you asking for the string length of s again and again

2185
01:46:10,680 --> 01:46:11,790
一遍又一遍？
and again and again?

2186
01:46:11,789 --> 01:46:14,229
在这种情况下，它不会改变。
It's not going to change in this context.

2187
01:46:14,229 --> 01:46:17,886
因此，如果我们继续要求用户提供更多输入，就会得出乔纳森的观点。
So Jonathan's point is taken if we keep asking the user for more input.

2188
01:46:17,886 --> 01:46:19,969
但是在这种情况下，我们只问了一次人类。
But in this case, we've only asked the human once.

2189
01:46:19,970 --> 01:46:20,920
那你知道吗？
So you know what?

2190
01:46:20,920 --> 01:46:26,700
让我们听乔纳森（Jonathan）的建议，将int n等于s的字符串长度。
Let's take Jonathan's advice and do int n equals the string length of s.

2191
01:46:26,699 --> 01:46:28,949
然后，也许您知道我们能做什么？
And then maybe you know what we could do?

2192
01:46:28,949 --> 01:46:32,169
相反，将n置于此条件下。
Put n in this condition instead.

2193
01:46:32,170 --> 01:46:35,520
所以现在我问的是同样的问题，但我不是愚蠢的，
So now I'm asking the same question, but I'm not foolishly,

2194
01:46:35,520 --> 01:46:39,030
一遍又一遍地低效率地问同样的问题，
inefficiently asking the same question again and again,

2195
01:46:39,029 --> 01:46:42,719
因此，相同的问题需要大量的工作
whereby the same question requires a good amount of work

2196
01:46:42,720 --> 01:46:45,940
一次又一次地找到反斜杠0。
to find the backslash 0 again and again and again.

2197
01:46:45,939 --> 01:46:48,469
现在，我们也可以在此处进行一些清理。
Now, there's some cleaning up we can do here too.

2198
01:46:48,470 --> 01:46:50,970
事实证明，for循环还有另一个微妙的功能。
It turns out there's this other subtle feature of for loops.

2199
01:46:50,970 --> 01:46:54,660
如果您想将另一个变量初始化为一个值，
If you want to initialize another variable to a value,

2200
01:46:54,659 --> 01:46:56,369
您实际上可以一次完成所有操作。
you can actually do this all at once.

2201
01:46:56,369 --> 01:46:59,129
您可以在分号之前执行此操作。
And you can do so before the semicolon.

2202
01:46:59,130 --> 01:47:04,530
您可以将逗号n等于s的strlen。
You can do comma n equals strlen of s.

2203
01:47:04,529 --> 01:47:07,149
然后就可以像我在这里一样使用n了。
And then you can use n, just as I have here.

2204
01:47:07,149 --> 01:47:09,209
所以这并没有那么好，但是
So it's not all that much better, but it's

2205
01:47:09,210 --> 01:47:11,790
稍微干净一点，现在我已经写了两行代码
a little cleaner in that now I've taken two lines of code

2206
01:47:11,789 --> 01:47:13,709
并将它们合而为一。
and collapsed them into one.

2207
01:47:13,710 --> 01:47:15,750
它们都必须是相同的数据类型，
They both have to be of the same data types,

2208
01:47:15,750 --> 01:47:19,379
但这没关系，因为i和n都可以。
but that's OK here because both i and n are.

2209
01:47:19,380 --> 01:47:21,750
再一次，这里的低效率是愚蠢的
So again, the inefficiency here is that it was foolish

2210
01:47:21,750 --> 01:47:26,099
在此之前，我一直一次又一次地问同样的问题。
before that I kept asking the same question again and again and again.

2211
01:47:26,100 --> 01:47:30,810
但是现在我问了一个问题，在一个叫做n的变量中记住了这个问题，
But now I'm asking the question once, remembering it in a variable called n,

2212
01:47:30,810 --> 01:47:36,720
并且仅将i与实际上没有变化的整数进行比较。
and only comparing i against that integer which does not actually change.

2213
01:47:36,720 --> 01:47:38,370
好吧，我知道很多。
All right, I know that too was a lot.

2214
01:47:38,369 --> 01:47:41,909
让我们继续在这里休息3分钟，只是为了伸展腿和其他东西。
Let's go ahead here and take a 3-minute break just to stretch legs and whatnot.

2215
01:47:41,909 --> 01:47:44,879
3分钟后，我们将返回并开始查看应用程序
In 3 minutes, we'll come back and start to see applications

2216
01:47:44,880 --> 01:47:48,030
现在所有这些功能最终都会导致一些问题，
now of all of these features ultimately to some problems that

2217
01:47:48,029 --> 01:47:51,029
在语言的可读性方面，本周将领先
are going to lie ahead this week on the readability of language

2218
01:47:51,029 --> 01:47:52,509
以及密码学。
and also on cryptography.

2219
01:47:52,510 --> 01:47:54,750
因此，我们将在3分钟后见到您。
So we'll see you in 3 minutes.

2220
01:47:54,750 --> 01:47:57,240
好吧，我们回来了。
All right, so we're back.

2221
01:47:57,239 --> 01:48:00,884
诚然，这是一堆低级的细节。
And this has been a whole bunch of low-level details, admittedly.

2222
01:48:00,885 --> 01:48:03,510
最终，本周及以后我们将如何处理此问题
And where we're going with this ultimately this week and beyond

2223
01:48:03,510 --> 01:48:05,562
是其中一些构建基块的应用。
is applications of some of these building blocks.

2224
01:48:05,561 --> 01:48:08,519
而下周和下一个问题集中的应用程序之一
And one of those applications this coming week and the next problem set

2225
01:48:08,520 --> 01:48:11,580
将会是加密技术，即加扰或加密的艺术
is going to be that of cryptography, the art of scrambling or encrypting

2226
01:48:11,579 --> 01:48:12,596
信息。
information.

2227
01:48:12,596 --> 01:48:14,429
如果您要加密信息，
And if you're trying to encrypt information,

2228
01:48:14,430 --> 01:48:16,830
像消息一样，这些消息可能很好
like messages, well, those messages might very well

2229
01:48:16,829 --> 01:48:19,259
如果可以的话，可以用英文或ASCII书写。
be written in English or in ASCII, if you will.

2230
01:48:19,260 --> 01:48:23,250
您可能想从一件事转换某些ASCII字符
And you might want to convert some of those ASCII characters from one thing

2231
01:48:23,250 --> 01:48:27,480
传递给另一个人，以便如果您的消息被某个第三方截获，
to another so that if your message is intercepted by some third party,

2232
01:48:27,479 --> 01:48:30,989
他们实际上无法破译或弄清楚您发送的邮件是什么。
they can't actually decipher or figure out what it is that you've sent.

2233
01:48:30,989 --> 01:48:33,359
所以我觉得我们几乎要-
So I feel like we're almost toward--

2234
01:48:33,359 --> 01:48:35,549
我们几乎有能力在代码中
we're almost at the ability where, in code, we

2235
01:48:35,550 --> 01:48:39,270
可以开始将一个单词转换为另一个单词或扰乱我们的文本。
can start to convert one word to another or to scramble our text.

2236
01:48:39,270 --> 01:48:41,490
但是我们确实需要更多的构建块。
But we do need a couple of more building blocks.

2237
01:48:41,489 --> 01:48:44,039
所以回想一下，我们放弃了这张照片
So recall that we left off with this picture

2238
01:48:44,039 --> 01:48:47,159
在这里，我们在计算机的内存中有两个单词：“嗨！”和“再见！”，
here, where we had two words in the computer's memory, "HI!" and "BYE!",

2239
01:48:47,159 --> 01:48:50,609
既带有感叹号，也带有反斜杠0
both with exclamation points, but also both with these backslash 0's

2240
01:48:50,609 --> 01:48:52,799
您和我没有明确地放在那儿。
that you and I do not put there explicitly.

2241
01:48:52,800 --> 01:48:56,370
只要您使用双引号和任何时间，它们就会为您发生
They just happen for you any time you use the double quotes and any time

2242
01:48:56,369 --> 01:48:58,989
您使用get_string函数。
you use the get_string function.

2243
01:48:58,989 --> 01:49:03,719
因此，一旦我们将它们存储在内存中，就可以将它们分别视为s和t。
So once we have those in memory, you can think of them as s and t respectively.

2244
01:49:03,720 --> 01:49:06,480
但是字符串s或t只是一个数组。
But a string, s or t, is just an array.

2245
01:49:06,479 --> 01:49:11,039
同样，您也可以引用所有这些单独的字符或字符
So again, you can also refer to all of these individual characters or chars

2246
01:49:11,039 --> 01:49:15,419
通过今天的新方括号符号s [0]，s [1]，s [2]，s [3]，
via the new square bracket notation of today, s[0], s[1], s[2], s[3],

2247
01:49:15,420 --> 01:49:21,210
然后是t [0]，t [1]，[2]，[3]和[4]，然后是其他任何东西
and then t[0], t[1], [2], [3], and [4], and then whatever else is

2248
01:49:21,210 --> 01:49:22,470
在计算机的内存中。
in the computer's memory.

2249
01:49:22,470 --> 01:49:26,880
但是您知道您什至可以做这件事-假设相反，我们
But you know what you can even do is this-- suppose that instead we

2250
01:49:26,880 --> 01:49:28,980
想要有一个单词数组。
wanted to have an array of words.

2251
01:49:28,979 --> 01:49:32,649
所以之前，我们有一个分数数组，一个整数数组。
So before, we had an array of scores, an array of integers.

2252
01:49:32,649 --> 01:49:35,369
但是现在假设我们想要在其他程序的上下文中
But now suppose we wanted in the context of some other program

2253
01:49:35,369 --> 01:49:36,779
有一系列的单词。
to have an array of words.

2254
01:49:36,779 --> 01:49:37,799
您完全可以做到这一点。
You can totally do that.

2255
01:49:37,800 --> 01:49:40,560
没有什么可以阻止您拥有一系列单词。
There's nothing stopping you from having an array of words.

2256
01:49:40,560 --> 01:49:42,240
而且语法将是相同的。
And the syntax is going to be identical.

2257
01:49:42,239 --> 01:49:48,149
请注意，如果我想要一个名为word的数组，该数组可以容纳两个字符串，
Notice, if I want an array called words that has room for two strings,

2258
01:49:48,149 --> 01:49:51,179
我只是说字符串字[2]。
I literally just say, string words[2].

2259
01:49:51,180 --> 01:49:56,540
嘿，这意味着计算机给我一个大小为2的数组，每个成员
This means, hey, computer, give me an array of size 2, each of whose members

2260
01:49:56,539 --> 01:49:57,539
将是一个字符串。
is going to be a string.

2261
01:49:57,539 --> 01:49:58,919
如何填充该数组？
How do I populate that array?

2262
01:49:58,920 --> 01:50:00,510
与以前相同的分数-
Same as before with the scores--

2263
01:50:00,510 --> 01:50:02,790
单词[0]得到，引用不加引号，“嗨！”
words[0] gets, quote unquote, "HI!"

2264
01:50:02,789 --> 01:50:05,279
Words [1]得到，引用不带引号的“再见！”
Words[1] gets, quote unquote, "BYE!"

2265
01:50:05,279 --> 01:50:09,539
这就是说，使用此代码，我们可以创建类似于该图片的图片吗？
So that is to say with this code, could we create a picture similar to the one

2266
01:50:09,539 --> 01:50:10,379
之前？
previously?

2267
01:50:10,380 --> 01:50:12,540
但是我没有将这些字符串称为s和t。
But I'm not calling these strings s and t.

2268
01:50:12,539 --> 01:50:16,889
现在，我在两个不同的位置分别将它们称为“单词”，分别为0和1
Now I'm calling them both "words" at two different locations, 0 and 1

2269
01:50:16,890 --> 01:50:17,830
分别。
respectively.

2270
01:50:17,829 --> 01:50:20,039
因此，我们可以像这样重绘同一张图片。
So we could redraw that same picture like this.

2271
01:50:20,039 --> 01:50:23,789
现在，该词在技术上被命名为words [0]。
Now this word is technically named words[0].

2272
01:50:23,789 --> 01:50:26,639
而这个用词[1]来指代。
And this one is referred to by words[1].

2273
01:50:26,640 --> 01:50:29,310
但是，字符串又是什么呢？
But again, what is a string?

2274
01:50:29,310 --> 01:50:30,990
字符串是一个数组。
A string is an array.

2275
01:50:30,989 --> 01:50:34,359
但是，这里我们有一个字符串数组。
And yet, here we have an array of strings.

2276
01:50:34,359 --> 01:50:37,509
因此，我们有点拥有数组数组。
So we kind of sort of have an array of arrays.

2277
01:50:37,510 --> 01:50:40,440
所以我们有一个单词数组，但是一个单词只是一个字符串。
So we've got an array of words, but a word is just a string.

2278
01:50:40,439 --> 01:50:42,849
字符串是字符数组。
And a string is an array of characters.

2279
01:50:42,850 --> 01:50:47,430
所以我在黑板上真正拥有的是一个数组阵列。
So what I really have on the board is an array of arrays.

2280
01:50:47,430 --> 01:50:51,190
所以在这里-这将是今天的最后一个怪异的语法-
And so here-- and this will be the last weird syntax for today--

2281
01:50:51,189 --> 01:50:55,049
您实际上可以背对背使用多个方括号。
you can actually have multiple square brackets back to back.

2282
01:50:55,050 --> 01:50:58,650
因此，如果您的变量被称为单词，而该变量是一个数组，
So if your variable's called words, and that variable's an array,

2283
01:50:58,649 --> 01:51:03,239
如果要获取数组中的第一个单词，则执行words [0]。
if you want to get the first word in the array, you do words[0].

2284
01:51:03,239 --> 01:51:06,089
一旦你说了这个“ HI！”，你就想要
Once you're at that word, "HI!", and you want

2285
01:51:06,090 --> 01:51:10,860
要获得该单词的第一个字符，您可以类似地执行[0]。
to get the first character in that word, you can similarly do [0].

2286
01:51:10,859 --> 01:51:14,229
因此，第一个括号指的是您要在数组中使用的单词。
So the first bracket refers to what word do you want in the array.

2287
01:51:14,229 --> 01:51:18,059
第二个括号指的是您要在该单词中使用什么字符。
The second bracket refers to what character do you want in that word.

2288
01:51:18,060 --> 01:51:22,320
所以现在我就是那个单词[0] [1]。
So now the I is that words[0][1].

2289
01:51:22,319 --> 01:51:25,499
感叹号是单词[0] [2]。
The exclamation point is that words[0][2].

2290
01:51:25,500 --> 01:51:28,810
空字符位于单词[0] [3]处。
And the null character's at words[0][3].

2291
01:51:28,810 --> 01:51:37,508
同时，B是单词[1] [0]，[1] [1]，[1] [2]，[1] [3]，[1] [4]。
Meanwhile, the B is that words[1][0], [1][1], [1][2], [1][3], [1][4].

2292
01:51:37,507 --> 01:51:40,049
因此，如果可以的话，它几乎有点像坐标系。
So it's almost kind of like a coordinate system, if you will.

2293
01:51:40,050 --> 01:51:43,200
它是二维数组或数组数组。
It's a two-dimensional array, or an array of arrays.

2294
01:51:43,199 --> 01:51:49,079
所以这只是说，如果我们想考虑字符串数组
So this is only to say that if we wanted to think of arrays of strings

2295
01:51:49,079 --> 01:51:53,279
作为个人角色，我们可以。
as individual characters, we can.

2296
01:51:53,279 --> 01:51:56,679
我们现在具有编码的表达能力。
We have that expressiveness now to encode.

2297
01:51:56,680 --> 01:52:00,460
那么，现在我可以在此级别上进行操作了，该怎么办？
So what more can I do now that I can manipulate things at this level?

2298
01:52:00,460 --> 01:52:03,263
让我做一个非常适用的程序，
Let me do a program that'll be pretty applicable,

2299
01:52:03,262 --> 01:52:05,429
我认为，还有一些我们即将推出的计划。
I think, with some of our upcoming programs as well.

2300
01:52:05,430 --> 01:52:06,960
让我将此称为大写。
Let me call this one uppercase.

2301
01:52:06,960 --> 01:52:09,240
让我快速写出一个以生活为目的的程序
Let me quickly write a program whose purpose in life

2302
01:52:09,239 --> 01:52:12,119
只是将输入的单词转换为大写。
is just to convert an input word to uppercase.

2303
01:52:12,119 --> 01:52:13,539
让我们看看我们如何做到这一点。
And let's see how we can do this.

2304
01:52:13,539 --> 01:52:16,379
因此，让我继续并#includecs50.h。
So let me go ahead and #include cs50.h.

2305
01:52:16,380 --> 01:52:20,050
让我继续并#include stdio.h。
Let me go ahead and #include stdio.h.

2306
01:52:20,050 --> 01:52:23,160
让我也包括这个时间string.h，这是
Let me also include this time string.h, which is

2307
01:52:23,159 --> 01:52:24,989
给我们像strlen这样的功能。
going to give us functions like strlen.

2308
01:52:24,989 --> 01:52:27,669
然后让我做int main（void）。
And then let me do int main(void).

2309
01:52:27,670 --> 01:52:31,280
然后让我继续前进，像以前一样从用户那里获取一个字符串。
And then let me go ahead here and get a string from the user like before.

2310
01:52:31,279 --> 01:52:34,029
所以我只想问用户一个字符串。
So I'm just going to ask the user for a string.

2311
01:52:34,029 --> 01:52:36,369
我希望他们给我任何弦乐
And I want them to give me whatever the string should

2312
01:52:36,369 --> 01:52:38,949
在我将所有内容都大写之前。
be before I uppercase everything.

2313
01:52:38,949 --> 01:52:41,889
然后，我将继续打印字面意思为“之后”，
Then I'm just going to go ahead and print out literally "After,"

2314
01:52:41,890 --> 01:52:46,330
只是为了让我看到将字符串中的所有内容都大写之后会发生什么。
just so I can see what happens after I capitalize everything in the string.

2315
01:52:46,329 --> 01:52:49,689
现在让我继续执行此操作-因为我得到0，
And now let me go ahead and do this-- for int i get 0,

2316
01:52:49,689 --> 01:52:53,109
我小于s的字符串长度，i ++。
i less than string length of s, i++.

2317
01:52:53,109 --> 01:52:55,179
等一下，我之前犯了那个错误。
Wait a minute, I made that mistake before.

2318
01:52:55,180 --> 01:52:57,200
让我们不再重复这个问题。
Let's not repeat this question.

2319
01:52:57,199 --> 01:53:02,739
让我们给自己一个第二个变量-n的字符串长度为s，i小于n，
Let's give myself a second variable-- n gets string length of s, i less than n,

2320
01:53:02,739 --> 01:53:04,089
我++。
i++.

2321
01:53:04,090 --> 01:53:06,340
如此一来，现在这已成为样板。
So again, this is now becoming boilerplate.

2322
01:53:06,340 --> 01:53:09,400
每当您要遍历字符串中的所有字符时，
Any time you want to iterate over all of the characters in the string,

2323
01:53:09,399 --> 01:53:11,912
这可能是一个合理的起点。
this probably is a reasonable place to start.

2324
01:53:11,912 --> 01:53:13,329
然后让我问一个问题
And then let me ask the question--

2325
01:53:13,329 --> 01:53:15,672
我想遍历字符串中的每个字符
I want to iterate over every character in the string

2326
01:53:15,672 --> 01:53:16,839
人类输入的内容。
that the human has typed in.

2327
01:53:16,840 --> 01:53:20,470
我想问自己一个问题，就像我们对任何算法所做的一样。
And I want to ask myself a question, just as we've done with any algorithm.

2328
01:53:20,470 --> 01:53:23,980
具体来说，我想问一下当前字母是否为小写，
Specifically, I want to ask if the current letter is lowercase,

2329
01:53:23,979 --> 01:53:26,079
让我以某种方式将其转换为大写。
let me somehow convert it to uppercase.

2330
01:53:26,079 --> 01:53:28,259
否则，让我直接将其打印出来。
Else, let me just print it out unchanged.

2331
01:53:28,260 --> 01:53:31,540
那么，我如何使用上周和本周的构建基块来表达这一点？
So how can I express that using last week and this week's building blocks?

2332
01:53:31,539 --> 01:53:33,279
好吧，让我说这样的话-
Well, let me say something like this--

2333
01:53:33,279 --> 01:53:39,669
如果位于s中第i个位置的字符，或者位于s中第i个字符
if the character at location i in s, or if the i-th character in s

2334
01:53:39,670 --> 01:53:47,710
大于或等于小写字母a，且s中的第i个字符
is greater than or equal to a lowercase a, and the i-th character in s

2335
01:53:47,710 --> 01:53:52,270
小于或等于小写字母z，我想怎么办？
is less than or equal to a lower case z, what do I want to do?

2336
01:53:52,270 --> 01:53:55,750
让我继续打印一个字符。
Let me go ahead and print out a character.

2337
01:53:55,750 --> 01:53:59,319
但是那个角色应该是什么？的括号我，
But that character should be what? s bracket i,

2338
01:53:59,319 --> 01:54:01,959
但我不知道该怎么办。
but I'm not sure what to do here yet.

2339
01:54:01,960 --> 01:54:03,460
但是，让我回到这一点。
But let me come back to that.

2340
01:54:03,460 --> 01:54:09,250
否则，让我继续，只打印不变的字符s [i]。
Else, let me go ahead and just print out that character unchanged, s[i].

2341
01:54:09,250 --> 01:54:14,269
所以减去占位符，我问过的问号，我一直都挺好的
So minus the placeholder, the question marks I've put, I'm kind of all the way

2342
01:54:14,270 --> 01:54:14,770
那里。
there.

2343
01:54:14,770 --> 01:54:16,872
第10行将i初始化为0。
Line 10 initializes i to 0.

2344
01:54:16,872 --> 01:54:20,080
它将一直计数到n，其中n是字符串的长度。
It's going to count all the way up to n, where n is the length of the string.

2345
01:54:20,079 --> 01:54:21,309
而且它将继续增加i。
And it's going to keep incrementing i.

2346
01:54:21,310 --> 01:54:22,393
因此，我们之前已经看到过。
So we've seen that before.

2347
01:54:22,393 --> 01:54:25,330
再一次，那将很快成为肌肉记忆。
And again, that's going to become muscle memory before long.

2348
01:54:25,329 --> 01:54:28,479
第12行有点新，但是使用了构建块
Line 12 is a little new, but it uses building blocks

2349
01:54:28,479 --> 01:54:29,531
从上周开始。
from last week and this.

2350
01:54:29,532 --> 01:54:31,240
这周，我们有了新的方括号
This week, we have the new square bracket

2351
01:54:31,239 --> 01:54:34,809
表示法，以获取字符串s中的第i个字符。
notation to get the i-th character in the string s.

2352
01:54:34,810 --> 01:54:37,870
大于或等于，小于或等于-我们看到至少一个
Greater than or equal to, less than or equal to-- we saw at least one

2353
01:54:37,869 --> 01:54:38,769
上周的那些。
of those last week.

2354
01:54:38,770 --> 01:54:41,860
那只是意味着大于或等于，小于或等于。
That just means greater than or equal to, less than or equal to.

2355
01:54:41,859 --> 01:54:46,369
我上周提到了&amp;&amp;，这是逻辑AND运算符，
I mentioned &amp;&amp; last week, which is the logical AND operator,

2356
01:54:46,369 --> 01:54:49,149
这意味着您可以检查一种情况，而另一种情况。
which means you can check one condition and another.

2357
01:54:49,149 --> 01:54:52,539
如果这两个都是正确的，那么整个事情就是正确的。
And the whole thing is true if both of those are true.

2358
01:54:52,539 --> 01:54:54,439
今天有点奇怪。
This is a bit weird today.

2359
01:54:54,439 --> 01:54:57,099
但是如果要表达，是当前字符
But if you want to express, is the current character

2360
01:54:57,100 --> 01:55:01,930
在小写字母a和小写字母z之间，完全可以
between lowercase a and lowercase z, totally fine

2361
01:55:01,930 --> 01:55:07,750
将a和z隐式地视为数字，它们实际上是数字。
to implicitly treat a and z as numbers, which they really are.

2362
01:55:07,750 --> 01:55:11,180
因为同样，如果回到最喜欢的ASCII图表，
Because again, if we come back to our favorite ASCII chart,

2363
01:55:11,180 --> 01:55:16,600
您会再次看到小写字母a有一个与之相关的数字97。
you'll see again that lowercase a has a number associated with it, 97.

2364
01:55:16,600 --> 01:55:20,410
小写字母z有一个与之关联的数字122。
Lowercase z has a number associated with it, 122.

2365
01:55:20,409 --> 01:55:24,999
因此，如果我真的想成为一个学究的人，可以回到我的代码中
So if I really wanted to be pedantic, I could go back into my code

2366
01:55:25,000 --> 01:55:28,540
并执行类似的操作，如果大于或等于97，
and do something like, well, if this is greater than or equal to 97,

2367
01:55:28,539 --> 01:55:32,319
小于或等于122，但设计不佳。
and it's less than or equal to 122, but bad design.

2368
01:55:32,319 --> 01:55:35,271
就像，我永远不会记住小写字母z是122。
Like, I'm never going to remember that lowercase z is 122.

2369
01:55:35,271 --> 01:55:36,729
就像，没有人会知道这一点。
Like, no one is going to know that.

2370
01:55:36,729 --> 01:55:38,319
它使代码不那么明显。
It makes the code less obvious.

2371
01:55:38,319 --> 01:55:41,079
继续以一种更多的方式编写它
Go ahead and write it in a way that's a little more

2372
01:55:41,079 --> 01:55:43,729
这样对人类友好。
friendly to humans like this.

2373
01:55:43,729 --> 01:55:45,069
但是请注意这个问号。
But notice this question mark.

2374
01:55:45,069 --> 01:55:46,719
如何填写此空白？
How do I fill in this blank?

2375
01:55:46,720 --> 01:55:48,970
好，让我回到ASCII图表。
Well, let me go back to the ASCII chart.

2376
01:55:48,970 --> 01:55:51,520
这很微妙，但这很酷。
This is subtle, but this is kind of cool.

2377
01:55:51,520 --> 01:55:53,560
人类肯定在向前思考。
And humans were definitely thinking ahead.

2378
01:55:53,560 --> 01:55:56,590
请注意，小写字母a为97。
Notice that lowercase a is 97.

2379
01:55:56,590 --> 01:55:58,900
大写字母A为65。
Capital A is 65.

2380
01:55:58,899 --> 01:56:00,999
小写字母b为98。
Lowercase b is 98.

2381
01:56:01,000 --> 01:56:03,430
大写B为66。
Capital B is 66.

2382
01:56:03,430 --> 01:56:05,965
并注意这两个数字-
And notice these two numbers--

2383
01:56:05,965 --> 01:56:13,330
65至97、66至98、67至99。
65 to 97, 66 to 98, 67 to 99.

2384
01:56:13,329 --> 01:56:17,319
似乎无论我们比较什么字母，小写
It would seem that no matter what letters we compare, lowercase

2385
01:56:17,319 --> 01:56:20,542
和大写字母，它们始终相距32。
and uppercase, they're always 32 apart.

2386
01:56:20,542 --> 01:56:21,459
这是一致的。
And that's consistent.

2387
01:56:21,460 --> 01:56:24,290
我们可以为所有26个英文字母做到这一点。
We could do it for all 26 English letters.

2388
01:56:24,289 --> 01:56:27,519
因此，如果他们总是相隔32岁，您知道我能做些什么-
So if they're always 32 apart, you know what I could do--

2389
01:56:27,520 --> 01:56:30,730
如果我想用小写字母，
if I want to take a lowercase letter, which

2390
01:56:30,729 --> 01:56:33,789
这就是我在第14行中所考虑的
is what I'm thinking about in line 14, I could just

2391
01:56:33,789 --> 01:56:36,101
在这种情况下，请减去32。
subtract off 32 in this case.

2392
01:56:36,101 --> 01:56:37,809
这不是最干净的，因为我再次
It's not the cleanest, because again, I'm

2393
01:56:37,810 --> 01:56:39,640
在某个时候可能会忘记那个数学。
probably going to forget that math at some point.

2394
01:56:39,640 --> 01:56:41,598
但至少在数学上，我认为这样做
But at least mathematically, I think that'll do

2395
01:56:41,597 --> 01:56:44,049
诀窍，因为97会变成65。
the trick because 97 will become 65.

2396
01:56:44,050 --> 01:56:47,922
98将变为66，这将迫使这些字符转换为小写。
98 will become 66, which is forcing those characters to lowercase.

2397
01:56:47,921 --> 01:56:49,629
但是它们并没有被打印为数字。
But they're not being printed as numbers.

2398
01:56:49,630 --> 01:56:52,870
我仍在使用％c强制将其作为字符。
I'm still using %c to coerce it to be a char.

2399
01:56:52,869 --> 01:56:56,779
因此，如果我在这里没有弄乱任何语法，请让我大写。
So if I didn't mess any syntax up here, let me make uppercase.

2400
01:56:56,779 --> 01:56:59,259
好的，。/大写。
OK, ./uppercase.

2401
01:56:59,260 --> 01:57:03,580
让我继续输入，例如，用小写形式输入我的名字。
And let me go ahead and type in, for instance, my name in all lowercase.

2402
01:57:03,579 --> 01:57:05,489
瞧，大写。
And voila, uppercase.

2403
01:57:05,489 --> 01:57:06,489
现在，这有点丑陋。
Now, it's a little ugly.

2404
01:57:06,489 --> 01:57:08,529
我忘了反斜线n，所以让我继续
I forgot my backslash n, so let me go ahead

2405
01:57:08,529 --> 01:57:11,619
并添加其中一种真正的快速工具来修复光标。
and add one of those real quick just to fix the cursor.

2406
01:57:11,619 --> 01:57:14,589
让我用make大写重新编译代码。
Let me recompile the code with make uppercase.

2407
01:57:14,590 --> 01:57:17,650
让我用./uppercase重新运行程序，然后输入我的名字，
Let me rerun the program with ./uppercase and now type in my name,

2408
01:57:17,649 --> 01:57:18,399
大卫。
David.

2409
01:57:18,399 --> 01:57:20,049
让我再和Brian一起做一次。
Let me do it again with Brian.

2410
01:57:20,050 --> 01:57:23,770
并注意，每个字符都在大写
And notice that it's capitalizing everything character by character

2411
01:57:23,770 --> 01:57:26,470
仅使用今天的构件。
using only today's building blocks.

2412
01:57:26,470 --> 01:57:27,530
这是对的。
This is correct.

2413
01:57:27,529 --> 01:57:30,349
它的样式非常好，因为所有东西都缩进了。
It's pretty well styled because everything's nicely indented.

2414
01:57:30,350 --> 01:57:33,890
即使乍一看它看起来有点神秘，它还是非常易读的。
It's very readable even though it might look a little cryptic at first glance.

2415
01:57:33,890 --> 01:57:35,430
但我认为我可以做得更好。
But I think I can do better.

2416
01:57:35,430 --> 01:57:37,940
通过使用另一个库，我可以做得更好。
And I can do better by using yet another library.

2417
01:57:37,939 --> 01:57:41,269
这就是C（实际上是一般的编程）变得强大的地方。
And here's where C, and really programming in general, gets powerful.

2418
01:57:41,270 --> 01:57:43,340
使用流行语言的重点
The whole point of using popular languages

2419
01:57:43,340 --> 01:57:46,742
是因为在解决问题之前还有很多其他人
is because so many other people before you have solved problems

2420
01:57:46,742 --> 01:57:48,200
您无需再次解决。
that you don't need to solve again.

2421
01:57:48,199 --> 01:57:51,229
我敢肯定，在过去的50年中，有人可能
And I'm sure over the past, like, 50 years, someone has probably

2422
01:57:51,229 --> 01:57:54,769
编写了一个为我大写字母的函数。
written a function that capitalizes letters for me.

2423
01:57:54,770 --> 01:57:56,690
我不必自己做。
I don't have to do this myself.

2424
01:57:56,689 --> 01:58:00,769
确实，还有一个我要去的图书馆
And indeed, there is another library that I'm going

2425
01:58:00,770 --> 01:58:02,540
通过其头文件包括在内。
to include by way of its header file.

2426
01:58:02,539 --> 01:58:07,049
在ctype.h中，type是语言C和一堆与类型相关的东西。
In ctype.h, type which is the language C and a bunch of type-related things.

2427
01:58:07,050 --> 01:58:11,270
在ctype.h中，结果是有一个函数调用-
And in ctype.h, it turns out there's a function call--

2428
01:58:11,270 --> 01:58:12,650
有几个功能。
there's a couple of functions.

2429
01:58:12,649 --> 01:58:15,989
具体来说，让我摆脱所有这些代码。
Specifically, let me get rid of all of this code.

2430
01:58:15,989 --> 01:58:21,979
让我调用一个称为islower的函数并将其传递给islower s [i]。
And let me call a function called islower and pass to islower s[i].

2431
01:58:21,979 --> 01:58:24,559
正如您可能猜到的，它的生命目标更低
And islower, as you might guess, its purpose in life

2432
01:58:24,560 --> 01:58:27,230
实质上是返回布尔值true或false，
is to return essentially a Boolean value, true or false,

2433
01:58:27,229 --> 01:58:28,769
如果该字符较低。
if that character is lower.

2434
01:58:28,770 --> 01:58:31,610
如果是这样，那么，让我继续并打印出一个占位符
And if so, well, let me go ahead and print out a placeholder

2435
01:58:31,609 --> 01:58:34,279
然后是那封信的大写。
followed by the capitalization of that letter.

2436
01:58:34,279 --> 01:58:37,669
现在，在我不得不用负32进行烦人的数学运算并弄清楚之前，
Now, before I had to do that annoying math with minus 32 and figure it out,

2437
01:58:37,670 --> 01:58:44,120
嗯，括号s [i]的上半部分。
uh-uh, toupper of parentheses s[i].

2438
01:58:44,119 --> 01:58:48,109
现在，我可以原样打印该字符，
And now I can otherwise just print out that character unchanged,

2439
01:58:48,109 --> 01:58:50,989
和以前一样，s [i]。
just as before, s[i].

2440
01:58:50,989 --> 01:58:52,399
但是现在请注意我的程序-
But now notice my program--

2441
01:58:52,399 --> 01:58:54,539
老实说，它肯定要短一点。
honestly, it's definitely a little shorter.

2442
01:58:54,539 --> 01:58:56,899
这有点简单，因为代码更少。
It's a little simpler in that there's just less code.

2443
01:58:56,899 --> 01:59:00,799
希望如果写得较低和较高的人做得很好，
And hopefully, if the person that wrote islower and toupper did a good job,

2444
01:59:00,800 --> 01:59:01,898
我知道是对的。
I know it's correct.

2445
01:59:01,898 --> 01:59:03,440
我只是站在他们的肩膀上。
I'm just standing on their shoulders.

2446
01:59:03,439 --> 01:59:07,009
坦率地说，我的代码更具可读性，因为我了解更低的代码
And frankly, my code's more readable because I understand what islower

2447
01:59:07,010 --> 01:59:11,450
意味着，而疯狂的&amp;&amp;语法和所有其他代码-
means, whereas that crazy &amp;&amp; syntax and all of the additional code--

2448
01:59:11,449 --> 01:59:14,359
可以说，这很难使您的想法四处走动。
that was just a lot harder to wrap your mind around, arguably.

2449
01:59:14,359 --> 01:59:19,509
因此，现在如果我继续进行编译，请大写。
So now if I go ahead and compile this-- make uppercase.

2450
01:59:19,510 --> 01:59:21,460
好的，这似乎很好。
OK, that seemed to work well.

2451
01:59:21,460 --> 01:59:24,870
现在我要继续进行操作。/大写并在所有输入我的名字
And now I'm going to go ahead and do ./uppercase and type in my name in all

2452
01:59:24,869 --> 01:59:25,799
再次小写。
lowercase again.

2453
01:59:25,800 --> 01:59:26,810
大卫似乎在工作。
David seems to work.

2454
01:59:26,810 --> 01:59:27,690
布赖恩似乎在工作。
Brian seems to work.

2455
01:59:27,689 --> 01:59:29,064
我可以整日做到这一点。
And I could do this all day long.

2456
01:59:29,064 --> 01:59:30,389
它似乎仍然有效。
It seems to still work.

2457
01:59:30,390 --> 01:59:31,350
但是你知道吗？
But you know what?

2458
01:59:31,350 --> 01:59:33,407
我认为我不必这么明确。
I don't think I have to be even this explicit.

2459
01:59:33,407 --> 01:59:33,990
你知道吗？
You know what?

2460
01:59:33,989 --> 01:59:36,659
我敢打赌，写to的人很聪明，
I bet if the human who wrote toupper was smart,

2461
01:59:36,659 --> 01:59:41,699
我敢打赌，我可以盲目地将任何字符传递给toupper，
I bet I can just blindly pass in any character to toupper,

2462
01:59:41,699 --> 01:59:46,947
如果可以将其转换为大写字母，则只会使用大写字母。
and it's only going to uppercase it if it can be converted to uppercase.

2463
01:59:46,948 --> 01:59:48,740
否则，它将原样传递。
Otherwise, it'll pass it through unchanged.

2464
01:59:48,739 --> 01:59:49,447
那你知道吗？
So you know what?

2465
01:59:49,448 --> 01:59:53,340
让我摆脱所有这些东西，真正加强这个程序
Let me get rid of all of this stuff and really tighten this program up

2466
01:59:53,340 --> 01:59:59,760
并打印出c的占位符，然后打印s [i]的占位符。
and print out a placeholder for c and then toupper of s[i].

2467
01:59:59,760 --> 02:00:02,760
确实，如果您阅读了此功能的文档，
And sure enough, if you read the documentation for this function,

2468
02:00:02,760 --> 02:00:07,380
它可以处理小写或不小写的情况。
it will handle the case where it's either lowercase or not lowercase.

2469
02:00:07,380 --> 02:00:09,270
它将做正确的事。
And it will do the right thing.

2470
02:00:09,270 --> 02:00:14,070
因此，现在，如果我重新编译我的代码，请大写，到目前为止效果很好。
So now if I recompile my code, make uppercase, so far so good.

2471
02:00:14,069 --> 02:00:15,779
./大写，David又来了。
./uppercase, David again.

2472
02:00:15,779 --> 02:00:17,369
瞧，它仍然有效。
Voila, it still works.

2473
02:00:17,369 --> 02:00:21,299
并请注意，实际上更紧密，更清洁，
And notice truly just how much tighter, how much cleaner,

2474
02:00:21,300 --> 02:00:23,100
我的代码短了多少。
how much shorter my code is.

2475
02:00:23,100 --> 02:00:26,790
从某种意义上来说，此函数的可读性更高。
And it's more readable in the sense that this function is pretty well named.

2476
02:00:26,789 --> 02:00:29,069
Toupper确实是所谓的。
Toupper is what it's indeed called.

2477
02:00:29,069 --> 02:00:31,139
但是这里有一个重要的细节。
But there is an important detail here.

2478
02:00:31,140 --> 02:00:34,140
Toupper希望输入一个字符。
Toupper expects as input a character.

2479
02:00:34,140 --> 02:00:36,090
您无法将整个单词传递给它。
You cannot pass a whole word to it.

2480
02:00:36,090 --> 02:00:39,480
在这一点上，我仍然有必要使用此循环
It is still necessary at this point for me to be using this loop

2481
02:00:39,479 --> 02:00:41,541
并逐个字符地进行。
and doing it character by character.

2482
02:00:41,542 --> 02:00:42,750
现在，您怎么知道呢？
Now, how would you know this?

2483
02:00:42,750 --> 02:00:45,910
好吧，在接下来的几周中，您将看到多个示例。
Well, you'll see multiple examples of this over the weeks to come.

2484
02:00:45,909 --> 02:00:49,999
但是如果我转到语言C的手册页，
But if I go to what's called the manual pages for the language C,

2485
02:00:50,000 --> 02:00:51,750
我们有他们自己的基于Web的版本。
we have our own web-based version of them.

2486
02:00:51,750 --> 02:00:54,209
我们将在本课程的实验室中为您链接
And we'll link this for you in the course's labs

2487
02:00:54,210 --> 02:00:55,690
并根据需要设置问题。
and problem sets as needed.

2488
02:00:55,689 --> 02:00:58,679
您可以在C中看到所有可用功能的列表
You can see a list of all of the available functions in C

2489
02:00:58,680 --> 02:01:00,570
至少在CS50中经常使用。
at least that are frequently used in CS50.

2490
02:01:00,569 --> 02:01:03,509
如果取消选中顶部的框，则可以看到更多功能。
And if we uncheck a box at the top, we can see even more functions.

2491
02:01:03,510 --> 02:01:06,660
有数十种，也许数百种功能，其中大多数
There's dozens, maybe hundreds of functions, most of which

2492
02:01:06,659 --> 02:01:08,714
我们将不需要或不使用CS50。
we will not need or use in CS50.

2493
02:01:08,715 --> 02:01:10,590
但这在任何语言中都是正确的。
But this is going to be true in any language.

2494
02:01:10,590 --> 02:01:13,623
您可以逐渐选择所需的构建基块。
You sort of pick up the building blocks that you need over time.

2495
02:01:13,622 --> 02:01:15,539
因此，我们将为您推荐这些资源
So we'll refer you to these kinds of resources

2496
02:01:15,539 --> 02:01:18,929
这样您就不会仅依靠我们在本节和讲座中展示的内容，
so that you don't rely only on what we show in section and lecture,

2497
02:01:18,930 --> 02:01:24,010
但是您还可以使用这些其他功能和工具包。
but you have at your disposal these other functions and toolkits as well.

2498
02:01:24,010 --> 02:01:28,120
我们还将对Python和SQL以及其他语言进行相同的处理。
And we'll do the same with Python and SQL and other languages as well.

2499
02:01:28,119 --> 02:01:32,039
这些就是我们再次称为手册页的内容。
So those are what we call, again, manual pages.

2500
02:01:32,039 --> 02:01:34,439
好吧，这是我们什至没有的最后功能
All right, a final feature before we even

2501
02:01:34,439 --> 02:01:38,879
考虑习题集2的加密和加扰信息。
think about cryptography and scrambling information as for problem set 2.

2502
02:01:38,880 --> 02:01:41,520
因此，我之前在名称中提到了一个命令行参数-
So a command-line argument I mentioned by name before--

2503
02:01:41,520 --> 02:01:44,460
就像一个单词，您可以在程序名称后面输入
it's like a word you can type after a program's name

2504
02:01:44,460 --> 02:01:46,960
为了在命令行提供输入。
in order to provide it input at the command line.

2505
02:01:46,960 --> 02:01:52,140
因此，打个招呼-hello是程序的命令行参数，打招呼。
So make hello-- hello is a command-line argument to the program, hello.

2506
02:01:52,140 --> 02:01:58,470
rm space a.out-a.out是参数，是程序的命令行参数
Rm space a.out-- a.out was an argument, a command-line argument to the program

2507
02:01:58,470 --> 02:02:00,130
rm，当我想将其删除时。
rm when I wanted to remove it.

2508
02:02:00,130 --> 02:02:02,790
因此，我们已经看到了命令行参数的实际作用。
So we've already seen command-line arguments in action.

2509
02:02:02,789 --> 02:02:05,519
但是我们实际上还没有编写任何程序
But we haven't actually written any programs

2510
02:02:05,520 --> 02:02:11,460
允许您从所谓的命令行接受单词或其他输入。
that allow you to accept words or other inputs from the so-called command line.

2511
02:02:11,460 --> 02:02:14,430
到目前为止，您和我的所有输入都已包含在我们的程序中
Up until now, all of the input you and I have gotten in our programs

2512
02:02:14,430 --> 02:02:16,440
来自get_string，get_int等。
comes from get_string, get_int, and so forth.

2513
02:02:16,439 --> 02:02:20,489
我们从来没有看过人类很可能拥有的单词
We have never been able to look at words that the human might very well have

2514
02:02:20,489 --> 02:02:23,609
在运行程序时在提示符下键入。
typed at the prompt when running your program.

2515
02:02:23,609 --> 02:02:25,349
但这一切现在都将改变。
But that's all about to change now.

2516
02:02:25,350 --> 02:02:28,350
让我继续创建一个名为argv.c的程序，
Let me go ahead and create a program called argv.c,

2517
02:02:28,350 --> 02:02:31,140
很快就会明白为什么。
and it'll become clear why in just a moment.

2518
02:02:31,140 --> 02:02:36,270
我要继续，包括stdio.h。
I'm going to go ahead and include, shall we say, stdio.h.

2519
02:02:36,270 --> 02:02:39,120
然后我要给自己int main（void）。
And then I'm going to give myself int main(void).

2520
02:02:39,119 --> 02:02:43,649
然后，我将非常简单地返回并更改空白。
And then I'm just going to very simply go back and change the void.

2521
02:02:43,649 --> 02:02:47,159
因此，就像我们自己的自定义函数可以接受输入一样，
So just as our own custom functions can take inputs--

2522
02:02:47,159 --> 02:02:49,289
我们通过get_negative_int看到了这一点。
and we saw that with get_negative_int.

2523
02:02:49,289 --> 02:02:52,019
我们今天平均看到了
We saw that with average today--

2524
02:02:52,020 --> 02:02:54,600
main也可能会接受输入。
so does main potentially take inputs.

2525
02:02:54,600 --> 02:02:57,120
到目前为止，我们一直在说无效。
Up till now though, we've been saying void.

2526
02:02:57,119 --> 02:02:58,769
我们告诉你上周说无效。
And we told you to say void last week.

2527
02:02:58,770 --> 02:03:01,380
我们告诉您说问题1中的内容无效。
And we told you to say void in problem set 1.

2528
02:03:01,380 --> 02:03:06,780
但是现在事实证明，C确实允许您将其他输入放入main。
But now it turns out that C does allow you to put other inputs into main.

2529
02:03:06,779 --> 02:03:10,719
您可以说，不，main不接受任何命令行参数。
You can either say, nope, main does not take any command-line arguments.

2530
02:03:10,720 --> 02:03:15,270
但是，如果确实如此，您可以按字面意思说int argc
But if it does, you can say literally, int argc

2531
02:03:15,270 --> 02:03:19,150
和带有方括号的字符串argv。
and string argv with square brackets.

2532
02:03:19,149 --> 02:03:20,219
因此有点神秘。
So it's a little cryptic.

2533
02:03:20,220 --> 02:03:22,803
从技术上讲，您不必完全以这种方式键入它。
And technically, you don't have to type it precisely this way.

2534
02:03:22,802 --> 02:03:26,219
但是人类的惯例至少在现在是这样让你这样做的。
But human convention would have you do it, at least for now, in this way.

2535
02:03:26,220 --> 02:03:29,010
这表示main，您的function，main，
This says that main, your function, main,

2536
02:03:29,010 --> 02:03:33,360
将整数作为一个输入而不是字符串
takes an integer as one input and not a string

2537
02:03:33,359 --> 02:03:36,569
而是一个字符串数组作为输入。
but an array of strings as input.

2538
02:03:36,569 --> 02:03:40,479
argc是参数计数的简写形式。
And argc is shorthand notation for argument count.

2539
02:03:40,479 --> 02:03:43,859
参数计数是一个整数，它将表示单词的数量
Argument count is an integer that's going to represent the number of words

2540
02:03:43,859 --> 02:03:45,719
您的用户在提示符下键入。
that your users type at the prompt.

2541
02:03:45,720 --> 02:03:48,330
Argv是自变量向量的缩写。
Argv is short for argument vector.

2542
02:03:48,329 --> 02:03:50,429
向量是说表的一种奇特的方式。
Vector is a fancy way of saying list.

2543
02:03:50,430 --> 02:03:55,470
这是一个变量，它将所有字符串存储在数组中
It is a variable that's going to store in an array all of the strings

2544
02:03:55,470 --> 02:03:59,940
有人在您自己的程序名称后的提示符下键入。
that a human types at the prompt after your own program's name.

2545
02:03:59,939 --> 02:04:02,709
因此，例如，我们可以如下使用它。
So we can use this, for instance, as follows.

2546
02:04:02,710 --> 02:04:06,330
假设我想让用户在命令提示符下键入自己的名称。
Suppose that I want to let the user type their own name at the command prompt.

2547
02:04:06,329 --> 02:04:06,959
我不想使用get_string。
I don't want to use get_string.

2548
02:04:06,960 --> 02:04:09,583
我不想稍后再提示该人的名字。
I don't want to have to prompt the human later for their name.

2549
02:04:09,582 --> 02:04:12,749
我希望他们能够运行我的程序并一次给我他们的名字，
I want them to be able to run my program and give me their name all at once,

2550
02:04:12,750 --> 02:04:17,080
就像make一样，就像rm和Clang以及我们看到的其他程序一样。
just like make, just like rm, and Clang, and other programs we've seen.

2551
02:04:17,079 --> 02:04:20,849
因此，我将执行此操作-如果argc == 2--
So I'm going to do this-- if argc == 2--

2552
02:04:20,850 --> 02:04:24,390
因此，如果我程序的参数个数是2-
so if the number of arguments to my program is 2--

2553
02:04:24,390 --> 02:04:31,420
继续并打印出“ hello，％s”，然后插入任何argv [1]。
go ahead and print out, "hello, %s", and plug in whatever is that argv[1].

2554
02:04:31,420 --> 02:04:33,450
稍后，将对此进行更多介绍。
So more on this in just a moment.

2555
02:04:33,449 --> 02:04:37,769
否则，如果argc不等于2，我们就使用上周的默认值，
Else, if argc is not equal to 2, let's just go with last week's default,

2556
02:04:37,770 --> 02:04:39,190
“你好，世界。”
"hello, world."

2557
02:04:39,189 --> 02:04:41,249
那么这个程序的目的是什么？
So what is this program's purpose in life?

2558
02:04:41,250 --> 02:04:43,680
如果人类在提示符下键入两个单词，
If the human types two words at the prompt,

2559
02:04:43,680 --> 02:04:47,310
我想说，“你好，大卫”，“你好，布莱恩”，“你好，某某”。
I want to say, "hello, David," "hello, Brian," "hello, so-and-so."

2560
02:04:47,310 --> 02:04:50,310
否则，如果他们没有在提示符下键入两个单词，
Otherwise, if they don't type two words at the prompt,

2561
02:04:50,310 --> 02:04:52,630
我只想说默认的“你好，世界”。
I'm just going to say the default "hello, world."

2562
02:04:52,630 --> 02:04:55,780
因此，让我编译一下，制作argv。
So let me compile this, make argv.

2563
02:04:55,779 --> 02:05:00,349
而且，嗯，我在这里没搞清楚-未知类型字符串，未知类型
And, hm, I didn't get it right here-- unknown type string, unknown type

2564
02:05:00,350 --> 02:05:00,850
细绳。
string.

2565
02:05:00,850 --> 02:05:01,820
好吧，我很无聊。
All right, I goofed.

2566
02:05:01,819 --> 02:05:07,149
如果我使用的是字符串，请回想一下，现在我需要开始使用CS50库。
If I'm using string, recall that now I need to start using the CS50 library.

2567
02:05:07,149 --> 02:05:09,729
再一次，我们将在接下来的几周内进一步了解为什么
And again, we'll see all the more why in the coming weeks as

2568
02:05:09,729 --> 02:05:11,439
我们将那些训练轮取下来。
we take those training wheels off.

2569
02:05:11,439 --> 02:05:13,869
但是现在我要再做一次，制作argv。
But now I'm going to do this again, make argv.

2570
02:05:13,869 --> 02:05:14,439
好了
There we go.

2571
02:05:14,439 --> 02:05:18,279
现在它可以工作了-./argv，输入“ hello world”。
Now it works-- ./argv, Enter, "hello, world."

2572
02:05:18,279 --> 02:05:20,709
这几乎等于我们上周所做的。
That's pretty much equivalent to what we did last week.

2573
02:05:20,710 --> 02:05:26,030
但是请注意，如果我输入了例如argv [1] David，请回车，它说：“你好，
But notice if I type in, for instance, argv[1] David, Enter, it says, "hello,

2574
02:05:26,029 --> 02:05:26,529
大卫。”
David."

2575
02:05:26,529 --> 02:05:29,499
如果我输入argv Brian，它会说。
If I type in argv Brian, it says that.

2576
02:05:29,500 --> 02:05:33,709
如果我输入Brian Yu，它会说“你好，世界”。
If I type in Brian Yu, it says "hello, world."

2577
02:05:33,710 --> 02:05:35,200
发生什么了？
So what's going on?

2578
02:05:35,199 --> 02:05:40,989
好吧，用C编写接受零个或多个命令行的程序的方式
Well, the way you write programs in C that accept zero or more command-line

2579
02:05:40,989 --> 02:05:44,619
参数-即程序名称后的提示符下的单词-
arguments-- that is, words at the prompt after your program's name--

2580
02:05:44,619 --> 02:05:48,909
你改变了我们一直以来所做的事情吗？
is you change what we have been doing all this time from void

2581
02:05:48,909 --> 02:05:52,747
将其放入带有方括号的argc字符串argv中。
to be this into argc string argv with square brackets.

2582
02:05:52,747 --> 02:05:55,164
电脑会自动为您做什么
And what the computer is going to do for you automatically

2583
02:05:55,164 --> 02:05:59,169
它会在argc中存储一定数量的单词吗？
is it's going to store in argc a number of the total number of words

2584
02:05:59,170 --> 02:06:01,690
从技术上讲，人类输入的不仅是论据
that the human typed in, not just the arguments, technically

2585
02:06:01,689 --> 02:06:04,419
所有的单词，包括您自己的程序的名称。
all of the words, including your own program's name.

2586
02:06:04,420 --> 02:06:08,650
然后它将填充此字符串数组，也就是argv，
It's then going to fill this array of strings, a.k.a. argv,

2587
02:06:08,649 --> 02:06:11,889
并在提示下输入了所有人类键入的字词，而不仅仅是
with all of the words the human typed at the prompt, so not just

2588
02:06:11,890 --> 02:06:16,340
像Brian或David这样的参数，还有程序的名称。
the arguments like Brian or David, but also the name of your program.

2589
02:06:16,340 --> 02:06:20,560
因此，如果人类输入了两个字，argv Brian，
So if the human typed in two total words, which they did, argv Brian,

2590
02:06:20,560 --> 02:06:24,160
argv David，那么我想打印出来，“你好”
argv David, then I want to print out, "hello"

2591
02:06:24,159 --> 02:06:27,789
然后是一个占位符，然后是argv [1]处的任何值。
followed by a placeholder and then whatever value is at argv[1].

2592
02:06:27,789 --> 02:06:29,769
我故意不做0。
And I'm deliberately not doing 0.

2593
02:06:29,770 --> 02:06:33,340
如果我的口头定义是0，
If I did 0, based on the verbal definition I just gave,

2594
02:06:33,340 --> 02:06:38,260
如果我重新编译该程序，我不想看到这个，。/ argv。
if I recompile this program, I don't want to see this, hello, ./argv.

2595
02:06:38,260 --> 02:06:43,030
因此，程序本身的名称会自动始终为您存储
So the program's own name is automatically always stored for you

2596
02:06:43,029 --> 02:06:45,189
在该数组的第一个位置。
at the first location in that array.

2597
02:06:45,189 --> 02:06:48,069
但是，如果您想获得第一个有用的信息，
But if you want the first useful piece of information,

2598
02:06:48,069 --> 02:06:53,859
在这里重新编译代码后，您实际上可以在[1]处对其进行访问。
you actually would, after recompiling the code here, access it at [1].

2599
02:06:53,859 --> 02:06:58,029
这样我们就可以在argv中看到我们实际上可以
And so in this way do we see in argv that we can actually

2600
02:06:58,029 --> 02:06:59,349
访问单个单词。
access individual words.

2601
02:06:59,350 --> 02:07:00,520
但也要注意这一点-
But notice this too--

2602
02:07:00,520 --> 02:07:05,410
假设我要打印出某人的所有单个字符
suppose I want to print out all of the individual characters in someone's

2603
02:07:05,409 --> 02:07:06,009
输入。
input.

2604
02:07:06,010 --> 02:07:06,593
你知道吗？
You know what?

2605
02:07:06,592 --> 02:07:08,082
我敢打赌我什至可以做到这一点。
I bet I could even do this.

2606
02:07:08,082 --> 02:07:09,249
让我继续执行此操作。
Let me go ahead and do this.

2607
02:07:09,250 --> 02:07:13,330
让我不仅仅打印出“ hello”，还因为我得到0，
Instead of just printing out "hello," let me do for int i get 0,

2608
02:07:13,329 --> 02:07:17,619
n等于argv [1]的字符串长度。
n equals the string length of argv[1].

2609
02:07:20,270 --> 02:07:24,800
然后在这里，我要做的是我小于n，即i ++。
And then over here, I'm going to do i is less than n, i++.

2610
02:07:24,800 --> 02:07:27,770
好吧，所以我要遍历所有字符
All right, so I'm going to iterate over all of the characters

2611
02:07:27,770 --> 02:07:30,930
在argv中的第一个实词中。
in the first real word in argv.

2612
02:07:30,930 --> 02:07:32,160
我该怎么办？
And what am I going to do?

2613
02:07:32,159 --> 02:07:37,309
好吧，让我继续打印出argv [1]处的字符
Well, let me go ahead and print out a character that's at argv[1]

2614
02:07:37,310 --> 02:07:38,900
但在位置我。
but at location i.

2615
02:07:38,899 --> 02:07:41,299
所以我刚才在图片中说
So I said a moment ago with our picture that we

2616
02:07:41,300 --> 02:07:47,090
可以认为一个字符串数组实际上只是一个数组数组。
could think of an array of strings as really just being an array of arrays.

2617
02:07:47,090 --> 02:07:53,570
因此，我可以通过进入argv [1]来理解这个词，从而在此处采用该语法
And so I can employ that syntax here by going into argv[1] to get me the word

2618
02:07:53,569 --> 02:07:57,439
例如“ David”或“ Brian”等，然后使用更多
like "David" or "Brian" or so forth, and then further index into it with more

2619
02:07:57,439 --> 02:08:02,099
方括号使我得到D，A，V，I，D等。
square brackets that get me the D, the A, the V, the I, the D, and so forth.

2620
02:08:02,100 --> 02:08:05,300
为了更加清晰，让我在其中放置一个换行符
And just to be super clear, let me put a new line character there

2621
02:08:05,300 --> 02:08:08,070
以便我们可以清楚地看到发生了什么。
just so we can see explicitly what's going on.

2622
02:08:08,069 --> 02:08:10,579
现在让我继续，删除这个“你好，世界”
And let me go ahead now and just delete this "hello, world"

2623
02:08:10,579 --> 02:08:12,204
因为我不想看到任何问候。
because I don't want to see any hellos.

2624
02:08:12,204 --> 02:08:14,239
我只想看看人类输入的单词。
I just want to see the word the human typed in.

2625
02:08:14,239 --> 02:08:19,499
制作argv-糟糕，我做错了什么？
Make argv-- whoops, what did I do wrong?

2626
02:08:19,500 --> 02:08:25,259
哦，我不应该使用strlen，因为我没有包含string.h
Oh, I used strlen when I shouldn't have because I haven't included string.h

2627
02:08:25,260 --> 02:08:26,550
在顶部。
at the top.

2628
02:08:26,550 --> 02:08:31,230
好吧，现在，如果我重新编译此代码并重新编译make argv--
OK, now if I recompile this code and recompile make argv--

2629
02:08:31,229 --> 02:08:36,009
我们去了-./argv David，您将看到每行一个字符。
there we go-- ./argv David, you'll see one character per line.

2630
02:08:36,010 --> 02:08:38,940
如果我也用Brian的名字或任何人的名字做同样的事情
And if I do the same with Brian's name or anyone's name

2631
02:08:38,939 --> 02:08:42,351
并将其更改为Brian，我一次打印一个字符。
and change it to Brian, I'm printing one character at a time.

2632
02:08:42,351 --> 02:08:44,559
再次重申，我不确定您为什么要这么做。
So again, I'm not sure why you would want to do that.

2633
02:08:44,560 --> 02:08:47,760
但是在这种情况下，我的目标仅仅是不仅仅迭代
But in this case, my goal simply was to not only iterate over

2634
02:08:47,760 --> 02:08:51,970
第一个单词中的字符，但将其打印出来。
the characters in that first word, but print them out.

2635
02:08:51,970 --> 02:08:56,520
再说一次，只需在这段时间内应用两次，
So again, just by applying twice over this time this principle,

2636
02:08:56,520 --> 02:09:00,570
我们可以实际看到一个程序可以访问吗
can we actually see that a program has access

2637
02:09:00,569 --> 02:09:03,599
到每个字符串中的单个字符。
to the individual characters in each of these strings.

2638
02:09:03,600 --> 02:09:06,090
好吧，我们面前的最后一个解释
All right, and one last explanation before we

2639
02:09:06,090 --> 02:09:08,880
介绍加密货币及其应用。
introduce the crypto and application thereof.

2640
02:09:08,880 --> 02:09:11,790
这里的东西这里的东西-任何人都可以做
This thing here, this thing here-- does anyone

2641
02:09:11,789 --> 02:09:15,659
对于上周和本周为何主要的情况有任何想法，
have any idea as to why main, last week and this week,

2642
02:09:15,659 --> 02:09:19,319
即使它不是一般函数，似乎也返回一个int？
seems to return an int even though it's not an average function?

2643
02:09:19,319 --> 02:09:20,999
这不是get_positive_int函数。
It's not a get_positive_int function.

2644
02:09:21,000 --> 02:09:22,469
不是get_negative_int。
It's not get_negative_int.

2645
02:09:22,470 --> 02:09:26,040
出于某种原因，即使我们不满意，main仍会返回int
Somehow, for some reason, main keeps returning an int even though we

2646
02:09:26,039 --> 02:09:29,409
从未见过这种int的作用。
have never seen this int in action.

2647
02:09:29,409 --> 02:09:31,039
这可能是什么意思？
What might this mean?

2648
02:09:31,039 --> 02:09:33,339
这是我们承诺的最后一块
This is the one last piece that we promised

2649
02:09:33,340 --> 02:09:37,090
上周我们将最终进行解释。
last week we would eventually explain.

2650
02:09:37,090 --> 02:09:38,800
这可能是什么意思？
What might this mean?

2651
02:09:38,800 --> 02:09:41,420
这是一个艰难的过程。
And this one's a tough one.

2652
02:09:41,420 --> 02:09:43,870
布莱恩，我们有谁？
Brian, who do we have?

2653
02:09:43,869 --> 02:09:47,229
怎么样 [？贪婪，？]是吗？
How about [? Gred, ?] is it?

2654
02:09:47,229 --> 02:09:51,809
[？ GRED：？]通常，最后的函数返回0。
[? GRED: ?] Usually, the functions in the end have returned 0.

2655
02:09:51,810 --> 02:09:54,060
这意味着该功能停止。
And that means that the function stops.

2656
02:09:54,060 --> 02:10:00,270
0是从主函数中弹出的整数。
And the 0 is the integer that pops out of the main function.

2657
02:10:00,270 --> 02:10:03,810
戴维·马兰（David MALAN）：是的，这很妙，如果您之前曾编程过，
DAVID MALAN: Yeah, and this one's subtle in that if you had programmed before,

2658
02:10:03,810 --> 02:10:06,390
赔率是-我猜你有，[？ Gred--？]您已经看到了这个用法
odds are-- and I'm guessing you have, [? Gred-- ?] you've seen this in use

2659
02:10:06,390 --> 02:10:07,020
前。
before.

2660
02:10:07,020 --> 02:10:10,350
但是，我们人类在使用Mac和PC的现实世界中-
We humans, though, in the real world of using Macs and PCs--

2661
02:10:10,350 --> 02:10:13,320
您实际上已经在奇怪的地方看到了数字和整数。
you've actually seen numbers, integers in weird places.

2662
02:10:13,319 --> 02:10:17,219
坦白说，几乎在您的计算机死机或看到错误消息时，
Frankly, almost any time your computer freezes or you see an error message,

2663
02:10:17,220 --> 02:10:21,280
您很可能会在错误消息中看到英语或某种口头语言。
odds are you see an English or some spoken language in the error message.

2664
02:10:21,279 --> 02:10:23,306
但是，您经常会看到一个数字代码。
But you very often see a numeric code.

2665
02:10:23,306 --> 02:10:25,139
例如，如果您遇到缩放问题，
For instance, if you're having Zoom trouble,

2666
02:10:25,140 --> 02:10:29,700
您经常会在Zoom程序的错误窗口中看到数字5。
you'll often see the number 5 in the error window in Zoom's program.

2667
02:10:29,699 --> 02:10:31,709
5仅表示您遇到网络问题。
And 5 just means you're having network issues.

2668
02:10:31,710 --> 02:10:34,710
因此程序员经常将整数与事物相关联
So programmers often associate integers with things

2669
02:10:34,710 --> 02:10:36,540
在程序中可能会出错。
that can go wrong in a program.

2670
02:10:36,539 --> 02:10:42,209
并作为 [？ Gred？]注释，它们使用0表示没有任何问题，
And as [? Gred ?] notes, they use 0 to connote that nothing has gone wrong,

2671
02:10:42,210 --> 02:10:43,660
那也一样。
that all as well.

2672
02:10:43,659 --> 02:10:48,284
所以让我在这里写一个最终的程序，叫做exit.c
So let me write one final program here just called exit.c

2673
02:10:48,284 --> 02:10:49,949
对此进行了测试。
that puts this to the test.

2674
02:10:49,949 --> 02:10:54,639
让我继续并在名为exit.c的文件中编写程序
Let me go ahead and write a program in a file called exit.c

2675
02:10:54,640 --> 02:10:57,870
这将介绍我们称之为退出状态的信息。
that's going to introduce what we're going to call an exit status.

2676
02:10:57,869 --> 02:11:01,229
这是一个微妙之处，因为我们的程序会变得有用
This is a subtlety that will be useful as our programs get

2677
02:11:01,229 --> 02:11:02,579
稍微复杂一点。
a little more complicated.

2678
02:11:02,579 --> 02:11:06,359
我要去这里做#includecs50.h。
I'm going to go in here and do #include cs50.h.

2679
02:11:06,359 --> 02:11:09,359
我将继续并#include stdio.h。
And I'm going to go ahead and #include stdio.h.

2680
02:11:09,359 --> 02:11:14,969
而且我要给自己更长的main版本，例如int argc，string
And I'm going to give myself the longer version of main, so int argc, string

2681
02:11:14,970 --> 02:11:17,140
带有方括号的argv。
argv with the square brackets.

2682
02:11:17,140 --> 02:11:21,690
在这里，我要说的是，如果argc不等于2，
And in here, I'm going to say, if argc does not equal 2,

2683
02:11:21,689 --> 02:11:24,289
呃，人类没有做我想要他们做的事，
uh-uh, the human is not doing what I want them to,

2684
02:11:24,289 --> 02:11:26,039
我会以某种方式对他们大喊大叫。
and I'm going to yell at them in some way.

2685
02:11:26,039 --> 02:11:28,579
我要说的是缺少命令行参数。
I'm going to say missing command-line arguments.

2686
02:11:28,579 --> 02:11:31,959
因此，我希望人类在屏幕上看到的任何类型的错误消息，
So any kind of error message that I want the human to see on the screen,

2687
02:11:31,960 --> 02:11:33,900
我只想用这些信息告诉他们。
I'm just going to tell them with that message.

2688
02:11:33,899 --> 02:11:37,649
但是我将非常巧妙地返回数字1。
But I'm going to very subtly return the number 1.

2689
02:11:37,649 --> 02:11:39,089
我将返回一个错误代码。
I'm going to return an error code.

2690
02:11:39,090 --> 02:11:41,830
而且人类不一定会看到此代码。
And the human is not necessarily going to see this code.

2691
02:11:41,829 --> 02:11:45,149
但是如果我们要使用图形用户界面或其他功能
But if we were to have a graphical user interface or some other feature

2692
02:11:45,149 --> 02:11:47,129
这个程序就是那个数字
to this program, that would be the number

2693
02:11:47,130 --> 02:11:49,110
他们在弹出的错误窗口中看到，
they see in the error window that pops up,

2694
02:11:49,109 --> 02:11:52,319
就像Zoom可能在出现问题时向您显示数字5一样。
just like Zoom might show you the number 5 if something has gone wrong.

2695
02:11:52,319 --> 02:11:54,869
同样，坦率地说，如果您曾经访问过某个页面，
Similarly, if you've ever visited a page, frankly,

2696
02:11:54,869 --> 02:11:59,129
并且网页不存在，您会看到整数404。
and the web page doesn't exist, you see the integer 404.

2697
02:11:59,130 --> 02:12:01,890
从技术上讲，这并不是完全相同的化身，
That's not technically the exact same incarnation of this,

2698
02:12:01,890 --> 02:12:05,440
但是它代表程序员使用数字表示错误。
but it is representative of programmers using numbers to represent errors.

2699
02:12:05,439 --> 02:12:07,229
因此，您可能已经看到了。
So that one, you probably have seen.

2700
02:12:07,229 --> 02:12:11,159
不过，在这里，我将继续进行操作，默认情况下，说“你好，％s”
Here, I'm going to go ahead, though, and by default, say, "hello, %s,"

2701
02:12:11,159 --> 02:12:14,249
就像以前一样，传入argv [1]中的所有内容。
just like before, passing in whatever's in argv[1].

2702
02:12:14,250 --> 02:12:17,939
程序与以前一样，但是我不会做任何这样的la脚，“你好，
So same program as before, but I'm not going to do any of this lame, "hello,

2703
02:12:17,939 --> 02:12:21,579
世界”，如果人类没有按我的期望输入他们的名字。
world" if the human doesn't type in their name as I expect.

2704
02:12:21,579 --> 02:12:25,109
相反，我要检查一下，人类
Instead, I am going to check, did the human

2705
02:12:25,109 --> 02:12:27,179
在命令行给我两个词？
give me two words at the command line?

2706
02:12:27,180 --> 02:12:30,210
如果没有，我将打印“缺少命令行参数”
If not, I'm going to print, "missing command-line argument,"

2707
02:12:30,210 --> 02:12:32,220
然后返回此退出代码。
and then return this exit code.

2708
02:12:32,220 --> 02:12:36,750
否则，如果一切正常，我将继续并显式返回0。
Otherwise, if all is well, I'm going to go ahead and return explicitly 0.

2709
02:12:36,750 --> 02:12:40,200
这是您我本人永远都不会看到的另一个数字，
This is another number that the human, you and I, are never going to see,

2710
02:12:40,199 --> 02:12:42,059
但我们可以使用它。
but we could have access to it.

2711
02:12:42,060 --> 02:12:46,200
坦率地说，出于课程目的，check50可以访问此文件。
And frankly, for course purposes, check50 can have access to this.

2712
02:12:46,199 --> 02:12:48,569
还有图形用户界面，当我们进入这些界面时，
And graphical user interfaces, when we get to those,

2713
02:12:48,569 --> 02:12:50,979
可以访问这些值。
can have access to these values.

2714
02:12:50,979 --> 02:12:54,159
所以0，如[？ Gred？]笔记也一样。
So 0, as [? Gred ?] notes, is just all as well.

2715
02:12:54,159 --> 02:12:56,234
但是1表示出了点问题。
But 1 would mean that something goes wrong.

2716
02:12:56,234 --> 02:12:58,859
因此，让我继续并退出，这是适当的，
So let me go ahead and make exit, which is kind of appropriate,

2717
02:12:58,859 --> 02:13:00,269
当我们在这里结束时。
as we're wrapping up here.

2718
02:13:00,270 --> 02:13:02,760
让我继续做./exit。
And let me go ahead and do ./exit.

2719
02:13:02,760 --> 02:13:05,700
显示“缺少命令行参数”。
"Missing command-line argument" is what's displayed.

2720
02:13:05,699 --> 02:13:09,119
如果我继续说，退出大卫，现在我看到“你好，大卫”。
If I go ahead and say, exit David, now I see "hello, David."

2721
02:13:09,119 --> 02:13:12,569
或退出Brian，我将看到“退出Brian”。
Or exit Brian, I'll see "exit Brian."

2722
02:13:12,569 --> 02:13:15,119
现在，这不是您经常需要使用的技术，
Now, this is not a technique you'll need to use often,

2723
02:13:15,119 --> 02:13:19,109
但是如果需要，您实际上可以看到这些返回值。
but you can actually see these return values if you want.

2724
02:13:19,109 --> 02:13:23,969
如果我运行出口，并且看到此错误消息，我可以很奇怪地说，
If I run exit, and I see this error message, I can very weirdly say,

2725
02:13:23,970 --> 02:13:28,260
echo $ ?，这是一个非常隐蔽的说法，
echo $?, which is a very admittedly cryptic way of saying,

2726
02:13:28,260 --> 02:13:30,120
我的退出状态是什么？
what was my exit status?

2727
02:13:30,119 --> 02:13:32,639
如果您按Enter键，则会看到1。
And if you hit Enter, you'll see 1.

2728
02:13:32,640 --> 02:13:35,370
相比之下，如果我逃离大卫，我实际上
By contrast, if I run exit of David, and I actually

2729
02:13:35,369 --> 02:13:42,059
看到“你好，大卫”，我回显$ ?，现在我将看到0。
see "hello, David," and I do echo $?, now I will see 0.

2730
02:13:42,060 --> 02:13:45,030
同样，这不是您我会经常使用的技术。
So again, this is not a technique you and I will use very frequently.

2731
02:13:45,029 --> 02:13:48,479
但这是程序的能力，是C的能力，
But it's a capability of a program, and it's a capability of C,

2732
02:13:48,479 --> 02:13:49,919
您现在可以访问的。
that you do now have access to.

2733
02:13:49,920 --> 02:13:52,140
因此，在编写向前发展的程序时，
And so in writing programs moving forward,

2734
02:13:52,140 --> 02:13:55,380
我们在实验室，问题集等中经常要做的事情
what we will often do in labs and in problem sets and the like

2735
02:13:55,380 --> 02:14:02,430
要求您从主站返回0或1或2或3或4
is ask you to return from main either 0 or 1 or maybe 2 or 3 or 4

2736
02:14:02,430 --> 02:14:06,060
根据程序中可能出问题的问题
based on the problems that might have gone wrong in your program

2737
02:14:06,060 --> 02:14:09,420
您已经检测到并做出了适当的回应。
that you have detected and responded to appropriately.

2738
02:14:09,420 --> 02:14:13,530
因此，这是一种以标准方式处理错误的非常有效的方法
So it's a very effective way of handling errors in a standard way

2739
02:14:13,529 --> 02:14:18,179
以便您知道自己正在主动发现错误。
so that you know that you are being proactive about detecting mistakes.

2740
02:14:18,180 --> 02:14:20,540
那么，本周我们可能会处理哪些类型的错误？
So what kinds of mistakes might we handle this week?

2741
02:14:20,539 --> 02:14:22,289
我们可以解决哪些问题？
And what kinds of problems might we solve?

2742
02:14:22,289 --> 02:14:26,099
好吧，今天完全是关于解构字符串是什么。
Well, today was entirely about deconstructing what a string is.

2743
02:14:26,100 --> 02:14:29,220
上周，这只是一段文本，一段文本。
Last week, it was just a sequence of text, a chunk of text.

2744
02:14:29,220 --> 02:14:31,740
今天，它现在是字符数组。
Today, it's now an array of characters.

2745
02:14:31,739 --> 02:14:34,949
而且我们在C语言中提供了用于访问这些字符的新语法。
And we have new syntax in C for accessing those characters.

2746
02:14:34,949 --> 02:14:38,369
今天，我们还可以访问更多的库，更多的头文件，
We also today have access to more libraries, more header files,

2747
02:14:38,369 --> 02:14:41,459
因此，文档，以便我们可以实际解决问题
the documentation, therefore, so that we can actually solve problems

2748
02:14:41,460 --> 02:14:43,290
无需自己编写太多代码。
without writing as much code ourselves.

2749
02:14:43,289 --> 02:14:46,629
我们可以以这些库的形式使用其他人的代码。
We can use other people's code in the form of these libraries.

2750
02:14:46,630 --> 02:14:49,890
因此，我们将通过问题集2解决下个星期的一个问题
So one problem we will solve this coming week by way of problems set 2

2751
02:14:49,890 --> 02:14:51,120
是可读性。
is that of readability.

2752
02:14:51,119 --> 02:14:54,149
例如，当您阅读书籍，论文，论文或其他任何内容时，
Like, when you're reading a book or an essay or a paper or anything,

2753
02:14:54,149 --> 02:14:56,369
是什么使它像三年级的阅读
what is it that makes it like a 3rd-grade reading

2754
02:14:56,369 --> 02:14:59,916
或12年级的阅读水平或大学的阅读水平？
level or a 12th-grade reading level or university reading level?

2755
02:14:59,917 --> 02:15:02,250
好吧，我们所有人都可能具有直觉，对吗？
Well, all of us probably have an intuitive sense, right?

2756
02:15:02,250 --> 02:15:05,939
例如，如果它是大字体和短词，则可能是针对年幼的孩子的。
Like, if it's big font and short words, it's probably for younger kids.

2757
02:15:05,939 --> 02:15:08,999
如果真的是很复杂的单词，而且词汇量很大
And if it's really complicated words with big vocabulary and things

2758
02:15:09,000 --> 02:15:12,459
我们不知道，也许这是针对大学观众的。
we don't know, maybe it's meant for university audiences.

2759
02:15:12,460 --> 02:15:16,440
但是我们可以更加公式化地量化这一点，
But we can quantify this a little more formulaically,

2760
02:15:16,439 --> 02:15:19,327
不一定是唯一的方法，但是我们会给您一些定义。
not necessarily the only way, but we'll give you a few definitions.

2761
02:15:19,328 --> 02:15:21,120
例如，这是一个著名的句子
So for instance, here's a famous sentence--

2762
02:15:21,119 --> 02:15:23,369
“女贞路四号先生和达斯利夫人，
"Mr. And Mrs. Dursley, of number four, Privet Drive,

2763
02:15:23,369 --> 02:15:26,411
我们很自豪地说他们很正常，非常感谢，”
we're proud to say that they were perfectly normal, thank you very much,"

2764
02:15:26,412 --> 02:15:27,420
等等。
and so forth.

2765
02:15:27,420 --> 02:15:32,070
好吧，这本书的内容是什么，使哈利·波特升入了七年级
Well, what is it about this text that puts Harry Potter at grade seven

2766
02:15:32,069 --> 02:15:32,939
阅读水平？
reading level?

2767
02:15:32,939 --> 02:15:35,519
好吧，这可能与词汇单词有关。
Well, it probably has to do with the vocabulary words.

2768
02:15:35,520 --> 02:15:38,760
但这可能与句子的长度，数量有关
But it probably has to do with the lengths of the sentences, the amount

2769
02:15:38,760 --> 02:15:44,550
标点符号，也许是您可能要计算的字符总数。
of punctuation perhaps, the total number of characters that you might count up.

2770
02:15:44,550 --> 02:15:48,518
您可以想象仅基于外观对其进行量化
You can imagine quantifying it just based generically on the look

2771
02:15:48,518 --> 02:15:49,810
以及文字的美感。
and the aesthetics of the text.

2772
02:15:49,810 --> 02:15:50,670
那这个呢？
What about this?

2773
02:15:50,670 --> 02:15:53,010
“在计算语言学中，作者身份归属
"In computational linguistics, authorship attribution

2774
02:15:53,010 --> 02:15:55,590
是预测作者身份不明的文档的作者的任务。
is the task of predicting the author of document of unknown authorship.

2775
02:15:55,590 --> 02:15:58,673
通常通过分析测音特征来执行此任务-
This task is generally performed by the analysis of stylometric features--

2776
02:15:58,672 --> 02:16:00,749
特别”-这是Brian的高级论文。
particular"-- this is Brian's senior thesis.

2777
02:16:00,750 --> 02:16:02,649
因此，这不是七年级的阅读水平。
So this is not a seventh-grade reading level.

2778
02:16:02,649 --> 02:16:04,859
这实际上被评为16年级。
This was actually rated at grade 16.

2779
02:16:04,859 --> 02:16:08,129
因此，在撰写论文时，布莱恩相当精明。
So Brian's pretty sophisticated when it comes to writing theses.

2780
02:16:08,130 --> 02:16:11,160
但是在那儿，您也许也可以从老练中汲取灵感
But there too, you could perhaps glean from the sophistication

2781
02:16:11,159 --> 02:16:14,009
句子，句子的长度和其中的单词-
of the sentences, the length thereof, and the words therein--

2782
02:16:14,010 --> 02:16:17,010
我们也许可以量化一些东西以应用数字。
there's something we could perhaps quantify so as to apply numbers.

2783
02:16:17,010 --> 02:16:21,720
实际上，这是评估文本可读性的一种方式
And indeed, that's one way you could assess the readability of a text

2784
02:16:21,720 --> 02:16:24,480
即使您无权访问与之相关的字典
even if you don't have access to a dictionary with which

2785
02:16:24,479 --> 02:16:27,359
找出哪些是实际的大字或小字。
to figure out which are the actual big or small words.

2786
02:16:27,359 --> 02:16:28,819
密码学又如何呢？
And what about cryptography?

2787
02:16:28,819 --> 02:16:32,159
所以这几天真是太普遍了，所以很重要
So it's incredibly common these days and so important

2788
02:16:32,159 --> 02:16:37,019
这些天，您和我都使用加密技术，而不必使用
these days for you and I to use cryptography, not necessarily using

2789
02:16:37,020 --> 02:16:39,389
我们自己想出的算法，而是使用
algorithms we ourselves come up with, but rather using

2790
02:16:39,388 --> 02:16:43,468
WhatsApp，Signal and Telegram和Messenger等软件，
software, like WhatsApp and Signal and Telegram and Messenger and others,

2791
02:16:43,468 --> 02:16:48,339
支持您与第三方，朋友或家人之间的加密，
that support encryption between you and the third party or friend or family,

2792
02:16:48,340 --> 02:16:51,090
或至少是与您互动的网站。
or at least minimally the website with which you're interacting.

2793
02:16:51,090 --> 02:16:55,590
因此，密码学是加扰信息或隐藏信息的艺术。
So cryptography is the art of scrambling information, or hiding information.

2794
02:16:55,590 --> 02:16:59,430
坦率地说，如果是文字信息，那么从CS50的第三周开始，
And if that information is text, well, frankly, as of this third week of CS50,

2795
02:16:59,430 --> 02:17:03,059
我们已经有了必要的构件，不仅可以代表文本，
we already have the requisite building blocks for not only representing text,

2796
02:17:03,058 --> 02:17:05,039
但是我们今天看到了它。
but we saw today manipulating it.

2797
02:17:05,040 --> 02:17:09,330
即使只是大写字符也可以使我们开始对文本进行变异。
Even just uppercasing characters allows us to start mutating text.

2798
02:17:09,329 --> 02:17:11,458
那么，加密信息意味着什么？
Well, what does it mean to encrypt information?

2799
02:17:11,459 --> 02:17:13,650
好吧，就像上周我们的黑匣子一样。
Well, it's like our black box from last week.

2800
02:17:13,649 --> 02:17:14,519
您有一些意见。
You have some input.

2801
02:17:14,520 --> 02:17:15,395
您需要一些输出。
You want some output.

2802
02:17:15,395 --> 02:17:18,040
输入之后，我们将开始调用纯文本。
The input, we're going to start calling plaintext.

2803
02:17:18,040 --> 02:17:20,969
您要从自己发送给其他人的消息。
The message, you want to send from yourself to someone else.

2804
02:17:20,968 --> 02:17:22,975
密文是所需的输出。
Ciphertext is the output that you want.

2805
02:17:22,976 --> 02:17:24,809
因此，在这两者之间
And so in between there, there's going to be

2806
02:17:24,808 --> 02:17:26,225
我们将其称为密码。
what we're going to call a cipher.

2807
02:17:26,226 --> 02:17:30,270
密码是一种加密或加扰的算法
A cipher is an algorithm that encrypts or scrambles

2808
02:17:30,270 --> 02:17:34,177
它的输入，以便产生第三方无法理解的输出。
its input so as to produce output that a third party can't understand.

2809
02:17:34,176 --> 02:17:35,968
希望该密码，该算法，
And hopefully, that cipher, that algorithm,

2810
02:17:35,968 --> 02:17:40,019
是一个可逆的过程，因此当您收到加扰的密文时，
is a reversible process so that when you receive the scrambled ciphertext,

2811
02:17:40,020 --> 02:17:44,830
您可以弄清楚此人发送给您的邮件是什么。
you can figure out what it was that the person sent to you.

2812
02:17:44,829 --> 02:17:48,029
但是双关语意是使用加密技术的关键-
But the key to using cryptography-- pun intended--

2813
02:17:48,030 --> 02:17:49,282
也要有一个秘密钥匙。
is to also have a secret key.

2814
02:17:49,281 --> 02:17:51,239
所以，如果您回想小学，也许您
So if you think back to grade school, maybe you

2815
02:17:51,239 --> 02:17:53,548
在和一个班上的某人调情，而你发给他们
were flirting with someone in class, and you sent them

2816
02:17:53,549 --> 02:17:55,082
在一张纸上的笔记。
a note on a piece of paper.

2817
02:17:55,082 --> 02:17:58,290
好吧，希望你不只是在纸上说，例如，我爱你
Well, hopefully, you didn't just say, like, I love you, on the piece of paper

2818
02:17:58,290 --> 02:18:00,165
然后将其传递给您所有的朋友，
and then pass it through all of your friends,

2819
02:18:00,165 --> 02:18:02,910
或者更不用说老师了，最终的接受者。
or let alone the teacher, to the ultimate recipient.

2820
02:18:02,909 --> 02:18:05,339
也许您做了类似的事情，A变成了
Maybe you did something like, an A becomes

2821
02:18:05,340 --> 02:18:08,459
B. AB变成C. AC变成D.像，
a B. A B becomes a C. A C becomes a D. Like,

2822
02:18:08,459 --> 02:18:11,740
您有点应用一种算法将所有字母加1
you kind of apply an algorithm to add 1 to all of the letters

2823
02:18:11,739 --> 02:18:14,218
这样，如果老师确实拦截并看着它，
so that if the teacher does intercept it and look at it,

2824
02:18:14,218 --> 02:18:17,069
他们可能在世界上没有足够的心态去弄清楚这是什么。
they probably don't have enough care in the world to figure out what this is.

2825
02:18:17,069 --> 02:18:18,689
这看起来像是胡说八道。
It's just going to look like nonsense.

2826
02:18:18,690 --> 02:18:21,840
但是如果您的朋友知道您将A更改为B，则B
But if your friend knows that you changed A to B, B

2827
02:18:21,840 --> 02:18:26,010
在C上加上每个字母1，他们可以逆转该过程
to C by adding 1 to every letter, they could reverse that process

2828
02:18:26,010 --> 02:18:27,610
并解密。
and decrypt it.

2829
02:18:27,610 --> 02:18:30,270
因此，例如，该密钥实际上可能是数字1。
So the key, for instance, might be literally the number 1.

2830
02:18:30,270 --> 02:18:32,610
该消息的字面意思可能是“我爱你”。
The message literally might be, "I LOVE YOU."

2831
02:18:32,610 --> 02:18:35,080
但是密文是什么，或者是输出？
But what would the ciphertext be, or the output?

2832
02:18:35,079 --> 02:18:38,609
好吧，让我们考虑一下“ I LOVE YOU”是一个字符串，从今天开始，
Well, let's consider "I LOVE YOU" is a string which, as of today,

2833
02:18:38,610 --> 02:18:40,240
是一个字符数组。
is an array of characters.

2834
02:18:40,239 --> 02:18:41,999
那有什么用呢？
So what use is that?

2835
02:18:42,000 --> 02:18:45,123
好吧，让我们仔细考虑一下该短语，就好像它是一个数组一样。
Well, let's consider exactly that phrase as though it's an array.

2836
02:18:45,122 --> 02:18:46,289
它是一个字符数组。
It's an array of characters.

2837
02:18:46,290 --> 02:18:50,969
从上周我们知道，字符只是整数，十进制整数，
We know from last week, characters are just integers, decimal integers,

2838
02:18:50,968 --> 02:18:53,189
多亏了ASCII，以及Unicode。
thanks to ASCII, and in turn, Unicode.

2839
02:18:53,190 --> 02:18:55,770
事实证明，我已经是73岁了。
So it turns out I, we already know, is 73.

2840
02:18:55,770 --> 02:19:04,920
如果我们在图表上查找所有其他图表，则L为76、79、86、69、89、79、85。
And if we looked up all the others on a chart, L is 76, 79, 86, 69, 89, 79, 85.

2841
02:19:04,920 --> 02:19:08,400
这样我们就可以相对轻松地看到-您可能必须检查一下笔记
So we could relatively easily and see-- you might have to check your notes

2842
02:19:08,399 --> 02:19:10,239
并检查我的示例代码，依此类推-
and check my sample code and so forth--

2843
02:19:10,239 --> 02:19:15,749
但在C中相对容易地将“ I LOVE YOU”转换为相应的整数
but relatively easily in C convert "I LOVE YOU" to the corresponding integers

2844
02:19:15,750 --> 02:19:19,290
通过仅将字符转换为整数就可以了。
by just casting, so to speak, chars to integers.

2845
02:19:19,290 --> 02:19:23,340
我可以很容易地在数学上使用C语言中的plus运算符，
I could very easily mathematically, using the plus operator in C,

2846
02:19:23,340 --> 02:19:26,910
开始向这些字符中的每个字符加1，
start to add 1 to every one of these characters,

2847
02:19:26,909 --> 02:19:29,308
从而加密我的信息。
thereby encrypting my message.

2848
02:19:29,308 --> 02:19:31,397
但是我可以把这些号码发给我的朋友。
But I could send my friend these numbers.

2849
02:19:31,397 --> 02:19:33,689
但我也可以使它更加人性化
But I might as well make it a little more user friendly

2850
02:19:33,690 --> 02:19:36,209
并将其从整数转换回char。
and cast it back from integers to chars.

2851
02:19:36,209 --> 02:19:42,930
因此，现在看来，如果我使用1的密钥，则“ I LOVE YOU”的密文-
So now it would seem that the ciphertext for "I LOVE YOU," if using a key of 1--

2852
02:19:42,930 --> 02:19:47,910
而1只是意味着将A更改为B，而不是将A更改为C，只需将其移动一个位置-
and 1 just means change A to B, not A to C, just move it by one place--

2853
02:19:47,909 --> 02:19:52,739
这是“我爱你”的加密消息的密文。
this is the ciphertext for an encrypted message of, "I LOVE YOU."

2854
02:19:52,739 --> 02:19:55,839
因此整个过程变为1就是输入作为键。
And so the whole process becomes 1 is the input as the key.

2855
02:19:55,840 --> 02:19:57,810
输入的内容为“ I LOVE YOU”（纯文字）。
"I LOVE YOU" is the input as the plaintext.

2856
02:19:57,809 --> 02:20:00,989
输出最终就是这个不可发音的短语
And the output ultimately is this unpronounceable phrase

2857
02:20:00,989 --> 02:20:03,629
再说一次，如果老师或一些朋友拦截，
that, again, if the teacher or some friend intercepts,

2858
02:20:03,629 --> 02:20:06,059
他们可能不知道发生了什么。
they probably don't know what's going on.

2859
02:20:06,059 --> 02:20:08,519
确实，这是密码学的本质。
And indeed, this is the essence of cryptography.

2860
02:20:08,520 --> 02:20:12,027
保护我们的电子邮件，文本和财务信息的算法
The algorithms that protect our emails and texts and financial information

2861
02:20:12,027 --> 02:20:13,860
和健康信息有望更多
and health information is hopefully way more

2862
02:20:13,860 --> 02:20:17,160
比该特定算法更复杂。
sophisticated than that particular algorithm as it is.

2863
02:20:17,159 --> 02:20:19,349
但这归结为相同的过程-
But it reduces to the same process--

2864
02:20:19,350 --> 02:20:23,640
一个输入键和一个输入文本，后跟一些输出，
an input key and an input text followed by some output,

2865
02:20:23,639 --> 02:20:25,049
所谓的密文。
the so-called ciphertext.

2866
02:20:25,049 --> 02:20:28,499
数十年来，这种形式一直伴随着我们，有时甚至
And this has been with us for decades now in some form, sometimes even

2867
02:20:28,500 --> 02:20:29,400
机械形式。
mechanical form.

2868
02:20:29,399 --> 02:20:32,759
过去，您实际上可以得到这些小的圆形装置
Back in the day, you could actually get these little circular devices

2869
02:20:32,760 --> 02:20:35,343
在一侧的字母上有字母的字母，在其他字母上
that have letters on the alphabet on one side, other letters

2870
02:20:35,343 --> 02:20:36,760
在另一边的字母上。
on the alphabet on the other side.

2871
02:20:36,760 --> 02:20:39,720
如果您旋转一个或另一个，A可能会排成一行
And if you rotate one or the other, A might line up

2872
02:20:39,719 --> 02:20:41,309
与B，B可能会与C对齐。
with B, B might line up with C.

2873
02:20:41,309 --> 02:20:44,759
因此，您甚至可以拥有加密的物理化身，
So you can have even a physical incarnation of cryptography,

2874
02:20:44,760 --> 02:20:49,920
就像在电视上无休止地播放电影一样，
just as was popular in a movie that seems to play endlessly on TV,

2875
02:20:49,920 --> 02:20:52,930
至少在圣诞节期间在美国这里。
at least here in the US around Christmas time.

2876
02:20:52,930 --> 02:20:56,980
而且您可能会认识到，如果您看过《圣诞节故事》就是这样一个样子。
And you might recognize if you've seen A Christmas Story one such look.

2877
02:20:56,979 --> 02:20:59,459
所以我们只用了几分钟的最后一刻
So we'll use just a couple of minutes of our final moments

2878
02:20:59,459 --> 02:21:02,909
一起来看一下这种加密技术的真实世界
together to take a look at this real-world incarnation of cryptography

2879
02:21:02,909 --> 02:21:06,532
毫无疑问，您可能会在今年秋天在电视上看到它。
that undoubtedly you can probably see on TV this fall.

2880
02:21:06,532 --> 02:21:07,199
[视频回放]
[VIDEO PLAYBACK]

2881
02:21:07,200 --> 02:21:09,810
-“众所周知，拉尔夫·帕克（Ralph Parker）特此登场
- "Be it known to all and sundry that Ralph Parker is hereby

2882
02:21:09,809 --> 02:21:12,719
任命小孤儿安妮秘密圈子的成员
appointed a member of the Little Orphan Annie secret circle

2883
02:21:12,719 --> 02:21:16,299
并有权享有由此产生的所有荣誉和利益。”
and is entitled to all the honors and benefits occurring thereto."

2884
02:21:16,299 --> 02:21:18,809
-《小孤儿安妮签名》。
- "Signed, Little Orphan Annie."

2885
02:21:18,809 --> 02:21:22,919
墨水中的“皮埃尔·安德烈（Countersigned）”
"Countersigned, Pierre Andre," in ink.

2886
02:21:22,920 --> 02:21:25,620
荣誉和福利已经九岁了。
Honors and benefits already at the age of nine.

2887
02:21:25,620 --> 02:21:27,942
[无线电聊天]
[RADIO CHATTER]

2888
02:21:27,941 --> 02:21:28,899
-（广播）注意！
- (ON RADIO) Attention!

2889
02:21:28,899 --> 02:21:29,709
[听不清]落水！
[INAUDIBLE] overboard!

2890
02:21:29,709 --> 02:21:30,164
[更改中]
[CLANGING]

2891
02:21:30,165 --> 02:21:31,530
-（广播）来[听不清]落水了！
- (ON RADIO) Come [INAUDIBLE] Gone overboard!

2892
02:21:31,530 --> 02:21:32,440
-（在收音机上）[听不清]
- (ON RADIO) [INAUDIBLE]

2893
02:21:32,440 --> 02:21:33,808
-来吧，让我们继续吧。
- Come on, let's get on with it.

2894
02:21:33,808 --> 02:21:36,100
我不需要关于走私者和海盗的爵士乐。
I don't need all that jazz about smugglers and pirates.

2895
02:21:36,100 --> 02:21:36,976
[叫声]
[BARKING]

2896
02:21:37,645 --> 02:21:40,270
-（广播）明天晚上听结局冒险
- (ON RADIO) Listen tomorrow night for the concluding adventure

2897
02:21:40,270 --> 02:21:42,450
黑色海盗船。
of the Black Pirate Ship.

2898
02:21:42,450 --> 02:21:48,430
现在是时候向您的秘密圈子成员发送安妮的秘密消息了。
Now it's time for Annie's secret message for you members of the secret circle.

2899
02:21:48,430 --> 02:21:52,150
记住孩子，只有任何秘密圈子的成员
Remember kids, only members of any secret circle

2900
02:21:52,149 --> 02:21:54,729
可以解码任何秘密消息。
can decode any secret message.

2901
02:21:54,729 --> 02:21:58,899
记住，安妮取决于你。
Remember, Annie is depending on you.

2902
02:21:58,899 --> 02:22:01,479
将引脚设置为B-2。
Set your pins to B-2.

2903
02:22:01,479 --> 02:22:03,759
这是消息。
Here is the message.

2904
02:22:03,760 --> 02:22:05,710
12、11、2、8-
12, 11, 2, 8--

2905
02:22:05,709 --> 02:22:07,539
-我正在第一次秘密聚会。
- I am in my first secret meeting.

2906
02:22:07,540 --> 02:22:12,250
-（广播）--25、14、11、18、16、23--
- (ON RADIO) --25, 14, 11, 18, 16, 23--

2907
02:22:12,250 --> 02:22:14,110
-今晚老皮埃尔大声疾呼。
- Old Pierre was in great voice tonight.

2908
02:22:14,110 --> 02:22:14,350
-（收音机）--12，23--
- (ON RADIO) --12, 23--

2909
02:22:14,350 --> 02:22:16,767
-我可以说今晚的信息非常重要
- I could tell that tonight's message was really important

2910
02:22:16,766 --> 02:22:19,659
-（广播）--21，3，25。
- (ON RADIO) --21, 3, 25.

2911
02:22:19,659 --> 02:22:21,399
那是安妮本人的信息。
That's a message from Annie herself.

2912
02:22:21,399 --> 02:22:22,619
记住，不要告诉任何人。
Remember, don't tell anyone.

2913
02:22:22,620 --> 02:22:25,584
[脚步声和气喘吁吁]
[FOOTSTEPS AND PANTING]

2914
02:22:27,559 --> 02:22:31,549
-90秒后，我在房子里唯一一个有9个男孩的房间里
- 90 seconds later, I'm in the only room in the house where a boy of nine

2915
02:22:31,549 --> 02:22:33,634
可以私下里坐下并解码。
could sit in privacy and decode.

2916
02:22:33,635 --> 02:22:43,070
[笑声] Aha，B. [笑声]我去了下一个，E。第一个单词是“ be”。
[CHUCKLES] Aha, B. [CHUCKLES] I went to the next, E. The first word is "be."

2917
02:22:43,069 --> 02:22:45,679
S，现在变得更容易了。
S, it was coming easier now.

2918
02:22:45,680 --> 02:22:47,747
U. [笑脸] 25，是R。
U. [CHUCKLES] 25, that's R.

2919
02:22:47,746 --> 02:22:50,191
-噢，来吧，拉尔菲，我得走了。
- Aw, come on, Ralphie, I gotta go.

2920
02:22:50,191 --> 02:22:51,169
- 快点。
- Come on.

2921
02:22:51,170 --> 02:22:53,126
-我马上下来，妈！
- I'll be right down, Ma!

2922
02:22:53,126 --> 02:22:54,104
-哎呀
- Gee whiz.

2923
02:22:57,040 --> 02:23:01,120
-T，O。“一定要。”
- T, O. "Be sure to."

2924
02:23:01,120 --> 02:23:02,380
确定要做什么？
Be sure to what?

2925
02:23:02,379 --> 02:23:04,512
小孤儿安妮想说什么？
What was Little Orphan Annie trying to say?

2926
02:23:04,513 --> 02:23:05,180
确定要做什么？
Be sure to what?

2927
02:23:05,180 --> 02:23:06,970
-Ralphie，Randy得走了。
- Ralphie, Randy has got to go.

2928
02:23:06,969 --> 02:23:08,349
你能出来吗？
Will you please come out?

2929
02:23:08,350 --> 02:23:09,580
-好的，妈！
- All right, Ma!

2930
02:23:09,579 --> 02:23:11,469
我马上出去！
I'll be right out!

2931
02:23:11,469 --> 02:23:13,369
-我现在越来越近了。
- I was getting closer now.

2932
02:23:13,370 --> 02:23:15,300
紧张局势非常糟糕。
The tension was terrible.

2933
02:23:15,299 --> 02:23:16,309
它以前如何？
What was it?

2934
02:23:16,309 --> 02:23:18,775
行星的命运可能悬而未决。
The fate of the planet may hang in the balance.

2935
02:23:18,775 --> 02:23:19,275
[敲门声]
[KNOCKING]

2936
02:23:19,275 --> 02:23:19,775
-拉尔夫！
- Ralphie!

2937
02:23:19,775 --> 02:23:21,665
兰迪要走了！
Randy's got to go!

2938
02:23:21,665 --> 02:23:25,011
-我马上就出来，大声喊出来！
- I'll be right out, for crying out loud!

2939
02:23:25,012 --> 02:23:26,860
-[笑声]快到了。
- [CHUCKLES] Almost there.

2940
02:23:26,860 --> 02:23:27,930
我的手指飞舞。
My fingers flew.

2941
02:23:27,930 --> 02:23:31,560
我的心是一个钢陷阱，每个毛孔都在振动。
My mind was a steel trap, every pore vibrated.

2942
02:23:31,559 --> 02:23:33,523
这几乎是清楚的。
It was almost clear.

2943
02:23:33,523 --> 02:23:35,893
是的，是的，是的，是的。
Yes, yes, yes, yes.

2944
02:23:35,894 --> 02:23:41,700
-“一定要喝你的椭圆形药。”
- "Be sure to drink your Ovaltine."

2945
02:23:41,700 --> 02:23:42,630
椭圆形的？
Ovaltine?

2946
02:23:46,510 --> 02:23:47,750
笨拙的广告？
A crummy commercial?

2947
02:23:47,750 --> 02:23:50,890
[音乐播放]
[MUSIC PLAYING]

2948
02:23:50,889 --> 02:23:52,316
桦木的儿子。
Son of a bi*ch.

2949
02:23:52,316 --> 02:23:52,899
[结束播放]
[END PLAYBACK]

2950
02:23:52,899 --> 02:23:55,029
DAVID MALAN：好的，就是CS50。
DAVID MALAN: All right, that's it for CS50.

2951
02:23:55,030 --> 02:23:57,310
下次见。
We will see you next time.

2952
02:23:57,309 --> 02:24:00,659
[音乐播放]
[MUSIC PLAYING]

