1
00:00:00,000 --> 00:00:04,482
[音乐响起--字幕精校中--By Persisan]
[MUSIC PLAYING]

2
00:00:49,369 --> 00:00:53,269
戴维·马兰：好的，这是CS50，这是第四周。
DAVID MALAN: All right, this is CS50, and this is week four.

3
00:00:53,270 --> 00:00:55,190
在过去的几周中，我们已经
And for the past several weeks, we've had

4
00:00:55,189 --> 00:00:58,216
使用这种称为C的语言时，各种训练轮都会启动。
training wheels of sorts on, while using this language known as C.

5
00:00:58,216 --> 00:01:01,049
那些训练轮已采用CS50库的形式。
And those training wheels have been in the form of the CS50 library.

6
00:01:01,049 --> 00:01:05,579
当然，您可以通过选择并包含cs50.h来使用该库。
And you use this library, of course, by selecting and including cs50.h

7
00:01:05,579 --> 00:01:06,649
在您的代码之上。
atop your code.

8
00:01:06,650 --> 00:01:08,733
然后，如果您考虑[音频不清晰]的工作原理，
And then if you think about how [INAUDIBLE] works,

9
00:01:08,733 --> 00:01:12,080
您已经通过破折号L CS50链接了代码。
you've been linking your code via dash L CS50.

10
00:01:12,079 --> 00:01:15,289
到目前为止，所有这些操作都已经使用make自动化了。
But all of that has been automated for you up until now, using make.

11
00:01:15,290 --> 00:01:17,900
今天，我们将从上周的重点过渡
Today, we'll transition from last week's focus

12
00:01:17,900 --> 00:01:21,290
在算法上更多地关注机器
on algorithms to a little more focus on machines

13
00:01:21,290 --> 00:01:24,980
在我们现在用来实现这些算法的机器上
and on the machines we now use to implement these algorithms all the more

14
00:01:24,980 --> 00:01:27,410
当我们开始起飞这些训练轮时，功能强大
powerfully, as we begin to take off these training wheels

15
00:01:27,409 --> 00:01:30,839
并查看计算机机箱内部到底发生了什么。
and look at what's really going on underneath the hood of your computer.

16
00:01:30,840 --> 00:01:33,740
和C的某些方面一样复杂，
And as complicated as some aspects of C have been,

17
00:01:33,739 --> 00:01:36,319
因为编程是新手，很可能适合您，
as new is programming may very well be to you,

18
00:01:36,319 --> 00:01:39,709
意识到引擎盖下没有太多事情要做
realize that there's not all that much going on underneath the hood

19
00:01:39,709 --> 00:01:42,349
我们需要了解的才能继续前进
that we need to understand to now move onward

20
00:01:42,349 --> 00:01:45,919
并开始解决更有趣，更复杂，更多的问题
and start solving far more interesting and more sophisticated and more

21
00:01:45,920 --> 00:01:46,820
好玩的问题。
fun problems.

22
00:01:46,819 --> 00:01:49,169
我们只需要一些其他的构建基块。
We just need a few additional building blocks.

23
00:01:49,170 --> 00:01:52,340
因此，今天，我们将首先通过重新学习计数方法来做到这一点。
And so today, we'll do this, first, by relearning how to count.

24
00:01:52,340 --> 00:01:55,080
例如，在这里，我们将其称为计算机的内存。
Here, for instance, is what we'll call the computer's memory.

25
00:01:55,079 --> 00:01:56,419
而且我们之前已经看过这个网格。
And we've seen this grid before.

26
00:01:56,420 --> 00:01:59,420
而且我们可以对计算机内存中的所有字节进行编号。
And we can number recall all of the bytes in your computer's memory.

27
00:01:59,420 --> 00:02:04,550
我们可以将此字节号称为0、1、2、3、4，一直到字节15。
We might call this byte number 0, 1, 2, 3, 4, all the way up to byte 15,

28
00:02:04,549 --> 00:02:05,609
等等。
and so forth.

29
00:02:05,609 --> 00:02:08,239
但是事实证明，当谈论计算机的记忆时，
But it turns out, when talking about computers' memories,

30
00:02:08,240 --> 00:02:10,610
计算机以及计算机科学家和程序员
computers and computer scientists and programmers

31
00:02:10,610 --> 00:02:13,070
实际上并不倾向于使用十进制。
actually don't tend to use decimal.

32
00:02:13,069 --> 00:02:15,829
他们绝对不会在这样低的级别上使用二进制文件。
They definitely don't tend to use binary at that low level.

33
00:02:15,830 --> 00:02:19,010
取而代之的是，他们倾向于出于常规目的而使用，
Instead, they tend to use, just for conventional sake,

34
00:02:19,009 --> 00:02:21,019
称为十六进制的东西。
something called hexadecimal.

35
00:02:21,020 --> 00:02:23,210
十六进制是一个不同的基本系统，
Hexadecimal is a different base system that,

36
00:02:23,210 --> 00:02:27,120
而不是使用10位数或2位数，而是使用16。
instead of using 10 digits or 2 digits, uses 16 instead.

37
00:02:27,120 --> 00:02:29,360
因此，计算机科学家在对事物进行编号时
And so a computer scientist, when numbering things

38
00:02:29,360 --> 00:02:33,980
像计算机内存中的字节一样，仍会执行0、1、2、3、4、5、6、7、8、9。
like bytes in a computer memory, would still do 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.

39
00:02:33,979 --> 00:02:37,349
但是在那之后，与其继续使用小数点到10，
But after that, instead of going onward with decimal to, say, 10,

40
00:02:37,349 --> 00:02:40,969
通常是11、12、13、14、15，
11, 12, 13, 14, 15, they instead, conventionally,

41
00:02:40,969 --> 00:02:43,259
将开始使用几个字母。
would start using a few letters of the alphabet.

42
00:02:43,259 --> 00:02:47,269
因此，以十六进制表示，这个不同的基本系统基础16
And so, in hexadecimal, this different base system base 16,

43
00:02:47,270 --> 00:02:48,980
您仍然从0开始计数。
you start counting at 0 still.

44
00:02:48,979 --> 00:02:51,129
您最多可以算到9。
You count up to and through 9.

45
00:02:51,129 --> 00:02:52,879
但是当你想继续计数时，
But when you want to keep counting higher,

46
00:02:52,879 --> 00:02:57,439
然后转到A，B，C，D，E和F。
you then go to A, B, C, D, E, and F.

47
00:02:57,439 --> 00:03:02,629
这样做的好处是，在十六进制内（十六进制表示16）
And the upside of this is that, within hexadecimal-- and that hex implies 16--

48
00:03:02,629 --> 00:03:08,629
您总共有16个个人数字，即0到9，以及现在的A到F。
you have 16 total individual digits, 0 through 9, and also now, A through F.

49
00:03:08,629 --> 00:03:12,299
因此，我们不必引入第二位数字就可以计算出最高为16的数字。
So we don't have to introduce second digits just to count up as high as 16.

50
00:03:12,300 --> 00:03:14,480
我们可以使用0到F的单个数字。
We can use individual digits 0 through F.

51
00:03:14,479 --> 00:03:18,649
而且我们可以通过使用多个十六进制数字来进一步计数。
And we can keep counting up further by using multiple hexadecimal digits.

52
00:03:18,650 --> 00:03:21,150
但是要到达那里，让我们介绍一下这个词汇。
But to get there, let's introduce this vocabulary.

53
00:03:21,150 --> 00:03:23,540
因此，在二进制中，我们当然使用0和1。
So in binary, of course, we use 0's and 1's.

54
00:03:23,539 --> 00:03:25,689
当然，在十进制中，我们使用0到9。
In decimal, of course, we use 0 through 9's.

55
00:03:25,689 --> 00:03:29,359
而且要明确一点，在十六进制中，我们将使用0到F之间的值，否则
And in hexadecimal, to be clear, we're going to use 0 through F's, otherwise

56
00:03:29,360 --> 00:03:30,860
被称为基础16。
known as base-16.

57
00:03:30,860 --> 00:03:33,320
这只是我们使用A到F的约定。
And it's just a convention that we use A through F. We

58
00:03:33,319 --> 00:03:35,449
本可以使用其他六个符号。
could have used any other six symbols.

59
00:03:35,449 --> 00:03:37,559
但是，这些都是人类选择的。
But these are what humans have chosen.

60
00:03:37,560 --> 00:03:41,090
因此，十六进制的工作原理与我们熟悉的十进制非常相似。
So hexadecimal works quite similarly to our familiar decimal system.

61
00:03:41,090 --> 00:03:45,110
现在，您对二进制系统的了解甚至还很熟悉，如下所示。
And it's even familiar to, now, what you know as the binary system, as follows.

62
00:03:45,110 --> 00:03:49,370
让我们考虑使用十六进制而不是十进制的两位数值
Let's consider a two-digit value using hexadecimal instead of decimal

63
00:03:49,370 --> 00:03:50,600
而不是二进制。
and instead of binary.

64
00:03:50,599 --> 00:03:54,679
好吧，就像在十进制世界中一样，我们以10为底，
Well, just like in the world of decimal, we used base-10,

65
00:03:54,680 --> 00:03:57,080
或在二进制世界中，我们使用了base-2。
or in the world of binary, we used base-2.

66
00:03:57,080 --> 00:04:01,170
现在，我们将使用base-16，ergo，十六进制。
We're just going to use, now, base-16, ergo, hexadecimal.

67
00:04:01,169 --> 00:04:02,359
因此，这是第16个。
So this is 16 to the first.

68
00:04:02,360 --> 00:04:03,590
这是16-
This is 16 to the--

69
00:04:03,590 --> 00:04:05,090
对不起16到0。
sorry 16 to the 0.

70
00:04:05,090 --> 00:04:06,590
这是16到第一个。
This is 16 to the first.

71
00:04:06,590 --> 00:04:09,570
当然，如果我们将其相乘，那只是一列
And of course, if we multiply that out, it's just the ones column

72
00:04:09,569 --> 00:04:11,279
现在是16列。
and now the 16's column.

73
00:04:11,280 --> 00:04:13,550
因此，如果您想以十六进制进行计数，
And so if you want to count up in hexadecimal,

74
00:04:13,550 --> 00:04:21,290
您仍然照常从0开始，然后是01、02、03、04、05、06、07、08、09。
you still start with 0 as usual, then 01, 02, 03, 04, 05, 06, 07, 08, 09.

75
00:04:21,290 --> 00:04:22,910
然后事情变得有趣了。
And then things get interesting.

76
00:04:22,910 --> 00:04:26,660
现在，您无需转到01，因为那是不正确的。
Now, you don't go to 01, because that would be incorrect.

77
00:04:26,660 --> 00:04:31,880
在这个基本系统中，01等于16乘以1加1乘以0。
01, in this base system, would be like 16 times 1 plus 1 times 0.

78
00:04:31,879 --> 00:04:32,959
那不是我们想要的。
That's not what we want.

79
00:04:32,959 --> 00:04:38,929
在我们知道的数字是9之后，我们现在可以算出A，B，C，D，E，F。
After the number we know is 9, we now count up to A, B, C, D, E, F.

80
00:04:38,930 --> 00:04:40,670
现在，事情又变得有趣了。
And now, things get interesting again.

81
00:04:40,670 --> 00:04:43,580
但是就像在十进制系统中一样，当您计数到99时，
But just like in the decimal system, when you count up to, like, 99,

82
00:04:43,579 --> 00:04:46,549
您必须在这里开始携带1，同样的东西。
you have to start carrying the 1, same thing here.

83
00:04:46,550 --> 00:04:49,820
如果要计数过去的F，请携带1。
If you want to count past F, you carry the 1.

84
00:04:49,819 --> 00:04:55,339
现在，为了表示一个大于F的值，我们使用01，
And so now, to represent one value greater than F, we use 01,

85
00:04:55,339 --> 00:04:57,349
看起来像10，但不是10。
which looks like 10, but is not 10.

86
00:04:57,350 --> 00:04:59,675
十六进制为01。
In hexadecimal, it is 01.

87
00:04:59,675 --> 00:05:01,880
16乘以1给我们16。
16 times 1 gives us 16.

88
00:05:01,879 --> 00:05:03,679
1乘以0得出0。
1 times 0 gives us 0.

89
00:05:03,680 --> 00:05:07,050
当然，这使我们现在知道的十进制数为16。
And of course, that gives us the decimal number we now know is 16.

90
00:05:07,050 --> 00:05:09,980
因此，我们将不再引入越来越多的基本系统。
So we will no longer introduce more and more base systems.

91
00:05:09,980 --> 00:05:12,607
但是让我规定，仅通过使用这些列即可
But let me stipulate that just by using these columns

92
00:05:12,607 --> 00:05:14,690
你在小学时学到的，大概是
that you learned back in grade school, presumably,

93
00:05:14,689 --> 00:05:16,939
您现在可以实现任何基本系统吗？
can you implement any base system now.

94
00:05:16,939 --> 00:05:19,309
碰巧的是，在计算机世界中，
It just so happens that in the world of computers,

95
00:05:19,310 --> 00:05:22,295
如今在内存世界中，很快还有文件，
and today in the world of memory, and soon, also files,

96
00:05:22,295 --> 00:05:24,170
这将是非常传统的
it's just going to be very conventional to be

97
00:05:24,170 --> 00:05:26,990
能够识别和使用十六进制。
able to recognize and use hexadecimal.

98
00:05:26,990 --> 00:05:29,530
实际上，人类有一个理由喜欢十六进制，
And in fact, there's a reason humans like hexadecimal,

99
00:05:29,529 --> 00:05:30,529
或至少有人。
or at least some humans.

100
00:05:30,529 --> 00:05:36,826
计算机科学家回忆说，在这种情况下，如果我们将FF计数为高，
Computer scientists recall that if we count up as high as FF, in this case,

101
00:05:36,826 --> 00:05:38,159
我们仍然会做同样的数学。
we would still do the same math.

102
00:05:38,160 --> 00:05:44,060
所以16乘15加1乘15将给我们，真的，
So 16 times 15 plus 1 times 15 is going to give us, really, this,

103
00:05:44,060 --> 00:05:49,210
或者是240加15或255。
or of course, 240 plus 15, or 255.

104
00:05:49,209 --> 00:05:50,459
我很快就做了。
And I did that pretty quickly.

105
00:05:50,459 --> 00:05:52,999
但这只是小学数学相乘的一种
But that's just the sort of grade school math of multiplying

106
00:05:53,000 --> 00:05:55,729
列中的值，再一次，
the column by the value that's in it, where again,

107
00:05:55,730 --> 00:06:00,140
这些F中的每一个就是我们现在使用一位数字表示15的方式。
each of these F's is how we now express 15 using a single digit.

108
00:06:00,139 --> 00:06:02,479
但是回想一下，我们之前看过255个。
But recall that we've seen 255 before.

109
00:06:02,480 --> 00:06:04,610
几周前，当我们谈论二进制文件时，
Back when we talked about binary a few weeks ago,

110
00:06:04,610 --> 00:06:12,450
255恰好也是我们在这里看到的模式，使用二进制的8个1位。
255 also happened to be the pattern that we see here, eight 1 bits using binary.

111
00:06:12,449 --> 00:06:15,277
因此，计算机科学家倾向于使用十六进制的原因
And so the reason that computer scientists tend to hexadecimal,

112
00:06:15,278 --> 00:06:17,570
是的，你知道在八位中，实际上
is that, you know what, in eight bits, there's actually

113
00:06:17,569 --> 00:06:19,999
这里有两对，左边是四对，右边是四对。
two pairs here, like four on the left, four on the right.

114
00:06:20,000 --> 00:06:22,339
如果我们把这些东西整理一下，那
If we sort of scooch these things over, it

115
00:06:22,339 --> 00:06:25,519
事实证明，因为十六进制允许
turns out that because hexadecimal allows

116
00:06:25,519 --> 00:06:28,729
您代表16个可能的值，这是
you to represent 16 possible values, it's

117
00:06:28,730 --> 00:06:32,750
一次代表四个位的完美系统。
a perfect system for representing four bits at a time.

118
00:06:32,750 --> 00:06:36,980
毕竟，如果这里有四个位，每个位可以是0或1，
After all, if you've got four bits here, each of which can be a 0 or 1,

119
00:06:36,980 --> 00:06:42,020
分别是2乘2乘2乘2的可能值，
that's 2 times 2 times 2 times 2 possible values for each of those,

120
00:06:42,019 --> 00:06:45,739
或16个总值，也就是说，在计算机世界中，
or 16 total values, which is to say that in the world of computers,

121
00:06:45,740 --> 00:06:48,560
如果您想以四位为单位说话，
if you ever want to talk in units of four bits,

122
00:06:48,560 --> 00:06:51,590
改用十六进制非常方便，
it's wonderfully convenient to use hexadecimal instead,

123
00:06:51,589 --> 00:06:56,269
只是因为方便地，一个十六进制数字恰好是
only because, conveniently, one hexadecimal digit happens to be

124
00:06:56,269 --> 00:07:00,589
等效于四个二进制数字，0和1。
equivalent to four binary digits, 0's and 1's.

125
00:07:00,589 --> 00:07:05,159
所以0，0，0，0一直到1，1，1，1。
So 0, 0, 0, 0, all the way up through 1, 1, 1, 1.

126
00:07:05,160 --> 00:07:06,320
那么为什么人类要这样做呢？
So why do humans do this?

127
00:07:06,319 --> 00:07:09,239
正是由于这种便利，这才是人类的惯例。
It's just now the human convention because of that convenience.

128
00:07:09,240 --> 00:07:11,760
现在，你们中的某些人可能很早以前就看到过十六进制。
Now, some of you may very well have seen hexadecimal before.

129
00:07:11,759 --> 00:07:14,659
实际上，回想一下我们在RGB第0周的讨论，
In fact, recall our discussion in week 0 of RGB,

130
00:07:14,660 --> 00:07:17,660
我们讨论了使用
where we discussed the representation of colors using

131
00:07:17,660 --> 00:07:19,860
一定数量的红色，绿色和蓝色。
some amount of red, green, and blue.

132
00:07:19,860 --> 00:07:21,720
当时，我们使用了这个示例。
And at the time, we used this example.

133
00:07:21,720 --> 00:07:24,080
我们从上下文中拿出了我们的例子。
We took our example out of context.

134
00:07:24,079 --> 00:07:27,559
而不是使用hi作为文本字符串，
And instead of using hi as a string of text,

135
00:07:27,560 --> 00:07:33,410
我们将72、73和33重新解释为一系列颜色。
we reinterpreted 72, 73, and 33 as a sequence of colors.

136
00:07:33,410 --> 00:07:34,550
你要多少红色？
How much red do you want?

137
00:07:34,550 --> 00:07:35,720
您要多少绿色？
How much green do you want?

138
00:07:35,720 --> 00:07:36,860
你想要多少蓝色？
How much blue do you want?

139
00:07:36,860 --> 00:07:37,820
很好。
And that's fine.

140
00:07:37,819 --> 00:07:41,059
用小数表示和表达自己的观点是非常好的。
It's perfectly fine to think and express yourself in terms of decimal.

141
00:07:41,060 --> 00:07:44,270
但是计算机科学家往往不会在色彩环境中那样做
But computer scientists tend not to do it that way in the context of colors

142
00:07:44,269 --> 00:07:45,789
并在记忆的背景下。
and in the context of memory.

143
00:07:45,790 --> 00:07:49,160
取而代之的是，他们倾向于使用一种称为十六进制的东西。
Instead, they tend to use something called hexadecimal.

144
00:07:49,160 --> 00:07:51,590
在这里，十六进制实际上只是
And hexadecimal, here, would actually just

145
00:07:51,589 --> 00:07:57,859
您是否将这些值从72、73、33更改为等效的十六进制
have you change these values from 72, 73, 33, to the equivalent hexadecimal

146
00:07:57,860 --> 00:07:58,533
表示。
representation.

147
00:07:58,533 --> 00:08:00,200
而且我们不会在这里进行数学运算。
And we won't bother doing the math here.

148
00:08:00,199 --> 00:08:04,339
但我只规定十进制为72、73、33
But let me just stipulate that 72, 73, 33 in decimal

149
00:08:04,339 --> 00:08:10,261
与十六进制的48、49、21相同。
is the same thing as 48, 49, 21 in hexadecimal.

150
00:08:10,262 --> 00:08:12,470
现在，很明显，如果您看一下这三个数字，
Now, obviously, if you glance at these three numbers,

151
00:08:12,470 --> 00:08:15,980
如果您要查看十六进制数字，这一点都不明显
it's not at all obvious if you're looking at hexadecimal digits

152
00:08:15,980 --> 00:08:21,080
或十进制数字，因为它们确实使用相同的子集，即0到9。
or decimal digits, because they do use the same subset, 0's through 9's.

153
00:08:21,079 --> 00:08:23,239
因此，在计算机世界中，惯例也是如此
And so a convention, too, in the computing world,

154
00:08:23,240 --> 00:08:25,850
每当您代表十六进制数字时，
is any time you represent hexadecimal digits,

155
00:08:25,850 --> 00:08:29,300
您通常会以0x作为前缀。
you tend to prefix them, just because, with 0x.

156
00:08:29,300 --> 00:08:32,179
而且0或x没有数学意义。
And there's no mathematical meaning to the 0 or the x.

157
00:08:32,178 --> 00:08:35,418
它只是您放置在此处以使观众清楚看到的前缀
It's just a prefix you put there to make clear to the viewer

158
00:08:35,418 --> 00:08:38,298
即使它们可能是十六进制数字
that these are hexadecimal digits, even if they might otherwise

159
00:08:38,298 --> 00:08:40,489
看起来像十进制数字。
look like decimal digits.

160
00:08:40,490 --> 00:08:41,940
那么我们要去哪里呢？
So where are we going with this?

161
00:08:41,940 --> 00:08:43,857
好吧，那些可能已经尝试过的人
Well, those of you who might have experimented

162
00:08:43,856 --> 00:08:46,849
过去制作自己的网页并使它们色彩丰富，
in the past with making your own web pages and making them colorful,

163
00:08:46,850 --> 00:08:50,450
或那些曾经使用过Photoshop等程序的艺术家
or those of you who are artists and have used programs like Photoshop, odds

164
00:08:50,450 --> 00:08:53,190
是，您之前已经看过这些代码。
are, you've seen these codes before.

165
00:08:53,190 --> 00:08:55,940
实际上，这里有一些Photoshop本身的屏幕截图。
In fact, here are a few screenshots of Photoshop itself.

166
00:08:55,940 --> 00:08:59,190
如果您在Photoshop中单击一种颜色，然后打开此窗口，
If you click on a color in Photoshop and you pull up this window,

167
00:08:59,190 --> 00:09:02,300
您可以更改屏幕上绘制的颜色
you can change the color that you're drawing on the screen

168
00:09:02,299 --> 00:09:04,969
成为彩虹的任何颜色。
to be any of the colors of the rainbow.

169
00:09:04,970 --> 00:09:07,470
但更不可思议的是，如果您低头看这里，
But more arcanely, if you look down here,

170
00:09:07,470 --> 00:09:09,620
您实际上可以看到这些十六进制代码，
you can actually see these hexadecimal codes,

171
00:09:09,620 --> 00:09:11,990
因为多年来已经成为人类的惯例
because it's become human convention over the years

172
00:09:11,990 --> 00:09:15,630
使用十六进制表示不同数量的红色，绿色，
to use hexadecimal to represent different amounts of red, green,

173
00:09:15,629 --> 00:09:16,319
和蓝色。
and blue.

174
00:09:16,320 --> 00:09:23,435
因此，如果您没有红色，没有绿色，没有蓝色，否则表示为000000，
So if you have no red, no green, no blue, otherwise represented as 000000,

175
00:09:23,434 --> 00:09:26,059
好吧，这将为您提供我们在这里称为黑色的颜色。
well, that's going to give you the color we know here as black.

176
00:09:26,059 --> 00:09:29,509
那里没有任何波长的光。
It's sort of the absence of any wavelengths of light there.

177
00:09:29,509 --> 00:09:33,469
相比之下，如果您将所有这六位数字都更改了
If by contrast, though, you change all of those six digits

178
00:09:33,470 --> 00:09:38,810
到最大可能的值，再次是F。十六进制的范围0
to the highest possible value, which, again, is F. The range in hexadecimal 0

179
00:09:38,809 --> 00:09:42,889
到F，否则为十进制，从0到15，好吧，
through F, otherwise in decimal, being 0 through 15, well,

180
00:09:42,889 --> 00:09:46,799
FFFFFF就是很多红色，很多绿色，很多蓝色。
with FFFFFF, that's a lot of red, a lot of green, a lot of blue.

181
00:09:46,799 --> 00:09:48,799
当您组合这些波长的光时，
And when you combine those wavelengths of light,

182
00:09:48,799 --> 00:09:51,199
您会看到我们在这里看到的白色。
you get the color we see here as white.

183
00:09:51,200 --> 00:09:53,480
您可以想像，现在，将不同数量的
And you can imagine, now, combining different amounts

184
00:09:53,480 --> 00:09:54,930
红色，绿色或蓝色。
of red or green or blue.

185
00:09:54,929 --> 00:10:00,739
因此，例如，十六进制FF0000是我们称为红色的颜色。
So for instance, in hexadecimal, FF0000, is the color we know as red.

186
00:10:00,740 --> 00:10:05,270
00FF00是我们称为绿色的颜色。
00FF00 is the color we know as green.

187
00:10:05,269 --> 00:10:09,629
最后，0000FF是我们称为蓝色的颜色，因为同样，
And finally, 0000FF is the color we know as blue, because again,

188
00:10:09,629 --> 00:10:14,239
程序员和美工经常但不总是使用的系统确实是，
the system that programmers and artists often but don't always use, is indeed,

189
00:10:14,240 --> 00:10:17,710
此RGB系统用于红色，绿色和蓝色。
this system of RGB for red, green, and blue.

190
00:10:17,710 --> 00:10:19,460
所以我们在这里介绍这个不是因为你
So we introduced this here not because you

191
00:10:19,460 --> 00:10:21,810
必须开始以不同的方式思考，因为再次，
have to start thinking any differently, because again,

192
00:10:21,809 --> 00:10:24,559
数学机制与第0周相同。
the mathematical mechanism is the same as week 0.

193
00:10:24,559 --> 00:10:28,969
但是您将开始在示例，程序中看到数字，
But you're going to start seeing numbers in examples, in programs,

194
00:10:28,970 --> 00:10:32,900
只是按照惯例以十六进制显示，而不是
as just appearing in hexadecimal by convention, as opposed to actually

195
00:10:32,899 --> 00:10:35,549
被解释为十进制。
being interpreted as decimal.

196
00:10:35,549 --> 00:10:37,879
因此，如果现在考虑计算机的内存，
So if we consider, now, our computer's memory,

197
00:10:37,879 --> 00:10:40,609
现在，我们将开始考虑整个内存范围，
we'll now start thinking of this whole canvas of memory,

198
00:10:40,610 --> 00:10:43,010
所有这些字节都在我们计算机的内存中，
all of these bytes inside of our computer's memory,

199
00:10:43,009 --> 00:10:46,699
一直到F都是无数的0、1、2。
as being innumerable as 0, 1, 2, all the way through F.

200
00:10:46,700 --> 00:10:53,750
然后如果继续计数，我们可以转到10、11、12、13、14、15、16、17、18，
And then if we keep counting, we can go to 10, 11, 12, 13, 14, 15, 16, 17, 18,

201
00:10:53,750 --> 00:10:58,849
19、1A，1B，1C，1D等。
19, 1A, 1B, 1C, 1D, and so forth.

202
00:10:58,850 --> 00:11:00,790
如果不是那么明显就很好，
And it's fine if it's not nearly that obvious,

203
00:11:00,789 --> 00:11:03,669
当您查看这些内容时，十进制等效项是什么。
as you look at these things, what the decimal equivalents are.

204
00:11:03,669 --> 00:11:04,689
那不是问题。
That's not a problem.

205
00:11:04,690 --> 00:11:09,130
在这种情况下，这只是一种不同的思考位置的方式，
It's just a different way of thinking about the locations, in this case,

206
00:11:09,129 --> 00:11:13,479
计算机内存或一种颜色或另一种颜色的表示形式。
of a computer's memory, or the representation of one color or another.

207
00:11:13,480 --> 00:11:19,480
好吧，现在让我们以此为契机，
All right, well, let's now use this as an example of an opportunity,

208
00:11:19,480 --> 00:11:22,690
而是考虑实际存储在我们计算机内存中的内容。
rather, to consider what's actually being stored in our computer's memory.

209
00:11:22,690 --> 00:11:26,320
而且要明确的是，我将开始为所有这些内存地址添加前缀，
And to be clear, I'll start prefixing all of these memory addresses,

210
00:11:26,320 --> 00:11:29,890
可以这么说，使用0x只是为了表明我们现在正在谈论
so to speak, with 0x, just to make clear that we're now talking, indeed,

211
00:11:29,889 --> 00:11:31,479
以0和1表示。
in terms of 0's and 1's.

212
00:11:31,480 --> 00:11:32,980
因此，这是一条简单的代码行。
So here's a simple line of code.

213
00:11:32,980 --> 00:11:35,147
脱离上下文，我们实际上需要把这个
Out of context, we would need to, actually, put this

214
00:11:35,147 --> 00:11:37,910
在主程序或其他程序中实际上可以执行任何操作。
in main or some other program to actually do anything with it.

215
00:11:37,909 --> 00:11:39,701
但是我们现在已经看过很多次了
But we've seen this before many times, now,

216
00:11:39,701 --> 00:11:42,759
在其中声明变量的位置，例如，n代表数字。
where you declare a variable, for instance, n for number.

217
00:11:42,759 --> 00:11:44,829
声明它作为其类型的int。
Declare it as an int for its type.

218
00:11:44,830 --> 00:11:47,170
然后，甚至可以为其分配一个值。
And then, perhaps, even assign it a value.

219
00:11:47,169 --> 00:11:51,519
好吧，当我们在计算机中使用这种代码时，实际发生了什么？
Well, what's actually going on when we use this kind of code in our computer?

220
00:11:51,519 --> 00:11:54,759
好吧，让我们继续前进，并在实际程序中鞭打一下。
Well, let's go ahead and whip this thing up in a actual program.

221
00:11:54,759 --> 00:11:57,969
让我创建一个名为address.c的文件，因为我
Let me create a file called address.c because I

222
00:11:57,970 --> 00:12:01,300
想开始尝试使用计算机内存中的某些地址。
want to start experimenting with some addresses in the computer's memory.

223
00:12:01,299 --> 00:12:04,179
我将继续介绍标准io点h。
I'm going to go ahead and include standard io dot h.

224
00:12:04,179 --> 00:12:06,459
我要给自己诠释主要的虚无。
I'm going to give myself int main void.

225
00:12:06,460 --> 00:12:08,890
在这里，我将继续进行声明
And down here, I'm going to go ahead and declare exactly

226
00:12:08,889 --> 00:12:10,914
该变量int n等于50。
that variable, int n equals 50.

227
00:12:10,914 --> 00:12:15,819
然后我将继续打印并输出百分比i和反斜杠0，
And then I'm going to go ahead and print out, with percent i and a backslash 0,

228
00:12:15,820 --> 00:12:17,230
n的值
the value of n.

229
00:12:17,230 --> 00:12:19,930
因此，那里没有什么有趣的，也没有太复杂的。
So nothing interesting there, nothing too complicated.

230
00:12:19,929 --> 00:12:21,789
我将继续致辞。
I'm going to go ahead and make address.

231
00:12:21,789 --> 00:12:24,122
然后，我将继续执行点斜杠地址。
And then I'm going to go ahead and do dot slash address.

232
00:12:24,123 --> 00:12:26,380
当然，就第一周而言，我们希望
And of course, as per week one, we should hopefully

233
00:12:26,379 --> 00:12:27,929
只能看到数字50。
see just the number 50.

234
00:12:27,929 --> 00:12:31,569
但是今天，我们将为您提供更多工具，使您可以实际使用
But today, we're going to give you some more tools with which you can actually

235
00:12:31,570 --> 00:12:33,880
开始四处查看计算机的内存。
start poking around your computer's memory.

236
00:12:33,879 --> 00:12:35,949
但首先让我们考虑一下这行代码
But let's first consider this line of code

237
00:12:35,950 --> 00:12:38,240
在计算机硬件环境中。
in the context of your computer's hardware.

238
00:12:38,240 --> 00:12:41,200
因此，如果您使用这样的代码编写程序，
So if you're writing a program with a line of code like this,

239
00:12:41,200 --> 00:12:44,500
n必须位于计算机内存中的某个位置。
that n needs to be somewhere in your computer's memory.

240
00:12:44,500 --> 00:12:47,870
那50个需要放在计算机内存中的某个位置。
That 50 needs to be put somewhere in your computer's memory.

241
00:12:47,870 --> 00:12:51,010
因此，如果我们再次认为这只是我们计算机的一部分
So if we, again, consider this to be just part of our computer's

242
00:12:51,009 --> 00:12:54,999
内存，几十个字节，假设那个变量n
memory, a few dozen bytes, well, suppose that that variable, n,

243
00:12:55,000 --> 00:12:57,129
恰好在这里结束。
happens to end up down here.

244
00:12:57,129 --> 00:13:01,569
我故意将n表示为占用四个字节，四个正方形，因为我们
I've deliberately drawn n as taking up four bytes, four squares, because we

245
00:13:01,570 --> 00:13:05,830
至少在CS50 IDE和现代系统上通常都将其称为整数，
call that an integer, typically, at least on CS50 IDE and modern systems,

246
00:13:05,830 --> 00:13:07,370
往往是四个字节。
tends to be four bytes.

247
00:13:07,370 --> 00:13:10,630
因此，我确保将其填满四个完整的框。
So I made sure to have it fill four complete boxes.

248
00:13:10,629 --> 00:13:13,939
然后可能实际存储在其中的值为50。
And then value might be 50 that's actually stored there.

249
00:13:13,940 --> 00:13:17,890
好吧，事实证明，在您的计算机内存中，
Well, it turns out that within your computer's memory, again,

250
00:13:17,889 --> 00:13:20,659
这些地址隐式存在。
there are these addresses that are implicitly there.

251
00:13:20,659 --> 00:13:23,529
因此，即使可以，我们也可以引用此变量n
So even though, yes, we can refer to this variable, n,

252
00:13:23,529 --> 00:13:26,619
根据我在代码中给它的变量名，
based on the variable name I gave it in my code,

253
00:13:26,620 --> 00:13:30,940
当然，此变量存在于内存中的特定位置。
surely this variable exists at a specific location in memory.

254
00:13:30,940 --> 00:13:32,530
我不知道它在哪里。
I don't know offhand where it is.

255
00:13:32,529 --> 00:13:38,409
但让我建议也许是在位置0x12345678上，
But let me just propose that maybe it's at location 0x12345678, just

256
00:13:38,409 --> 00:13:39,549
任意地址。
an arbitrary address.

257
00:13:39,549 --> 00:13:41,689
实际上，我不知道它在哪里。
I have no idea, in actuality, where it is.

258
00:13:41,690 --> 00:13:44,860
但它确实有地址，因为这些方块中的每个方块
But it certainly does have an address, because every one of these squares

259
00:13:44,860 --> 00:13:49,540
计算机内存中有一个地址，一个唯一的标识符，例如0、1
inside of your computer's memory has an address, a unique identifier like 0, 1,

260
00:13:49,539 --> 00:13:50,749
2，依此类推。
2, and so forth.

261
00:13:50,750 --> 00:13:56,709
也许50结束于内存地址0x12345678。
Maybe the 50 ended up at memory address 0x12345678.

262
00:13:56,710 --> 00:14:01,750
好吧，这对C来说很酷，因为我们实际上可以开始看到这一点，
Well, that's kind of cool about C, is that we can actually begin to see this,

263
00:14:01,750 --> 00:14:03,020
无双关语。
no pun intended.

264
00:14:03,019 --> 00:14:05,079
所以让我继续修改该程序
So let me go ahead and modify this program

265
00:14:05,080 --> 00:14:07,480
并介绍一些新的语法
and introduce a little bit of new syntax that

266
00:14:07,480 --> 00:14:11,510
将使我们能够开始在您的计算机内存中四处张望
will allow us to start poking around the inside of your computer's memory

267
00:14:11,509 --> 00:14:14,829
这样我们就可以实际看到其下发生了什么。
so we can actually see what's going on underneath.

268
00:14:14,830 --> 00:14:17,710
因此，我将继续更改该程序以代替执行此操作。
So I'm going to go ahead and change this program to do this instead.

269
00:14:17,710 --> 00:14:19,585
我要说，你知道吗？
I'm going to go ahead and say, you know what?

270
00:14:19,585 --> 00:14:23,590
不要只打印出值n，它当然是50。
Don't just print out the value, n, which, of course, is 50.

271
00:14:23,590 --> 00:14:28,060
出于好奇，让我看看n的实际地址是多少。
Let me see, just out of curiosity, what is the actual address of n.

272
00:14:28,059 --> 00:14:31,299
今天要做的是，我们将介绍一种新的语法，
And to do that today, we're going to introduce one new piece of syntax,

273
00:14:31,299 --> 00:14:33,069
这恰好是这里。
which happens to be this here.

274
00:14:33,070 --> 00:14:37,360
今天，在C中有两个新的运算符。第一个是＆符，
There's two new operators, today, in C. The first is an ampersand, which

275
00:14:37,360 --> 00:14:39,580
不代表逻辑与。
does not represent a logical and.

276
00:14:39,580 --> 00:14:42,100
回想一下几周前，我们确实发现，如果您
Recall a couple of weeks ago, we did see that if you

277
00:14:42,100 --> 00:14:46,840
想要结合布尔表达式，this和that，您使用两个＆符。
want to combine Boolean expressions, this and that, you use two ampersands.

278
00:14:46,840 --> 00:14:51,040
不幸的巧合是，这样的独奏“＆”号，
It's an unfortunate coincidence that an ampersand, solo like this,

279
00:14:51,039 --> 00:14:52,629
今天的意义会有所不同。
will mean something different today.

280
00:14:52,629 --> 00:14:56,829
具体来说，此“＆”号将成为我们操作员的地址。
Specifically, this ampersand is going to be our address of operator.

281
00:14:56,830 --> 00:15:02,590
只要在任何变数名称前加上与号，就可以告诉C，
By simply prefixing any variable name with an ampersand, we can tell C,

282
00:15:02,590 --> 00:15:06,520
请告诉我此变量存储在哪个地址。
please tell me what address this variable is stored in.

283
00:15:06,519 --> 00:15:10,179
这颗星，不要与乘法相混淆，
And this star, not to be confused with multiplication,

284
00:15:10,179 --> 00:15:12,879
在今天的背景下也具有另一种含义。
also has another meaning in today's context.

285
00:15:12,879 --> 00:15:15,309
当您使用此星号时，您实际上可以
When you use this asterisk, you can actually

286
00:15:15,309 --> 00:15:19,909
告诉您的程序在特定的内存地址中查找。
tell your program to look inside of a particular memory address.

287
00:15:19,909 --> 00:15:23,499
因此，“＆”号会告诉您变量位于什么地址。
So the ampersand tells you what address a variable is at.

288
00:15:23,500 --> 00:15:27,310
星号运算符，也称为解引用运算符，
The star operator, otherwise known as the dereference operator,

289
00:15:27,309 --> 00:15:30,189
意思是，转到以下地址。
means, go to the following address.

290
00:15:30,190 --> 00:15:32,050
因此，它们属于反向操作。
So they sort of are reverse operations.

291
00:15:32,049 --> 00:15:33,399
一个人弄清楚地址。
One figures out the address.

292
00:15:33,399 --> 00:15:35,239
一个去地址。
One goes to the address.

293
00:15:35,240 --> 00:15:37,850
因此，让我们在这里真正看到它。
And so let's see this for real here.

294
00:15:37,850 --> 00:15:43,070
让我继续并将此处的程序中的n更改为＆符。
Let me go ahead and change my n in my program here to ampersand n.

295
00:15:43,070 --> 00:15:48,980
所以我想打印出的不是n中的数字，而是n的地址。
So I want to print out, not the number in n, but the address of n.

296
00:15:48,980 --> 00:15:50,870
现在，如何打印地址？
And now, how do I print out an address?

297
00:15:50,870 --> 00:15:52,170
好吧，这只是一个数字。
Well, it is just a number.

298
00:15:52,169 --> 00:15:56,689
但实际上，printf支持地址的不同格式代码。
But actually, printf supports a different format code for addresses.

299
00:15:56,690 --> 00:15:59,840
您可以执行百分比p，出于我们很快就会看到的原因，
You can do percent p, for reasons we'll soon see,

300
00:15:59,840 --> 00:16:02,510
那说打印出这个变量的地址
that says to print out the address of this variable

301
00:16:02,509 --> 00:16:05,374
并再次按照惯例将其解释为十六进制。
and interpret it as hexadecimal, again, by convention.

302
00:16:05,375 --> 00:16:07,250
所以我现在继续做地址
So I'm going to go ahead and make address now

303
00:16:07,250 --> 00:16:10,529
仅对该文件进行两次更改之后。
after only making two changes to this file.

304
00:16:10,529 --> 00:16:12,349
一切似乎都可以编译。
Everything seems to compile OK.

305
00:16:12,350 --> 00:16:14,150
现在，我要继续运行地址。
Now, I'm going to go ahead and run address.

306
00:16:14,149 --> 00:16:17,209
我们将看到，在这个特定程序中，
And we will see that, in this particular program,

307
00:16:17,210 --> 00:16:21,620
address.c，无论出于何种原因，该变量n
address.c, for whatever reason, that variable, n,

308
00:16:21,620 --> 00:16:30,110
最终到达疯狂的位置0x7ffd80792f7c。
ended up at crazy location 0x7ffd80792f7c.

309
00:16:30,110 --> 00:16:31,160
现在，这有用吗？
Now, is that useful?

310
00:16:31,159 --> 00:16:32,869
不一定是实际中的。
Not in practice, necessarily.

311
00:16:32,870 --> 00:16:36,530
我们将通过利用这些地址来使其变得有用。
We're going to make this become useful by leveraging these addresses.

312
00:16:36,529 --> 00:16:38,899
但是具体地址并不有趣。
But the specific address is not interesting.

313
00:16:38,899 --> 00:16:40,069
我瞥了一眼这个数字。
I'm glancing at this number.

314
00:16:40,070 --> 00:16:41,993
我不知道那个数字是十进制。
I have no idea what that number is in decimal.

315
00:16:41,993 --> 00:16:44,660
我得算一下，或者坦率地说，只是谷歌一个转换器
I would have to do the math, or frankly, just Google a converter

316
00:16:44,659 --> 00:16:45,659
为我做
and do it for me.

317
00:16:45,659 --> 00:16:47,419
再说一遍，这不是有趣的部分。
So again, that's not the interesting part.

318
00:16:47,419 --> 00:16:50,419
这是十六进制的事实只是一个实现细节。
The fact that this is in hexadecimal is just an implementation detail.

319
00:16:50,419 --> 00:16:54,449
它恰好代表此变量的位置。
It happens to represent the location of this variable.

320
00:16:54,450 --> 00:16:58,230
再说一次，我们不一定要这样做。
And again, we won't want to do this, necessarily.

321
00:16:58,230 --> 00:17:00,830
但是要明确一点，这些运算符之一
But just to be clear that one of these operators,

322
00:17:00,830 --> 00:17:02,330
“＆”号获取地址。
the ampersand gets the address.

323
00:17:02,330 --> 00:17:05,089
然后星级经营者去一个地址。
And the star operator goes to an address.

324
00:17:05,088 --> 00:17:07,159
实际上，我们可以消除这些影响。
We can actually undo the effects of these things.

325
00:17:07,160 --> 00:17:13,010
举例来说，如果我现在打印出来的不是“＆”号，而是出于好奇，
For instance, if I print out now, not ampersand n, but just out of curiosity,

326
00:17:13,009 --> 00:17:18,169
星号＆符，我可以消除此运算符的影响。
star ampersand n, I can kind of undo the effects of this operator.

327
00:17:18,170 --> 00:17:21,170
“＆”号要说的是，n的地址是什么？
Ampersand n is going to say, what is the address of n?

328
00:17:21,170 --> 00:17:25,349
星号“＆”号要说的是，去那个地址。
Star ampersand n is going to say, go to that address.

329
00:17:25,348 --> 00:17:29,359
所以这是没有意义的练习，因为如果我只想要n中的值，
So this is kind of a pointless exercise, because if I just want what's in n,

330
00:17:29,359 --> 00:17:32,119
很显然，我可以像我们开始那样打印n。
I can just, obviously, print n like we began.

331
00:17:32,119 --> 00:17:34,559
但是同样，作为一项智力练习，
But again, just as an intellectual exercise,

332
00:17:34,559 --> 00:17:38,749
如果我在n前面加上运算符的地址，然后使用星号
if I prefix n with the address of operator, and then use the asterisk

333
00:17:38,750 --> 00:17:42,830
说，去那个地址，是一样的东西
and say, go to that address, it's the same exact thing

334
00:17:42,829 --> 00:17:44,279
就像打印n本身一样。
as just printing n itself.

335
00:17:44,279 --> 00:17:46,639
因此，让我将格式代码改回整数。
So let me change the format code back to an integer.

336
00:17:46,640 --> 00:17:50,060
取而代之的是百分比p，让我继续进行发言，
Instead percent p, let me go ahead and make address now,

337
00:17:50,059 --> 00:17:52,099
似乎编译OK，并运行地址。
seems to compile OK, and run address.

338
00:17:52,099 --> 00:17:53,884
瞧，我们又回到了50岁。
And voila, we're back at the 50.

339
00:17:53,884 --> 00:17:57,049
因此，就像今天的语法可能会令人感到奇怪一样，
So as weird as the syntax today might start to feel,

340
00:17:57,049 --> 00:17:59,329
意识到这些运营商在一天结束时，
realize that these operators, at the end of the day,

341
00:17:59,329 --> 00:18:01,832
他们的工作相对简单。
are relatively simple in what they do.

342
00:18:01,833 --> 00:18:05,000
而且，如果您了解一种只是抵消了另一种的影响，
And if you understand that one just kind of undoes the effects of the other,

343
00:18:05,000 --> 00:18:08,359
我们可以开始与他们建立一些非常有趣的程序吗？
can we start to build up some pretty interesting programs with them.

344
00:18:08,359 --> 00:18:11,869
我们将通过利用一种特殊类型的变量来做到这一点，
And we're going to do so by leveraging a special type of variable,

345
00:18:11,869 --> 00:18:13,909
一个称为指针的变量。
a variable called a pointer.

346
00:18:13,910 --> 00:18:16,670
并且存在以百分比p表示的p。
And there is that p in percent p.

347
00:18:16,670 --> 00:18:22,240
指针是一个包含其他值的地址的变量。
A pointer is a variable that contains the address of some other value.

348
00:18:22,240 --> 00:18:23,790
因此，我们之前已经看过整数。
So we've seen integers before.

349
00:18:23,789 --> 00:18:27,769
我们也见过浮点数，字符，字符串和其他类型。
We've seen floats and chars and strings and other types as well.

350
00:18:27,769 --> 00:18:31,429
现在，指针只是变量的另一种类型
Pointers, now, are just a different type of variable

351
00:18:31,430 --> 00:18:34,640
存储一些值的地址。
that store the address of some value.

352
00:18:34,640 --> 00:18:40,250
您可以使用指向整数的指针，指向chars的指针，指向bool的指针，
And you can have pointers to integers, pointers to chars, pointers to bools,

353
00:18:40,250 --> 00:18:41,870
或任何其他数据类型。
or any other data type.

354
00:18:41,869 --> 00:18:45,979
指针引用值的特定类型
A pointer references the specific type of the value

355
00:18:45,980 --> 00:18:48,223
它实际上指的是。
that it actually is referring to.

356
00:18:48,222 --> 00:18:49,639
因此，让我们更具体地看一下。
So let's see this more concretely.

357
00:18:49,640 --> 00:18:51,620
现在，让我回到这里的程序。
Let me go back, now, to my program here.

358
00:18:51,619 --> 00:18:53,839
让我在这里介绍另一个变量。
And let me introduce another variable here.

359
00:18:53,839 --> 00:18:58,429
让我继续打印，而不是立即打印出类似n的内容
Instead of immediately printing out something like n, let me go ahead

360
00:18:58,430 --> 00:19:02,870
并引入第二个类型为int star的变量。
and introduce a second variable that is of type int star.

361
00:19:02,869 --> 00:19:06,859
我承认，这可能是最令人困惑的C语法
And this, I will admit, is probably the most confusing piece of C syntax

362
00:19:06,859 --> 00:19:09,859
我们通常会看到，只是因为，我的天，星现在
that we'll, in general, see, just because, my god, star is now

363
00:19:09,859 --> 00:19:13,219
用于乘法，去地址，以及现在
used for multiplication, for going to an address, and also, now,

364
00:19:13,220 --> 00:19:14,610
声明一个变量。
declaring a variable.

365
00:19:14,609 --> 00:19:17,119
可以说，这不是最佳的设计决策。
This is, arguably, not the best design decision.

366
00:19:17,119 --> 00:19:18,349
但是它是几十年前制成的。
But it was made decades ago.

367
00:19:18,349 --> 00:19:19,729
这就是我们所拥有的。
So this is what we have.

368
00:19:19,730 --> 00:19:26,240
但是，如果我做int star p等于和号n，那么我现在可以做些什么，
But if I do int star p equals ampersand n, now, what I can do down here,

369
00:19:26,240 --> 00:19:31,770
通过将n的地址临时存储在变量中来打印出n的地址。
is print out the address of n by temporarily storing it in a variable.

370
00:19:31,769 --> 00:19:33,829
所以我现在还没有做任何新的事情。
So I'm not doing anything new just yet.

371
00:19:33,829 --> 00:19:36,019
我仍在第5行声明一个整数
I'm still declaring on line 5, an integer

372
00:19:36,019 --> 00:19:37,909
称为n，分配值为50。
called n, assigning at the value 50.

373
00:19:37,910 --> 00:19:42,260
现在第6行的新功能是，我正在引入一种新型的变量。
What's new now on line 6, is that I'm introducing a new type of variable.

374
00:19:42,259 --> 00:19:44,209
这种类型的变量称为指针。
This type of variable is known as a pointer.

375
00:19:44,210 --> 00:19:48,410
同样，指针只是一个存储某个值的地址的变量。
A pointer, again, is just a variable that stores the address of some value.

376
00:19:48,410 --> 00:19:53,240
而且，语法很奇怪，它声明了一个指向整数的指针，
And the syntax, admittedly weird, for declaring a pointer to an integer,

377
00:19:53,240 --> 00:19:57,560
字面意思是int，因为这就是您要指向的类型，
is literally say int, because that's the type you're pointing to,

378
00:19:57,559 --> 00:20:00,349
星号，然后是您要创建的变量的名称。
star, and then the name of the variable you want to create.

379
00:20:00,349 --> 00:20:03,319
我可以称呼它为任何东西，但为了保持简洁，我将其称为p。
And I could call this anything, but I'll call it p to keep it succinct.

380
00:20:03,319 --> 00:20:05,119
再一次，在等号的右侧
And again, on the right hand side of the equals sign

381
00:20:05,119 --> 00:20:06,619
与以前的运算符相同。
is the same operator as before.

382
00:20:06,619 --> 00:20:10,039
如果要弄清楚n的地址是什么，它就是＆符号。
If you want to figure out what is the address of n, it's just ampersand n.

383
00:20:10,039 --> 00:20:14,449
因此，我们现在可以将该地址长期存储。
And so we can store that address, now, somewhere longer-term.

384
00:20:14,450 --> 00:20:18,110
以前，我只是传入＆符n，而printf就是这样。
Before, I just passed in ampersand n and printf did it's thing.

385
00:20:18,109 --> 00:20:23,119
现在，我暂时在第6行上，将该地址存储在一个新变量中
Now, I'm temporarily, on line 6, storing that address in a new variable

386
00:20:23,119 --> 00:20:24,469
称为p。
called p.

387
00:20:24,470 --> 00:20:28,910
从技术上讲，它的类型是int star，这是程序员可能会说的。
And its type is technically int star, is what a programmer might say.

388
00:20:28,910 --> 00:20:33,680
因此，说int p等于“＆”号是不正确的。
So it would be incorrect to say int p equals ampersand n.

389
00:20:33,680 --> 00:20:35,780
确实，我们的编译器Clang不会那样。
And indeed, our compiler, Clang, won't like that.

390
00:20:35,779 --> 00:20:38,369
它很可能不会让您编译代码。
It won't let you compile the code, most likely.

391
00:20:38,369 --> 00:20:43,159
因此，相反，我做int star p来表明我知道自己在做什么。
And so, instead, I do int star p to make clear that I know what I'm doing.

392
00:20:43,160 --> 00:20:48,450
我说的是存储一个int的地址，而不是一个整数。
I am storing the address of an int, not an integer, per say.

393
00:20:48,450 --> 00:20:53,040
因此，如果我现在继续保存，请使用make地址重新编译。
So if I go ahead, now, and save this, recompile with make address.

394
00:20:53,039 --> 00:20:55,529
请注意，我之前更改了代码2的一行。
And notice, I changed one line of code 2 earlier.

395
00:20:55,529 --> 00:20:59,399
我回到百分比p打印一个指针，该指针是一个地址。
I went back to percent p to print a pointer that is an address.

396
00:20:59,400 --> 00:21:02,490
我指出的是p的值，不再是n的值。
And I'm pointing out the value of p, no longer the value of n.

397
00:21:02,490 --> 00:21:07,050
如果我现在运行点斜杠地址，瞧，那是个隐秘的地址。
If I now run dot slash address, voila, there's that cryptic address.

398
00:21:07,049 --> 00:21:09,299
这些地址很可能会随着时间而改变。
And these addresses may very well change over time.

399
00:21:09,299 --> 00:21:11,639
根据程序内部发生的情况
Depending on what's going on inside of your program

400
00:21:11,640 --> 00:21:15,390
或系统上的其他内容，这些地址每次都可能不同。
or other things on the system, these addresses might be different each time.

401
00:21:15,390 --> 00:21:18,060
这是可以预料的，而不是要依赖的东西。
And that's to be expected and not something to be relied on.

402
00:21:18,059 --> 00:21:20,249
但这显然是一些随机的秘密地址，
But it's clearly some random cryptic address,

403
00:21:20,250 --> 00:21:24,400
类似于我之前的任意0x12345678。
similar to my arbitrary 0x12345678 before.

404
00:21:24,400 --> 00:21:26,310
但是现在，让我们撤消此操作。
But now, let's just undo this operation.

405
00:21:26,309 --> 00:21:30,119
为了让我们可以围成一圈，现在让我提出建议
Just so we can come full circle here, let me now propose

406
00:21:30,119 --> 00:21:33,494
我如何打印n的值。
how I can print out the value of n.

407
00:21:33,494 --> 00:21:35,369
如果可以的话，让我请一个人这样做。
And let me call on someone for this if I can.

408
00:21:35,369 --> 00:21:41,639
如果我现在的目标是在第7行，不再打印n的地址，而是打印
If my goal, now, on line 7, is no longer to print the address of n, but to print

409
00:21:41,640 --> 00:21:43,972
n本身使用p。
n itself using p.

410
00:21:43,971 --> 00:21:45,929
我将继续前进，先发制人，
I'm going to go ahead and change, preemptively,

411
00:21:45,930 --> 00:21:47,820
格式代码为百分比i。
the format code to percent i.

412
00:21:47,819 --> 00:21:51,659
显然，速记符号只是print n。
And a shorthand notation would, obviously, be just print n.

413
00:21:51,660 --> 00:21:53,610
但是假设我不想为此打印n
But suppose I don't want to print n for this

414
00:21:53,609 --> 00:22:02,879
练习中，我现在如何通过使用p引用n中的值来打印它？
exercise, how can I now print the value in n by referring to it by way of p?

415
00:22:02,880 --> 00:22:05,910
我应该从字面上键入什么作为printf的第二个参数
What should I literally type as printf's second argument

416
00:22:05,910 --> 00:22:12,530
通过某种方式使用此新变量p打印n的值。
to print out the value of n by using this new variable, p, in some way.

417
00:22:12,529 --> 00:22:16,289
是的，让我们拜访约书亚。
Yeah, let's call on Joshua.

418
00:22:16,289 --> 00:22:19,859
听众：我相信，如果您在p之前使用＆号，
AUDIENCE: I believe, if you use the ampersand before the p,

419
00:22:19,859 --> 00:22:21,641
它可能会做到。
it will probably do it.

420
00:22:21,642 --> 00:22:24,100
大卫·马兰（David MALAN）：好的，“＆”号，让我继续尝试。
DAVID MALAN: OK, ampersand p, let me go ahead and try that.

421
00:22:24,099 --> 00:22:27,699
让我们尝试使用＆符号打印出该值。
Let's try ampersand p to print out this value.

422
00:22:27,700 --> 00:22:30,370
所以＆符p，我要保存文件。
So ampersand p, I'm going to save the file.

423
00:22:30,369 --> 00:22:32,609
我要做地址并输入。
I'm going to do make address and enter.

424
00:22:32,609 --> 00:22:34,414
事实并非如此。
And it doesn't seem to be the case.

425
00:22:34,414 --> 00:22:35,789
请注意，我遇到了错误。
Notice that I'm getting an error.

426
00:22:35,789 --> 00:22:36,719
这有点神秘。
It's a little cryptic.

427
00:22:36,720 --> 00:22:40,920
格式指定类型为int，但参数的类型为int star star，
Format specifies type int, but the argument has type int star star,

428
00:22:40,920 --> 00:22:42,090
再来一次。
more on that another time.

429
00:22:42,089 --> 00:22:43,569
因此，事实证明这是不正确的。
So it turns out this was incorrect.

430
00:22:43,569 --> 00:22:47,429
我们再提出一个建议，因为“＆”号，回想号，
Let's take one other suggestion, because the ampersand, recall,

431
00:22:47,430 --> 00:22:49,170
获取某物的地址。
gets the address of something.

432
00:22:49,170 --> 00:22:50,880
但是p已经是一个地址。
But p is already an address.

433
00:22:50,880 --> 00:22:52,590
因此，约书亚，您的技术建议是，
So Joshua, what you technically proposed,

434
00:22:52,589 --> 00:22:54,299
是给我地址的地址。
was get me the address of the address.

435
00:22:54,299 --> 00:22:56,189
那不是我们想要走的方向。
And that's not the direction we want to go.

436
00:22:56,190 --> 00:22:58,170
我们想去那个地址。
We want to go to what is at that address.

437
00:22:58,170 --> 00:23:00,740
索菲娅，你觉得呢？
Sophia, what do you think?

438
00:23:00,740 --> 00:23:02,640
观众：我们想增加一个百分比-
AUDIENCE: We want to add a percent--

439
00:23:02,640 --> 00:23:06,820
或在打印时加上星号p。
or a star p when we print it.

440
00:23:06,819 --> 00:23:07,569
戴维·马兰：是的。
DAVID MALAN: Yeah.

441
00:23:07,569 --> 00:23:09,379
所以听到你有点麻烦。
So I had a little trouble hearing you.

442
00:23:09,380 --> 00:23:12,370
但是我认为如果我们不使用＆运算符，
But I think if we instead use not the ampersand operator,

443
00:23:12,369 --> 00:23:14,709
但是明星经营者，
but the star operator, that's going to be,

444
00:23:14,710 --> 00:23:17,170
实际上，解引用运算符从本质上讲意味着
indeed, the dereference operator, which essentially means,

445
00:23:17,170 --> 00:23:19,120
转到p中的值。
go to the value in p.

446
00:23:19,119 --> 00:23:23,529
而且，如果p中的值是一个地址，我想，让我们尝试一下，创建地址。
And if the value in p is an address, I think, let's try this, make address.

447
00:23:23,529 --> 00:23:25,489
是的，这次编译还可以。
Yep, that compiled OK this time.

448
00:23:25,490 --> 00:23:27,550
现在，如果我做点斜杠地址，希望我
Now, if I do dot slash address, hopefully, I

449
00:23:27,549 --> 00:23:30,399
现在，的确会看到数字50。
will now see, indeed, the number 50.

450
00:23:30,400 --> 00:23:33,010
再一次，我们似乎没有取得任何根本进展。
So again, we don't seem to have made any fundamental progress.

451
00:23:33,009 --> 00:23:36,069
归根结底，我仍然只打印n的值。
At the end of the day, I'm still just printing out the value of n.

452
00:23:36,069 --> 00:23:39,099
但是我们已经介绍了这个新的原语，这个新的拼图，
But we've introduced this new primitive, this new puzzle piece,

453
00:23:39,099 --> 00:23:41,439
如果可以的话，这允许您以编程方式
if you will, that allows you, programmatically,

454
00:23:41,440 --> 00:23:44,390
找出计算机内存中某物的地址
to figure out the address of something in the computer's memory

455
00:23:44,390 --> 00:23:46,540
并实际去那个地址。
and to actually go to that address.

456
00:23:46,539 --> 00:23:52,069
而且我们很快就会看到对其进行更复杂的控制。
And we'll soon see exercise more sophisticated control over it as well.

457
00:23:52,069 --> 00:23:56,049
但是，让我们回到此的图形表示
But let's come back to a pictorial representation of this

458
00:23:56,049 --> 00:23:59,289
并考虑一下我们现在在这段代码的上下文中所做的事情。
and consider what it is we just did in the context, now, of this code.

459
00:23:59,289 --> 00:24:02,079
因此，在我的主代码中，有两行有趣的代码，
So inside of my main, the two interesting lines of code,

460
00:24:02,079 --> 00:24:05,319
真的，在我们添加Sophia之前，这两行是第一行吗？
really, were these two lines first before we made Sophia's addition

461
00:24:05,319 --> 00:24:07,989
并实际上取消了对p的引用，并使用printf将其打印出来。
and actually dereferenced p and printed it out with printf.

462
00:24:07,990 --> 00:24:10,810
但是，让我们暂时考虑一下这些值是什么
But let's consider, for a moment, what these values now

463
00:24:10,809 --> 00:24:12,279
看起来就像在计算机的内存中。
look like in a computer's memory.

464
00:24:12,279 --> 00:24:14,439
再说一次，语法有点神秘
And again, the syntax is a little cryptic

465
00:24:14,440 --> 00:24:16,475
因为我们现在有了一颗星星和一个“＆”号。
because we now have a star and an ampersand.

466
00:24:16,474 --> 00:24:18,849
但是，这再次意味着，现在，我们开始思考
But again, that just means, now, we get to start thinking

467
00:24:18,849 --> 00:24:20,404
就计算机的内存而言。
in terms of the computer's memory.

468
00:24:20,404 --> 00:24:23,029
例如，这是我计算机内部的内存网格。
So for instance, here's a grid of memory inside of my computer.

469
00:24:23,029 --> 00:24:26,979
也许，例如，50和n最终落在那儿。
And maybe, for instance, the 50 and the n end up down there.

470
00:24:26,980 --> 00:24:29,980
它们可能会出现在任何地方，甚至无法在此处显示在屏幕上。
They could end up anywhere, not even pictured on the screen here.

471
00:24:29,980 --> 00:24:34,090
就目前的目的而言，它们最终位于计算机内存中的某个位置。
They end up somewhere in the computer's memory, for our purposes thus far.

472
00:24:34,089 --> 00:24:36,099
但从技术上讲，它住在一个地址中。
But it technically lives in an address.

473
00:24:36,099 --> 00:24:38,949
让我简化一下地址，以便说得更快。
And let me simplify the address just so it's quicker to say.

474
00:24:38,950 --> 00:24:42,310
现在，这50个存储在变量n中，也许实际上
This 50, now, stored in the variable n, maybe it actually

475
00:24:42,309 --> 00:24:44,589
住在地址0x123。
lives at address 0x123.

476
00:24:44,589 --> 00:24:46,479
我不知道它在哪里，但我们显然
I have no idea where it is, but we've clearly

477
00:24:46,480 --> 00:24:50,200
看到它可以住在这样一个看似随机的地址中。
seen that it can live in a seemingly random address like that.

478
00:24:50,200 --> 00:24:51,640
现在，p呢？
Now, what about p?

479
00:24:51,640 --> 00:24:54,520
从技术上讲，p本身就是一个变量。
p is technically a variable itself.

480
00:24:54,519 --> 00:24:57,189
这是一个存储其他地址的变量。
It's a variable that stores the address of something else.

481
00:24:57,190 --> 00:25:00,190
但这仍然是一个变量，这意味着当您声明p时
But it's still a variable, which means, when you declare p

482
00:25:00,190 --> 00:25:04,660
在前面的代码中，它实际上确实占用了一些字节的内存
with the code earlier, it actually does take up some bytes of memory

483
00:25:04,660 --> 00:25:05,660
屏幕上。
on the screen.

484
00:25:05,660 --> 00:25:10,420
因此，让我继续前进，建议p恰好在这里存储在内存中。
And so let me go ahead and propose that p happens to end up in memory here.

485
00:25:10,420 --> 00:25:13,450
现在，故意将p画得更长一些。
Now, p is deliberately drawn to be longer here.

486
00:25:13,450 --> 00:25:15,700
这次我总共消耗了八个字节，
I'm consuming eight total bytes this time,

487
00:25:15,700 --> 00:25:20,470
因为事实证明，在包括CS50 IDE在内的现代计算机系统上，
because it turns out, on modern computer systems, including CS50 IDE,

488
00:25:20,470 --> 00:25:23,500
指针往往占用八个字节。
pointers tend to take up eight bytes.

489
00:25:23,500 --> 00:25:27,189
因此，不是一个字节，不是四个字节，而是八个字节，所以我只是简单地将其绘制成更大的字节。
So not one, not four, but eight bytes, so I've simply drawn it to be bigger.

490
00:25:27,190 --> 00:25:31,240
那么，实际上存储在变量p中的是什么？
So what is actually stored in the variable p?

491
00:25:31,240 --> 00:25:35,600
好吧，事实证明，它只是存储了一些值的地址。
Well, it turns out that, again, it's just storing the address of some value.

492
00:25:35,599 --> 00:25:42,459
因此，如果本身存储50的整数n位于位置0x123，
So if the integer n, which itself is storing 50, is at location 0x123,

493
00:25:42,460 --> 00:25:47,080
并为指针p分配了该地址，就像在说，
and pointer p is being assigned that address, it's just like saying,

494
00:25:47,079 --> 00:25:50,619
好吧，存储在此变量p中，实际上只是一个数字
well, stored in this variable p, is literally just a number

495
00:25:50,619 --> 00:25:54,189
此处以十六进制表示形式0x123表示。
represented here in hexadecimal notation, 0x123.

496
00:25:54,190 --> 00:25:56,650
这就是计算机内存中所有要做的事情
So that's all that's going on inside the computer's memory

497
00:25:56,650 --> 00:25:57,858
这两行代码。
with those two lines of code.

498
00:25:57,857 --> 00:26:00,039
除了事实，根本没有什么新的
There's nothing fundamentally new, except the fact

499
00:26:00,039 --> 00:26:04,429
我们有新的语法可用来显式地引用这些地址。
that we have new syntax with which to refer to these addresses explicitly.

500
00:26:04,430 --> 00:26:06,100
这里是n。
This is n down here.

501
00:26:06,099 --> 00:26:07,719
这是这里。
This is p up here.

502
00:26:07,720 --> 00:26:12,160
p的值恰好是一个地址。
And the value of p just happens to be an address.

503
00:26:12,160 --> 00:26:15,205
现在，我一直说这些地址有点神秘。
Now, I keep saying that these addresses are a little cryptic.

504
00:26:15,204 --> 00:26:16,329
他们有些武断。
They're a little arbitrary.

505
00:26:16,329 --> 00:26:16,871
他们是。
And they are.

506
00:26:16,872 --> 00:26:20,530
老实说，很少有启发性的了解，
And honestly, it is rarely, if ever, going to be enlightening to know,

507
00:26:20,529 --> 00:26:25,029
作为人类，该整数n实际位于什么地址。
as a human, what address this integer n is actually at.

508
00:26:25,029 --> 00:26:28,549
谁在乎它是0x123还是0x456？
Who cares if it's at 0x123 or 0x456?

509
00:26:28,549 --> 00:26:29,799
通常，我们不这样做。
Generally, we don't.

510
00:26:29,799 --> 00:26:33,069
因此，计算机科学家在谈论计算机的内存时，
And so computer scientists, when talking about computers' memory,

511
00:26:33,069 --> 00:26:38,009
就实际数字而言，倾向于不谈论这些低层次的细节。 ，
tend not to talk at these low level details, in terms of actual numbers. ,

512
00:26:38,009 --> 00:26:40,599
相反，他们倾向于简化图片，
Instead, they tend to simplify the picture,

513
00:26:40,599 --> 00:26:44,229
有点抽象所有其他内存，坦率地说，不是
sort of abstract away all of the other memory, which frankly, is not

514
00:26:44,230 --> 00:26:46,690
与到目前为止的讨论有关，并且只是
relevant to the discussion thus far, and just

515
00:26:46,690 --> 00:26:50,290
说，你知道吗，我知道p正在存储一个地址。
say, you know what, I know that p is storing an address.

516
00:26:50,289 --> 00:26:53,739
该地址恰好是这里的50。
And that address happens to be that of 50 down here.

517
00:26:53,740 --> 00:26:56,830
但是我真的不在乎我的日常编程生活中，
But I really don't care, in my everyday programming life,

518
00:26:56,829 --> 00:26:58,359
这些特定的地址是什么。
what these specific addresses are.

519
00:26:58,359 --> 00:26:59,229
那你知道吗？
So you know what?

520
00:26:59,230 --> 00:27:01,730
让我们将其抽象为箭头。
Let's just abstract it away as an arrow.

521
00:27:01,730 --> 00:27:06,250
同样，抽象就是简化底层细节
And again, abstraction is all about simplifying lower level details

522
00:27:06,250 --> 00:27:09,250
您可能非常需要了解，但不一定
that you may very well need to understand but you don't necessarily

523
00:27:09,250 --> 00:27:10,520
需要继续思考。
need to keep thinking about.

524
00:27:10,519 --> 00:27:11,949
您无需在这个级别上继续思考。
You don't need to keep thinking at this level.

525
00:27:11,950 --> 00:27:13,730
在这个级别上思考就足够了。
It suffices to think at this level.

526
00:27:13,730 --> 00:27:16,600
因此，我们不妨以图形方式绘制一个指针，
So we might as well draw a pointer, pictorially,

527
00:27:16,599 --> 00:27:20,709
指着一些价值，而不管什么
as pointing at some value and irrespective of what

528
00:27:20,710 --> 00:27:22,330
实际地址是。
the actual address is.

529
00:27:22,329 --> 00:27:25,149
因此，在我们人类世界中，情况就是如此。
And so this is very much the case in our human world.

530
00:27:25,150 --> 00:27:29,200
无论是否，我们都有非常相似的约定
We have very similar conventions whether or not

531
00:27:29,200 --> 00:27:31,750
乍一看可能很明显，例如
it might be obvious at first glance, such

532
00:27:31,750 --> 00:27:37,309
我们很可能会在日常生活中使用这些相同的机制。
that we may very well be using these same mechanisms in our everyday lives.

533
00:27:37,309 --> 00:27:40,689
举例来说，如果您家中的街道上碰巧有一个邮箱
So for instance, if you happen to have a mailbox out in the street on your home

534
00:27:40,690 --> 00:27:43,768
或在校园里的哈佛科学中心地下室
or down in the basement of Harvard Science Center when on campus, it

535
00:27:43,768 --> 00:27:46,810
至少在住宅上可能看起来像这样。
may very well look like something like this, at least more residentially.

536
00:27:46,809 --> 00:27:51,099
并假设在此情况下，此邮箱代表p，
And suppose that this mailbox here is representing, in this case, p,

537
00:27:51,099 --> 00:27:51,789
在故事里。
in the story.

538
00:27:51,789 --> 00:27:55,489
它存储一个指针，即其他内容的地址。
It's storing a pointer, that is, the address of something else.

539
00:27:55,490 --> 00:27:58,360
好吧，如果街上还有很多其他邮箱，
Well, if there's a whole bunch of other mailboxes on the street,

540
00:27:58,359 --> 00:28:01,509
好吧，我们可以在这些邮箱中放入所需的任何内容。
well, we can put anything we want in these mailboxes.

541
00:28:01,509 --> 00:28:04,839
我们甚至可以放明信片，信件，包裹。
We can put postcards, letters, packages even.

542
00:28:04,839 --> 00:28:08,249
就像在现实世界中一样，我们可以在虚拟环境中做同样的事情。
And just as in the real world, can we do the same in the virtual.

543
00:28:08,250 --> 00:28:12,889
我可以存储字符或整数或其他东西，包括地址。
I can store chars or integers or other things, including addresses.

544
00:28:12,890 --> 00:28:17,100
例如，布莱恩，我想您在其他地方拥有自己的邮箱。
So for instance, Brian, I think you have your own mailbox somewhere else.

545
00:28:17,099 --> 00:28:20,659
当然，布莱恩（Brian）拥有一个邮箱，该邮箱本身具有唯一的地址。
And Brian, of course, has a mailbox that itself has a unique address.

546
00:28:20,660 --> 00:28:23,600
例如，布莱恩（Brian），恰好是唯一地址
So Brian, for instance, what happens to be the unique address

547
00:28:23,599 --> 00:28:26,029
你那条街上的邮箱的地址？
of the mailbox on your street there?

548
00:28:26,029 --> 00:28:27,599
布莱恩：是的，这是我的邮箱。
BRIAN: Yeah, so here is my mailbox.

549
00:28:27,599 --> 00:28:28,369
标为n。
It's labeled n.

550
00:28:28,369 --> 00:28:29,749
它的地址在这里。
And its address is over here.

551
00:28:29,750 --> 00:28:33,200
我的邮箱地址似乎是0x123。
The address of my mailbox appears to be 0x123.

552
00:28:33,200 --> 00:28:35,450
DAVID MALAN：是的，所以我的邮箱也有一个地址。
DAVID MALAN: Yeah, so my mailbox, too, has an address.

553
00:28:35,450 --> 00:28:37,200
坦白说，我并不是很在乎。
Frankly, again, I don't really care about it.

554
00:28:37,200 --> 00:28:39,033
所以我什至没有把它放在这里的邮箱里。
So I've not even put it on the mailbox here.

555
00:28:39,032 --> 00:28:43,069
但是如果我的邮箱代表p，一个指针和Brian的邮箱
But if my mailbox represents p, a pointer, and Brian's mailbox

556
00:28:43,069 --> 00:28:45,919
代表n，一个整数，它应该
represents n, an integer, well, it should

557
00:28:45,920 --> 00:28:49,260
表示如果我查看指针的内容
mean that if I look inside the contents of my pointer

558
00:28:49,259 --> 00:28:53,689
我看到了值0x123，这现在是我的提示，
and I see the value 0x123, that is now my clue,

559
00:28:53,690 --> 00:28:57,560
种类繁多的面包屑，现在可以让我看一下Brian的邮箱内。
a breadcrumb of sorts, that can now let me go look inside of Brian's mailbox.

560
00:28:57,559 --> 00:29:00,319
还有布莱恩，如果您不介意为我们这样做，
And Brian, if you wouldn't mind doing that for us,

561
00:29:00,319 --> 00:29:02,429
你在那个地址有什么？
what do you have at that address?

562
00:29:02,430 --> 00:29:05,540
布莱恩：而且，如果我在邮箱中查找地址0x123，
BRIAN: And if I look in my mailbox at address 0x123,

563
00:29:05,539 --> 00:29:07,726
我的邮箱里有50号。
I have the number 50 inside of this mailbox.

564
00:29:07,727 --> 00:29:08,810
戴维·马兰（David MALAN）：是的，的确如此。
DAVID MALAN: Yeah, indeed.

565
00:29:08,809 --> 00:29:10,399
因此，在这种情况下，他碰巧正在存储一个int。
So in this case, he happens to be storing an int.

566
00:29:10,400 --> 00:29:11,650
但这可能是其他任何事情。
But it could be anything else.

567
00:29:11,650 --> 00:29:14,480
同样，我们通常并不关心这些特定地址。
And again, we don't typically care about these specific addresses.

568
00:29:14,480 --> 00:29:17,450
理解了隐喻之后，我们真的可以做些愚蠢的事情
Once you understand the metaphor, really, we can do something silly

569
00:29:17,450 --> 00:29:20,630
并且真的只是认为此邮箱存储的是
and really just think of this mailbox as storing a value that's

570
00:29:20,630 --> 00:29:23,180
指向布莱恩的邮箱。
pointing at Brian's mailbox.

571
00:29:23,180 --> 00:29:26,510
它是在那里绘制的某种方向，如箭头所示，
It's some kind of direction drawn there, pictorially as an arrow,

572
00:29:26,509 --> 00:29:28,999
这里就像一个愚蠢的泡沫手指。
here as a silly foam finger.

573
00:29:29,000 --> 00:29:34,750
或者，如果您愿意，可以使用泡沫耶鲁手指指向Brian的邮箱，
Or if you prefer, a foam Yale finger pointing, instead, at Brian's mailbox,

574
00:29:34,750 --> 00:29:38,720
就像一种面包屑将我们带到屏幕上的其他价值一样。
just as a sort of breadcrumb leading us to some other value on the screen.

575
00:29:38,720 --> 00:29:41,408
因此，当我们今天谈论地址之外时，
So when we talk today and beyond about addresses,

576
00:29:41,407 --> 00:29:42,699
这就是我们正在谈论的全部。
that's all we're talking about.

577
00:29:42,700 --> 00:29:45,790
现在，现实世界中的人类一直在使用eon的地址，
We humans in the real world have been using addresses for eons, now,

578
00:29:45,789 --> 00:29:49,029
以唯一地标识我们的房屋或企业等。
to uniquely identify our homes or businesses or the like.

579
00:29:49,029 --> 00:29:51,519
计算机在较低级别上执行完全相同的操作
Computers do the exact same thing at a lower level

580
00:29:51,519 --> 00:29:53,439
使用他们计算机的内存。
using their computer's memory.

581
00:29:53,440 --> 00:29:58,330
所以让我在这里暂停一下，看看是否有关于指针，变量的问题
So let me pause here to see if there are any questions on pointers, variables

582
00:29:58,329 --> 00:30:00,759
存储地址或在这些新的运算符上，
that store addresses, or on these new operators,

583
00:30:00,759 --> 00:30:02,889
像是“＆”号或“星号”
like the ampersand or the asterisk, which

584
00:30:02,890 --> 00:30:06,310
从今天起有了新的含义。
now has a new meaning today onward.

585
00:30:06,309 --> 00:30:06,967
还没有。
Nothing yet.

586
00:30:06,968 --> 00:30:09,010
好吧，什么也没看到，现在让我们考虑一下，
All right, seeing none, well, let's consider now,

587
00:30:09,009 --> 00:30:12,249
在完全不同的数据类型的上下文中是相同的故事。
the same story in the context of a completely different data type.

588
00:30:12,250 --> 00:30:15,310
到目前为止，我们只玩过int。
Thus far, we've played only with ints.

589
00:30:15,309 --> 00:30:16,629
但是考虑一下字符串。
But consider strings.

590
00:30:16,630 --> 00:30:20,950
我们花了很多时间在字符串上，对它们使用加密
We've spent a lot of time on strings, using encryption with them

591
00:30:20,950 --> 00:30:25,880
并使用用户的输入来解决实现选举算法的问题。
and solving implementing electoral algorithms using user's input.

592
00:30:25,880 --> 00:30:27,940
因此，让我们考虑一个根本不同的数据
So let's consider a fundamentally different data

593
00:30:27,940 --> 00:30:31,940
而不是存储单个整数的类型，而是存储文本字符串的类型。
type that stores, not individual integers, but strings of text instead.

594
00:30:31,940 --> 00:30:34,150
因此，例如，在涉及字符串的任何程序中，
So for instance, in any program involving a string,

595
00:30:34,150 --> 00:30:38,245
您可能会有一行看起来像这样的代码。字符串s等于，引用
you might have a line of code that looks like this. string s equals, quote

596
00:30:38,244 --> 00:30:40,089
取消引用，“嗨！”
unquote, "HI!"

597
00:30:40,089 --> 00:30:41,851
所有带有惊叹号的帽子。
in all caps with an exclamation point.

598
00:30:41,852 --> 00:30:44,560
因此，这很可能是到目前为止我们已经看到的代码行。
So that may very well be a line of code that we've seen thus far.

599
00:30:44,559 --> 00:30:46,934
计算机内存内部到底发生了什么？
What's actually going on inside of the computer's memory?

600
00:30:46,934 --> 00:30:51,339
好吧，让我建议您在输入引号unquote时输入“ HI！”。在电脑上
Well, let me propose that when you type in quote unquote, "HI!" in a computer,

601
00:30:51,339 --> 00:30:53,779
它最终存储在计算机内存中的某个位置。
it ends up somewhere in your computer's memory.

602
00:30:53,779 --> 00:30:58,839
因此，HI感叹号加上上周的反斜线0或两周前，
So HI exclamation point, plus, per last week, a backslash 0-- or two weeks ago,

603
00:30:58,839 --> 00:31:04,039
反斜杠0，这是计算机表示该字符串结尾的方式。
a backslash 0, which is how a computer represents the end of that string.

604
00:31:04,039 --> 00:31:06,099
但是让我们更仔细地看一下
But let's look a little more carefully at

605
00:31:06,099 --> 00:31:08,349
这里的引擎盖下面发生了什么。
what is going on underneath this hood here.

606
00:31:08,349 --> 00:31:12,189
从技术上讲，我可以解决那些个人角色
Technically speaking, I could address those individual characters

607
00:31:12,190 --> 00:31:16,280
从第二周开始，我们已经使用方括号表示法，例如s括号0，
we have seen as of week two, by using bracket notation like s bracket 0,

608
00:31:16,279 --> 00:31:18,909
s支架1，s支架2和s支架3。
s bracket 1, s bracket 2, and s bracket 3.

609
00:31:18,910 --> 00:31:22,427
我们使用方括号表示法来处理字符串
We use the square bracket notation to treat a string

610
00:31:22,426 --> 00:31:24,009
好像是一个字符数组。
as though it's an array of characters.

611
00:31:24,009 --> 00:31:26,899
是的，过去，现在仍然如此。
And it is, it was, and it still is.

612
00:31:26,900 --> 00:31:32,230
但是事实证明，字符串也可以通过它们的地址来操纵
But it turns out, strings can also be manipulated by way of their addresses

613
00:31:32,230 --> 00:31:32,960
也一样
as well.

614
00:31:32,960 --> 00:31:36,640
举例来说，也许是相同的字符串HI，
And so for instance, maybe this same exact string, HI,

615
00:31:36,640 --> 00:31:43,480
存储在内存地址0x123，然后存储在0x124、0x125和0x126。
is stored at memory address 0x123 and then 0x124, 0x125, and 0x126.

616
00:31:43,480 --> 00:31:46,150
请注意，它们是故意相邻的
Notice that they're deliberately contiguous

617
00:31:46,150 --> 00:31:47,560
地址，背对背。
addresses, back to back to back.

618
00:31:47,559 --> 00:31:50,869
而且它们之间只有一个字节，因为每个字符当然都
And they're only one byte apart, because each of these chars, of course,

619
00:31:50,869 --> 00:31:53,139
在C中只是一个字节
is just one byte in C.

620
00:31:53,140 --> 00:31:56,920
因此，具体来说，这些数字并不重要。
So those numbers are not important, specifically.

621
00:31:56,920 --> 00:31:59,530
但事实是它们彼此相距一个字节
But the fact that they're one byte apart from each other

622
00:31:59,529 --> 00:32:02,349
很重要，因为这是字符串的定义，
is important, because that's the definition of a string,

623
00:32:02,349 --> 00:32:05,469
确实是一个阵列，以背对背地拥有内存。
and indeed, an array, to have memory back to back to back.

624
00:32:05,470 --> 00:32:08,140
现在，到底S是什么？
Now, what exactly, though, is S?

625
00:32:08,140 --> 00:32:11,530
S是我刚才提到的那行代码的变量名称，
S was the name of the variable I gave a moment ago to go to that line of code,

626
00:32:11,529 --> 00:32:13,839
字符串S等于引号取消引号“ HI”。
string S equals quote unquote, "HI."

627
00:32:13,839 --> 00:32:14,709
好吧，S是什么？
well, what is S?

628
00:32:14,710 --> 00:32:18,950
S是必须在计算机内存中存储的变量。
S is a variable that has to go somewhere in the computer's memory.

629
00:32:18,950 --> 00:32:24,880
并且假设S确实是带有感叹号的HI。
And suppose that S is, indeed, HI with an exclamation point.

630
00:32:24,880 --> 00:32:28,600
HI恰好住在这里。
And the HI happens to live at this location here.

631
00:32:28,599 --> 00:32:31,389
您知道您可以将S视为现在，
You know what you can think of S as being now,

632
00:32:31,390 --> 00:32:34,840
在高层次上不是一个字符串，但在较低层次上，
isn't, at a high level, a string, but at a lower level,

633
00:32:34,839 --> 00:32:37,299
它只是一个字符串的地址。
it's just the address of a string.

634
00:32:37,299 --> 00:32:40,779
更具体地说，让我们开始考虑一个字符串
More specifically, let's start thinking about a string

635
00:32:40,779 --> 00:32:46,296
从技术上讲，它只是字符串中第一个字符的地址。
as technically being just the address of the first character in the string.

636
00:32:46,297 --> 00:32:48,130
现在，这可能会让您暂停片刻，
Now, that might give you pause for a moment,

637
00:32:48,130 --> 00:32:49,810
因为为什么第一个字符？
because why the first character?

638
00:32:49,809 --> 00:32:53,709
您将如何记住这一点，请稍等片刻，该字符串不是唯一的
How are you going to remember that, wait a minute, this string isn't at and only

639
00:32:53,710 --> 00:32:54,940
在0x123。
at 0x123.

640
00:32:54,940 --> 00:33:00,110
它还以0x124、0x125等继续。
It also continues at 0x124, 0x125, and so forth.

641
00:33:00,109 --> 00:33:02,949
但让我暂停一下，问一下这里的小组，为什么
But let me pause and ask the group here, why

642
00:33:02,950 --> 00:33:06,110
也许对于一台电脑来说就足够了
might it very well be sufficient for a computer

643
00:33:06,109 --> 00:33:12,549
和我们程序员只是考虑存在的字符串
and us programmers to just think of strings in terms of being

644
00:33:12,549 --> 00:33:15,459
第一个字节的地址。
the address of the very first byte.

645
00:33:15,460 --> 00:33:18,220
就像，为什么足够，无论多长时间
Like, why is it sufficient, no matter how long

646
00:33:18,220 --> 00:33:20,830
即使是整个文本段，字符串也是
the string is, even if it's a whole paragraph of text,

647
00:33:20,829 --> 00:33:25,359
为什么想到一个像S这样的字符串就足够聪明了
why is it very cleverly sufficient to think of a string like S

648
00:33:25,359 --> 00:33:31,419
只是与第一个字节的地址相同？
as just being identical to the address of the first byte?

649
00:33:31,420 --> 00:33:33,718
金妮，是吗？
Ginni, is it?

650
00:33:33,718 --> 00:33:37,480
听众：可能是因为无论何时我们定义
AUDIENCE: Possibly because it happens that strings, whenever we are defining

651
00:33:37,480 --> 00:33:39,490
一个新的字符串，共。
a new string, that is altogether.

652
00:33:39,490 --> 00:33:44,410
假设，如果我写我的名字叫Ginni，那么它就是GINNI。
Suppose, if I'm writing my name, Ginni, so it will be G-I-N-N-I altogether.

653
00:33:44,410 --> 00:33:46,810
因此，只要有针对性的话就足够了
So it will be sufficient if something is pointed

654
00:33:46,809 --> 00:33:50,559
朝向我名字的第一个字符，这样我就可以
towards just first character of my name, so that I can just

655
00:33:50,559 --> 00:33:55,894
跟进第一个字符，然后再获取所有字符。
follow up for the first character and then get all the characters afterwards.

656
00:33:55,894 --> 00:33:56,769
大卫·马兰（David MALAN）：完美。
DAVID MALAN: Perfect.

657
00:33:56,769 --> 00:33:59,799
因此，过去几周我们拥有的所有这些基本定义
So all of these basic definitions we had over the past couple of weeks

658
00:33:59,799 --> 00:34:00,789
现在走到一起。
now come together.

659
00:34:00,789 --> 00:34:02,811
如果字符串只是一个字符数组-
If a string is just an array of characters--

660
00:34:02,811 --> 00:34:05,019
根据数组的定义，这些字符又回来了
and by definition of array, those characters are back

661
00:34:05,019 --> 00:34:09,279
背靠背，每两周一次，每个字符串
to back to back, and per two weeks ago, every string

662
00:34:09,280 --> 00:34:13,300
以该常规反斜杠零或nul字符结尾。
ends with this conventional backslash zero or nul character.

663
00:34:13,300 --> 00:34:15,550
考虑字符串时您需要做的所有事情
All you need to do when thinking about a string

664
00:34:15,550 --> 00:34:17,530
只是想知道字符串从哪里开始，
is just to know where does the string begin,

665
00:34:17,530 --> 00:34:19,719
因为您可以使用四个循环或一个while循环
because you can use a four loop or a while loop

666
00:34:19,719 --> 00:34:22,540
或其他带有条件和布尔表达式的启发式方法
or some other heuristic with a condition and a Boolean expression

667
00:34:22,539 --> 00:34:25,928
弄清楚字符串结尾的位置，甚至不知道，
to figure out where the string ends without even knowing,

668
00:34:25,929 --> 00:34:27,710
提前，它的长度。
in advance, its length.

669
00:34:27,710 --> 00:34:30,159
就是说，让我们开始吧，
So that is to say, let's start, for the moment,

670
00:34:30,159 --> 00:34:32,679
认为字符串很简单
thinking of about strings as being quite simply

671
00:34:32,679 --> 00:34:37,969
那只是字符串中第一个字符的地址。
that, just the address of the first character in the string.

672
00:34:37,969 --> 00:34:40,989
如果我们将其视为事实，那么现在就开始吧，
And if we then take that as fact, let's go ahead, now,

673
00:34:40,989 --> 00:34:43,989
然后开始玩一个不使用整数的程序，而是
and start playing with a program that doesn't use integers, but instead,

674
00:34:43,989 --> 00:34:46,570
使用此基本原语的字符串。
used strings, using this basic primitive.

675
00:34:46,570 --> 00:34:49,929
因此，让我继续删除我之前编写的代码，即地址。c。
So let me go ahead and delete the code I'd written before, an address.c.

676
00:34:49,929 --> 00:34:54,580
让我将其更改为字符串等于引号unquote，“ HI”分号。
Let me just change it up to be string equals quote unquote, "HI" semicolon.

677
00:34:54,579 --> 00:34:57,699
请注意，我没有手动输入任何反斜杠0。
And notice, I'm not manually typing any backslash 0's.

678
00:34:57,699 --> 00:34:59,559
C自动为我们做到这一点。
C does that for us automatically.

679
00:34:59,559 --> 00:35:02,259
当您关闭引号时，编译器会注意
When you close the quote, the compiler takes care

680
00:35:02,260 --> 00:35:04,158
为您添加反斜杠0的说明。
of adding that backslash 0 for you.

681
00:35:04,157 --> 00:35:05,949
现在，我要继续下一行
Now, I'm going to go ahead on the next line

682
00:35:05,949 --> 00:35:10,041
并打印出％的反斜杠逗号，
and go ahead and print out percent s backslash n comma s,

683
00:35:10,041 --> 00:35:11,499
如果我想打印出该字符串。
if I want to print out that string.

684
00:35:11,500 --> 00:35:13,967
现在，这个程序一点也不有趣了。
Now, this program is not at all interesting anymore.

685
00:35:13,967 --> 00:35:15,759
早在第一周，我们就写了-
Back in week one, we wrote something like--

686
00:35:15,760 --> 00:35:18,730
好，是的，这很有趣，因为我搞砸了。
OK, yes it is interesting because I screwed up.

687
00:35:18,730 --> 00:35:19,780
有五个错误。
So five errors.

688
00:35:19,780 --> 00:35:22,450
我已经写了七行代码和五个错误。
I've written seven lines of code and five errors.

689
00:35:22,449 --> 00:35:24,069
让我们看看发生了什么。
And let's see what's going on.

690
00:35:24,070 --> 00:35:27,430
和往常一样，总是走在最前面，因为赔率很高，
As always, always go to the top, because odds are,

691
00:35:27,429 --> 00:35:29,649
只是有一些令人困惑的级联效果。
there's just some confusing cascading effect.

692
00:35:29,650 --> 00:35:34,090
我看到的第一个错误是使用未声明的标识符字符串。
The very first error I see is use of undeclared identifier string.

693
00:35:34,090 --> 00:35:35,230
我的意思是标准n吗？
Did I mean standard n?

694
00:35:35,230 --> 00:35:37,900
我不是说标准n，字符串，字符串，字符串。
I didn't mean standard n, string, string, string.

695
00:35:37,900 --> 00:35:40,780
所以我可以将帮助50作为我的前沿，但是说实话，我
So I could run help 50 as my frontier, but honestly, I

696
00:35:40,780 --> 00:35:43,150
经常犯这样的错误，我现在有点知道
make this mistake often enough that I kind of know now

697
00:35:43,150 --> 00:35:46,690
我忘了包含cs50.h。
that I forgot to include cs50.h.

698
00:35:46,690 --> 00:35:49,960
确实，如果我现在执行此操作并重新编译make地址，
And indeed, if I now do this and recompile make address--

699
00:35:49,960 --> 00:35:53,080
好的，仅通过一个简单的更改，所有五个错误都消失了。
OK, all five errors are gone just by that one simple change.

700
00:35:53,079 --> 00:35:56,199
如果我现在运行地址，那就很简单地说HI。
And if I run address now, it's just going to, quite simply, say HI.

701
00:35:56,199 --> 00:35:59,019
但是现在让我们开始考虑发生了什么
But let's now start to consider what's going

702
00:35:59,019 --> 00:36:00,649
在这个程序的幕后。
on underneath the hood of this program.

703
00:36:00,650 --> 00:36:06,040
假设我很好奇，想打印出实际的内容
Suppose I am curious and want to print out what is actually

704
00:36:06,039 --> 00:36:08,169
该字符串所在的地址。
the address at which this string lives.

705
00:36:08,170 --> 00:36:09,520
好吧，事实证明……
Well, it turns out--

706
00:36:09,519 --> 00:36:10,689
让我在这里聪明一点。
let me be clever here.

707
00:36:10,690 --> 00:36:14,830
让我打印出来，不是百分比s的格式代码，而是百分比p的格式代码。
Let me print out, not a format code of percent s, but percent p.

708
00:36:14,829 --> 00:36:18,289
告诉我这个与地址相同的字符串。
Show me this same string as an address.

709
00:36:18,289 --> 00:36:22,059
让我继续进行重新编译，使之寻址，好像编译就可以了。
Let me go ahead and recompile, make address, seems to compile OK.

710
00:36:22,059 --> 00:36:23,559
让我运行点斜杠地址。
Let me run dot slash address.

711
00:36:23,559 --> 00:36:26,349
再说一次，我仍在打印s，但我问的是printf
And again, I'm still printing s, but I'm asking printf

712
00:36:26,349 --> 00:36:30,259
呈现它，就像它是一个指针一样。
to present it as though it's a pointer.

713
00:36:30,260 --> 00:36:32,430
有趣的是，它与以前不同。
And interesting, it's not the same as before.

714
00:36:32,429 --> 00:36:35,059
但这又是合理的，因为内存地址
But again, that's reasonable because the memory addresses

715
00:36:35,059 --> 00:36:36,539
不会总是一样的。
aren't going to always be the same.

716
00:36:36,539 --> 00:36:37,939
但这无关紧要。
But it doesn't matter what it is.

717
00:36:37,940 --> 00:36:39,232
但这有点有趣。
But that's kind of interesting.

718
00:36:39,231 --> 00:36:41,749
一直以来，无论何时您一直在使用字符串，
All this time, any time you've been using strings,

719
00:36:41,750 --> 00:36:44,299
您是否刚刚将百分比s更改为百分比p，
had you just changed your percent s to a percent p,

720
00:36:44,300 --> 00:36:48,290
您可能已经看到了该字符串在内存中实际开始的位置。
you could have seen where, in memory, that string actually starts.

721
00:36:48,289 --> 00:36:50,779
到目前为止，它在功能上对我们还没有用。
It's not functionally useful to us just yet.

722
00:36:50,780 --> 00:36:52,700
但是它一直都在那儿。
But it's been there this whole time.

723
00:36:52,699 --> 00:36:54,799
现在让我继续进行以下操作。
And let me go ahead and do the following now.

724
00:36:54,800 --> 00:36:58,950
假设我进一步感到好奇，我做了printf。
Suppose I get a little curious further, and I do printf.

725
00:36:58,949 --> 00:37:02,389
让我继续并打印出另一个地址，然后再换一行。
Let me go ahead and print out another address followed by a new line.

726
00:37:02,389 --> 00:37:07,034
让我继续打印第一个字符的地址。
And let me go ahead and print out the address of the first character.

727
00:37:07,034 --> 00:37:08,659
再说一次，这有点奇怪。
So again, this is a little weird to do.

728
00:37:08,659 --> 00:37:10,219
而且我们通常不会经常这样做。
And we wouldn't typically do this that often.

729
00:37:10,219 --> 00:37:13,429
但是，再次强调一下，这些运算符使我们非常简单
But again, just to make the point that these operators give us very simple

730
00:37:13,429 --> 00:37:16,849
问题的答案，例如，这东西的地址是什么？
answers to questions like, what is the address of this thing?

731
00:37:16,849 --> 00:37:23,959
如果截至CS50第二周的s括号i代表s中的第二个字符，
If s bracket i, as of week two in CS50, represented the second character in s,

732
00:37:23,960 --> 00:37:28,190
因为0索引表示s括号0是第一个，s括号1是第二个。
because 0 index means s bracket 0 is the first, s bracket 1 is the second.

733
00:37:28,190 --> 00:37:30,410
如果我和今天的新运营商一起玩，
If I play around with today's new operator,

734
00:37:30,409 --> 00:37:36,019
我敢打赌我可以看到第二个字符的地址。
this ampersand, I bet I can see the address of that second character.

735
00:37:36,019 --> 00:37:38,389
实际上，让我继续说得更明确些。
And in fact, let me go ahead and be more explicit.

736
00:37:38,389 --> 00:37:43,159
让我将第一个s更改为s括号0并在此处放置一个＆符。
Let me change this first s to be s bracket 0 and put an ampersand here.

737
00:37:43,159 --> 00:37:46,429
现在，让我继续，编写该程序，编写地址。
And let me go ahead, now, and make this program, make address.

738
00:37:46,429 --> 00:37:48,169
好吧，有点时髦-
OK, a little funky--

739
00:37:48,170 --> 00:37:49,680
我只是想念一个分号。
I just missed a semicolon.

740
00:37:49,679 --> 00:37:51,059
在那里很容易修复。
So easy fix there.

741
00:37:51,059 --> 00:37:53,599
让我继续并用make地址重新编译。
Let me go ahead and recompile with make address.

742
00:37:53,599 --> 00:37:55,879
让我继续运行点斜杠地址。
Let me go ahead and run dot slash address.

743
00:37:55,880 --> 00:37:58,970
有趣的是，也许-
And interesting, well, maybe--

744
00:37:58,969 --> 00:38:00,319
对我来说很有趣。
interesting to me.

745
00:38:00,320 --> 00:38:02,780
所以，您现在看到两个地址，第一个
So you see, now, two addresses, the first of which

746
00:38:02,780 --> 00:38:08,900
是0x4006a4，显然是s中第一个字符的地址。
is 0x4006a4, which apparently, is the address of the first character in s.

747
00:38:08,900 --> 00:38:10,880
但是请注意下一个是什么。
But notice what's curious about the next one.

748
00:38:10,880 --> 00:38:15,720
几乎是相同的，只是字节相距更远。
It's almost the same except the byte is one further away.

749
00:38:15,719 --> 00:38:18,379
而且我敢打赌，如果我这样做，不仅限于h和i，
And I bet if I do this, not just for the h and the i,

750
00:38:18,380 --> 00:38:20,330
还有感叹号-让我去做
but also the exclamation point-- let me do

751
00:38:20,329 --> 00:38:23,209
一行几乎相同的代码，只是
one more line of almost identical code, just

752
00:38:23,210 --> 00:38:26,240
指出所有这些时间的确是
to make the point that all this time it's, indeed,

753
00:38:26,239 --> 00:38:30,559
字符串中的所有字符都背靠背排列的情况。
been the case that all characters in a string are back to back to back.

754
00:38:30,559 --> 00:38:32,539
现在您可以在代码中看到它。
And you can now see it in code.

755
00:38:32,539 --> 00:38:37,609
b4，b5，b6仅相隔一个字节。
b4, b5, b6, are just one byte apart.

756
00:38:37,610 --> 00:38:40,940
因此，我们看到了一些视觉确认，现在字符串确实是
So we see some visual confirmation, now, that strings are indeed

757
00:38:40,940 --> 00:38:42,990
这样布置在内存中。
laid out in memory just like this.

758
00:38:42,989 --> 00:38:46,129
再说一次，这不是一个非常有用的程序设计练习
Now, again, this is not a very useful programmatic exercise

759
00:38:46,130 --> 00:38:48,500
查看单个字符的地址。
to look at the address of individual characters.

760
00:38:48,500 --> 00:38:51,350
但是，这再次是为了强调在引擎盖下，
But again, this is just to emphasize that underneath the hood,

761
00:38:51,349 --> 00:38:53,959
一些相对简单的操作正在
some relatively simple operations are being

762
00:38:53,960 --> 00:38:58,562
通过这个新的“＆”号，然后是星号运算符启用。
enabled by way of this new ampersand, and in turn, star operator.

763
00:38:58,561 --> 00:39:00,769
因此，让我们考虑一下这看起来到底是什么
So let's consider for a moment what this really looks

764
00:39:00,769 --> 00:39:02,389
就像在计算机内存中一样。
like inside the computer's memory.

765
00:39:02,389 --> 00:39:05,659
从低层次上讲，是的，s从技术上讲是一个地址。
At a low level, yes, s is technically an address.

766
00:39:05,659 --> 00:39:08,539
是的，从技术上讲，这是第一个字节的地址，
And yes, it's technically the address of the first byte,

767
00:39:08,539 --> 00:39:10,879
在实际的计算机中，看起来有所不同。
which in the actual computer, looked different.

768
00:39:10,880 --> 00:39:13,100
但是在我这里的幻灯片中，我只是随意地提出了
But in my slide here, I just arbitrarily proposed

769
00:39:13,099 --> 00:39:17,209
它位于0x123、0x124、0x125。
that it's at 0x123, 0x124, 0x125.

770
00:39:17,210 --> 00:39:20,300
但是，再次，我们不必关心该详细程度。
But again, let's not care about that level of detail.

771
00:39:20,300 --> 00:39:23,210
让我们挥挥手，摘掉这些地址
Let's just kind of wave our hands and abstract away these addresses

772
00:39:23,210 --> 00:39:30,950
刚刚开始考虑s，这是一个字符串，从技术上讲
and just now start thinking of s, that is a string, as technically just being

773
00:39:30,949 --> 00:39:32,449
一个指针。
a pointer.

774
00:39:32,449 --> 00:39:33,259
指针。
A pointer.

775
00:39:33,260 --> 00:39:36,463
事实证明，即使它非常有用且非常普遍
So it turns out that even though it's very useful and very common

776
00:39:36,463 --> 00:39:39,380
认为字符串显然只是字符序列。
to think of strings as, obviously, just being sequences of characters.

777
00:39:39,380 --> 00:39:41,240
从第一周开始就是如此。
And that's been true since week one.

778
00:39:41,239 --> 00:39:43,129
您也可以将它们视为数组，
And you can also think of them as arrays,

779
00:39:43,130 --> 00:39:44,990
背对背的字符序列。
back to back sequences of characters.

780
00:39:44,989 --> 00:39:47,329
事实证明，从今天开始，
You can also, it turns out, starting today,

781
00:39:47,329 --> 00:39:51,289
认为它们只是指针，也就是说，
think of them as just being pointers, that is,

782
00:39:51,289 --> 00:39:54,899
计算机内存中某个字符的地址。
the address of a character somewhere in the computer's memory.

783
00:39:54,900 --> 00:39:58,550
正如Ginni所指出的，因为字符串中的所有字符
And as Ginni notes, because all of the characters in a string

784
00:39:58,550 --> 00:40:00,770
从定义上讲，是背对背，
are, by definition, back to back to back,

785
00:40:00,769 --> 00:40:05,719
并且因为根据定义，所有字符串都以反斜杠0结尾，因此
and because, by definition, all strings end with a backslash 0, that

786
00:40:05,719 --> 00:40:08,749
实际上是最小且唯一的信息量
is literally the smallest and only amount of information

787
00:40:08,750 --> 00:40:12,919
您需要在计算机中四处走动，以了解所有字符串的位置。
you need to keep around in a computer to know where all of your strings are.

788
00:40:12,920 --> 00:40:16,340
只要记住第一个字符的地址
Just remember the address of the very first character

789
00:40:16,340 --> 00:40:19,430
在其中，因为您可以找到通往终点的道路
therein, because you can find your way to the end

790
00:40:19,429 --> 00:40:24,319
记得这个反斜杠0确实是8 0
by remembering that this backslash 0 is, really, just eight 0

791
00:40:24,320 --> 00:40:27,080
位，否则表示为反斜杠0。
bits, otherwise represented as backslash 0.

792
00:40:27,079 --> 00:40:29,616
所以我们当然可以有一个if条件，
And so we could certainly have an if condition,

793
00:40:29,617 --> 00:40:31,700
就像我们两个星期前在玩耍时所做的一样
much like we did two weeks ago when playing around

794
00:40:31,699 --> 00:40:36,229
加上字符串的长度，这使我们能够准确地进行检查。
with the lengths of strings, that allows us to check for precisely that.

795
00:40:36,230 --> 00:40:41,030
因此，当我说我们要卸下一些训练轮时，它们就到了。
And so when I say we're taking off some training wheels, here they go.

796
00:40:41,030 --> 00:40:44,330
到目前为止，我们一直在使用CS50库，
So up until now, we've been using, again, the CS50 library,

797
00:40:44,329 --> 00:40:47,469
这给了我们方便的功能，例如get string和get int
which gives us, conveniently, functions like get string and get int

798
00:40:47,469 --> 00:40:49,649
并开始浮动等等。
and get float and so forth.

799
00:40:49,650 --> 00:40:54,650
但是，一直以来，CS50库，特别是文件cs50.h，
But all this time, the CS50 library, specifically the file, cs50.h,

800
00:40:54,650 --> 00:40:58,070
有一点教学上的简化。
had a little bit of a pedagogical simplification in it.

801
00:40:58,070 --> 00:41:02,510
回想上周，您可以定义自己的自定义数据类型。
Recall last week, that you can define your own custom data types.

802
00:41:02,510 --> 00:41:06,955
好吧，事实证明，一直以来，我们一直在声称字符串存在
Well, it turns out that all this time, we've been claiming that strings exist

803
00:41:06,954 --> 00:41:09,079
它们是您可以在程序中使用的东西。
and they're something you can use in your programs.

804
00:41:09,079 --> 00:41:14,419
字符串确实存在于C中。它们确实存在于Python，JavaScript，Java，
And strings do exist in C. They do exist in Python, in JavaScript, in Java,

805
00:41:14,420 --> 00:41:16,980
和C ++，还有许多其他许多语言。
and C++, in many, many, many other languages.

806
00:41:16,980 --> 00:41:18,860
这不是CS50术语。
This is not a CS50 term.

807
00:41:18,860 --> 00:41:25,190
但是从技术上讲，字符串在C中不作为数据类型存在。相反，
But string, technically, does not exist as a data type in C. It instead,

808
00:41:25,190 --> 00:41:31,180
更隐秘，更底层地称为char star。
is more cryptically and more low-level known as char star.

809
00:41:31,179 --> 00:41:33,079
查尔斯星，这是什么意思？
Char star, now what does that mean?

810
00:41:33,079 --> 00:41:37,179
好吧，char明星，就像几分钟前我们的int明星一样，
Well, char star, much like our int star a few minutes ago,

811
00:41:37,179 --> 00:41:40,839
只是代表一个字符的地址，就像int star
just represents the address of a character, much like int star

812
00:41:40,840 --> 00:41:43,210
代表一个整数的地址。
represents the address of an int.

813
00:41:43,210 --> 00:41:46,210
再说一次，如果您现在也同意我的观点，
And if, again, you kind of agree with me now,

814
00:41:46,210 --> 00:41:49,450
您可以将字符串视为字符序列，
that you can think of strings as sequences of characters,

815
00:41:49,449 --> 00:41:52,659
或更具体地说，是字符数组，或更具体地，
or more specifically, arrays of characters, or more specifically,

816
00:41:52,659 --> 00:41:56,919
到今天为止，第一个字符的地址，
as of today, the address of just the first character,

817
00:41:56,920 --> 00:41:59,680
那么的确是这样，我们现在可以
then it's, indeed, the case that we now can

818
00:41:59,679 --> 00:42:02,799
运用今天的指针新术语，
apply this new terminology, today, of pointer,

819
00:42:02,800 --> 00:42:06,040
给我们熟悉的老朋友，弦乐。
to our old familiar friends, strings.

820
00:42:06,039 --> 00:42:10,689
字符串与char star的同义词是一样的。
String is the same thing as a synonym, if you will, for char star.

821
00:42:10,690 --> 00:42:14,200
实际上，在CS50库中，我们有一行代码
And it's in the CS50 library that we, essentially, have a line of code

822
00:42:14,199 --> 00:42:18,347
可以简化或抽象出char char星，说实话，没人愿意
that simplifies or abstracts away char star, which honestly, no one wants

823
00:42:18,347 --> 00:42:20,889
在上课的第一周去思考或挣扎，
to think about or struggle with in the first week of a class,

824
00:42:20,889 --> 00:42:23,259
更不用说上课的前两，三周了。
let alone the first two or three weeks of a class.

825
00:42:23,260 --> 00:42:28,475
这是一种简化的自定义数据类型，我们将其命名为string，
It's a simplification, a custom data type, that we name string,

826
00:42:28,474 --> 00:42:30,849
只是您不必考虑，这颗星是什么？
just so you don't have to think about, what is this star?

827
00:42:30,849 --> 00:42:32,016
角色是什么？
What is it to the character?

828
00:42:32,016 --> 00:42:33,099
地址是什么？
What is it an address of?

829
00:42:33,099 --> 00:42:37,449
但是今天，我们可以移除那些训练轮，并在所有时间内揭示出这些，
But today, we can remove those training wheels and reveal that, all this time,

830
00:42:37,449 --> 00:42:40,719
您刚刚在操作特定地址的字符。
you've just been manipulating characters at specific addresses.

831
00:42:40,719 --> 00:42:43,179
而且我们之前使用过这种技术，
And we've used this kind of technique before,

832
00:42:43,179 --> 00:42:45,549
提取这些较低级别的细节。
abstracting away these lower level details.

833
00:42:45,550 --> 00:42:48,310
例如，回想一下上周，我们介绍了
For instance, recall last week, that we introduced

834
00:42:48,309 --> 00:42:52,629
这种结构的概念，您可以自定义自己的数据类型。
this notion of a struct, a data type that you can customize to be your own.

835
00:42:52,630 --> 00:42:56,200
通过包装在一起，我们实现了更好的电话簿
We implemented a better phone book by wrapping together

836
00:42:56,199 --> 00:42:58,629
自定义数据类型中的名称和数字，
a name and a number inside of a custom data type,

837
00:42:58,630 --> 00:43:01,960
如果可以的话，将它们封装在我们称为“人”的内部。
encapsulating them if you will, inside of something we called person.

838
00:43:01,960 --> 00:43:05,650
我们声称的每个人都有一个结构
And every person we claimed had a structure

839
00:43:05,650 --> 00:43:07,580
其中包含一个名称和一个数字。
that contains a name and a number.

840
00:43:07,579 --> 00:43:11,409
通过C的这种特性typedef，我们可以定义一个新类型。
And by the way of this feature of C, typedef, we can define a new type.

841
00:43:11,409 --> 00:43:15,199
上周，这种类型的名字就是人。
And the name of that type, last week, was just person.

842
00:43:15,199 --> 00:43:18,099
所以我们已经在使用，并且我们已经秘密地进行了
So we're using, already, and we have been sort of secretly

843
00:43:18,099 --> 00:43:22,749
自C的第一周开始使用，一行代码
using since the first week of C in the class, a line of code that

844
00:43:22,750 --> 00:43:24,020
实际上看起来像这样。
actually looks like this.

845
00:43:24,019 --> 00:43:28,089
实际上，这是cs50.h内部的代码行之一。
And this is, indeed, one of the lines of code inside of cs50.h.

846
00:43:28,090 --> 00:43:31,000
它说typedef，这意味着给我一个自定义类型。
It says typedef, which means give me a custom type.

847
00:43:31,000 --> 00:43:35,769
并且它为char star创建了一个名为string的同义词。
And it creates a synonym for char star called string.

848
00:43:35,769 --> 00:43:39,699
这只是我们隐藏时髦的char星的一种方式。
And it's just a way where we can hide the funky char star.

849
00:43:39,699 --> 00:43:42,069
我们可以特别隐藏星号，而不会
We can hide the asterisk, in particular, which would not

850
00:43:42,070 --> 00:43:43,990
在头几天玩的很开心，
be fun to play with in the first few days,

851
00:43:43,989 --> 00:43:47,199
但无需更改字符串的定义。
but without changing the definition of what a string is.

852
00:43:47,199 --> 00:43:51,849
因此，字符串存在于C中。但是C中没有称为字符串的数据类型
So strings exist in C. But there's no data type called string in C

853
00:43:51,849 --> 00:43:56,019
直到您使用CS50之类的库为止
until you use a library like CS50's, which makes it exist

854
00:43:56,019 --> 00:43:58,929
通过这种定义的方式。
by way of that kind of definition.

855
00:43:58,929 --> 00:44:01,449
好吧，让我在这里停留看看是否有
All right, let me pause here to see if there's

856
00:44:01,449 --> 00:44:03,759
那么，关于什么是字符串的任何问题
any questions, then, about what strings are

857
00:44:03,760 --> 00:44:09,360
或这些新的思考方式。
or these new ways of thinking about them.

858
00:44:09,360 --> 00:44:13,390
对字符串或字符星有任何疑问吗？
Any questions about strings or char stars?

859
00:44:13,389 --> 00:44:15,139
好吧，如果这里没有问题，为什么
All right, well, if no questions here, why

860
00:44:15,139 --> 00:44:17,514
我们不要继续，先在这里休息5分钟。
don't we go ahead and take our 5 minute break here first.

861
00:44:17,514 --> 00:44:19,789
然后我们回到5，再来看看
And we'll be back in 5 and take another look

862
00:44:19,789 --> 00:44:22,039
我们现在可以使用这些新原语做什么。
at what we can now do with these new primitives.

863
00:44:22,039 --> 00:44:23,479
好吧，我们回来了。
All right, we're back.

864
00:44:23,480 --> 00:44:27,680
现在，我们已经在代码中获得了获取某些变量地址的功能
And we have, now, this ability in code to get the address of some variable

865
00:44:27,679 --> 00:44:30,139
并且也要使用＆符去一个地址
and also to go to an address using ampersand

866
00:44:30,139 --> 00:44:31,849
和星号分别。
and the asterisk, respectively.

867
00:44:31,849 --> 00:44:36,529
我们认为字符串不仅是连续的序列
We've thought about strings as being not only contiguous sequences

868
00:44:36,530 --> 00:44:38,150
字符，也可以是数组。
of characters, but also arrays.

869
00:44:38,150 --> 00:44:42,477
然后，当然，到今天为止，实际地址，
And then of course, as of today now, actual addresses,

870
00:44:42,476 --> 00:44:44,809
第一个字符的地址，然后从那里开始，
the address of the first character and then, from there,

871
00:44:44,809 --> 00:44:46,939
我们能否以编程方式找到最终的方法，
can we find our way, programmatically, to the end,

872
00:44:46,940 --> 00:44:48,380
多亏了那个nul角色。
thanks to that nul character.

873
00:44:48,380 --> 00:44:52,220
但是事实证明，我们可以使用这些地址做另一件事
But it turns out there's one other thing we can do with these addresses

874
00:44:52,219 --> 00:44:53,839
或更一般地使用指针。
or with pointers more generally.

875
00:44:53,840 --> 00:44:55,550
这就是所谓的指针算法。
And that's known as pointer arithmetic.

876
00:44:55,550 --> 00:44:58,577
所以，当然，任何数字都可以进行数学运算。
So anything that's a number, of course, we can do math on.

877
00:44:58,577 --> 00:45:00,410
数学不会变得复杂，
And the math is not going to be complicated,

878
00:45:00,409 --> 00:45:03,389
但这对我们来说将是强大的。
but it is going to be powerful for us here.

879
00:45:03,389 --> 00:45:07,039
因此，我将返回到最新的address.c状态。
So I'm going to go back to my most recent state of address.c.

880
00:45:07,039 --> 00:45:11,479
现在让我继续，并重申我们可以打印出
And let me go ahead, now, and reiterate that we can print out

881
00:45:11,480 --> 00:45:15,800
字符串中的各个字符，就像我们在第二周所做的一样，
the individual characters in a string, just like we did back in week two,

882
00:45:15,800 --> 00:45:18,270
如使用方括号表示法。
as by using our square bracket notation.

883
00:45:18,269 --> 00:45:21,169
因此，我暂时摆脱了那些地址的所有证据。
So I'm getting rid of all evidence of those addresses for now.

884
00:45:21,170 --> 00:45:23,420
我正在将该程序重新编译为make地址。
I'm recompiling this program as make address.

885
00:45:23,420 --> 00:45:25,650
然后我现在要运行点斜杠地址。
And then I'm going to run dot slash address now.

886
00:45:25,650 --> 00:45:29,690
而且我看到HI感叹号，每行一个字符。
And I see HI exclamation point, one character per line.

887
00:45:29,690 --> 00:45:34,290
但是现在，请考虑不需要字符串数据类型。
But now, consider that there doesn't need to be a string data type.

888
00:45:34,289 --> 00:45:36,319
实际上，我们可以取消此训练轮。
In fact, we can take this training wheel off.

889
00:45:36,320 --> 00:45:38,690
虽然刚开始时可能会感到不舒服，
And while it might feel a little uncomfortable at first,

890
00:45:38,690 --> 00:45:42,620
如果我完全删除了第一行，因为我还是无意中省略了
if I delete this first line altogether, as I've accidentally omitted anyway

891
00:45:42,619 --> 00:45:45,659
有时，我不需要继续称呼事物为字符串。
sometimes, I don't need to keep calling things strings.

892
00:45:45,659 --> 00:45:47,569
我可以用口头上的字符串来形容它们。
I can describe them as strings verbally.

893
00:45:47,570 --> 00:45:49,790
我可以将它们视为字符串，因为字符串
I can think of them as strings, because string

894
00:45:49,789 --> 00:45:53,149
在许多不同的编程语言中都是一回事。
is a thing in many different programming languages.

895
00:45:53,150 --> 00:45:56,070
但是默认情况下，在C中，它根本不作为类型存在。
But by default, in C, it just doesn't exist as a type.

896
00:45:56,070 --> 00:45:59,750
取而代之的是，该类型有些隐晦地命名为char star。
Instead, the type is somewhat cryptically named, char star.

897
00:45:59,750 --> 00:46:02,839
但是，这再次说明，星星意味着这里是
But again, all that means is that the star means here's

898
00:46:02,840 --> 00:46:04,010
某物的地址。
the address of something.

899
00:46:04,010 --> 00:46:06,140
字符表示这是一个字符的地址。
Char means it's the address of a char.

900
00:46:06,139 --> 00:46:09,949
所以char star给你一个指针变量
So char star gives you a pointer variable

901
00:46:09,949 --> 00:46:12,719
这将指向一个角色。
that's going to point to a character.

902
00:46:12,719 --> 00:46:16,079
所以现在，如果s是，我实际上可以将其视为相同。
So now, if s is that, I can actually treat it the same.

903
00:46:16,079 --> 00:46:20,959
没有理由我不能继续使用s，就像第二周返回一个字符串一样，
There's no reason I can't keep using s like a string was back in week two,

904
00:46:20,960 --> 00:46:22,400
使用方括号表示法。
using our square bracket notation.

905
00:46:22,400 --> 00:46:24,770
而且我可以继续打印出HI感叹号
And I can keep printing out HI exclamation point

906
00:46:24,769 --> 00:46:27,319
使用相同的方括号语法。
using that same square bracket syntax.

907
00:46:27,320 --> 00:46:30,170
但是我还有另一种方法可以做到这一点。
But there's one other way I can do this.

908
00:46:30,170 --> 00:46:35,150
如果我现在知道s实际上只是一个地址，
If I now know that s is really just an address,

909
00:46:35,150 --> 00:46:37,760
我可以摆脱这种方括号表示法。
I can get rid of this square bracket notation.

910
00:46:37,760 --> 00:46:42,860
而且我实际上可以做star，因为还记得那颗star
And I can actually just do star s, because recall that star, in addition

911
00:46:42,860 --> 00:46:47,270
成为我们在此处声明指针时使用的新符号，
to being the new symbol that we use when declaring a pointer up here,

912
00:46:47,269 --> 00:46:50,989
它也是同一个符号，令人困惑，诚然，
it's also the same symbol, confusingly, admittedly,

913
00:46:50,989 --> 00:46:53,309
我们曾经去过一个地址。
that we used to go to an address.

914
00:46:53,309 --> 00:46:57,649
因此，如果s存储一个地址，根据定义它是一个指针，
So if s is storing an address, which it is by definition of being a pointer,

915
00:46:57,650 --> 00:46:59,900
star的意思是去那个地址。
star s means go to that address.

916
00:46:59,900 --> 00:47:02,000
根据我之前的照片，
And per my picture earlier, it would seem

917
00:47:02,000 --> 00:47:08,059
s很有可能是从0x123开始的地址。
to be the case that s is most likely at an address beginning at 0x123.

918
00:47:08,059 --> 00:47:10,249
在我这里的实际IDE中，它不会是一样的。
It's not going to be the same in my actual IDE here.

919
00:47:10,250 --> 00:47:12,167
这将是计算机要执行的所有操作。
It will be whatever the computer has ordained.

920
00:47:12,166 --> 00:47:14,609
但这将是完全相同的想法。
But it's going to be the same exact idea.

921
00:47:14,610 --> 00:47:17,150
因此，让我继续前进并前往星号。
So let me go ahead and go to star s.

922
00:47:17,150 --> 00:47:20,130
只是为了踢球，让我把它留在那一行。
And just for kicks, let me leave it as just that one line.

923
00:47:20,130 --> 00:47:23,870
因此，让我继续并将其作为make地址重新运行。
So let me go ahead and rerun this as make address.

924
00:47:23,869 --> 00:47:25,469
好的，现在是点斜杠地址。
All right, and now dot slash address.

925
00:47:25,469 --> 00:47:30,709
希望我应该看到一个大写的H而只有一个H。但是请注意这一点。
I should see, hopefully, a capital H and only an H. But watch this.

926
00:47:30,710 --> 00:47:34,400
如果我知道s（一个字符串）从技术上来说只是一个地址，
If I know that s, a string, is technically just an address,

927
00:47:34,400 --> 00:47:35,960
我现在实际上可以对此进行数学运算。
I can actually now do math on it.

928
00:47:35,960 --> 00:47:39,470
我可以继续打印出另一个字符，然后换行。
And I can go ahead and print out another character, followed by a new line.

929
00:47:39,469 --> 00:47:44,089
我可以去的不是s，而是s加1。
And I can go to, not s, but how about s plus 1.

930
00:47:44,090 --> 00:47:47,600
因此，如果可以的话，我可以对该指针执行一些非常简单的算术运算。
So I can do some very simple arithmetic, if you will, on that pointer.

931
00:47:47,599 --> 00:47:49,919
让我继续，现在重新编译它。
And let me go ahead and now recompile this.

932
00:47:49,920 --> 00:47:54,800
这样做地址，编译就可以了，点斜杠地址。
So make address, compiles OK, dot slash address.

933
00:47:54,800 --> 00:47:56,570
我应该看你好。
And I should see HI.

934
00:47:56,570 --> 00:48:01,790
如果我再做一行这样的代码，printf，％c，反斜杠n，
And if I do one more line of code like this, printf, percent c, backslash n,

935
00:48:01,789 --> 00:48:07,129
star s plus 2，我现在可以去找角色
star s plus 2, I can now go to the character

936
00:48:07,130 --> 00:48:10,770
与s相距两个字节
that is two bytes away from whatever s is,

937
00:48:10,769 --> 00:48:12,479
再次，它是字符串的开头。
which again, is the start of the string.

938
00:48:12,480 --> 00:48:15,890
所以现在，我用感叹号字符重印了HI
So now, I've reprinted HI with the exclamation point character

939
00:48:15,889 --> 00:48:19,279
按字符，但不使用此花括号
by character, but not by using this fancy square bracket

940
00:48:19,280 --> 00:48:24,710
表示法，只是在某种意义上看上它对我们来说是一种抽象，
notation, fancy only in the sense that it was sort of an abstraction for us,

941
00:48:24,710 --> 00:48:25,670
如果可以的话。
if you will.

942
00:48:25,670 --> 00:48:28,885
我实际上是在处理s的实际含义，这只是一个地址。
I'm instead, manipulating s for what it really is, which is just an address.

943
00:48:28,885 --> 00:48:31,010
所以在这里，我之前也用过这个词，
And so here, too, and I've used this phrase before,

944
00:48:31,010 --> 00:48:33,710
我们在第二周引入的方括号符号
that square bracket notation that we introduced in week two,

945
00:48:33,710 --> 00:48:36,410
从技术上讲只是语法糖。
is technically just syntactic sugar.

946
00:48:36,409 --> 00:48:39,499
它没有做任何根本不同的事情
It's not doing anything fundamentally different

947
00:48:39,500 --> 00:48:42,770
来自这些星号和这些地址。
from these asterisks and these addresses.

948
00:48:42,769 --> 00:48:45,439
老实说，它只是以一种更加友好的方式进行操作。
It's just doing it, honestly, in a much more user-friendly way.

949
00:48:45,440 --> 00:48:49,160
我个人还是比较喜欢第二周的方括号表示法。
I still prefer, personally, the square bracket notation from week two.

950
00:48:49,159 --> 00:48:54,679
但这与使用恒星并自己进行数学运算是一样的。
But it's the same thing as using the star and doing this math yourself.

951
00:48:54,679 --> 00:48:57,019
因此，C只是为我们提供了这一方便的功能
So C is just providing us with this handy feature

952
00:48:57,019 --> 00:49:00,199
使用方括号来完成所有这些所谓的指针
of using square brackets that does all of this so-called pointer

953
00:49:00,199 --> 00:49:02,359
为您算术。
arithmetic for you.

954
00:49:02,360 --> 00:49:04,290
但是再次，我们将要达到这个低水平
But again, we're going to this low level just

955
00:49:04,289 --> 00:49:10,309
强调这到底是怎么回事。
to emphasize what it is that's going on ultimately underneath the hood here.

956
00:49:10,309 --> 00:49:13,069
好吧，让我在这里停留任何疑问。
All right, let me pause here for any questions.

957
00:49:13,070 --> 00:49:17,290
还有Brian，请随时对您的任何内容进行口头表达。
And Brian, please do feel free to verbalize any on your end.

958
00:49:17,289 --> 00:49:19,789
布莱恩：我看到一个关于将会发生什么的问题
BRIAN: I see a question that came in about what would happen

959
00:49:19,789 --> 00:49:22,232
如果您尝试打印star s plus 3。
if you tried to print star s plus 3.

960
00:49:22,233 --> 00:49:25,400
大卫·马兰（David MALAN）：因此，我很确定这将打印出nul字符。
DAVID MALAN: So I'm pretty sure that's going to print out the nul character.

961
00:49:25,400 --> 00:49:27,233
但是，让我们继续在这里进行确认，
But let's go ahead and confirm as much here,

962
00:49:27,233 --> 00:49:31,760
百分比c反斜杠n星s加3。
percent c backslash n star s plus 3.

963
00:49:31,760 --> 00:49:35,120
好吧，我这里有点冒险
All right, I'm getting a little adventurous here

964
00:49:35,119 --> 00:49:38,059
通过看我可能不应该看的东西，因为那是
by looking at things I maybe shouldn't be looking at, because that's

965
00:49:38,059 --> 00:49:39,544
低级实施细节。
a low level implementation detail.

966
00:49:39,545 --> 00:49:40,670
但是，让我们看看会发生什么。
But let's see what happens.

967
00:49:40,670 --> 00:49:43,130
它会编译OK，点斜杠地址。
It compiles OK, dot slash address.

968
00:49:43,130 --> 00:49:44,780
它似乎是空白。
And it seems to be blank.

969
00:49:44,780 --> 00:49:46,730
现在，也许这就是nul角色。
Now, maybe that's the nul character.

970
00:49:46,730 --> 00:49:48,980
老实说，这并不是要成为可打印的字符。
Honestly, it's not meant to be a printable character.

971
00:49:48,980 --> 00:49:52,770
这个特殊的哨兵值表示字符串的结尾。
It's this special sentinel value that indicates the end of the string.

972
00:49:52,769 --> 00:49:54,019
但是我可以做到这一点。
But I could do this.

973
00:49:54,019 --> 00:49:57,169
我从第二周开始就知道char是整数
I know from week two that chars are integers

974
00:49:57,170 --> 00:49:59,670
如果我想用整数的话，整数就是字符。
and integers are chars if I want to think of them that way.

975
00:49:59,670 --> 00:50:01,880
所以让我只更改最后一个字符
So let me change only the very last character

976
00:50:01,880 --> 00:50:03,950
使用格式代码百分比i。
to use the format code percent i.

977
00:50:03,949 --> 00:50:05,689
让我重新编译我的代码。
Let me recompile my code.

978
00:50:05,690 --> 00:50:07,940
让我继续说一下地址。
Let me go ahead and run address.

979
00:50:07,940 --> 00:50:11,540
和瞧，HI感叹号0。
And voila, HI exclamation 0.

980
00:50:11,539 --> 00:50:16,399
而且这里所有的0位都表示为一个十进制数字
And there is the all 0 bits represented here as one single decimal digit thanks

981
00:50:16,400 --> 00:50:17,570
占百分之一
to percent i.

982
00:50:17,570 --> 00:50:19,970
现在，我可以在这里变得非常疯狂。
Now, I can get really crazy here.

983
00:50:19,969 --> 00:50:23,419
为什么我们不继续打印出不只是什么字符
And why don't we go ahead and print out not just what characters

984
00:50:23,420 --> 00:50:28,580
就在此序列之后，HI感叹号nul字符，
are right after this sequence, HI exclamation point nul character,

985
00:50:28,579 --> 00:50:33,769
我们为什么不去-哦，该如何处理1000字节的距离，
why don't we go to-- oh heck, how about address 1,000 bytes away,

986
00:50:33,769 --> 00:50:35,989
并真的让我的计算机内管闲事？
and really get nosy inside of my computer?

987
00:50:35,989 --> 00:50:38,449
让我重新编译该点斜杠地址。
Let me recompile that dot slash address.

988
00:50:38,449 --> 00:50:40,459
好吧，那边什么都没有发生。
OK, nothing really going on over there.

989
00:50:40,460 --> 00:50:42,620
大约10,000个字节如何？
How about 10,000 bytes away?

990
00:50:42,619 --> 00:50:44,269
让我继续发言。
Let me go ahead and make address.

991
00:50:44,269 --> 00:50:47,989
让我继续运行此细分错误。好的
Let me go ahead and run this segmentation fault. All, right

992
00:50:47,989 --> 00:50:49,009
那很糟。
that's bad.

993
00:50:49,010 --> 00:50:53,030
您可能是幸运的少数人，之前也曾见过此错误
And you might be among the fortunate few who have seen this error before

994
00:50:53,030 --> 00:50:54,440
通过触摸内存，您不应该这样做。
by touching memory you shouldn't.

995
00:50:54,440 --> 00:50:56,607
今天，我们将故意考虑这一点。
And we're going to deliberately consider this today.

996
00:50:56,606 --> 00:50:59,539
但是，细分错误实际上意味着您已经做了一些事情
But a segmentation fault, indeed, means that you have done something

997
00:50:59,539 --> 00:51:01,429
错误的代码中的某个地方。
wrong somewhere in your code.

998
00:51:01,429 --> 00:51:03,999
这往往意味着您触及了一段内存
And it tends to mean that you touched a segment of memory

999
00:51:04,000 --> 00:51:05,000
你不应该拥有的
that you shouldn't have.

1000
00:51:05,000 --> 00:51:08,750
老实说，我没事，要看10,000个字节
And I have no business, honestly, looking 10,000 bytes away

1001
00:51:08,750 --> 00:51:11,419
从我知道的内存中属于字符串。
from the memory that I know belongs to the string.

1002
00:51:11,420 --> 00:51:14,670
就像随意查看计算机内存中的任何地方，
That's like arbitrarily looking anywhere in your computer's memory,

1003
00:51:14,670 --> 00:51:16,890
看来，这可能不是一个好主意。
which probably, it seems, is not a good idea.

1004
00:51:16,889 --> 00:51:18,999
但是更多的只是一点点。
But more on that in just a bit.

1005
00:51:19,000 --> 00:51:21,470
现在，让我们考虑一下其中的一些含义
So let's consider, now, some of the implications

1006
00:51:21,469 --> 00:51:25,129
这些基本的实施细节
of these underlying implementation details

1007
00:51:25,130 --> 00:51:28,580
再考虑一下，从上周开始，为什么我们做了一些事情
and consider, now, from last week, why we did a few things the way

1008
00:51:28,579 --> 00:51:30,589
实际上，我们在过去几周中做到了。
we did in the past few weeks, in fact.

1009
00:51:30,590 --> 00:51:32,360
因此，string只是一个char明星。
So string is just a char star.

1010
00:51:32,360 --> 00:51:33,860
现在，让我们考虑一个示例。
And let's, now, consider an example.

1011
00:51:33,860 --> 00:51:37,260
让我放大自己的记忆，这样我就可以一次添加更多内容。
Let me zoom out on my memory, just so I can cram more in at once.

1012
00:51:37,260 --> 00:51:39,620
让我们考虑一个我可能想写的例子
Let's consider an example where I might want to write

1013
00:51:39,619 --> 00:51:42,569
比较两个字符串的程序。
a program that compares two strings.

1014
00:51:42,570 --> 00:51:45,830
这次，让我继续在新文件中编写一些新代码，
Let me go ahead and write some new code here in a new file this time,

1015
00:51:45,829 --> 00:51:48,349
例如，称为compare.c。
called, for instance, compare.c.

1016
00:51:48,349 --> 00:51:50,479
很简单，我对该程序的目标是
My goal with this program, quite simply, is

1017
00:51:50,480 --> 00:51:55,580
将会打印出内容-或进行比较
going to be to print out the contents of-- or rather to compare

1018
00:51:55,579 --> 00:51:57,589
用户可能输入的两个字符串。
two strings that the user might input.

1019
00:51:57,590 --> 00:52:00,040
我将继续进行，并包含cs59.h，
I'm going to go ahead and include cs59.h,

1020
00:52:00,039 --> 00:52:02,809
不是因为我想再说一遍字符串，
not because I want string, per say, anymore,

1021
00:52:02,809 --> 00:52:05,749
但是因为我想使用get string只是为了方便。
but because I want to use get string just for convenience.

1022
00:52:05,750 --> 00:52:08,180
但是，我们也会暂时取消该训练轮。
But we'll take that training wheel off in a bit, too.

1023
00:52:08,179 --> 00:52:10,519
在这个程序中，我将继续进行
And in this program, I'm going to go ahead and first

1024
00:52:10,519 --> 00:52:11,689
使用，尚未获取字符串。
use, not get string yet.

1025
00:52:11,690 --> 00:52:14,450
让我继续保持简单，从get int开始。
Let me go ahead and keep it simple and start with get int.

1026
00:52:14,449 --> 00:52:16,909
我会问用户一个变量i。
And I'll ask the user for a variable i.

1027
00:52:16,909 --> 00:52:19,339
然后让我再做一个int并问
And let me do another one of these in get int and ask

1028
00:52:19,340 --> 00:52:21,270
用户输入j的值。
the user for a value for j.

1029
00:52:21,269 --> 00:52:24,664
然后让我继续简单地说，如果我等于j，
And then let me go ahead and quite simply say, if i equals equals j,

1030
00:52:24,664 --> 00:52:28,789
然后继续打印其他内容。
then go ahead and print out same else.

1031
00:52:28,789 --> 00:52:31,769
让我继续打印不同的内容。
Let me go ahead and print out different.

1032
00:52:31,769 --> 00:52:35,929
因此，这是第一周的工作，我在其中使用了两个变量。
So this is week one stuff, where I'm using a couple of variables.

1033
00:52:35,929 --> 00:52:38,299
我正在使用带有两个分支的条件
I'm using a condition with two branches, and I'm

1034
00:52:38,300 --> 00:52:42,990
使用printf打印出两个变量i和j是否相同。
using printf to print out whether those two variables, i and j, are the same.

1035
00:52:42,989 --> 00:52:44,929
因此，让我们继续进行编译。
So let's go ahead and compile this.

1036
00:52:44,929 --> 00:52:45,949
一切都很好。
All is well.

1037
00:52:45,949 --> 00:52:49,309
运行比较，然后让我给数字1和2。
Run compare, and let me give it digits 1 and 2.

1038
00:52:49,309 --> 00:52:50,629
实际上，它们是不同的。
And indeed, they're different.

1039
00:52:50,630 --> 00:52:53,400
让我继续给它1和1，它们是相同的。
And let me go ahead and give it 1 and 1, and they're the same.

1040
00:52:53,400 --> 00:52:56,270
因此，我认为从逻辑上讲可以通过示例进行证明，如果您愿意，
So I think, logically, proof by example, if you will,

1041
00:52:56,269 --> 00:52:57,859
这个程序看起来正确。
this program looks correct.

1042
00:52:57,860 --> 00:53:02,630
但是让我通过不使用整数来快速使它看起来不正确。
But let me quickly make it seemingly uncorrect, by not using integers.

1043
00:53:02,630 --> 00:53:05,840
但是，通过使用字符串代替。
But how about, by using strings instead.

1044
00:53:05,840 --> 00:53:07,988
让我继续，给我自己一个字符串。
Let me go ahead and give myself a string.

1045
00:53:07,987 --> 00:53:10,279
虽然，不，我不再需要该训练轮。
Although, no, I don't need that training wheel anymore.

1046
00:53:10,280 --> 00:53:15,300
让我们做char star s equals获得s的字符串。
Let's just do char star s equals get string of s.

1047
00:53:15,300 --> 00:53:17,300
但是再说一次，即使我称它为char star，
But again, even though I'm calling it char star,

1048
00:53:17,300 --> 00:53:19,580
仍然像几周前一样。
it's still a string like it was weeks ago.

1049
00:53:19,579 --> 00:53:23,509
让我给自己另一个字符串t，以保持名称简短。
Let me give myself another string called t, just to keep the name short.

1050
00:53:23,510 --> 00:53:25,100
s会得到-
And s will get--

1051
00:53:25,099 --> 00:53:26,729
t将在那里获得该值。
t will get that value there.

1052
00:53:26,730 --> 00:53:30,140
而且让我只是，非常幼稚，但有一点合理，
And let me just, very naively but kind of reasonably,

1053
00:53:30,139 --> 00:53:34,309
假设s等于t，让我们继续打印出来。
say if s equals equals t, let's go ahead and print out same.

1054
00:53:34,309 --> 00:53:37,999
否则，让我们继续进行打印。
And otherwise, let's go ahead and print out different.

1055
00:53:38,000 --> 00:53:41,240
因此，相同的确切代码，只是不同的数据类型，并且使用
So same exact code, just different data types, and using

1056
00:53:41,239 --> 00:53:42,829
获取字符串而不是获取整数。
get string instead of get int.

1057
00:53:42,829 --> 00:53:47,359
让我继续进行比较，似乎可以编译好了，点斜杠进行比较。
Let me go ahead and make compare, seems to compile OK, dot slash compare.

1058
00:53:47,360 --> 00:53:51,770
让我继续输入HI！-
Let me go ahead and type in HI!--

1059
00:53:51,769 --> 00:53:53,569
哇，嗨！
woops, HI!.

1060
00:53:53,570 --> 00:53:55,220
让我继续输入HI！再次。
Let me go ahead and type in HI! again.

1061
00:53:55,219 --> 00:53:57,499
和瞧，不同。
And voila, different.

1062
00:53:57,500 --> 00:54:01,009
而且我忘记了反斜杠n，但这似乎是我遇到的最少问题。
And I forgot my backslash n's, but that seems to be the least of my problems.

1063
00:54:01,010 --> 00:54:05,240
让我重新编译一下，进行比较，现在，让我再次运行它。
Let me recompile this, make compare, and now, let me run it again.

1064
00:54:05,239 --> 00:54:07,129
怎么样，让我们做一个快速测试。
How about, let's do a quick test.

1065
00:54:07,130 --> 00:54:09,010
大卫，布莱恩，这些绝对不同。
David, Brian, these are definitely different.

1066
00:54:09,010 --> 00:54:09,580
好好
OK, good.

1067
00:54:09,579 --> 00:54:11,239
因此，该程序似乎可以正常工作。
So the program seems to work.

1068
00:54:11,239 --> 00:54:13,149
大卫，大卫呢？
How about David, David?

1069
00:54:13,150 --> 00:54:14,140
也不同。
Also different.

1070
00:54:14,139 --> 00:54:15,369
，让我再试一次。
Huh, let me try again.

1071
00:54:15,369 --> 00:54:18,599
布莱恩，布莱恩，也有所不同。
Brian, Brian, also different.

1072
00:54:18,599 --> 00:54:21,569
但是我很确定那些字符串是相同的。
But I'm pretty sure those strings are the same.

1073
00:54:21,570 --> 00:54:24,180
为什么该程序有缺陷？
Why might this program be flawed?

1074
00:54:24,179 --> 00:54:28,581
此程序现在有什么问题？
What is wrong with this program right now?

1075
00:54:28,581 --> 00:54:30,289
布莱恩：聊天中的几个人
BRIAN: A couple of people in the chat are

1076
00:54:30,289 --> 00:54:32,749
说我们实际上不是在比较字符，
saying that we're not actually comparing the characters,

1077
00:54:32,750 --> 00:54:34,370
我们正在比较地址。
we're comparing the addresses.

1078
00:54:34,369 --> 00:54:37,376
戴维·马兰（David MALAN）：是的，这是今天的逻辑结论
DAVID MALAN: Yeah, so that's sort of the logical conclusion from today's

1079
00:54:37,376 --> 00:54:38,959
字符串真正是什么的定义。
definition of what a string really is.

1080
00:54:38,960 --> 00:54:41,750
如果字符串只是其第一个字符的地址，
If a string is just the address of its first character,

1081
00:54:41,750 --> 00:54:44,450
那么如果您实际上是在做s等于t，
then if you're literally doing s equals equals t,

1082
00:54:44,449 --> 00:54:46,696
您正在比较这两个地址。
you're comparing those two addresses.

1083
00:54:46,697 --> 00:54:48,530
他们可能会有所不同，
And they are probably going to be different,

1084
00:54:48,530 --> 00:54:50,990
即使我输入相同的内容，因为每次
even if I type in the same thing, because every time we've

1085
00:54:50,989 --> 00:54:55,009
称为get int或get string，有点用户的输入
called get int or get string, it's kind of plopped the user's input

1086
00:54:55,010 --> 00:54:56,750
在我计算机内存中的某个位置。
somewhere in my computer's memory.

1087
00:54:56,750 --> 00:55:00,560
但说实话，我们现在有了工具来回答这个问题或审查这个回答
But we now have the tools, honestly, to answer this or vet this answer

1088
00:55:00,559 --> 00:55:01,129
我们自己。
ourselves.

1089
00:55:01,130 --> 00:55:03,230
让我继续简化此程序。
Let me go ahead and simplify this program.

1090
00:55:03,230 --> 00:55:06,050
然后，就像快速进行健全性检查一样，打印出s。
And let's, just as a quick sanity check, print out s.

1091
00:55:06,050 --> 00:55:10,610
让我们继续，并在每行之后使用新行打印出来，
And let's go ahead and print out t using a new line after each,

1092
00:55:10,610 --> 00:55:12,350
以便我们可以看到字符串是什么。
just so we can see what the strings are.

1093
00:55:12,349 --> 00:55:16,829
因此，让我继续进行此操作，进行比较，编译正常，点斜杠
So let me go ahead and do this again, make compare, compiles OK, dot slash

1094
00:55:16,829 --> 00:55:17,329
比较。
compare.

1095
00:55:17,329 --> 00:55:19,309
我输入HI，HI。
Let me type in HI, HI.

1096
00:55:19,309 --> 00:55:21,709
它们看起来在视觉上是相同的。
And they seem to be visually the same.

1097
00:55:21,710 --> 00:55:24,770
但是回想一下，现在，我还有其他格式的代码，
But recall that, now, I have this other format code,

1098
00:55:24,769 --> 00:55:27,079
这样我现在就可以开始处理弦乐了
such that I can now start treating strings

1099
00:55:27,079 --> 00:55:29,329
作为技术上的地址。
as the addresses they technically are.

1100
00:55:29,329 --> 00:55:33,139
因此，让我在两个地方将百分比s更改为百分比p。
So let me change percent s to percent p in both places.

1101
00:55:33,139 --> 00:55:37,609
然后让我重新编译程序，然后重新运行HI和HI。
Let me then recompile the program, and now, rerun compare with both HI and HI

1102
00:55:37,610 --> 00:55:38,690
完全相同的类型。
identically typed.

1103
00:55:38,690 --> 00:55:43,100
但是请注意，它们最终位于稍微不同的内存位置。
But notice, they've ended up at slightly different memory locations.

1104
00:55:43,099 --> 00:55:46,819
即使我碰巧键入了相同的内容，C和我的计算机
Even though I have coincidentally typed the same thing, C and my computer

1105
00:55:46,820 --> 00:55:52,097
不会太冒昧，以至于两个字符串都使用相同的字节。
are not going to be so presumptuous as to use the same bytes for both strings.

1106
00:55:52,097 --> 00:55:53,930
那不会给我太大的灵活性
That's not going to give me much flexibility

1107
00:55:53,929 --> 00:55:55,489
如果我想换一个。
if I want to change one or the other.

1108
00:55:55,489 --> 00:55:58,489
它将非常简单地将一个放入此内存中
It's going to very simplistically put one in this chunk of memory

1109
00:55:58,489 --> 00:56:00,239
另一个在此内存块中。
and the other in this chunk of memory.

1110
00:56:00,239 --> 00:56:03,679
实际上，这些地址分别是但任意地
And indeed, those addresses are respectively, but arbitrarily,

1111
00:56:03,679 --> 00:56:07,219
0x22fe670和0x22fe6b0。
0x22fe670 and 0x22fe6b0.

1112
00:56:09,769 --> 00:56:12,499
因此它们分散开了一段距离。
So they are spread apart some distance.

1113
00:56:12,500 --> 00:56:15,810
但是同样，这取决于计算机来决定将它们实际放置在何处。
But again, it's up to the computer to decide where to actually put those.

1114
00:56:15,809 --> 00:56:18,309
那么，计算机内存内部到底发生了什么？
So what's actually going on inside of the computer's memory?

1115
00:56:18,309 --> 00:56:22,009
好吧，让我们考虑一下，例如，这是我的指针，还是真的，
Well, let's consider if, for instance, this is s, my pointer, or really,

1116
00:56:22,010 --> 00:56:22,640
我的绳子。
my string.

1117
00:56:22,639 --> 00:56:23,809
但这只是一个指针。
But it's just a pointer now.

1118
00:56:23,809 --> 00:56:25,059
这是某物的地址。
It's the address of something.

1119
00:56:25,059 --> 00:56:28,249
请注意，我将其绘制为占用八个正方形，
Notice that I've drawn it as taking up eight squares,

1120
00:56:28,250 --> 00:56:31,680
因为同样，现代系统上的指针是八个字节。
because again, a pointer on modern systems is eight bytes.

1121
00:56:31,679 --> 00:56:33,319
这就是为什么这个东西这么大的原因。
So that's why this thing is so big.

1122
00:56:33,320 --> 00:56:37,100
同时，当我用感叹号输入HI之类的内容时，
Meanwhile, when I type in something like HI with the exclamation point,

1123
00:56:37,099 --> 00:56:38,719
然后它最终会出现在内存中的某个地方。
then it ends up somewhere in memory.

1124
00:56:38,719 --> 00:56:40,439
我们真的不知道也不在乎它在哪里。
We don't really know or care where it is.

1125
00:56:40,440 --> 00:56:42,773
因此，我们随便说一下它恰好在那儿结束了
So let's just arbitrarily say it happens to end up there

1126
00:56:42,773 --> 00:56:43,850
在我计算机的内存中。
in my computer's memory.

1127
00:56:43,849 --> 00:56:46,729
现在，这些字节中的每个字节当然都有一个地址。
Now, each of those bytes, of course, has an address.

1128
00:56:46,730 --> 00:56:48,950
我不一定知道或不在乎它们是什么。
I don't necessarily know or care what they are.

1129
00:56:48,949 --> 00:56:52,039
但是为了说明起见，让我们像以前一样对它们再次编号，
But for explanation's sake, let's just number them again like before,

1130
00:56:52,039 --> 00:56:56,809
0x123、0x124、0x125、0x126。
0x123, 0x124, 0x125, 0x126.

1131
00:56:56,809 --> 00:57:02,959
然后，当我在左侧分配s时，从右侧的get string中获取值，
When I then assign s on the left the value from get string on the right,

1132
00:57:02,960 --> 00:57:04,670
得到字符串，怎么办？
get string, what is it going to do?

1133
00:57:04,670 --> 00:57:07,640
好吧，自从第一周开始，所有的时间，因为您一直在使用它，
Well, all of this time since week one, since you've been using it,

1134
00:57:07,639 --> 00:57:11,969
是的，获取字符串并将其作为返回值返回给您。
it is, yes, getting a string and handing it back to you as a return value.

1135
00:57:11,969 --> 00:57:13,679
但这到底是什么意思？
But what does that really mean?

1136
00:57:13,679 --> 00:57:18,199
好吧，如果字符串只是一个地址，那么函数的返回值
Well, if a string is just an address, the return value of a function

1137
00:57:18,199 --> 00:57:23,029
就像获取字符串是要返回的，而不是字符串本身，因为那是
like get string is to return to, not the string per se, because that's

1138
00:57:23,030 --> 00:57:24,740
一种高级概念。
kind of a high level concept.

1139
00:57:24,739 --> 00:57:27,049
获取字符串一直为我们做的事情
What get string has always been doing for us

1140
00:57:27,050 --> 00:57:29,810
返回字符串的地址，或者更多
is returning the address of the string, or more

1141
00:57:29,809 --> 00:57:33,409
具体来说，是字符串中第一个字符的地址。
specifically, the address of the first character in the string.

1142
00:57:33,409 --> 00:57:39,739
因此，从技术上讲，要清楚地存储在s中的是该地址0x123。
And so what is technically stored in s, to be clear, is that address, 0x123.

1143
00:57:39,739 --> 00:57:43,399
它并没有返回到整个字符串，即H，I，感叹号。
It's not returning to the whole string, the H, the I, the exclamation point.

1144
00:57:43,400 --> 00:57:46,040
相反，它只是向您返回一个值。
Rather, it's returning just one value to you.

1145
00:57:46,039 --> 00:57:50,989
它仅向您返回该字符串的第一个字符的地址。
It's returning only to you the address of the first character of that string.

1146
00:57:50,989 --> 00:57:54,499
但是同样，这对于s来说都是非常好的。
But again, this is all very good for just s.

1147
00:57:54,500 --> 00:57:55,879
t怎么了？
What's going on with t?

1148
00:57:55,880 --> 00:57:58,910
t有点类似，因为我要再次调用get string。
t is kind of the same story, because I'm calling get string again.

1149
00:57:58,909 --> 00:58:02,389
t将被分配第一个字符的地址
t is going to get assigned the address of the first character

1150
00:58:02,389 --> 00:58:03,499
此版本的HI。
of this version of HI.

1151
00:58:03,500 --> 00:58:13,160
我们随便说一下它是0x456、0x457、0x458和0x459。
And let's just arbitrarily say it's at 0x456, 0x457, 0x458, and 0x459.

1152
00:58:13,159 --> 00:58:16,872
此时，t将取值为0x456。
And at this point, t is going to take on the value of 0x456.

1153
00:58:16,873 --> 00:58:19,790
现在，老实说，到这一点，我们真的进入了杂草丛生。
And now, at this point, honestly, we're really getting into the weeds.

1154
00:58:19,789 --> 00:58:21,664
让我们开始将所有这些抽象出来
Let's just start abstracting all of this away

1155
00:58:21,664 --> 00:58:23,869
并使用箭头指向这些值。
and use arrows to point at the values.

1156
00:58:23,869 --> 00:58:26,719
实际上，这些箭头仅代表指针
And indeed, these arrows just represent pointers

1157
00:58:26,719 --> 00:58:29,189
当我们不再关心特定的地址时。
when we stop caring about the particular addresses.

1158
00:58:29,190 --> 00:58:32,300
所以s实际上只是一个指针，一个变量指向
So s is really just a pointer, a variable pointing

1159
00:58:32,300 --> 00:58:34,070
在这里HI的第一个字符处。
at the first character of HI here.

1160
00:58:34,070 --> 00:58:38,490
t只是指向HI的第一个字符的变量。
t is just a variable pointing at the first character of HI there.

1161
00:58:38,489 --> 00:58:41,539
因此，当您比较两个字符串时
And so when you are comparing two strings

1162
00:58:41,539 --> 00:58:45,439
就像我以前在程序的早期版本中一样，
as I was before in the earlier version of my program,

1163
00:58:45,440 --> 00:58:53,540
在检查s是否等于t的地方，的确是在比较s和t。
where I was checking if s equals equals t, I was, indeed, comparing s and t.

1164
00:58:53,539 --> 00:58:55,129
s和t是什么？
What are s and t?

1165
00:58:55,130 --> 00:59:01,640
s和t分别是0x123和0x456，
s and t, respectively, are 0x123 and 0x456,

1166
00:59:01,639 --> 00:59:03,769
或实际值是多少
or whatever the actual values happen to be,

1167
00:59:03,769 --> 00:59:06,319
这不会是相同的，因为它们发生了
which are not going to be the same because they happen

1168
00:59:06,320 --> 00:59:09,920
指向不同的内存块。
to point to different chunks of memory.

1169
00:59:09,920 --> 00:59:12,110
好吧，谁在乎？
All right, well who cares?

1170
00:59:12,110 --> 00:59:14,630
这是一种很好的智力练习。
This is all kind of a nice intellectual exercise.

1171
00:59:14,630 --> 00:59:15,512
但谁在乎？
But who cares?

1172
00:59:15,512 --> 00:59:16,970
那么，我们如何解决这个问题呢？
Well, how do we solve this problem?

1173
00:59:16,969 --> 00:59:20,479
让我们考虑一下我在上一个演示中的实际操作。
Let's consider what I actually did in a previous demo.

1174
00:59:20,480 --> 00:59:23,955
我有点抢先提到了这个功能，字符串比较，
I sort of preemptively mentioned that there's this function, string compare,

1175
00:59:23,954 --> 00:59:25,579
可以比较两个字符串。
that allows you to compare two strings.

1176
00:59:25,579 --> 00:59:28,039
我保证我们最终会解释
And I promised that we would eventually explain

1177
00:59:28,039 --> 00:59:31,572
为什么我们使用str compare而不是仅使用等号。
why we use str compare as opposed to just using the equal equal sign.

1178
00:59:31,572 --> 00:59:33,739
好吧，要使用此功能，我将需要添加
Well, to use this function, I'm going to need to add

1179
00:59:33,739 --> 00:59:37,909
大约每时每刻在string.h中。
in string.h up here per lat time.

1180
00:59:37,909 --> 00:59:40,789
但是，如果字符串比较st，让我继续进行重新编译，
But if string compare s t, let me go ahead and recompile this,

1181
00:59:40,789 --> 00:59:43,159
比较点斜线比较。
compare dots slash compare.

1182
00:59:43,159 --> 00:59:45,709
现在，让我输入HI！和嗨！同样。
Now, let me type HI! and HI! identically.

1183
00:59:45,710 --> 00:59:47,870
现在，它们似乎仍然不同。
Now, they still seem to be different.

1184
00:59:47,869 --> 00:59:51,679
该死的，我犯了和上次一样的愚蠢错误。
And dammit, I made the same stupid mistake as I did last time.

1185
00:59:51,679 --> 00:59:57,169
有谁知道我在比较两个字符串时犯了什么错误？
Does anyone know what mistake I made when comparing two strings?

1186
00:59:57,170 --> 01:00:00,590
我似乎以某种方式非常善于犯这个错误。
Somehow I seem to be very good at making this mistake.

1187
01:00:00,590 --> 01:00:03,440
布莱恩：易卜拉欣建议您添加一个相等的零。
BRIAN: Ibrahim is suggesting that you add an equal equal zero.

1188
01:00:03,440 --> 01:00:04,398
戴维·马兰：谢谢。
DAVID MALAN: Thank you.

1189
01:00:04,398 --> 01:00:05,390
易卜拉欣说得很对。
Ibrahim is quite right.

1190
01:00:05,389 --> 01:00:07,999
str比较的返回值，回想，
The return value, recall, of str compare,

1191
01:00:08,000 --> 01:00:13,040
如果相同，则返回0；如果相同，则返回负数
is to return 0 if they're the same, a negative number if one comes

1192
01:00:13,039 --> 01:00:16,429
在另一个之前，如果一个在另一个之后，则为正数，
before the other, and a positive number if one comes after the other,

1193
01:00:16,429 --> 01:00:18,599
如ASCIIbetical顺序。
as in ASCIIbetical order.

1194
01:00:18,599 --> 01:00:21,439
所以上次和这次我应该做的，
So what I should have done, both last time and this time,

1195
01:00:21,440 --> 01:00:23,600
是检查是否等于0。
is check for equality with 0.

1196
01:00:23,599 --> 01:00:26,219
让我继续并重新编译该程序。
Let me go ahead and recompile this program.

1197
01:00:26,219 --> 01:00:27,049
好好
OK, good.

1198
01:00:27,050 --> 01:00:29,090
现在，让我用HI重新运行该程序！
Now, let me rerun this program with HI!

1199
01:00:29,090 --> 01:00:30,230
两次。
twice.

1200
01:00:30,230 --> 01:00:31,940
瞧，他们是一样的。
Voila, they're the same.

1201
01:00:31,940 --> 01:00:34,580
只是为了确保，让我再做一次检查。
And just to make sure, let me do one other check.

1202
01:00:34,579 --> 01:00:38,809
让我来做大卫和布莱恩，这的确应该有所不同。
Let me do David and Brian, which should be, indeed, different.

1203
01:00:38,809 --> 01:00:42,049
因此，现在再说一次，我与上次没有做任何不同的事情。
So now, again, I haven't really done anything different from that last time.

1204
01:00:42,050 --> 01:00:47,420
但是我现在正在考虑这些字符串从根本上说只是
But I'm now thinking about these strings as being fundamentally just

1205
01:00:47,420 --> 01:00:48,173
他们的地址。
their addresses.

1206
01:00:48,172 --> 01:00:50,089
因此，现在，让我们将其与实际联系起来。
And so, now, let's make this actually germane.

1207
01:00:50,090 --> 01:00:52,160
让我继续创建一个新文件。
Let me go ahead and create a new file altogether.

1208
01:00:52,159 --> 01:00:56,589
并且，让我们相当合理地尝试复制一个字符串并对其进行更改。
And let's, pretty reasonably, try to copy one string and make changes to it.

1209
01:00:56,590 --> 01:00:57,840
所以我要在这里继续。
So I'm going to go ahead here.

1210
01:00:57,840 --> 01:01:00,230
为了方便起见，我将继续使用CS50库，
And just for convenience, I'm going to still use the CS50 library,

1211
01:01:00,230 --> 01:01:02,300
不是用于字符串数据类型，而是用于
not for the string data type, but just for the

1212
01:01:02,300 --> 01:01:06,200
获取字符串函数，我们将看到它比其他东西更方便-
get string function, which we'll see is more handy than other things--

1213
01:01:06,199 --> 01:01:07,789
比其他的做事方式。
than other ways of doing things.

1214
01:01:07,789 --> 01:01:11,629
我将继续介绍标准io点h。
And I'm going to go ahead and include standard io dot h.

1215
01:01:11,630 --> 01:01:17,450
我将继续介绍string.h。
And I'm going to go ahead and include, how about, string.h.

1216
01:01:17,449 --> 01:01:19,999
让我继续做int main void。
Let me go ahead and do int main void.

1217
01:01:20,000 --> 01:01:22,790
让我继续前进，在这个程序中，让自己成为一个字符串。
And let me go ahead, in this program, and get myself a string.

1218
01:01:22,789 --> 01:01:24,539
但是请注意，我们不再将其称为字符串。
But note, we won't call it string anymore.

1219
01:01:24,539 --> 01:01:26,029
我们就称它为char star。
We'll just call it char star.

1220
01:01:26,030 --> 01:01:28,380
因此，再次开始脱下训练轮。
So again, start taking off that training wheel.

1221
01:01:28,380 --> 01:01:31,312
我将继续获取名为s的字符串。
And I'm going to go ahead and get a string called s.

1222
01:01:31,311 --> 01:01:33,019
然后我将获得另一个字符串。
And then I'm going to get another string.

1223
01:01:33,019 --> 01:01:34,061
但我不会这样称呼。
But I won't call it that.

1224
01:01:34,061 --> 01:01:36,229
我称它为char star t。
I'll call it char star t.

1225
01:01:36,230 --> 01:01:37,400
我想复制s。
And I want to copy s.

1226
01:01:37,400 --> 01:01:40,790
因此，您可能会根据第一周，第二周以及自那以后的情况来考虑，
And so you might think, based on week one, week two, and since, that OK,

1227
01:01:40,789 --> 01:01:42,889
如果要复制变量，请执行此操作。
if you want to copy a variable, just do it.

1228
01:01:42,889 --> 01:01:44,689
我的意思是，我们使用了赋值运算符
I mean, we've used the assignment operator

1229
01:01:44,690 --> 01:01:48,530
将变量从右向左复制为整数，字符，
to copy a variable from right to left for integers, for chars,

1230
01:01:48,530 --> 01:01:50,600
对于其他数据类型，也许也是如此。
and for other data types, perhaps, too.

1231
01:01:50,599 --> 01:01:54,689
现在，我将继续进行操作，并对原始字符串进行更改。
I'm going to go ahead, now, and make a change to the original string.

1232
01:01:54,690 --> 01:01:56,270
因此，让我继续执行此操作。
So let me go ahead and do this.

1233
01:01:56,269 --> 01:02:01,279
让我继续说，让我们更改t的第一个字符
Let me go ahead and say, let's change the first character of t

1234
01:02:01,280 --> 01:02:02,780
大写。
to be uppercase.

1235
01:02:02,780 --> 01:02:04,940
回想一下，上面有这个功能，
Recall that there's this function, to upper,

1236
01:02:04,940 --> 01:02:09,170
它接受一个字符（例如t中的第一个字符）作为输入，
which takes, as input, a character, like the first character in t,

1237
01:02:09,170 --> 01:02:11,120
并返回大写版本。
and returns the uppercase version.

1238
01:02:11,119 --> 01:02:14,239
现在，要使用上层，我需要另一个头文件，
Now, to use to upper, I need another header file,

1239
01:02:14,239 --> 01:02:17,989
我从几周前回想起，现在我需要ctype.h。
which I recall from a couple of weeks ago now, I need ctype.h.

1240
01:02:17,989 --> 01:02:20,749
因此，让我抢先回去，把它放在那里。
So let me preemptively go back and put that there.

1241
01:02:20,750 --> 01:02:23,279
现在，让我继续打印这两个字符串。
And now, let me go ahead and print these two strings.

1242
01:02:23,280 --> 01:02:27,500
让我继续打印s为该百分比s。
Let me go ahead and print out s as being this percent s.

1243
01:02:27,500 --> 01:02:33,990
让我继续，用百分比s打印出t的值，如下所示。
And let me go ahead and print out the value of t with percent s as follows.

1244
01:02:33,989 --> 01:02:36,679
再说一遍，我正在做的是从用户那里得到一个字符串。
So again, what I'm doing is I'm getting a string from the user.

1245
01:02:36,679 --> 01:02:40,489
今天唯一的新事物是char star，它是string的同义词。
And the only new thing here is char star today, which is synonymous with string.

1246
01:02:40,489 --> 01:02:44,269
在这里的第10行，我从右到左复制字符串。
On line 10 here, I'm copying the string from right to left.

1247
01:02:44,269 --> 01:02:47,329
然后我只大写第一个字母
And then I'm capitalizing only the first letter

1248
01:02:47,329 --> 01:02:49,639
在副本中，也称为t。
in the copy, otherwise known as t.

1249
01:02:49,639 --> 01:02:51,139
然后我只是将两者都打印出来。
And then I'm just printing both out.

1250
01:02:51,139 --> 01:02:54,289
因此，让我继续进行复制，然后编译即可。
So let me go ahead and make copy, compiles OK.

1251
01:02:54,289 --> 01:02:56,509
制作警察-点斜线副本。
Make cop-- dot slash copy.

1252
01:02:56,510 --> 01:03:00,020
让我继续输入嗨！小写，全部小写，
Let me go ahead and type in hi! in lowercase, all lowercase,

1253
01:03:00,019 --> 01:03:00,919
然后输入。
and then enter.

1254
01:03:00,920 --> 01:03:03,830
瞧，呵呵。
And voila, huh.

1255
01:03:03,829 --> 01:03:10,759
似乎我以某种方式将S和T都大写，即使我只是
It would seem that I somehow capitalized both S and T, even though I only

1256
01:03:10,760 --> 01:03:17,080
任何想法都吸引到T. Brian的追捧
called to upper on T. Brian, any thoughts

1257
01:03:17,079 --> 01:03:24,819
关于为什么我会意外和错误地大写的内容
from the group on why I've accidentally and erroneously capitalized

1258
01:03:24,820 --> 01:03:26,260
两者都以某种方式？
both somehow?

1259
01:03:26,260 --> 01:03:29,735
布莱恩：有人说t只是s的别名。
BRIAN: A couple of people are saying that t is just an alias of s.

1260
01:03:29,735 --> 01:03:32,860
DAVID MALAN：只是s的别名，这是对它的合理思考，
DAVID MALAN: Just an alias of s, that's a reasonable way of thinking of it,

1261
01:03:32,860 --> 01:03:33,360
当然。
sure.

1262
01:03:33,360 --> 01:03:38,320
更准确地说，还有其他关于为什么这是不正确的想法吗？
And more precisely, any other thoughts on why this is incorrect somehow?

1263
01:03:38,320 --> 01:03:41,540
布莱恩：彼得现在建议他们使用相同的地址。
BRIAN: Peter is now suggesting that they have the same address.

1264
01:03:41,539 --> 01:03:45,879
DAVID MALAN：是的，更具体地说，我所做的只是将s复制到t中。
DAVID MALAN: So yeah, more specifically, all I've done is copy s into t.

1265
01:03:45,880 --> 01:03:48,040
但是再说一遍，今天是什么？
But again, what is s as of today?

1266
01:03:48,039 --> 01:03:49,389
这只是一个地址。
It's just an address.

1267
01:03:49,389 --> 01:03:51,039
是的，我已经复制了。
So yes, I have copied s.

1268
01:03:51,039 --> 01:03:54,819
但是我已经按原样复制了它，这意味着复制了它的地址0x123，
But I've copied it literally, which means copying its address, 0x123,

1269
01:03:54,820 --> 01:03:55,820
或它是什么。
or whatever it is.

1270
01:03:55,820 --> 01:04:01,180
然后在第12行上，请注意我正在通过大写字母来更改t。
And then on line 12, notice that I'm changing t by uppercasing it.

1271
01:04:01,179 --> 01:04:04,129
但是t与s位于相同的地址。
But t is at the same address of s.

1272
01:04:04,130 --> 01:04:08,130
所以说真的，我要在同一字符串中更改一个。
So really, I'm changing one in the same string.

1273
01:04:08,130 --> 01:04:10,630
因此，如果我们以计算机的内存来考虑这一点，
So if we think about this in terms of the computer's memory,

1274
01:04:10,630 --> 01:04:12,088
让我们考虑一下我刚刚做了什么。
let's consider what I've just done.

1275
01:04:12,088 --> 01:04:13,570
让我清除计算机的内存。
Let me clear the computer's memory.

1276
01:04:13,570 --> 01:04:15,290
让我像以前一样放下心来。
Let me put s down as before.

1277
01:04:15,289 --> 01:04:18,249
我打招呼！像以前一样下降，但是这次全部小写。
Let me put hi! down as before, but all lowercase this time.

1278
01:04:18,250 --> 01:04:23,320
回想一下，它可能是地址0x123、124、125和126。
And recall that it might be it addresses 0x123, 124, 125, and 126.

1279
01:04:23,320 --> 01:04:26,350
现在，如果我们从技术上考虑
And now, if we consider that s technically

1280
01:04:26,349 --> 01:04:29,739
包含第一个字符的地址0x123，
contains the address of that first character, 0x123,

1281
01:04:29,739 --> 01:04:34,959
然后我继续创建一个新变量t并给t赋s的值，
and I proceed to create a new variable, t, and assign t the value of s,

1282
01:04:34,960 --> 01:04:36,970
我必须从字面上接受该声明。
I got to take that statement literally.

1283
01:04:36,969 --> 01:04:39,669
我实际上只是在这里放0x123。
I'm literally just putting 0x123 here.

1284
01:04:39,670 --> 01:04:41,770
如果我们现在将这些细节抽象出来
And if we now abstract away these details just

1285
01:04:41,769 --> 01:04:44,019
为了从视觉上更清楚地说明正在发生的事情，
to make it more clear visually what's going on,

1286
01:04:44,019 --> 01:04:48,069
这就像说s和t都一样
that's pretty much like saying that both s and t point

1287
01:04:48,070 --> 01:04:49,750
到内存中的相同位置。
to the same location in memory.

1288
01:04:49,750 --> 01:04:52,297
是的，从这个意义上讲，t只是s的别名，
So yes, in that sense, t is just an alias for s,

1289
01:04:52,297 --> 01:04:54,130
这是一种合理的思考方式。
which is a reasonable way of thinking of it.

1290
01:04:54,130 --> 01:04:56,920
但是实际上，只是t与s相同。
But really, just t is identical to s.

1291
01:04:56,920 --> 01:04:59,110
因此，当您使用方括号表示法时
So when you use the square bracket notation

1292
01:04:59,110 --> 01:05:02,290
转到t的第一个字符，您等效
to go to the first character of t, you are equivalently

1293
01:05:02,289 --> 01:05:04,749
转到s中的第一个字符。
going to the first character in s.

1294
01:05:04,750 --> 01:05:06,199
他们是一样的。
They are one in the same.

1295
01:05:06,199 --> 01:05:10,389
因此，当我呼叫鞋面时，我会在这个角色上呼叫它，这当然是
So when I call to upper, I'm calling it on this character, which of course, is

1296
01:05:10,389 --> 01:05:12,969
故事中唯一的一个。
the one and only h in the story.

1297
01:05:12,969 --> 01:05:16,239
当我打印s并打印t时，printf为
And when I print s and I print t, printf is

1298
01:05:16,239 --> 01:05:18,609
跟随那些面包屑，如果您愿意的话，
following those same breadcrumbs, if you will,

1299
01:05:18,610 --> 01:05:24,070
并最终显示与更改相同的值。
and ultimately displaying the same value as having changed.

1300
01:05:24,070 --> 01:05:27,220
因此，我们似乎需要从根本上重新考虑
So we would seem to need to fundamentally rethink

1301
01:05:27,219 --> 01:05:28,989
我们如何复制字符串。
how we are copying strings.

1302
01:05:28,989 --> 01:05:34,299
让我问一下，如果这是将一个字符串复制到另一个字符串的错误方法，那是什么
And let me ask, if this is the wrong way to copy one string into the other, what

1303
01:05:34,300 --> 01:05:35,350
是正确的方法吗？
is the right way?

1304
01:05:35,349 --> 01:05:39,339
即使您没有头脑中的功能或正确的词汇，
Even if you don't have the functions in mind or the right vocabulary,

1305
01:05:39,340 --> 01:05:43,750
只是直觉上，如果我们想以人类将要复制的方式
just intuitively, , if we want to copy a string in the way that a human would

1306
01:05:43,750 --> 01:05:50,019
想到将一个副本复制到另一个副本中，例如照片或影印本，
think of copying one into the other, like a photograph or a photocopy,

1307
01:05:50,019 --> 01:05:52,609
我们要如何做到这一点？
how do we want to do this?

1308
01:05:52,610 --> 01:05:54,460
有什么想法吗，布莱恩？
Any thoughts, Brian?

1309
01:05:54,460 --> 01:05:57,430
布莱恩：是的，索菲亚建议我们以某种方式进行循环
BRIAN: Yeah, Sophia suggested we would want to somehow loop over

1310
01:05:57,429 --> 01:05:59,947
s中的元素并将其放入t。
the elements in s and put them into t.

1311
01:05:59,947 --> 01:06:01,239
戴维·马兰（David MALAN）：是的，我喜欢。
DAVID MALAN: Yeah, I like that.

1312
01:06:01,239 --> 01:06:04,119
因此，循环遍历s的元素并将其放入t。
So loop over the elements of s and put them into t.

1313
01:06:04,119 --> 01:06:05,799
因此，这听起来需要更多工作。
So it sounds like more work.

1314
01:06:05,800 --> 01:06:07,660
但这又是我们将要拥有的
But that's, again, what we're going to have

1315
01:06:07,659 --> 01:06:09,581
如果我们想考虑这些-
to do if we want to think of these--

1316
01:06:09,581 --> 01:06:12,789
如果我们要接受一个事实，即s和t只是地址，
if we want to accept the fact that these things, s and t, are just addresses,

1317
01:06:12,789 --> 01:06:15,549
我们现在必须去追踪那些面包屑。
we're going to now have to go and follow those breadcrumbs.

1318
01:06:15,550 --> 01:06:18,790
因此，让我们继续考虑该程序的变体。
So let's go ahead and consider a variant of this program.

1319
01:06:18,789 --> 01:06:24,519
让我继续，在这里，更改它，使我仍然得到字符串s。
Let me go ahead, here, and change this such that I'm still getting a string s.

1320
01:06:24,519 --> 01:06:28,389
但是现在，让我继续提出确切的建议，
But now, let me go ahead and propose exactly that,

1321
01:06:28,389 --> 01:06:30,339
我们复制单个字符。
that we copy the individual characters.

1322
01:06:30,340 --> 01:06:32,320
但是我需要将它们复制到某个地方。
But I need to copy them somewhere.

1323
01:06:32,320 --> 01:06:35,200
所以我觉得这是复制字符串过程中的又一步
So I feel like another step in this process of copying a string

1324
01:06:35,199 --> 01:06:37,749
必须给自己一些额外的记忆。
has to be to give myself some additional memory.

1325
01:06:37,750 --> 01:06:40,839
如果我有n个感叹号，
If I have H i exclamation point in nul character,

1326
01:06:40,840 --> 01:06:43,150
我现在需要以某种方式控制这种情况
I need to, now, somehow take control of this situation

1327
01:06:43,150 --> 01:06:48,320
并以某种方式告诉计算机，再给我四个字节的内存
and tell the computer somehow, in code, give me four more bytes of memory

1328
01:06:48,320 --> 01:06:53,390
这样我就可以在其中复制这些字符的位置。
so that I have location for t in which to copy those characters.

1329
01:06:53,389 --> 01:06:55,359
因此，今天有一个新功能。
So here's a new function today.

1330
01:06:55,360 --> 01:06:59,470
如果我想创建一个字符串t（今天又称为字符星），
If I want to create a string t, otherwise known today as a char star,

1331
01:06:59,469 --> 01:07:02,679
我们可以使用一个名为malloc的新函数
there is a new function we can use called malloc, which

1332
01:07:02,679 --> 01:07:04,719
表示内存分配。
represents memory allocation.

1333
01:07:04,719 --> 01:07:08,199
幸运的是，这是一个非常漂亮的函数，非常易于使用。
This is a pretty fancy function that, fortunately, is pretty simple to use.

1334
01:07:08,199 --> 01:07:10,389
它仅需要一个数字作为输入。
It takes, as input, just a number.

1335
01:07:10,389 --> 01:07:14,479
您要向计算机请求多少字节的内存？
How many bytes of memory do you want to ask the computer for?

1336
01:07:14,480 --> 01:07:16,000
那么我该怎么做呢？
So how do I do this?

1337
01:07:16,000 --> 01:07:20,110
好吧，我的感叹号为反斜杠0，我可以说四个。
Well, H i exclamation point backslash 0, I could literally just say four.

1338
01:07:20,110 --> 01:07:21,850
但这感觉并不动态。
But this doesn't feel very dynamic.

1339
01:07:21,849 --> 01:07:26,409
我想我可以以编程的方式更优雅地实现这一点。
I think I can programmatically implement this a little more elegantly.

1340
01:07:26,409 --> 01:07:30,369
让我继续说，给我尽可能多的字节
Let me go ahead and say, give me as many bytes

1341
01:07:30,369 --> 01:07:35,199
因为s中有字符加1。
as there are characters in s plus 1.

1342
01:07:35,199 --> 01:07:37,089
加1，为什么我要这样做？
Plus 1, why am I doing this?

1343
01:07:37,090 --> 01:07:40,773
好吧，我的感叹号是nul字符，从技术上讲
Well, H i exclamation point nul character, that's technically

1344
01:07:40,773 --> 01:07:42,190
存储在引擎盖下的东西。
what's stored underneath the hood.

1345
01:07:42,190 --> 01:07:45,250
但是您和我对Hi的长度有何看法？作为？
But what do you and I think of the length of Hi! as being?

1346
01:07:45,250 --> 01:07:48,069
好吧，在人类世界中，这很可能是我的感叹号。
Well, odds are, in the human world, it's H i exclamation point.

1347
01:07:48,070 --> 01:07:50,710
谁在乎这个低级的细节，这个nul终结者。
And who cares about this low level detail, this nul terminator.

1348
01:07:50,710 --> 01:07:53,800
您不要在英文单词或任何单词的长度中包含该单词。
You don't include that in the length of an English word or any word.

1349
01:07:53,800 --> 01:07:56,290
您只想到可以看到的实际字符。
You only think of the actual characters you can see.

1350
01:07:56,289 --> 01:08:00,579
因此，H的长度，我，感叹号3。
So the length of H, i, exclamation point 3.

1351
01:08:00,579 --> 01:08:08,109
但是我确实需要巧妙地为nul角色添加一口，第四口，
But I do need to cleverly add one more bite, a fourth, for the nul character,

1352
01:08:08,110 --> 01:08:10,580
因为我也必须将其复制过来。
because I'm going to have to copy that over as well.

1353
01:08:10,579 --> 01:08:13,269
否则，如果我没有相同的nul字符，
Otherwise, if I don't have an identical nul character,

1354
01:08:13,269 --> 01:08:15,829
t不会有明显的结局。
t is not going to have an obvious ending.

1355
01:08:15,829 --> 01:08:17,871
那么，现在如何将一个字符串复制到另一个字符串中？
So how do I copy, now, one string into the other?

1356
01:08:17,872 --> 01:08:20,538
好吧，让我继续前进，带走我们的老朋友for循环，
Well, let me go ahead and take out our old friend, the for loop,

1357
01:08:20,537 --> 01:08:21,379
从第一周开始。
from week one.

1358
01:08:21,380 --> 01:08:24,050
并说，因为我等于0-
And say, for i equals 0--

1359
01:08:24,050 --> 01:08:26,810
实际上，n等于s的字符串长度。
how about, actually, n equals string length of s.

1360
01:08:26,810 --> 01:08:28,279
我们以前做过这个技巧。
We've done this trick before.

1361
01:08:28,279 --> 01:08:33,080
我小于n，我++。
i is less than n, i++.

1362
01:08:33,079 --> 01:08:38,688
让我继续，很简单地说，说“括号i”得到“ s括号i”。
Let me go ahead and, quite simply, say t bracket i gets s bracket i.

1363
01:08:38,689 --> 01:08:43,939
因此，这将一次从s逐字复制每个字符
So this will literally copy, from s, each of the characters one at a time

1364
01:08:43,939 --> 01:08:45,020
到t
into t.

1365
01:08:45,020 --> 01:08:46,640
但是我现在需要变得更聪明。
But I need to be a little smarter now.

1366
01:08:46,640 --> 01:08:49,130
即使我们几乎总是使我小于n，
Even though we almost always do i less than n,

1367
01:08:49,130 --> 01:08:55,660
我实际上要非常积极地说我小于或等于n。
I'm actually going to very aggressively say i less than or equal to n.

1368
01:08:55,659 --> 01:08:56,829
为什么？
Why?

1369
01:08:56,829 --> 01:09:00,249
我为什么比我通常认为的要往前走一步
Why am I going one step further than I feel we normally

1370
01:09:00,250 --> 01:09:03,310
在遍历字符串时执行，比您更进一步
do when iterating over strings, and one step further than you

1371
01:09:03,310 --> 01:09:07,149
遍历凯撒密码或字符串时可能做过
probably did when iterating over a caesar cipher or a string

1372
01:09:07,149 --> 01:09:09,130
在那种情况下？
in that context?

1373
01:09:09,130 --> 01:09:10,939
布莱恩，这里有什么想法吗？
Brian, any thoughts here?

1374
01:09:10,939 --> 01:09:16,569
为什么我第一次从i小于或等于n开始？
Why am I going from i less than or equal to n kind of for the first time here?

1375
01:09:16,569 --> 01:09:19,779
布莱恩：西莉娜（Celina）建议我们将nul字符包括在内。
BRIAN: Celina is suggesting that we need to include the nul character.

1376
01:09:19,779 --> 01:09:22,843
戴维·马兰（David MALAN）：是的，如果我-现在，我了解字符串的工作原理。
DAVID MALAN: Yeah, so if I-- and now I understand how strings works.

1377
01:09:22,842 --> 01:09:25,509
因此仅复制H，I，感叹号是不够的。
So it's not sufficient to just copy the H, I, exclamation point.

1378
01:09:25,510 --> 01:09:29,020
我需要更进一步，比字符串的长度还要多。
I need to go one step further, one more than the length of the string.

1379
01:09:29,020 --> 01:09:32,290
最简单的方法是小于或等于n。
And the easiest way to do that would be less than or equal to n.

1380
01:09:32,289 --> 01:09:34,449
或者我可以在那里做一个加号1。
Or I could just do a plus 1 there.

1381
01:09:34,449 --> 01:09:35,949
或者，我可以通过多种方法来执行此操作。
Or I can do this any number of ways.

1382
01:09:35,949 --> 01:09:37,398
没关系，怎么做。
Doesn't matter how you do it.

1383
01:09:37,399 --> 01:09:40,899
但是我认为小于或等于是这样做的一种合理方法。
But I think a less than or equal to is one reasonable way to do it.

1384
01:09:40,899 --> 01:09:43,540
现在，让我们深入到这里，现在
And now, let's go down to the bottom here and now actually

1385
01:09:43,539 --> 01:09:44,589
进行大写。
do this capitalization.

1386
01:09:44,590 --> 01:09:47,710
现在让我们更改t中的第一个字符
Let's now change the first character in t

1387
01:09:47,710 --> 01:09:52,750
是在t的第一个字符上调用upper的结果。
to be the result of calling to upper on the first character of t.

1388
01:09:52,750 --> 01:09:56,769
然后，像以前一样，让我们继续打印出s是什么。
And then, as before, let's go ahead and print out whatever s is.

1389
01:09:56,770 --> 01:09:59,080
和以前一样，让我们继续打印
And like before, let's go ahead and print out

1390
01:09:59,079 --> 01:10:05,109
不管t是什么，现在都希望只有t被大写。
whatever t is and hope now that only t has been capitalized.

1391
01:10:05,109 --> 01:10:07,329
但是，我现在确实需要进行一次更改。
But I do need to make one change now.

1392
01:10:07,329 --> 01:10:10,689
事实证明，该函数malloc来了
It turns out that this function, malloc, comes

1393
01:10:10,689 --> 01:10:12,896
在称为标准lib点h的文件中。
in a file called standard lib dot h.

1394
01:10:12,896 --> 01:10:15,729
同样，您可以在笔记中记下这种事情。
And again, this is the kind of thing that you can jot down in notes.

1395
01:10:15,729 --> 01:10:17,562
您可以随时通过Google进行此类操作。
You can always Google these kinds of things.

1396
01:10:17,563 --> 01:10:20,740
甚至我都忘记了有时会在这些头文件中声明这些函数。
Even I forget what header files these functions are sometimes declared in.

1397
01:10:20,739 --> 01:10:24,309
但这恰好是一个新的库，称为标准库
But it happens to be a new one called standard lib for library

1398
01:10:24,310 --> 01:10:26,110
这使您可以访问malloc。
that gives you access to malloc.

1399
01:10:26,109 --> 01:10:29,799
现在让我继续进行比较。
So let me go ahead, now, and make compare.

1400
01:10:29,800 --> 01:10:31,210
好的，到目前为止很好。
All right, so far so good.

1401
01:10:31,210 --> 01:10:34,360
点斜线比较-抱歉，这不是比较。
Dot slash compare-- sorry, this is not compare.

1402
01:10:34,359 --> 01:10:35,679
旧程序运行正常。
The old program works fine.

1403
01:10:35,680 --> 01:10:38,630
复印-哦，天哪，七个错误。
Make copy-- oh my god, seven mistakes.

1404
01:10:38,630 --> 01:10:40,460
我在这错了吗？
What'd I do wrong here?

1405
01:10:40,460 --> 01:10:44,560
哦，看来我忘记了i和n的类型。
Oh, it looks like I forgot the type of i and n.

1406
01:10:44,560 --> 01:10:47,440
因此，让我进入我的for循环并添加int。
So let me go into my for loop and add the int.

1407
01:10:47,439 --> 01:10:49,869
那是我的错让我再次复印。
That was my fault. Let me make copy again.

1408
01:10:49,869 --> 01:10:51,909
好的，幸运的是，所有七个错误都消失了。
OK, all seven errors, thankfully, went away.

1409
01:10:51,909 --> 01:10:56,709
进行复制，让我们继续并输入嗨！小写，然后按Enter。
Make copy, let's go ahead and type in hi! in lower case and hit Enter.

1410
01:10:56,710 --> 01:11:02,860
瞧，现在我只将s的副本大写，也就是
And voila, now I have capitalized only the copy of s, a.k.a.

1411
01:11:02,859 --> 01:11:03,579
t。
t.

1412
01:11:03,579 --> 01:11:06,009
为了清楚起见，我有点退缩了
And just to be clear, I've kind of regressed back

1413
01:11:06,010 --> 01:11:09,140
老实说，以我的方括号表示法，因为它是完全可以接受的。
to my square bracket notation, honestly, because it's perfectly acceptable.

1414
01:11:09,140 --> 01:11:10,360
这是非常可读的。
It's very readable.

1415
01:11:10,359 --> 01:11:12,639
但是请注意，如果我真的想炫耀，
But notice, if I really want to show off,

1416
01:11:12,640 --> 01:11:19,190
我可以说些类似的话，好吧，去t&#39;s plus i location。
I could say something like, well, go to t's plus i location.

1417
01:11:19,189 --> 01:11:23,077
然后，再次执行此操作，出于可读性考虑，我不一定会建议这样做。
And then do this, which again, I don't necessarily recommend for readability.

1418
01:11:23,078 --> 01:11:24,620
但是同样，这是等效的。
But again, there is this equivalence.

1419
01:11:24,619 --> 01:11:28,639
方括号表示法与指针算术相同。
The square bracket notation is the same thing as pointer arithmetic.

1420
01:11:28,640 --> 01:11:34,160
因此，如果您想前往位于t的地址加上我想抵消的任何金额
So if you want to go to the address at t plus whatever i is to offset yourself

1421
01:11:34,159 --> 01:11:36,569
一个或多个字节，您完全可以做到这一点。
one or more bytes, you can totally do that.

1422
01:11:36,569 --> 01:11:39,919
如果我想花哨的话，我可以去这里说：
And if I want to be fancy, I can go down here and say,

1423
01:11:39,920 --> 01:11:45,350
转到t的第一个字符并将其大写。
go to the first character in t and capitalize it.

1424
01:11:45,350 --> 01:11:48,170
但是我还是要说，即使，是的，你非常聪明
But again, I would argue that even though, yes, you're very clever

1425
01:11:48,170 --> 01:11:50,420
并且您现在了解了指针和地址
and that you understand pointers and addresses at this point

1426
01:11:50,420 --> 01:11:51,795
如果您正在编写这样的代码。
if you're writing code like this.

1427
01:11:51,795 --> 01:11:53,990
老实说，它不一定具有可读性。
Honestly, it's not necessarily as readable.

1428
01:11:53,989 --> 01:11:57,799
因此，完全坚持使用方括号表示法的第二周语法
So sticking with week two syntax of the square bracket notation, totally

1429
01:11:57,800 --> 01:12:03,110
合理，完全正确，完全精心设计，甚至可能更可取，
reasonable, totally correct, totally well-designed, and perhaps preferable,

1430
01:12:03,109 --> 01:12:04,889
虽然我在这里要小心
though I should be careful here.

1431
01:12:04,890 --> 01:12:07,550
这行代码对我来说有点冒险
This line of code is a little bit risky for me

1432
01:12:07,550 --> 01:12:10,310
因为如果用户只是按Enter键而他们没有键入hi怎么办
because what if the user just hits Enter and they don't type hi

1433
01:12:10,310 --> 01:12:11,540
或大卫或布莱恩。
or David or Brian.

1434
01:12:11,539 --> 01:12:13,579
如果他们只输入Enter，该怎么办？
What if they type nothing except Enter?

1435
01:12:13,579 --> 01:12:16,129
在这种情况下，字符串的长度可能为0。
In that case, the length of the string might be 0.

1436
01:12:16,130 --> 01:12:19,220
然后我可能不应该将第一个字符大写
And then I probably shouldn't capitalizing the first character

1437
01:12:19,220 --> 01:12:22,230
甚至根本不存在的字符串中。
in a string that doesn't really even exist.

1438
01:12:22,229 --> 01:12:25,249
所以我可能应该进行一些错误检查，
So I should probably have some error checking,

1439
01:12:25,250 --> 01:12:32,450
例如，如果t的字符串长度至少大于0，
like if, for instance, the string length of t is at least greater than 0,

1440
01:12:32,449 --> 01:12:34,959
然后继续并安全地执行此操作。
then go ahead and safely do that.

1441
01:12:34,960 --> 01:12:37,550
但是同样，这只是一些其他错误的例子
But again, this is just one example of some additional error

1442
01:12:37,550 --> 01:12:39,200
检查我可以添加到程序中。
checking I can add to the program.

1443
01:12:39,199 --> 01:12:41,299
实际上还有一个错误检查
There's actually one more piece of error checking

1444
01:12:41,300 --> 01:12:43,520
我真的应该在一个完全正确的程序中做，
I should really do in a fully correct program,

1445
01:12:43,520 --> 01:12:45,170
就像您应该在问题集中做的那样。
as you should do in problem sets.

1446
01:12:45,170 --> 01:12:47,010
有时情况可能会出错。
Sometimes things can go wrong.

1447
01:12:47,010 --> 01:12:50,270
而且如果您的程序太大，那么花哨，也很耗内存
And if your program is so big, so fancy, and so memory-hungry

1448
01:12:50,270 --> 01:12:52,187
您正在分配大量的内存，
that you're mallocing lots and lots of memory,

1449
01:12:52,186 --> 01:12:54,061
在这么小的程序中您不会做的，
which you won't do in the program this small,

1450
01:12:54,061 --> 01:12:56,269
但是随着时间的流逝，您可能需要越来越多的内存，
but over time you might need more and more memory,

1451
01:12:56,270 --> 01:13:01,490
我们还应确保t实际上具有有效地址。
we should also make sure that t actually has a valid address.

1452
01:13:01,489 --> 01:13:04,669
事实证明，在大多数情况下，malloc
It turns out that malloc, most of the time,

1453
01:13:04,670 --> 01:13:08,090
将返回给您的内存块的地址
is going to return to you the address of a chunk of memory

1454
01:13:08,090 --> 01:13:09,470
它已经为您分配了。
it has allocated for you.

1455
01:13:09,470 --> 01:13:11,300
就像获取字符串一样，它将返回给您
Just like get string, it will return to you

1456
01:13:11,300 --> 01:13:14,900
内存块的第一个字节的地址
the address of the first byte of the chunk of memory

1457
01:13:14,899 --> 01:13:16,819
它已经找到了空间。
that it has found space for.

1458
01:13:16,819 --> 01:13:18,739
但是，有时情况可能会出错。
However, sometimes things can go wrong.

1459
01:13:18,739 --> 01:13:20,629
有时您的计算机可能内存不足。
Sometimes your computer can be out of memory.

1460
01:13:20,630 --> 01:13:24,320
您可能已经看到Mac或PC冻结，挂起或自行重启。
You've probably seen your Mac or PC freeze or hang or reboot itself.

1461
01:13:24,319 --> 01:13:26,909
这通常是内存错误的结果。
That is very often the result of memory errors.

1462
01:13:26,909 --> 01:13:28,999
因此，我们实际上应该检查类似这样的内容。
So we should actually check something like this.

1463
01:13:29,000 --> 01:13:32,569
如果t等于这个特殊值nul，
If t equals equals this special value nul,

1464
01:13:32,569 --> 01:13:35,359
然后我将继续前进，纾困并归还，
then I'm going to go ahead and just bail out and return one,

1465
01:13:35,359 --> 01:13:37,279
退出，让我们退出程序。
quit, let's get out of the program.

1466
01:13:37,279 --> 01:13:38,759
这是行不通的。
It's not going to work.

1467
01:13:38,760 --> 01:13:41,610
这可能只发生一百万分之一。
This might only happen one out of a million times.

1468
01:13:41,609 --> 01:13:44,219
但是检查nul更正确。
But it's more correct to check for nul.

1469
01:13:44,220 --> 01:13:48,350
现在，不幸的是，C类的设计师还是程序员
Now, unfortunately, the designers of C kind of used-- or programmers

1470
01:13:48,350 --> 01:13:53,210
更笼统地说，使用这个词，与NUL几乎相同，
more generally, use this word, which is almost the same as N-U-L,

1471
01:13:53,210 --> 01:13:54,980
否则称为反斜杠0。
otherwise known as backslash 0.

1472
01:13:54,979 --> 01:13:57,289
不幸的是，这是一个不同的值。
Unfortunately, this is a different value.

1473
01:13:57,289 --> 01:14:01,369
NULL表示空指针。
N-U-L-L represents a nul pointer.

1474
01:14:01,369 --> 01:14:02,869
这是假地址。
It is a bogus address.

1475
01:14:02,869 --> 01:14:04,579
这是没有地址。
It is the absence of an address.

1476
01:14:04,579 --> 01:14:06,949
从技术上讲，其地址为0。
Technically, its address 0.

1477
01:14:06,949 --> 01:14:09,229
它与反斜杠0不同。
It is different from backslash 0.

1478
01:14:09,229 --> 01:14:13,999
就像我们今天所做的那样，您可以在指针的上下文中使用NULL。
You use N-U-L-L in the context of pointers, as we are doing today.

1479
01:14:14,000 --> 01:14:17,390
您使用反斜杠0，否则在口头上会知道，
You use backslash 0, otherwise known verbally,

1480
01:14:17,390 --> 01:14:21,210
在字符上下文中为NUL或nul。
as an N-U-L, or nul, in the context of characters.

1481
01:14:21,210 --> 01:14:23,810
因此，反斜杠0用于字符。
So backslash 0 is for characters.

1482
01:14:23,810 --> 01:14:26,750
所有大写中的NULL用于指针。
N-U-L-L in all caps is for pointers.

1483
01:14:26,750 --> 01:14:29,750
这只是我们今天要介绍的新符号
And it's just a new symbol we're introducing today

1484
01:14:29,750 --> 01:14:34,519
这个标准的lib dot h文件附带的文件。
that comes with this standard lib dot h file.

1485
01:14:34,520 --> 01:14:38,190
好的，事实证明，我不需要做一些这项工作。
All right, so it turns out, honestly, I don't need to do some of this work.

1486
01:14:38,189 --> 01:14:41,609
原来，如果我想将一个字符串复制到另一个字符串，
It turns out that if I want to copy one string to another,

1487
01:14:41,609 --> 01:14:43,169
有一个功能。
there is a function for that.

1488
01:14:43,170 --> 01:14:45,920
而且，您将不必编写太多的代码行
And increasingly, you will not have to write as many lines of code

1489
01:14:45,920 --> 01:14:49,520
就像以前一样，因为如果您在手册页中查找
as you previously did, because if you look up in the manual pages

1490
01:14:49,520 --> 01:14:52,730
或者您已经听说或在线找到了另一个功能，例如一个
or you've heard about or find online that there's another function, like one

1491
01:14:52,729 --> 01:14:56,789
实际上，您可以更简单地执行名为strcpy的类似操作。
called strcpy, you can actually, more simply, do something like this.

1492
01:14:56,789 --> 01:15:00,409
因此，即使我真的很喜欢这个主意，并且使用for循环也是正确的
So even though I really liked the idea, and it was correct to use a for loop

1493
01:15:00,409 --> 01:15:04,949
要将s中的所有字符复制到t中，有一个功能。
to copy all of the characters from s into t, there's a function for that.

1494
01:15:04,949 --> 01:15:06,199
叫做strcpy。
It's called strcpy.

1495
01:15:06,199 --> 01:15:09,829
它有两个参数，目的地，后跟源。
It takes two arguments, the destination followed by the source.

1496
01:15:09,829 --> 01:15:12,199
而且它将处理所有循环
And it will just handle all of the looping

1497
01:15:12,199 --> 01:15:15,889
对我们来说，所有对我们的复制，包括反斜杠0，
for us, all of the copying for us, including the backslash 0,

1498
01:15:15,890 --> 01:15:18,830
这样我就可以专注于自己想做的事情，在这种情况下，
so that I can focus on what I want to do, which in this case,

1499
01:15:18,829 --> 01:15:21,299
实际上是大写东西。
is actually capitalize things.

1500
01:15:21,300 --> 01:15:26,497
因此，如果我们现在考虑这个示例，在我的计算机内存中，
So if we consider, now, this example, in the context of my computer's memory,

1501
01:15:26,497 --> 01:15:28,580
我们会看到它的布局有些不同。
we'll see that it's laid out a little differently.

1502
01:15:28,579 --> 01:15:31,049
但是，我还想再修复一个错误。
But there's one more bug I do want to fix first.

1503
01:15:31,050 --> 01:15:33,230
这是我们尚未要做的事情。
And this is something we've not had to do yet.

1504
01:15:33,229 --> 01:15:37,849
事实证明，每当您使用malloc分配内存时，
It turns out that any time you allocate memory with malloc,

1505
01:15:37,850 --> 01:15:41,330
您要求计算机提供内存，程序员，您的责任就在您身上，
you ask the computer for memory, the onus is on you, the programmer,

1506
01:15:41,329 --> 01:15:43,159
最终将其还给。
to eventually give it back.

1507
01:15:43,159 --> 01:15:46,069
我的意思是，如果您分配四个字节，
And by that, I mean if you allocate four bytes,

1508
01:15:46,069 --> 01:15:49,429
或谁知道，400万字节的内存用于更大的程序，
or who knows, four million bytes of memory for an even bigger program,

1509
01:15:49,430 --> 01:15:52,160
您最好将其还给计算机，更具体地说，
you'd better give it back to the computer, more specifically,

1510
01:15:52,159 --> 01:15:55,251
操作系统，无论是Linux还是Mac OS或Windows，
the operating system, be it Linux or Mac OS or Windows,

1511
01:15:55,252 --> 01:15:57,710
这样您的计算机最终不会耗尽内存。
so that your computer eventually doesn't run out of memory.

1512
01:15:57,710 --> 01:16:00,418
如果您所要做的只是请求更多的内存，请请求更多的内存，
If all you ever do is ask for more memory, ask for more memory,

1513
01:16:00,417 --> 01:16:03,709
可以说最终您的计算机将耗尽，这是有原因的，因为
it stands to reason that eventually your computer will run out, because it only

1514
01:16:03,710 --> 01:16:05,370
具有有限的内存。
has a finite amount of memory.

1515
01:16:05,369 --> 01:16:07,909
它有一定数量的硬件召回。
It's got a finite amount of hardware recall.

1516
01:16:07,909 --> 01:16:11,779
因此，当您完成记忆后，这应该是您的最佳做法
So when you're done with memory, it should be your best practice

1517
01:16:11,779 --> 01:16:14,969
以后再释放它。
to free it afterward as well.

1518
01:16:14,970 --> 01:16:18,950
与malloc相反，它只是一个名为free的函数，它需要
And the opposite of malloc is just a function called free, which takes,

1519
01:16:18,949 --> 01:16:22,039
作为其输入，无论malloc的输出是什么。
as its input, whatever the output of malloc was.

1520
01:16:22,039 --> 01:16:25,069
并回想一下malloc的输出，malloc的返回值，
And recall that the output of malloc, the return value of malloc,

1521
01:16:25,069 --> 01:16:30,209
只是它已为您分配的内存的第一个字节的地址。
is just the address of the first byte of memory that it has allocated for you.

1522
01:16:30,210 --> 01:16:34,010
因此，如果您要求它提供四个字节，就像我几年前对malloc所做的那样，
So if you ask it for four bytes, like I did a few lines ago with malloc,

1523
01:16:34,010 --> 01:16:37,100
您将取回那些字节中第一个字节的地址。
you're going to get back the address of the first of those bytes.

1524
01:16:37,100 --> 01:16:41,150
而且，您要记住所要求的字节数。
And it's up to you to remember how many bytes you asked for.

1525
01:16:41,149 --> 01:16:43,759
在免费的情况下，您要做的就是
In the case of free, all you have to do is

1526
01:16:43,760 --> 01:16:49,820
通过其输入免费告诉malloc给您的地址是什么。
tell free via its input what the address was that malloc gave you.

1527
01:16:49,819 --> 01:16:53,209
因此，如果您像我一样存储该地址，则在名为t的变量中，
So if you stored that address as I did, in this variable called t,

1528
01:16:53,210 --> 01:16:58,190
当您用完称为free t的内存后，就足够了。
it suffices when you're done with that memory just called free t.

1529
01:16:58,189 --> 01:17:02,359
然后计算机将为您释放该内存。
And the computer will go about freeing up that memory for you.

1530
01:17:02,359 --> 01:17:04,879
而且，您很可能稍后再找回它。
And you might very well get it back later on.

1531
01:17:04,880 --> 01:17:07,400
但是至少您的计算机不会耗尽内存
But at least your computer won't run out of memory

1532
01:17:07,399 --> 01:17:13,489
速度很快，因为它现在可以将该空间重用于其他用途。
as quickly, because it can now reuse that space for something else.

1533
01:17:13,489 --> 01:17:15,409
好吧，让我继续，然后提出
All right, let me go ahead, then, and propose

1534
01:17:15,409 --> 01:17:17,869
我们为此画一幅图-
that we draw a picture of this--

1535
01:17:17,869 --> 01:17:20,941
现在是新程序的内存，我们可以在其中复制内容。
now new program's memory, where we copy things.

1536
01:17:20,942 --> 01:17:23,900
所以回想一下，这是我们在比较两个字符串之前停止的地方。
So recall, this is where we left off before when comparing two strings.

1537
01:17:23,899 --> 01:17:29,009
如果这是s并且s指向h，即小写的感叹号，
If this was s and s was pointing to h, i, exclamation point in lowercase,

1538
01:17:29,010 --> 01:17:32,510
我在copy.c中的新版本代码，请注意，
this new version of my code in copy.c, notice,

1539
01:17:32,510 --> 01:17:34,550
仍然给了我另一个指针t。
still gives me another pointer called t.

1540
01:17:34,550 --> 01:17:36,530
因此，故事的那一部分没有改变。
So that part of the story hasn't changed.

1541
01:17:36,529 --> 01:17:37,969
但是我现在叫malloc。
But I call malloc now.

1542
01:17:37,970 --> 01:17:40,790
而malloc将返回给我一些新的内存。
And malloc is going to return to me some new chunk of memory.

1543
01:17:40,789 --> 01:17:42,439
我事先不知道它在哪里。
I don't know in advance where it is.

1544
01:17:42,439 --> 01:17:45,739
但是malloc的返回值将是地址
But malloc's return value is going to be the address

1545
01:17:45,739 --> 01:17:47,919
该记忆的第一口。
of the first bite of that memory.

1546
01:17:47,920 --> 01:17:51,050
因此，例如0x456或其他值。
So for instance, 0x456 or whatever it is.

1547
01:17:51,050 --> 01:17:54,230
随后的字节将增加一个
And the subsequent bytes are going to be increasing by one

1548
01:17:54,229 --> 01:17:59,629
一次为0x457、0x458、0x459。
byte at a time, 0x457, 0x458, 0x459.

1549
01:17:59,630 --> 01:18:03,800
那么，当我为其分配malloc的返回值时，最终存储在t中的是什么？
So what is, ultimately, stored in t when I assign it the return value of malloc?

1550
01:18:03,800 --> 01:18:05,570
不管那个地址是什么。
It's whatever that address is.

1551
01:18:05,569 --> 01:18:07,979
再次，我可以从技术上在这里写0x456。
Again, I could technically write 0x456 up here.

1552
01:18:07,979 --> 01:18:09,799
但同样，我们有点过去了。
But again, we're kind of past that.

1553
01:18:09,800 --> 01:18:10,970
那是30分钟前。
That's very 30 minutes ago.

1554
01:18:10,970 --> 01:18:14,300
现在，让我们仅关注作为指针的抽象。
Let's now focus on just the abstraction that is a pointer.

1555
01:18:14,300 --> 01:18:17,690
指针只是从变量指向的箭头
A pointer is just an arrow pointing from the variable

1556
01:18:17,689 --> 01:18:19,979
到内存中的实际位置。
to the actual location in memory.

1557
01:18:19,979 --> 01:18:26,719
所以现在，如果我打算使用strcpy或更手动地将s复制到t中，
So now, if I go about copying s into t using strcpy, or more manually,

1558
01:18:26,720 --> 01:18:28,670
使用我的for循环，会发生什么？
using my for loop, what happens?

1559
01:18:28,670 --> 01:18:31,610
好吧，我正在将h从s复制到t。
Well, I'm copying the h over from s into t.

1560
01:18:31,609 --> 01:18:36,109
我要将i从s复制到t，将感叹号从s复制到t。
I'm copying the i over from s into t, the exclamation point from s into t.

1561
01:18:36,109 --> 01:18:40,529
最后，从n到t的终止nul字符。
And then lastly, the terminating nul character from s into t.

1562
01:18:40,529 --> 01:18:42,739
因此，情况现在根本不同了。
So the picture is now fundamentally different.

1563
01:18:42,739 --> 01:18:45,019
t指的不是同一件事。
t is not pointing at the same thing.

1564
01:18:45,020 --> 01:18:50,570
它指向的是自己的内存块，一次只有一步，
It's pointing at its own chunk of memory that has now, one step at a time,

1565
01:18:50,569 --> 01:18:56,209
一直在复制地址s上的内容。
been duplicating whatever was at the address s.

1566
01:18:56,210 --> 01:18:59,600
因此，这就是您和我作为人类所考虑的，大概是，
And so this is what you and I as humans would consider, presumably,

1567
01:18:59,600 --> 01:19:04,080
成为程序的正确副本。
to be a proper copy of the program.

1568
01:19:04,079 --> 01:19:09,659
那么，对引入malloc和free所做的事情有任何疑问吗？
Any questions, then, on what we've just done by introducing malloc and free?

1569
01:19:09,659 --> 01:19:11,909
第一个分配内存并为您提供
The first of which allocates memory and gives you

1570
01:19:11,909 --> 01:19:15,749
您现在可以使用的内存的第一个字节的地址，
the address of the first byte of memory that you can now use,

1571
01:19:15,750 --> 01:19:19,259
后者会将其交给您的操作系统，并说：
the latter of which hands it back to your operating system and says,

1572
01:19:19,260 --> 01:19:20,700
我已经完成了。
I'm done with this.

1573
01:19:20,699 --> 01:19:24,359
现在可以将其重用于其他变量，其他变量，
It can now be reused for something else, some other variable,

1574
01:19:24,359 --> 01:19:27,089
也许，如果我们的程序更长的话，在路上。
maybe, down the road, if our program were longer.

1575
01:19:27,090 --> 01:19:31,530
布莱恩，有什么问题或困惑可以帮助您吗？
Brian, any questions or confusion I can help with?

1576
01:19:31,529 --> 01:19:33,869
布莱恩：有人问，即使您使用的是strcpy
BRIAN: Someone asked, even if you're using strcpy

1577
01:19:33,869 --> 01:19:37,469
复制字符串，而不是一次复制一个字符，
to copy the string instead of copying the characters one at a time yourself,

1578
01:19:37,470 --> 01:19:39,420
您还需要释放内存吗？
do you still need to free the memory?

1579
01:19:39,420 --> 01:19:40,545
戴维·马兰：好的问题。
DAVID MALAN: Good question.

1580
01:19:40,545 --> 01:19:43,320
即使您使用的是strcpy，您仍然需要免费使用。
Even if you're using strcpy, you do need to still use free.

1581
01:19:43,319 --> 01:19:48,119
是的，此后任何时候使用malloc都必须使用free。
Yes, anytime you use malloc henceforth, you must use free.

1582
01:19:48,119 --> 01:19:52,469
每次使用malloc时，都必须使用free来释放该内存。
Anytime you use malloc, you must use free in order to free up that memory.

1583
01:19:52,470 --> 01:19:56,370
strcpy正在将一个内存块的内容复制到另一个。
strcpy is copying the contents of one chunk of memory to the other.

1584
01:19:56,369 --> 01:19:59,219
它不是为您分配或管理该内存。
It is not allocating or managing that memory for you.

1585
01:19:59,220 --> 01:20:02,520
本质上，它只是在实现for循环。
It is just implementing, essentially, that for loop.

1586
01:20:02,520 --> 01:20:05,520
也许也是时候，我可以脱下另一个训练轮了
And it's, perhaps, time too, where I can take off another training wheel

1587
01:20:05,520 --> 01:20:06,020
口头上
verbally.

1588
01:20:06,020 --> 01:20:10,410
事实证明，一直以来获取字符串都是一种神奇。
It turns out that get string, all this time, is kind of magical.

1589
01:20:10,409 --> 01:20:13,469
从CS50库获取字符串的事情之一
One of the things that get string does from the CS50 library

1590
01:20:13,470 --> 01:20:16,080
它本身是否使用malloc。
is it itself uses malloc.

1591
01:20:16,079 --> 01:20:19,799
毕竟，考虑一下，当我们员工几年前写成字符串时，
Consider, after all, when we, the staff, wrote get string years ago,

1592
01:20:19,800 --> 01:20:22,830
我们不知道您的名字今年要待多久。
we have no idea how long your names are going to be this year.

1593
01:20:22,829 --> 01:20:24,689
我们不知道你要说什么句子
We have no idea what sentences you're going

1594
01:20:24,689 --> 01:20:28,349
键入，要键入的段落，要分析的文本
to type, what paragraphs you're going to type, what text you're going to analyze

1595
01:20:28,350 --> 01:20:30,240
对于像可读性这样的程序。
for a program like readability.

1596
01:20:30,239 --> 01:20:32,609
所以我们必须以这种方式实现get string
So we had to implement get string in such a way

1597
01:20:32,609 --> 01:20:35,729
您可以在键盘上输入的字符数可以少或多
that you can type as few or as many characters at your keyboard

1598
01:20:35,729 --> 01:20:36,419
如你所愿。
as you want.

1599
01:20:36,420 --> 01:20:40,150
并且我们将确保该字符串有足够的内存。
And we will make sure there's enough memory for that string.

1600
01:20:40,149 --> 01:20:43,529
因此，在引擎盖下获取字符串，如果您看一下我们，员工的代码，
So get string, underneath the hood, if you look at the code we, the staff,

1601
01:20:43,529 --> 01:20:46,529
有一天写了，您会看到我们使用了malloc。
wrote someday, you'll see that we use malloc.

1602
01:20:46,529 --> 01:20:51,389
我们调用malloc以获得足够的内存以适合该字符串。
And we call malloc in order to get enough memory to fit that string.

1603
01:20:51,390 --> 01:20:54,600
然后，CS50库也在暗中进行操作，
And then, what the CS50 library is also secretly doing,

1604
01:20:54,600 --> 01:20:57,060
它也为您免费打电话吗？
is it is also calling free for you.

1605
01:20:57,060 --> 01:20:59,130
从本质上讲，有一种奇特的方式
There's, essentially, a fancy way where you

1606
01:20:59,130 --> 01:21:03,690
可以编写一个程序，一旦main将要退出或返回
can write a program that, as soon as main is about to quit or return

1607
01:21:03,689 --> 01:21:06,479
闪烁的提示，一些特殊的代码
to your blinking prompt, some special code

1608
01:21:06,479 --> 01:21:10,859
我们在最后一刻写了很多东西，释放了所有的记忆
we wrote swoops in at that final moment, frees any of the memory

1609
01:21:10,859 --> 01:21:14,129
我们图书馆分配给您
that we, the library, allocated so that you

1610
01:21:14,130 --> 01:21:17,190
不要因为我们而耗尽内存。
don't run out of memory because of us.

1611
01:21:17,189 --> 01:21:19,589
但是你们所有人在使用malloc时都会拥有
But you all, when using malloc, will have

1612
01:21:19,590 --> 01:21:23,700
拨打免费电话，因为图书馆不会为您做到这一点。
to call free, because the library is not going to do that for you.

1613
01:21:23,699 --> 01:21:26,399
实际上，今天和下周及以后的目标
And indeed, the goal of today and next week and beyond

1614
01:21:26,399 --> 01:21:30,832
最终将完全停止使用CS50库。
is to stop using the CS50 library, ultimately, altogether.

1615
01:21:30,832 --> 01:21:32,999
好吧，好吧-我认为这将是不公平的，
All right, well let's-- it would be unfair, I think,

1616
01:21:33,000 --> 01:21:36,000
如果我们引入了所有这些新颖的技术，但不一定
if we introduced all of these fancy new techniques but don't necessarily

1617
01:21:36,000 --> 01:21:40,620
为您提供确定跟踪错误的各种工具
provide you with any sort of tools with which to determine to chase down bugs

1618
01:21:40,619 --> 01:21:43,244
现在，使用新的精美代码或解决问题，
in your new fancy code or solve problems, now,

1619
01:21:43,244 --> 01:21:44,369
与记忆有关。
that are related to memory.

1620
01:21:44,369 --> 01:21:46,859
值得庆幸的是，有一些程序可以通过
And thankfully, there are programs via which

1621
01:21:46,859 --> 01:21:49,559
您可以追查与内存相关的错误。
you can chase down memory-related bugs.

1622
01:21:49,560 --> 01:21:52,080
这是除了printf之外的功能，
This is in addition to printf, that function,

1623
01:21:52,079 --> 01:21:56,549
以及更常见的help50和check50以及debug50和调试器。
and help50 and check50 and debug50 and debuggers more generally.

1624
01:21:56,550 --> 01:21:59,940
该程序-这实际上是我们将向您介绍的新工具中的最后一个
This program-- and it's really the last of the new tools we'll introduce you

1625
01:21:59,939 --> 01:22:01,919
C中的to称为valgrind。
to in C-- is called valgrind.

1626
01:22:01,920 --> 01:22:04,830
这是CS50 IDE中存在的程序。
And this is a program that exists in CS50 IDE.

1627
01:22:04,829 --> 01:22:07,619
但它存在于Mac，PC和Linux计算机上
But it exists on Macs and PC's and Linux computers

1628
01:22:07,619 --> 01:22:10,049
任何地方，您都可以在自己的代码上运行它
anywhere, where you can run it on your own code

1629
01:22:10,050 --> 01:22:12,870
来检测您的内存是否有问题。
to detect if you're doing anything wrong with memory.

1630
01:22:12,869 --> 01:22:14,369
您可能会在内存上做错什么？
What might you do wrong with memory?

1631
01:22:14,369 --> 01:22:17,036
好吧，以前，请记住，我触发了该细分错误。
Well, previously, remember, I triggered that segmentation fault.

1632
01:22:17,037 --> 01:22:19,320
我感动了我不应该的记忆。
I touched memory that I should not.

1633
01:22:19,319 --> 01:22:22,079
Valgrind是可以帮助您找出问题的工具，
Valgrind is a tool that can help you figure out,

1634
01:22:22,079 --> 01:22:24,999
您在哪里接触了本不应该拥有的记忆，
where did you touch memory that you shouldn't have,

1635
01:22:25,000 --> 01:22:27,959
以便将您自己的注意力集中在任何代码行上
so as to focus your own human attention on whatever lines of code

1636
01:22:27,960 --> 01:22:28,830
可能是越野车。
might be buggy.

1637
01:22:28,829 --> 01:22:32,609
Valgrind Grant还可以检测您是否忘记免费拨打电话。
Valgrind grant can also detect if you forget to call free.

1638
01:22:32,609 --> 01:22:36,239
如果您多次调用malloc，但不免费
If you call malloc one or more times, but don't call free

1639
01:22:36,239 --> 01:22:38,279
相应的次数，valgrind
a corresponding number of times, valgrind

1640
01:22:38,279 --> 01:22:40,889
是一个可以注意到并告诉您您有
is a program that can notice that and tell you that you have

1641
01:22:40,890 --> 01:22:42,580
所谓的内存泄漏。
what's called a memory leak.

1642
01:22:42,579 --> 01:22:44,759
实际上，这与我们自己的Mac和PC有密切关系。
And indeed, this is germane to our own Macs and PCs.

1643
01:22:44,760 --> 01:22:47,100
同样，如果您使用的是Mac或PC，有时
Again, if you've been using your Mac or PC or sometimes

1644
01:22:47,100 --> 01:22:50,070
甚至很长一段时间，甚至您的手机
even your phone for a long, long time, and maybe

1645
01:22:50,069 --> 01:22:53,339
一次运行许多不同的程序，许多浏览器选项卡
running lots of different programs at once, lots of browser tabs

1646
01:22:53,340 --> 01:22:55,680
打开，许多不同的程序同时打开，
open, lots of different programs open at once,

1647
01:22:55,680 --> 01:22:59,370
您的Mac或PC可能已经开始缓慢地爬行。
your Mac or PC might very well have begun to slow to a crawl.

1648
01:22:59,369 --> 01:23:01,919
如果不是不可能的话，可能会很烦人，
It might be annoying, if not impossible to use,

1649
01:23:01,920 --> 01:23:03,960
因为一切都太慢了。
because everything is so darn slow.

1650
01:23:03,960 --> 01:23:07,920
那很可能是因为您正在使用的一个或多个程序
That may very well be because one or more of the programs you're using

1651
01:23:07,920 --> 01:23:12,480
有一个错误，程序员可以不断分配内存
has some bug in it whereby a programmer kept allocating memory

1652
01:23:12,479 --> 01:23:15,209
从来没有绕过免费电话。
and never got around to calling free.

1653
01:23:15,210 --> 01:23:17,273
也许是一个错误，也许是故意的，
Maybe it's a bug, maybe it was deliberate,

1654
01:23:17,273 --> 01:23:19,440
他们没想到你会打开这么多窗户。
they didn't expect you to have so many windows open.

1655
01:23:19,439 --> 01:23:21,359
但是valgrind可以检测到这样的错误。
But valgrind can detect errors like that.

1656
01:23:21,359 --> 01:23:23,729
老实说，你们中的一些人，如果您像我一样，
And honestly, some of you, if you're like me,

1657
01:23:23,729 --> 01:23:29,369
您很可能会同时打开10、20、50个不同的浏览器标签，
you might very well have 10, 20, 50 different browser tabs open at once,

1658
01:23:29,369 --> 01:23:32,909
想着哦，即使我们从不这样做，我还是有一天会回到那一天。
thinking oh, I'm going to come back to that someday, even though we never do.

1659
01:23:32,909 --> 01:23:34,949
这些选项卡中的每一个都占用内存。
Each of those tabs takes up memory.

1660
01:23:34,949 --> 01:23:37,319
从字面上看，每当您打开浏览器标签时，都要想一想，
Literally, any time you open a browser tab, think of it,

1661
01:23:37,319 --> 01:23:41,579
确实如此，例如Chrome或Edge或Firefox或其他任何形式
really, as Chrome or Edge or Firefox or whatever

1662
01:23:41,579 --> 01:23:43,919
你在用引擎盖下的东西
you're using, underneath the hood, they're

1663
01:23:43,920 --> 01:23:46,320
可能在Mac OS或Windows上调用了一个函数
probably calling a function on Mac OS or Windows

1664
01:23:46,319 --> 01:23:50,669
像malloc这样可以给您更多的内存来包含该网页的内容
like malloc to give you more memory to contain the contents of that web page

1665
01:23:50,670 --> 01:23:51,480
暂时地。
temporarily.

1666
01:23:51,479 --> 01:23:54,309
而且，如果您继续打开越来越多的浏览器标签，
And if you keep opening more and more browser tabs,

1667
01:23:54,310 --> 01:23:56,190
这就像调用malloc，malloc，malloc。
it's like calling malloc, malloc, malloc.

1668
01:23:56,189 --> 01:23:57,839
最终，您将用光。
Eventually, you're going to run out.

1669
01:23:57,840 --> 01:23:59,700
这些天，计算机可以变得很聪明。
And computers can be smart these days.

1670
01:23:59,699 --> 01:24:03,059
他们可以暂时从内存中删除内容以释放空间。
They can kind of temporarily remove things from memory to free up space.

1671
01:24:03,060 --> 01:24:04,477
这称为虚拟内存。
This is called virtual memory.

1672
01:24:04,476 --> 01:24:06,309
但是最终，某些事情将会崩溃。
But eventually, something is going to break.

1673
01:24:06,310 --> 01:24:08,520
这很可能是您的用户体验
And it might very well be your user experience

1674
01:24:08,520 --> 01:24:11,700
当事情变得如此缓慢以至于您不得不退出程序时
when things get so slow that you literally have to quit the program

1675
01:24:11,699 --> 01:24:14,139
甚至重启计算机。
or maybe even reboot your computer.

1676
01:24:14,140 --> 01:24:15,240
那么我们如何使用valgrind？
So how do we use valgrind?

1677
01:24:15,239 --> 01:24:17,429
好吧，让我继续写一个简短的程序
Well, let me go ahead and write a short program

1678
01:24:17,430 --> 01:24:20,040
并没有做任何有用的事，但是证明了
that doesn't do anything useful, but demonstrates

1679
01:24:20,039 --> 01:24:22,079
与内存相关的多个错误。
multiple memory-related mistakes.

1680
01:24:22,079 --> 01:24:24,059
我称这个文件为memory.c。
I'll call this file memory.c.

1681
01:24:24,060 --> 01:24:27,550
我要继续打开文件memory.c
I'm going to go ahead and open up the file memory.c

1682
01:24:27,550 --> 01:24:30,842
并包括在最高标准的io点h上。
and include at the top standard io dot h.

1683
01:24:30,841 --> 01:24:32,549
然后我要先发制人
And then I'm going to also, preemptively,

1684
01:24:32,550 --> 01:24:37,290
包括标准的lib点h，它可以回想malloc，int main void在哪里。
include standard lib dot h, which recalls where malloc, int main void.

1685
01:24:37,289 --> 01:24:39,069
我将保持这一简单。
And I'm going to keep this one simple.

1686
01:24:39,069 --> 01:24:42,369
我要继续，只给自己一堆整数。
I'm going to go ahead and just give myself a whole bunch of integer.

1687
01:24:42,369 --> 01:24:43,809
因此，这实际上很酷。
So this is actually kind of cool.

1688
01:24:43,810 --> 01:24:46,480
事实证明-
It turns out that--

1689
01:24:46,479 --> 01:24:47,879
好吧，让我们继续吧。
well, let's go ahead.

1690
01:24:47,880 --> 01:24:48,910
是的，我可以做到。
Yeah, I can do this.

1691
01:24:48,909 --> 01:24:50,034
让我们继续执行此操作。
Let's go ahead and do this.

1692
01:24:50,034 --> 01:24:52,649
字符星获取malloc。
Char star s gets malloc.

1693
01:24:52,649 --> 01:24:57,629
让我继续前进，给我自己，这三个呢。
And let me go ahead and give myself, how about three of these.

1694
01:24:57,630 --> 01:25:01,050
让我继续，为三个字符分配空间。
Let me go ahead and allocate space for three chars.

1695
01:25:01,050 --> 01:25:03,640
或者实际上，像以前一样，让我给我四个。
Or actually, let's give me four, just like before.

1696
01:25:03,640 --> 01:25:08,340
现在，我要说s的括号0等于72。
Now, I'm going to go ahead and say s bracket 0 equals 72.

1697
01:25:08,340 --> 01:25:12,220
s支架1 –实际上，我将手动执行此操作。
s bracket 1-- actually, I'll just do this manually.

1698
01:25:12,220 --> 01:25:14,160
让我们做吧。
Let's do h.

1699
01:25:14,159 --> 01:25:16,349
我来吧
Let's do i.

1700
01:25:16,350 --> 01:25:19,960
让我们做我们通常的感叹号。
Let's do our usual exclamation point.

1701
01:25:19,960 --> 01:25:22,170
然后只是出于很好的考虑，s支架3得到了
And then just for good measure, s bracket 3 gets

1702
01:25:22,170 --> 01:25:24,120
引用取消引用，反斜杠0。
quote unquote, backslash 0.

1703
01:25:24,119 --> 01:25:29,339
这实际上是一种非常手动的方式-
This is the very manual way of actually--

1704
01:25:29,340 --> 01:25:32,430
这是实际构建字符串的非常手动的方法。
this is the very manual way of actually building up a string.

1705
01:25:32,430 --> 01:25:34,060
但是，让我介绍一个错误。
But let me introduce a mistake.

1706
01:25:34,060 --> 01:25:37,320
我不小心分配了三个字节，
Let me accidentally allocate only three bytes,

1707
01:25:37,319 --> 01:25:40,439
即使我显然需要四分之一的终止nul字符。
even though I clearly need a fourth for that terminating nul character.

1708
01:25:40,439 --> 01:25:42,509
还要注意，缺少免费。
And notice too, the absence of free.

1709
01:25:42,510 --> 01:25:45,720
我会很草率地打扰，免费打扰。
I'm going to, very sloppily, not bother calling free.

1710
01:25:45,720 --> 01:25:49,590
现在，我将继续编译该程序，创建内存。
Now, I'm going to go ahead and compile this program, make memory.

1711
01:25:49,590 --> 01:25:53,430
OK，它会编译OK，所以很好，点斜杠内存。
OK, it compiles OK, so that's good, dot slash memory.

1712
01:25:53,430 --> 01:25:55,413
好吧，什么也没发生，但是那种
OK, nothing happens, but that kind of makes

1713
01:25:55,412 --> 01:25:57,329
有道理，因为我没有告诉它做任何事情。
sense because I didn't tell it to do anything.

1714
01:25:57,329 --> 01:26:01,359
只是为了踢球，让我们像往常一样打印出该字符串。
Just for kicks, let's print out that string just like we always do.

1715
01:26:01,359 --> 01:26:04,499
现在让我重新编译内存，然后继续编译。
Let me now recompile memory, still compiles.

1716
01:26:04,500 --> 01:26:06,360
让我运行点斜杠内存。
Let me run dot slash memory.

1717
01:26:06,359 --> 01:26:07,569
好的，这似乎可行。
OK, it seems to work.

1718
01:26:07,569 --> 01:26:09,999
因此，乍一看，您可能会为自己感到骄傲。
So at first glance, you might be really proud of yourself.

1719
01:26:10,000 --> 01:26:12,910
您编写了另一个正确的程序，似乎通过了check50。
You've written another correct program, seems to pass check50.

1720
01:26:12,909 --> 01:26:13,409
您提交。
You submit.

1721
01:26:13,409 --> 01:26:14,326
你忙得不亦乐乎。
You go about your day.

1722
01:26:14,327 --> 01:26:16,380
几天后你很失望
And you're very disappointed some days later

1723
01:26:16,380 --> 01:26:19,920
当你意识到，该死的时候，我没有得到充分的认可，因为
when you realize, dammit, I did not get full credit on this because there's

1724
01:26:19,920 --> 01:26:21,780
实际上是一个潜在的错误。
actually a latent bug.

1725
01:26:21,779 --> 01:26:24,779
所以有时候确实在您的代码中有错误
So sometimes, indeed, there are bugs in your code

1726
01:26:24,779 --> 01:26:27,419
你不一定要看得见，你不一定
that you don't necessarily see visually, you don't necessarily

1727
01:26:27,420 --> 01:26:30,990
自己运行时的经验，但最终在那里
experience when running it yourself, but eventually, there

1728
01:26:30,989 --> 01:26:33,442
运行足够的时间可能是一个错误。
might be an error when running it enough times.

1729
01:26:33,443 --> 01:26:36,360
最终，计算机可能会注意到您做错了什么。
Eventually, a computer might notice that you're doing something wrong.

1730
01:26:36,359 --> 01:26:38,459
值得庆幸的是，存在像valgrind这样的工具，
And thankfully, tools exist like valgrind,

1731
01:26:38,460 --> 01:26:40,098
可以让您检测到。
that can allow you to detect that.

1732
01:26:40,097 --> 01:26:43,139
因此，让我继续前进，只需在此处增加终端窗口的大小即可。
So let me go ahead and just increase the size of my terminal window here.

1733
01:26:43,140 --> 01:26:48,090
让我继续，在点斜杠内存上运行valgrind。
And let me go ahead and run valgrind on dot slash memory.

1734
01:26:48,090 --> 01:26:49,290
因此，这就像debug50。
So it's just like debug50.

1735
01:26:49,289 --> 01:26:53,039
不用运行debug50然后使用斜杠来表示任何程序，
Instead of running debug50 and then dot slash whatever the program is,

1736
01:26:53,039 --> 01:26:55,812
您运行valgrind点斜杠内存。
you run valgrind dot slash memory.

1737
01:26:55,813 --> 01:26:58,230
不幸的是，这只是一个命令行界面。
This one, unfortunately, is only a command line interface.

1738
01:26:58,229 --> 01:27:00,479
没有像debug50这样的图形用户界面。
There's no graphical user interface like debug50.

1739
01:27:00,479 --> 01:27:04,529
老实说，这是一个令人毛骨悚然的输出序列。
And honestly, it's a hideous sequence of output.

1740
01:27:04,529 --> 01:27:06,629
乍一看，这应该会让您不知所措。
This should overwhelm you at first glance.

1741
01:27:06,630 --> 01:27:08,190
这里有疯狂的神秘感。
There's crazy cryptic-ness here.

1742
01:27:08,189 --> 01:27:09,689
这不是设计最好的程序。
It's not the best-designed program.

1743
01:27:09,689 --> 01:27:12,519
它确实是为最舒适的人准备的。
It really was meant for the most comfortable people.

1744
01:27:12,520 --> 01:27:15,180
但是我们可以摆脱一些有用的花招。
But there are some useful tidbits we can take away from it.

1745
01:27:15,180 --> 01:27:17,490
一如既往，让我一直展示到顶部
As always, let me show all the way to the top

1746
01:27:17,489 --> 01:27:19,259
到输出的第一行。
to the very first line of output.

1747
01:27:19,260 --> 01:27:21,600
我会提请您注意以下几点
And I'll draw your attention to a couple of things

1748
01:27:21,600 --> 01:27:23,070
那将开始跳到你身边。
that will start to jump out to you.

1749
01:27:23,069 --> 01:27:24,959
并且help50可以帮助您。
And help50 can help you with this.

1750
01:27:24,960 --> 01:27:28,020
如果您对valgrind的输出感到困惑，请重新运行它。
If you're confused by valgrind's output, rerun it.

1751
01:27:28,020 --> 01:27:29,520
但是请在开始时使用help50。
But put help50 at the beginning.

1752
01:27:29,520 --> 01:27:32,120
就像我现在将口头上做的一样，可以提供帮助50
And just like I will do now verbally, so can help50

1753
01:27:32,119 --> 01:27:36,509
帮助您注意到这种疯狂的输出混乱中的重要事项。
help you notice the important things in this crazy mess of output.

1754
01:27:36,510 --> 01:27:37,770
这太令人担忧了。
This is worrisome.

1755
01:27:37,770 --> 01:27:41,880
Valgrind在此注意这一点，大小为1的无效权限。
Valgrind is noting on this line here, invalid right of size 1.

1756
01:27:41,880 --> 01:27:44,370
那是在memory.c的第10行上。
And that's on line 10 of memory.c.

1757
01:27:44,369 --> 01:27:46,509
因此，我们稍后再讨论。
So we'll look at that in a moment.

1758
01:27:46,510 --> 01:27:50,530
如果我进一步向下滚动，则读取的大小为1。
If I scroll down further, invalid read of size 1.

1759
01:27:50,529 --> 01:27:55,809
这似乎也出现在了memory.c的第11行上。
And that also seems to be on here, it looks like, on line 11 of memory.c.

1760
01:27:55,810 --> 01:27:59,070
然后如果我继续滚动，继续滚动，继续滚动，
And then if I keep scrolling, keep scrolling, keep scrolling,

1761
01:27:59,069 --> 01:28:00,989
我不喜欢这个
I'm not liking this.

1762
01:28:00,989 --> 01:28:05,909
不管是什么，在丢失记录中肯定会丢失1个块中的3个字节。
3 bytes in 1 blocks are definitely lost in loss record, whatever that is.

1763
01:28:05,909 --> 01:28:10,169
但是肯定会丢失1个块中的三个字节。
But three bytes in 1 blocks are definitely lost.

1764
01:28:10,170 --> 01:28:15,240
然后在这里，泄漏摘要，肯定会丢失，共1个块3个字节。
And then down here, leak summary, definitely lost, 3 bytes in 1 blocks.

1765
01:28:15,239 --> 01:28:17,702
顺便说一句，显然语法不正确。
Incidentally, 1 blocks, obviously not correct grammar.

1766
01:28:17,703 --> 01:28:19,620
这是当您的程序不执行时会发生的情况
This is what happens when your program doesn't

1767
01:28:19,619 --> 01:28:24,209
具有if条件，用于检查数字是1还是正数或0。
have an if condition that checks if the number is 1 or positive or 0.

1768
01:28:24,210 --> 01:28:27,300
您可以使用简单的if条件在语法上诚实地解决此问题。
You could fix this, grammatically, honestly, with a simple if condition.

1769
01:28:27,300 --> 01:28:29,770
他们几年前写这个程序时还没有。
They did not when writing this program years ago.

1770
01:28:29,770 --> 01:28:32,110
所以这里有两个或三个错误。
So there's two or three mistakes here.

1771
01:28:32,109 --> 01:28:34,619
一种是某种无效的读取或写入。
One is some kind of invalid read or write.

1772
01:28:34,619 --> 01:28:35,952
另一个是这种泄漏。
And another is this leak.

1773
01:28:35,953 --> 01:28:36,870
那么，什么是写？
Well, what is a write?

1774
01:28:36,869 --> 01:28:38,939
写只是指更改值。
A write just refers to changing a value.

1775
01:28:38,939 --> 01:28:43,149
只读只是指读取或使用或打印值。
A read just refers to reading or using or printing a value.

1776
01:28:43,149 --> 01:28:44,729
因此，让我们关注第10行。
So let's focus on line 10.

1777
01:28:44,729 --> 01:28:48,059
如果我向下滚动到我的代码并看第10行，
If I scroll back down to my code and look on line 10,

1778
01:28:48,060 --> 01:28:51,760
这是无效的写入，无效的写入。
this was an invalid write, invalid write.

1779
01:28:51,760 --> 01:28:52,950
好吧，为什么它无效？
Well, why is it invalid?

1780
01:28:52,949 --> 01:28:57,179
好吧，按照今天的定义，如果您要分配3个字节，
Well, per today's definition, if you are allocating 3 bytes,

1781
01:28:57,180 --> 01:29:01,710
欢迎您触摸第一个字节，第二个字节和第三个字节。
you are welcome to touch the first byte, the second byte, and the third byte.

1782
01:29:01,710 --> 01:29:04,500
但是你没事碰第四个字节
But you have no business touching the fourth byte

1783
01:29:04,500 --> 01:29:06,419
如果您只要求三个。
if you've only asked for three.

1784
01:29:06,420 --> 01:29:11,070
这就像是一个小规模的版本，非常冒险且不合适
This is like a small scale version of the very adventurous and inappropriate

1785
01:29:11,069 --> 01:29:14,099
当我看着10,000字节远时，我就在附近闲逛。
poking around I did when I looked at 10,000 bytes away.

1786
01:29:14,100 --> 01:29:16,680
甚至看一个字节都是一个潜在的错误
Even looking one byte away is a potential bug

1787
01:29:16,680 --> 01:29:18,780
并可能导致程序崩溃。
and can cause a program to crash.

1788
01:29:18,779 --> 01:29:21,719
同时，第11行也有问题，
Meanwhile, line 11 is also problematic, which

1789
01:29:21,720 --> 01:29:25,470
是无效的读取，因为现在，您要说去打印出此字符串。
is an invalid read, because now, you're saying go print out this string.

1790
01:29:25,470 --> 01:29:28,043
但是那个字符串包含一个内存地址
But that string contains a memory address

1791
01:29:28,042 --> 01:29:30,209
首先您不应该碰触到。
that you should not have touched in the first place.

1792
01:29:30,210 --> 01:29:34,080
而内存泄漏，第三个问题，是由于事实
And the memory leak, the third problem, stems from the fact

1793
01:29:34,079 --> 01:29:36,519
我没有释放那段记忆。
that I didn't free that memory.

1794
01:29:36,520 --> 01:29:40,380
同样，这需要一些实践和经验，一些自己的错误，
So again, it'll take some practice and experience, some mistakes of your own,

1795
01:29:40,380 --> 01:29:42,480
注意并理解这些错误。
to notice and understand these bugs.

1796
01:29:42,479 --> 01:29:44,669
但是，让我这样修复前两个问题。
But let me fix the first two like this.

1797
01:29:44,670 --> 01:29:46,530
让我给自己四个字节。
Let me just give myself four bytes.

1798
01:29:46,529 --> 01:29:48,989
然后让我修复第二个或第三个问题，
And let me fix the second one or the third one,

1799
01:29:48,989 --> 01:29:53,819
确实，通过在最后释放s来完成，因为再一次，无论何时您使用malloc
really, by freeing s at the very end, because again, any time you use malloc

1800
01:29:53,819 --> 01:29:55,589
您必须免费使用。
you must use free.

1801
01:29:55,590 --> 01:29:59,310
让我继续并重新编译内存，似乎可以编译。
Let me go ahead and recompile memory, seems to compile.

1802
01:29:59,310 --> 01:30:02,130
让我重新运行它，仍然在视觉上保持不变。
Let me rerun it, still works the same, visually.

1803
01:30:02,130 --> 01:30:05,670
但是现在，让我们在上面重新运行valgrind，看看现在是否有任何错误，
But now, let's rerun valgrind on it and see if there are any errors now,

1804
01:30:05,670 --> 01:30:08,710
所以valgrind点斜线记忆，回车。
so valgrind dot slash memory, Enter.

1805
01:30:08,710 --> 01:30:10,710
输出看起来仍然很神秘。
The output's still going to look pretty cryptic.

1806
01:30:10,710 --> 01:30:15,300
但是请注意，无论这意味着什么，所有堆块都已释放。
But notice all heap blocks were freed, whatever that means.

1807
01:30:15,300 --> 01:30:16,217
没有泄漏是可能的。
No leaks are possible.

1808
01:30:16,216 --> 01:30:18,132
确实没有比这更明确的了。
It doesn't really get more explicit than that.

1809
01:30:18,132 --> 01:30:19,089
这是好事。
That's a good thing.

1810
01:30:19,090 --> 01:30:23,100
而且，如果我向上滚动，将看不到那些无效的读写操作。
And if I scroll up, I see no mention of those invalid reads or writes.

1811
01:30:23,100 --> 01:30:26,168
因此，从本周的问题和下周的C语言开始，
So starting with this week's problems and next week's in C,

1812
01:30:26,167 --> 01:30:27,959
您不仅要使用工具
not only are you going to want to use tools

1813
01:30:27,960 --> 01:30:31,590
例如help50和printf以及debug50和check50，
like help50 and printf and debug50 and check50,

1814
01:30:31,590 --> 01:30:35,710
但是即使您认为您的代码正确，输出看起来也正确，
but even if you think your code's right, the output looks right,

1815
01:30:35,710 --> 01:30:37,050
您可能有一个潜在的错误。
you might have a latent bug.

1816
01:30:37,050 --> 01:30:40,200
即使您的程序很小，它们也可能不会使计算机崩溃。
And even when your programs are small, they might not crash the computer.

1817
01:30:40,199 --> 01:30:43,499
它们可能不会导致该分段错误。最终，他们会的。
They might not cause that segmentation fault. Eventually, they will.

1818
01:30:43,500 --> 01:30:47,849
而且您确实想使用这样的工具来消除任何此类错误。
And you do want to use tools like this to chase down any such mistakes.

1819
01:30:47,850 --> 01:30:50,460
否则，可能会发生不好的事情。
Otherwise, bad things can happen.

1820
01:30:50,460 --> 01:30:51,600
会发生什么？
And what might happen?

1821
01:30:51,600 --> 01:30:54,900
好吧，让我继续在这里展示一个例子
Well, let me go ahead and reveal an example here

1822
01:30:54,899 --> 01:30:57,839
所提供的代码有些危险。
that presents some code that's a little dangerous.

1823
01:30:57,840 --> 01:31:00,600
因此，例如，这里是一个示例
So here, for instance, is an example where

1824
01:31:00,600 --> 01:31:05,202
我在函数顶部声明了int star x和int star y。
I'm declaring at the top of the function, int star x and int star y.

1825
01:31:05,202 --> 01:31:06,160
那是什么意思呢？
So what does that mean?

1826
01:31:06,159 --> 01:31:08,699
好吧，按照今天的说法，这意味着给我
Well, per today's parlance, this just means give me

1827
01:31:08,699 --> 01:31:11,549
指向x的整数的指针。
a pointer to an integer called x.

1828
01:31:11,550 --> 01:31:13,800
给我一个指向y的整数的指针。
Give me a pointer to an integer called y.

1829
01:31:13,800 --> 01:31:16,650
换句话说，给我一个叫做x的变量
Put another way, give me a variable called x that I

1830
01:31:16,649 --> 01:31:18,899
可以存储int的地址。
can store the address of an int in.

1831
01:31:18,899 --> 01:31:23,639
给我一个名为y的变量，我可以在其中存储另一个int的地址。
Give me a variable called y that I can store the address of another int in.

1832
01:31:23,640 --> 01:31:27,880
但是请注意我在前两行中没有做的事情。
But notice what I am not doing on these first two lines.

1833
01:31:27,880 --> 01:31:31,950
直到第3行，我才真正给它们赋值。
I'm not actually assigning them a value until line 3.

1834
01:31:31,949 --> 01:31:35,999
在第3行上，即使这很奇怪-这也不是我们分配空间的方式
On line 3, even though this is weird-- this is not how we've allocated space

1835
01:31:36,000 --> 01:31:37,530
对于之前的整数-
for integers before--

1836
01:31:37,529 --> 01:31:41,129
没有理由不能使用malloc
there's no reason that you can't use malloc

1837
01:31:41,130 --> 01:31:45,550
并说给我足够的空间来容纳一个整数。
and say, give me enough space for the size of an integer.

1838
01:31:45,550 --> 01:31:46,370
sizeof是新的。
sizeof is new.

1839
01:31:46,369 --> 01:31:50,149
只是C语言中的一个运算符，它告诉您数据类型的大小，
It's just an operator in C that tells you the size of a data type,

1840
01:31:50,149 --> 01:31:51,499
就像一个int的大小一样。
like a size of an int.

1841
01:31:51,500 --> 01:31:53,479
所以也许您忘记了int是4。
So maybe you forgot that an int is 4.

1842
01:31:53,479 --> 01:31:56,449
实际上，在所有系统中，int通常为4，但并不总是4。
And indeed, an int is usually 4, but not always 4 in all systems.

1843
01:31:56,449 --> 01:32:00,019
所以int的大小只是确保它始终会为您提供正确的答案，
So size of int just makes sure that it will always give you the right answer,

1844
01:32:00,020 --> 01:32:02,630
无论您使用的是现代计算机还是旧计算机。
whether you're using a modern computer or an old one.

1845
01:32:02,630 --> 01:32:07,190
因此，这实际上意味着在现代系统上为我分配4个字节。
So this just means, really, allocate 4 bytes to me on a modern system.

1846
01:32:07,189 --> 01:32:11,369
并将第一个字节的地址存储在x中。
And it stores the address of the first byte in x.

1847
01:32:11,369 --> 01:32:15,359
有人介意翻译成外行的术语吗？
Would someone mind translating to layman's terms, what

1848
01:32:15,359 --> 01:32:18,479
恒星x等于42在做什么？
is star x equal 42 doing?

1849
01:32:18,479 --> 01:32:20,879
同样，Star是取消引用运算符。
Star, again, is the dereference operator.

1850
01:32:20,880 --> 01:32:23,430
意思是去那个地址。
It means go to the address.

1851
01:32:23,430 --> 01:32:24,375
怎么办？
And do what?

1852
01:32:24,375 --> 01:32:27,509
您如何用口头评论来描述，
How would you describe, with a verbal comment,

1853
01:32:27,510 --> 01:32:30,450
x等于42的恒星在做什么？
what star x equals 42 is doing?

1854
01:32:30,449 --> 01:32:33,629
布莱恩，您介意表达任何想法吗？
Brian, would you mind verbalizing any thoughts?

1855
01:32:33,630 --> 01:32:37,555
布莱恩：是的，所以索菲亚建议在那个地址上，我们将放置42。
BRIAN: Yeah, so Sophia suggested that at that address, we are going to place 42.

1856
01:32:37,555 --> 01:32:38,430
大卫·马兰（David MALAN）：完美。
DAVID MALAN: Perfect.

1857
01:32:38,430 --> 01:32:40,080
在该地址放42。
At that address put 42.

1858
01:32:40,079 --> 01:32:44,639
同样，转到x中的该地址并将数字42放在此处。
Equivalently, go to that address in x and put the number 42 there.

1859
01:32:44,640 --> 01:32:48,870
就像去Brian的邮箱并将42放入他的邮箱，
It's like going to Brian's mailbox and putting the 42 in his mailbox,

1860
01:32:48,869 --> 01:32:52,034
而不是我们以前在那里的数字50。
instead of what we previously had there, which was the number 50.

1861
01:32:52,034 --> 01:32:57,179
接下来的第五行，星y等于13呢？
How about this next fifth line, star y equals 13?

1862
01:32:57,180 --> 01:32:59,670
布莱恩，你能说给别人听吗？
Brian, could you verbalize someone else?

1863
01:32:59,670 --> 01:33:03,500
y等于13的恒星对我们有什么作用？
What does star y equals 13 do for us?

1864
01:33:03,500 --> 01:33:07,849
13倒霉并不是偶然的。
And it's not an accident that 13 tends to be unlucky.

1865
01:33:07,850 --> 01:33:10,530
布莱恩：彼得说，在地址y处输入13。
BRIAN: Peter says, put 13 at the address y.

1866
01:33:10,529 --> 01:33:12,709
DAVID MALAN：好的，在y的地址中输入13。
DAVID MALAN: Good, put 13 at the address in y.

1867
01:33:12,710 --> 01:33:16,860
或者换种方式，转到y中的地址，然后在其中放置13。
Or put another way, go to the address in y and put 13 there.

1868
01:33:16,859 --> 01:33:19,069
但是这里有一个逻辑问题。
But there's a logical problem here.

1869
01:33:19,069 --> 01:33:20,869
y是什么？
What is in y?

1870
01:33:20,869 --> 01:33:24,859
如果倒带，则实际上不会分配ya值。
If I rewind, I never actually assign y a value.

1871
01:33:24,859 --> 01:33:27,049
我一开始就没有，最终也没有。
I don't initially, and I don't eventually.

1872
01:33:27,050 --> 01:33:30,500
至少使用x，即使我在此处声明它时没有给它一个值
At least with x, even though I didn't give it a value in declaring it up here

1873
01:33:30,500 --> 01:33:34,849
作为变量，我最终设法将实际地址存储在其中。
as a variable, I eventually got around to storing in it the actual address.

1874
01:33:34,850 --> 01:33:38,060
现在，为了真正挑剔，我可能甚至应该在该程序中
Now, just to be really nit picky, I should probably even, in this program,

1875
01:33:38,060 --> 01:33:40,495
检查nul，以防万一出问题了。
check for nul just in case anything went wrong.

1876
01:33:40,494 --> 01:33:41,869
但这是另一个问题。
But that's a whole other problem.

1877
01:33:41,869 --> 01:33:46,469
这是一个更加令人发指的问题，我什至没有重视。
It is a more damning problem that I haven't even given y a value.

1878
01:33:46,470 --> 01:33:49,610
这是我们可以揭示有关计算机的其他详细信息的地方。
And here's where we can reveal one other detail about a computer.

1879
01:33:49,609 --> 01:33:53,749
到目前为止，我们一直认为您和我几乎总是初始化
Thus far, we've been taking for granted that you and I almost always initialize

1880
01:33:53,750 --> 01:33:54,359
我们的记忆。
our memory.

1881
01:33:54,359 --> 01:33:56,899
如果我们想给自己一个字符，一个整数，一个字符串，
If we want to give ourselves a char, an int, a string,

1882
01:33:56,899 --> 01:33:59,899
我们从字面上将其输入到程序中
we literally type it out into the program

1883
01:33:59,899 --> 01:34:02,149
本身，以便它在我们需要时就在那儿。
itself so that it's there when we want it.

1884
01:34:02,149 --> 01:34:04,069
但是如果我们在这里考虑这张照片，
But if we consider this picture here, which

1885
01:34:04,069 --> 01:34:07,369
现在只是您计算机中某些内容的物理化身
is now just a physical incarnation of some of the contents of your computer's

1886
01:34:07,369 --> 01:34:11,749
记忆，俏皮地贴着很多奥斯卡的食人鱼，
memory, playfully labeled with a lot of Oscar the Grouches,

1887
01:34:11,750 --> 01:34:16,250
这是因为您永远不应该信任计算机内存中的内容
this is because you should never trust the contents of your computer's memory

1888
01:34:16,250 --> 01:34:18,500
如果您自己还没有在那儿放东西。
if you yourself have not put something there.

1889
01:34:18,500 --> 01:34:21,560
编程中有一个术语叫做垃圾值。
There's a term of art in programming called garbage values.

1890
01:34:21,560 --> 01:34:26,180
如果您自己尚未在内存中放置任何值，
If you yourself have not put a value somewhere in memory,

1891
01:34:26,180 --> 01:34:30,210
为了安全起见，您应该假定它是引用的“垃圾值”。
you should assume, to be safe, that it is a quote unquote, "garbage value."

1892
01:34:30,210 --> 01:34:31,440
这不是一个怪异的值。
It's not a weird value.

1893
01:34:31,439 --> 01:34:34,579
只是1、2，A，B，C
It's just a 1, a 2, an A, a B, a C, you just

1894
01:34:34,579 --> 01:34:38,509
不知道它是什么，因为如果您的程序随着时间运行
don't know what it is, because if your program is running over time

1895
01:34:38,510 --> 01:34:40,890
并且您正在调用函数，并且函数正在返回。
and you're calling functions and functions are returning.

1896
01:34:40,890 --> 01:34:43,348
您正在调用其他函数，并且函数正在返回。
You're calling other functions and functions are returning.

1897
01:34:43,347 --> 01:34:46,969
您计算机内存中的这些值在不断变化，
These values in your computer's memory are constantly changing,

1898
01:34:46,970 --> 01:34:48,740
并且您的内存被重用。
and your memory gets reused.

1899
01:34:48,739 --> 01:34:53,179
当您释放内存时，不会擦除它或将其全部设置回0或对其进行设置
When you free memory, that doesn't erase it or set it all back to 0's or set it

1900
01:34:53,180 --> 01:34:53,990
全部回到1。
all back to 1's.

1901
01:34:53,989 --> 01:34:56,599
它只是留下来，以便您可以重复使用
It just leaves it alone so that you can reuse

1902
01:34:56,600 --> 01:34:59,810
它，这意味着随着时间的流逝，您的计算机中会残留
it, which means over time, your computer contains remnants

1903
01:34:59,810 --> 01:35:03,960
在这里，这里，在程序中使用过的所有变量
of all of the variables you've ever used in your program over here, over here,

1904
01:35:03,960 --> 01:35:04,730
在那边。
over there.

1905
01:35:04,729 --> 01:35:10,849
因此，在这样的程序中，您尚未显式初始化y
And so in a program like this, where you have not explicitly initialized y

1906
01:35:10,850 --> 01:35:14,000
无论如何，你应该假设奥斯卡·格鲁奇（Oscar the Grouch）可以这么说，
to anything, you should assume that Oscar the Grouch, so to speak,

1907
01:35:14,000 --> 01:35:15,020
在那个位置。
is at that location.

1908
01:35:15,020 --> 01:35:20,570
它是一个垃圾值，看起来像一个地址，但不是有效的地址。
It is a garbage value that looks like an address but is not a valid address.

1909
01:35:20,569 --> 01:35:25,039
因此，当您说星号y等于13时，这意味着转到该地址。
And so when you say star y equals 13, that means go to that address.

1910
01:35:25,039 --> 01:35:28,909
但实际上，请转到该虚假地址并在其中放置一些内容。
But really, go to that bogus address and put something there.

1911
01:35:28,909 --> 01:35:31,849
很有可能，您的程序将崩溃。
And odds are, your program is going to crash.

1912
01:35:31,850 --> 01:35:33,650
您将遇到细分错误，
You are going to get a segmentation fault,

1913
01:35:33,649 --> 01:35:37,561
因为通过转到任意垃圾值地址，
because by going to some arbitrary garbage value address,

1914
01:35:37,561 --> 01:35:40,519
这就像拿起一张随机的纸，上面有一个数字
it would be like picking up a random piece of paper with a number on it

1915
01:35:40,520 --> 01:35:42,030
然后转到该邮箱。
and then going to that mailbox.

1916
01:35:42,029 --> 01:35:42,529
为什么？
Why?

1917
01:35:42,529 --> 01:35:44,299
它确实属于您。
It does it belong to you.

1918
01:35:44,300 --> 01:35:47,930
如果您尝试取消引用未初始化的变量，
If you try to dereference an uninitialized variable,

1919
01:35:47,930 --> 01:35:49,850
您的程序可能会崩溃。
your program may very well crash.

1920
01:35:49,850 --> 01:35:51,890
也许这没有更好的表现
And this is, perhaps, no better-presented

1921
01:35:51,890 --> 01:35:55,970
而不是我们的一些朋友，斯坦福大学教授尼克·帕兰特（Nick Parlante）
than by some of our friends, Nick Parlante, a professor at Stanford

1922
01:35:55,970 --> 01:36:02,510
大学，他的生活以黏土化中的角色“ Binky”为生。
University who is breathed life into a character in claymation known as Binky.

1923
01:36:02,510 --> 01:36:06,140
我们只有2分钟的剪辑来描绘坏事
We have just a 2 minute clip from this that paints the picture of bad things

1924
01:36:06,140 --> 01:36:09,020
确实在您不应该触摸内存时发生。
indeed happening when you touch memory that you shouldn't.

1925
01:36:09,020 --> 01:36:13,340
因此，希望能对如何使用指针和不使用指针提供有用的提示。
So hopefully, a helpful reminder as to what to do and not to do with pointers.

1926
01:36:13,340 --> 01:36:14,790
开始了。
Here we go.

1927
01:36:14,789 --> 01:36:16,609
[视频回放]
[VIDEO PLAYBACK]

1928
01:36:16,609 --> 01:36:17,539
-宾基。
- Hey, Binky.

1929
01:36:17,539 --> 01:36:20,889
醒来，是时候玩转指针了。
Wake up, it's time for pointer fun.

1930
01:36:20,890 --> 01:36:22,060
- 那是什么？
- What's that?

1931
01:36:22,060 --> 01:36:23,620
了解指针？
Learn about pointers?

1932
01:36:23,619 --> 01:36:25,389
哦，天哪！
Oh, goody!

1933
01:36:25,390 --> 01:36:28,430
-好吧，开始吧，我想我们需要几个提示。
- Well, to get started, I guess we're going to need a couple pointers.

1934
01:36:28,430 --> 01:36:32,940
-好的，此代码分配了两个可以指向整数的指针。
- OK, this code allocates two pointers which can point to integers.

1935
01:36:32,939 --> 01:36:35,041
-好的，我看到了两个指针。
- OK, well I see the two pointers.

1936
01:36:35,042 --> 01:36:37,000
但是他们似乎并没有指向任何东西。
But they don't seem to be pointing to anything.

1937
01:36:37,000 --> 01:36:37,780
- 这是正确的。
- That's right.

1938
01:36:37,779 --> 01:36:39,969
最初，指针不指向任何东西。
Initially, pointers don't point to anything.

1939
01:36:39,970 --> 01:36:42,190
他们指向或称为指向对象的东西。
The things they point to or called pointees.

1940
01:36:42,189 --> 01:36:44,109
设置它们是一个单独的步骤。
And setting them up's a separate step.

1941
01:36:44,109 --> 01:36:45,099
-哦，对，对。
- Oh, right, right.

1942
01:36:45,100 --> 01:36:45,790
我知道。
I knew that.

1943
01:36:45,789 --> 01:36:47,749
指示者是分开的。
The pointees are separate.

1944
01:36:47,750 --> 01:36:50,049
那么，你如何分配一个pointee呢？
So how do you allocate a pointee?

1945
01:36:50,050 --> 01:36:53,800
-好的，这段代码分配了一个新的整数指针。
- OK, well, this code allocates a new integer pointee.

1946
01:36:53,800 --> 01:36:56,880
这部分将x指向它。
And this part sets x to point to it.

1947
01:36:56,880 --> 01:36:58,180
-嘿，看起来好多了。
- Hey, that looks better.

1948
01:36:58,180 --> 01:36:59,700
因此，使其有所作为。
So make it do something.

1949
01:36:59,699 --> 01:37:05,459
-好的，我将取消引用指针x以将数字42存储到其指针中。
- OK, I'll dereference the pointer x to store the number 42 into its pointee.

1950
01:37:05,460 --> 01:37:08,970
对于这个技巧，我需要我的魔术师取消引用。
For this trick, I'll need my magic wand of dereferencing.

1951
01:37:08,970 --> 01:37:12,660
-您取消引用的魔杖？
- Your magic wand of dereferencing?

1952
01:37:12,659 --> 01:37:14,169
那太棒了。
That's great.

1953
01:37:14,170 --> 01:37:15,910
-这就是代码的样子。
- This is what the code looks like.

1954
01:37:15,909 --> 01:37:17,799
我将设置电话号码，然后-
I'll just set up the number and--

1955
01:37:17,800 --> 01:37:18,900
[流行音乐]
[POP]

1956
01:37:18,899 --> 01:37:20,999
-嘿，看，到了。
- Hey, look, there it goes.

1957
01:37:21,000 --> 01:37:25,830
因此，在x上进行解引用遵循箭头以访问其指针。
So doing a dereference on x follows the arrow to access its pointee.

1958
01:37:25,829 --> 01:37:28,019
在这种情况下，要在其中存储42。
In this case, to store 42 in there.

1959
01:37:28,020 --> 01:37:32,450
嘿，尝试使用它通过另一个指针y存储数字13。
Hey, try using it to store the number 13 through the other pointer, y.

1960
01:37:32,449 --> 01:37:33,569
- 好的。
- OK.

1961
01:37:33,569 --> 01:37:38,099
我将在这里转到y并设置数字13
I'll just go over here to y and get the number 13 set up

1962
01:37:38,100 --> 01:37:41,970
然后拿起取消引用的魔杖，然后-
and then take the wand of dereferencing and just--

1963
01:37:41,970 --> 01:37:43,580
[HORN]哇！
[HORN] whoa!

1964
01:37:43,579 --> 01:37:45,929
-哦，嘿，那没用。
- Oh, hey, that didn't work.

1965
01:37:45,930 --> 01:37:51,370
说，Binky，我认为取消引用y不是一个好主意，因为设置
Say, Binky, I don't think dereferencing y is a good idea, because setting up

1966
01:37:51,369 --> 01:37:52,839
指示人是一个单独的步骤。
the pointee is a separate step.

1967
01:37:52,840 --> 01:37:54,815
而且我认为我们从未做到过。
And I don't think we ever did it.

1968
01:37:54,814 --> 01:37:56,429
-嗯，好点。
- Hmm, good point.

1969
01:37:56,430 --> 01:37:58,800
-是的，我们分配了指针y。
- Yeah, we allocated the pointer y.

1970
01:37:58,800 --> 01:38:01,570
但是我们从来没有将它指向一个指向对象。
But we never set it to point to a pointee.

1971
01:38:01,569 --> 01:38:03,479
-嗯，非常细心。
- Hmm, very observant.

1972
01:38:03,479 --> 01:38:05,309
-嘿，你在那里看起来不错，宾基。
- Hey, you're looking good there, Binky.

1973
01:38:05,310 --> 01:38:08,250
您能解决这个问题，以使y指向与x相同的指针吗？
Can you fix it so that y points to the same pointee as x?

1974
01:38:08,250 --> 01:38:11,620
-当然，我将使用我的魔术棒进行指针分配。
- Sure, I'll use my magic wand of pointer assignment.

1975
01:38:11,619 --> 01:38:13,799
-这会像以前一样成问题吗？
- Is that going to be a problem like before?

1976
01:38:13,800 --> 01:38:15,630
-不，这不会触碰到指示者。
- No, this doesn't touch the pointees.

1977
01:38:15,630 --> 01:38:19,170
它只是更改一个指针以指向与另一个指针相同的事物。
It just changes one pointer to point to the same thing as another.

1978
01:38:19,170 --> 01:38:20,310
- 哦，我明白了。
- Oh, I see.

1979
01:38:20,310 --> 01:38:23,040
现在，y指向与x相同的位置。
Now, y points to the same place as x.

1980
01:38:23,039 --> 01:38:24,839
所以等等，现在y是固定的。
So wait, now y is fixed.

1981
01:38:24,840 --> 01:38:25,950
它有一个pointee。
It has a pointee.

1982
01:38:25,949 --> 01:38:29,759
因此，您可以尝试再次取消引用的魔杖以发送13个。
So you can try the wand of dereferencing again to send the 13 over.

1983
01:38:29,760 --> 01:38:31,093
- 哦好的。
- Oh, OK.

1984
01:38:31,092 --> 01:38:31,634
来了
Here it goes.

1985
01:38:31,635 --> 01:38:32,900
[流行音乐]
[POP]

1986
01:38:32,899 --> 01:38:34,159
-嘿，看那个。
- Hey, look at that.

1987
01:38:34,159 --> 01:38:35,869
现在，对y进行解引用。
Now, dereferencing works on y.

1988
01:38:35,869 --> 01:38:39,979
而且由于指针共享一个pointe，所以他们都看到了13。
And because the pointers are sharing that one pointee, they both see the 13.

1989
01:38:39,979 --> 01:38:41,719
-是的，分享，随便吧。
- Yeah, sharing, whatever.

1990
01:38:41,720 --> 01:38:43,610
那我们现在要换地方吗？
So are we going to switch places now?

1991
01:38:43,609 --> 01:38:45,269
-哦，看，我们没时间了。
- Oh look, we're out of time.

1992
01:38:45,270 --> 01:38:45,770
- 但 -
- But--

1993
01:38:45,770 --> 01:38:46,040
[结束播放]
[END PLAYBACK]

1994
01:38:46,039 --> 01:38:47,569
戴维·马兰（David MALAN）：好的，所以我们还没有时间。
DAVID MALAN: All right, so we are not quite out of time.

1995
01:38:47,569 --> 01:38:50,027
但是，让我们继续前进，在这里进行第二个5分钟的休息。
But let's go ahead and take our second 5 minute break here.

1996
01:38:50,028 --> 01:38:52,910
当我们回来时，我们将仔细研究奥斯卡等等。
And when we return, we'll take a closer look at Oscar and more.

1997
01:38:52,909 --> 01:38:54,259
返回5。
Back in 5.

1998
01:38:54,260 --> 01:38:57,380
好吧，我声称所有这些垃圾
All right, so I claim that there's all these garbage

1999
01:38:57,380 --> 01:38:58,950
您计算机内存中的值。
values in your computer's memory.

2000
01:38:58,949 --> 01:39:00,859
但是你怎么看到他们呢？
But how can you see them?

2001
01:39:00,859 --> 01:39:04,399
Binky所做的当然是尝试取消引用垃圾值
What Binky did was, of course, try to dereference a garbage value

2002
01:39:04,399 --> 01:39:05,816
当坏事发生时。
when bad things happen.

2003
01:39:05,817 --> 01:39:07,900
但是，实际上我们可以用自己的代码看到这一点。
But we can actually see this with code of our own.

2004
01:39:07,899 --> 01:39:10,969
所以，让我继续快速进行一下，在这里编写一个小程序，
So let me go ahead, quickly, and whip up a little program here,

2005
01:39:10,970 --> 01:39:15,290
就像我们在第一周或第二周所做的一样，
just like something we did in week one or week two,

2006
01:39:15,289 --> 01:39:17,089
但做得不好。
but without doing it very well.

2007
01:39:17,090 --> 01:39:21,410
让我继续，像往常一样包含标准io点h，它是int main void。
Let me go ahead and include standard io dot h as usual, int main void.

2008
01:39:21,409 --> 01:39:24,289
然后让我继续，给自己一些分数。
And then let me go ahead and give myself an array of scores.

2009
01:39:24,289 --> 01:39:25,999
三个分数的数组怎么样？
How about an array of three scores?

2010
01:39:26,000 --> 01:39:28,714
在从用户那里收集分数之前，我们已经完成了此操作。
And we've done this before where we collected scores from a user.

2011
01:39:28,715 --> 01:39:30,590
但是这次，我将故意
But this time, I'm going to deliberately make

2012
01:39:30,590 --> 01:39:33,170
没有真正初始化那些分数的错误
the mistake of not actually initializing those scores

2013
01:39:33,170 --> 01:39:35,450
甚至要求人类提供这些分数。
or even asking the human for those scores.

2014
01:39:35,449 --> 01:39:41,059
我只是盲目地从i等于0迭代到3。
I'm just going to blindly go about iterating from i equals 0 on up to 3.

2015
01:39:41,060 --> 01:39:46,070
在每次迭代中，我都将假定打印任何内容
And on each iteration, I'm just going to presumptuously print whatever is

2016
01:39:46,069 --> 01:39:49,219
在分数支架i中的那个位置。
at that location in scores bracket i.

2017
01:39:49,220 --> 01:39:52,430
因此，从逻辑上讲，我的代码在尝试执行时是正确的，
So logically, my code is correct in what it's trying to do,

2018
01:39:52,430 --> 01:39:54,230
打印出分数值。
print out the values in scores.

2019
01:39:54,229 --> 01:39:57,169
但是请注意，我没有故意初始化任何
But notice that I have deliberately not initialized any

2020
01:39:57,170 --> 01:40:00,147
阵列中1、2、3分的总分。
of the 1, 2, 3 scores in that array.

2021
01:40:00,146 --> 01:40:01,729
那么谁知道那里将会发生什么呢？
So who knows what's going to be there?

2022
01:40:01,729 --> 01:40:04,649
确实，它应该是某种垃圾值
Indeed, it should be garbage values of some sort

2023
01:40:04,649 --> 01:40:06,649
我们不一定可以事先预测。
that we couldn't necessarily predict in advance.

2024
01:40:06,649 --> 01:40:10,049
因此，让我继续进行垃圾处理，因为该程序
So let me go ahead and make garbage, since this program

2025
01:40:10,050 --> 01:40:11,300
在一个名为garbage.c的文件中。
is in a file called garbage.c.

2026
01:40:11,300 --> 01:40:15,140
编译正常，但是当我现在运行垃圾时，我们
Compiles OK, but when I now run garbage, we

2027
01:40:15,140 --> 01:40:21,230
应该看到三个分数，即833060864，它们在密码上是负数。
should see three scores, which are cryptically negative, 833060864.

2028
01:40:21,229 --> 01:40:23,779
另一个是32765。
Another one is 32765.

2029
01:40:23,779 --> 01:40:25,759
第三个恰好是0。
And the third just happens to be 0.

2030
01:40:25,760 --> 01:40:28,490
所以有那些垃圾值，因为同样，计算机
So there are those garbage values, because again, the computer

2031
01:40:28,489 --> 01:40:31,799
不会为您初始化任何这些值。
is not going to initialize any of those values for you.

2032
01:40:31,800 --> 01:40:33,570
现在，有例外。
Now, there are exceptions.

2033
01:40:33,569 --> 01:40:36,319
有时，我们使用了全局变量，
We have, on occasion, used a global variable,

2034
01:40:36,319 --> 01:40:40,489
在main函数和我所有其他函数的上下文之外的常量。
a constant that is outside the context of main and all of my other functions.

2035
01:40:40,489 --> 01:40:42,859
全局变量（如果未设置），
Global variables, if you do not set them,

2036
01:40:42,859 --> 01:40:47,209
通常会为您初始化为0或nul。
are conventionally initialized to 0 or nul for you.

2037
01:40:47,210 --> 01:40:50,000
但是您通常不应该依赖这种行为。
But you should generally not rely on that kind of behavior.

2038
01:40:50,000 --> 01:40:53,120
您的直觉应该是始终初始化值
Your instinct should be to always initialize values

2039
01:40:53,119 --> 01:40:56,629
在考虑触摸或阅读它们之前
before thinking of touching or reading them

2040
01:40:56,630 --> 01:40:59,030
如通过printf或其他某种机制。
as via printf or some other mechanism.

2041
01:40:59,029 --> 01:41:02,719
好吧，让我们看看现在对内存的了解，
All right, well, let's see how this understanding, now, of memory,

2042
01:41:02,720 --> 01:41:06,350
可以引导我们解决问题，但同时也会遇到新类型的问题，
can lead us to solve problems, but also encounter new types of problems,

2043
01:41:06,350 --> 01:41:08,960
但是我们现在可以希望理解的问题。
but problems that we can now hopefully understand.

2044
01:41:08,960 --> 01:41:11,250
我将继续在这里创建一个新程序。
I'm going to go ahead and create a new program here.

2045
01:41:11,250 --> 01:41:14,390
回想一下上周这很普遍
And recall from last week that it was very common

2046
01:41:14,390 --> 01:41:15,890
让我们想交换价值。
for us to want to swap values.

2047
01:41:15,890 --> 01:41:19,010
当布莱恩（Brian）为我们做分类时，无论是选择还是冒泡
When Brian was doing our sorts for us, whether it was selection or bubble

2048
01:41:19,010 --> 01:41:21,710
排序中，发生了很多交换。
sort, there was a lot of swapping going on.

2049
01:41:21,710 --> 01:41:24,440
但是，我们并未真正为这些算法编写任何代码。
And yet, we didn't really write any code for those algorithms.

2050
01:41:24,439 --> 01:41:25,231
很好。
And that's fine.

2051
01:41:25,231 --> 01:41:27,439
但是让我们考虑一下
But let's consider that very simple primitive of just

2052
01:41:27,439 --> 01:41:30,439
交换两个值，例如，交换两个整数。
swapping two values, for instance, swapping two integers.

2053
01:41:30,439 --> 01:41:34,159
让我继续，让我自己开始一个程序，然后在这里swap.c。
Let me go ahead and give myself the start of a program and swap.c here.

2054
01:41:34,159 --> 01:41:38,629
我将包括标准io点h，int main void。
I'm going to include standard io dot h, int main void.

2055
01:41:38,630 --> 01:41:41,370
在main内部，我要给自己两个整数。
And inside of main, I'm going to give myself two integers.

2056
01:41:41,369 --> 01:41:44,959
让我们给自己一个名为x的int并将其分配为1，一个称为y的int
Let's just give myself an int called x and assign it 1, an int called y

2057
01:41:44,960 --> 01:41:46,140
并分配给它2。
and assign it 2.

2058
01:41:46,140 --> 01:41:48,890
然后让我继续，然后打印出这些值是什么。
And then let me go ahead and just print out what those values are.

2059
01:41:48,890 --> 01:41:55,520
我只是说，从字面上看，x是百分比，逗号是y是反斜杠n。
I'll just say, literally, x is percent i comma y is percent i backslash n.

2060
01:41:55,520 --> 01:41:59,490
然后，我将继续打印x逗号y。
And then I'm going to go ahead and print out x comma y, respectively.

2061
01:41:59,489 --> 01:42:02,929
然后我最终要编写一个名为
And then I'm eventually going to write a function called

2062
01:42:02,930 --> 01:42:04,613
交换x和y的交换。
swap that swaps x and y.

2063
01:42:04,613 --> 01:42:06,530
但是，现在就假设存在。
But let's assume, for the moment, that exists.

2064
01:42:06,529 --> 01:42:08,869
不会，因为我当时想做的正确
It doesn't, because what I then want to do right

2065
01:42:08,869 --> 01:42:13,339
之后，只是重印了同一件事，x现在是百分比i，
after that is just reprint the same thing, x is now percent i,

2066
01:42:13,340 --> 01:42:17,690
y是百分比i，我的假设是x和y的值
y is percent i, my presumption being that the values of x and y

2067
01:42:17,689 --> 01:42:18,869
将被交换。
will be swapped.

2068
01:42:18,869 --> 01:42:20,479
那么我该如何交换这两个值呢？
So how might I swap these two values?

2069
01:42:20,479 --> 01:42:23,119
好吧，让我继续执行自己的功能。
Well, let me go ahead and implement my own function.

2070
01:42:23,119 --> 01:42:25,109
我认为它不需要返回任何东西，
I don't think it needs to return anything,

2071
01:42:25,109 --> 01:42:27,109
所以我要说void是返回类型。
so I'm going to say void is the return type.

2072
01:42:27,109 --> 01:42:28,339
我称之为交换。
I'll call it swap.

2073
01:42:28,340 --> 01:42:30,830
它需要两个参数作为输入。
It's going to take two arguments as input.

2074
01:42:30,829 --> 01:42:33,319
我们将其称为a和b，两者都是整数。
We'll call it a and b, both integers.

2075
01:42:33,319 --> 01:42:34,819
但是我可以随便叫它。
But I could call it anything I want.

2076
01:42:34,819 --> 01:42:36,799
但是a和b似乎是合理的。
But a and b seems reasonable.

2077
01:42:36,800 --> 01:42:39,350
现在，我想继续并交换两个值。
And now, I want to go ahead and swap two values.

2078
01:42:39,350 --> 01:42:42,140
现在，布莱恩（Brian）上周用两只手做了这种事。
Now, Brian was kind of doing this with his two hands last week.

2079
01:42:42,140 --> 01:42:45,830
很好，但是我们可能应该更仔细地考虑这一点。
And that's fine, but we should probably consider this a little more closely.

2080
01:42:45,829 --> 01:42:48,049
实际上，我们让Brian代替数字
In fact, Brian, instead of numbers, let's

2081
01:42:48,050 --> 01:42:49,920
做一些更真实的世界。
do something a little more real world.

2082
01:42:49,920 --> 01:42:53,080
我认为您面前有几杯饮料。
I think you have a couple of beverages in front of you.

2083
01:42:53,079 --> 01:42:53,579
布莱恩：是的。
BRIAN: Yeah.

2084
01:42:53,579 --> 01:42:56,219
所以在这里，我有一个红色的玻璃杯和一个蓝色的玻璃杯，
So right here, I have a red glass and a blue glass,

2085
01:42:56,220 --> 01:42:58,970
例如，我猜我们可以用来表示两个变量。
which I guess we can use to represent two variables, for instance.

2086
01:42:58,970 --> 01:42:59,180
戴维·马兰：是的。
DAVID MALAN: Yeah.

2087
01:42:59,180 --> 01:43:00,198
现在，让我假设-
Now, let me suppose--

2088
01:43:00,198 --> 01:43:01,490
希望我提前告诉您。
I wish I'd told you in advance.

2089
01:43:01,489 --> 01:43:03,919
我实际上更希望红色液体是
I'd actually prefer that the red liquid be

2090
01:43:03,920 --> 01:43:07,050
在蓝色玻璃杯中，蓝色液体在红色玻璃杯中。
in the blue glass and the blue liquid be in the red glass.

2091
01:43:07,050 --> 01:43:08,780
因此，您介意交换这两个值吗？
So do you mind swapping those two values,

2092
01:43:08,779 --> 01:43:11,309
就像您上周交换了数字一样？
just like you swapped numbers last week?

2093
01:43:11,310 --> 01:43:12,060
布莱恩：是的，当然。
BRIAN: Yeah, sure.

2094
01:43:12,060 --> 01:43:14,810
这样我就可以拿起两个眼镜，并且可以切换它们的位置。
So I can just take the two glasses, and I can switch their places.

2095
01:43:14,810 --> 01:43:17,717
戴维·马兰（David MALAN）：好吧，等等，那不完全是-
DAVID MALAN: OK, wait, OK, that's not exactly--

2096
01:43:17,716 --> 01:43:18,799
你从字面上也把我带走了。
you took me too literally.

2097
01:43:18,800 --> 01:43:22,760
我认为，如果我们现在将眼镜视为特定位置
I think here, if we think of the glasses, now, as specific locations

2098
01:43:22,760 --> 01:43:24,980
在记忆中，你不能只是身体移动
in memory, you can't just physically move

2099
01:43:24,979 --> 01:43:27,539
交换计算机内部内存的芯片。
the chips of memory inside of your computer to swap things.

2100
01:43:27,539 --> 01:43:30,409
所以我认为我确实需要您移动蓝色液体
So I think I literally need you to move the blue liquid

2101
01:43:30,409 --> 01:43:33,349
进入红色玻璃杯和红色液体进入蓝色玻璃杯
into the red glass and the red liquid into the blue glass

2102
01:43:33,350 --> 01:43:36,100
因此它更像是计算机的内存。
so that it's more like a computer's memory.

2103
01:43:36,100 --> 01:43:37,657
布莱恩：好的，我可以尝试这样做。
BRIAN: OK, I can try to do that.

2104
01:43:37,657 --> 01:43:40,240
不过，我有点紧张，因为我觉得我不能只是
I'm a little nervous, though, because I feel like I can't just

2105
01:43:40,239 --> 01:43:43,269
将蓝色液体倒入红色玻璃中，因为红色液体已经
pour the blue liquid into the red glass, because the red liquid's already

2106
01:43:43,270 --> 01:43:43,640
在那里。
in there.

2107
01:43:43,640 --> 01:43:45,730
大卫·马兰（David MALAN）：是的，所以这可能不会很好地结束，
DAVID MALAN: Yeah, so this probably doesn't end well,

2108
01:43:45,729 --> 01:43:48,219
如果他必须在两副眼镜之间进行某种转换。
if he's got to do some kind of switcheroo between the two glasses.

2109
01:43:48,220 --> 01:43:49,240
那么这里有什么想法吗？
So any thoughts here?

2110
01:43:49,239 --> 01:43:54,099
就像这个怪异但真实的问题在现实世界中的解决方案是什么？
Like what is the real world solution to this weird but real problem, where

2111
01:43:54,100 --> 01:43:57,490
我们想交换这两个位置的内容，
we want to swap the contents of these two locations,

2112
01:43:57,489 --> 01:44:01,179
就像Brian交换两个内存位置的内容一样
just like Brian was swapping the contents of two memory locations

2113
01:44:01,180 --> 01:44:02,290
上个星期？
last week?

2114
01:44:02,289 --> 01:44:04,899
布赖恩，如果您希望同时进行聊天，
Brian, if you have your eye on the chat in parallel,

2115
01:44:04,899 --> 01:44:08,479
谁能对我们如何交换这两种液体有任何想法？
might anyone have ideas on how we could swap these two liquids?

2116
01:44:08,479 --> 01:44:11,619
布莱恩：是的，有几个人在说我需要第三杯。
BRIAN: Yeah, a couple of people are saying that I need a third glass.

2117
01:44:11,619 --> 01:44:13,369
大卫·马兰：好吧，布莱恩，你呢
DAVID MALAN: All right, well Brian, do you

2118
01:44:13,369 --> 01:44:16,369
恰好有第三杯你在后台后面吗？
happen to have a third glass with you back there behind back stage?

2119
01:44:16,369 --> 01:44:18,039
布莱恩：事实上，我想是的。
BRIAN: In fact, I think I do.

2120
01:44:18,039 --> 01:44:21,189
因此，我在这里有了第三杯，恰好是空的。
So I have a third glass here that just so happens to be empty.

2121
01:44:21,189 --> 01:44:22,099
戴维·马兰：好的。
DAVID MALAN: OK.

2122
01:44:22,100 --> 01:44:25,610
您现在将如何交换这两件事？
And how would you, now, go about swapping these two things?

2123
01:44:25,609 --> 01:44:28,869
布莱恩：好的，所以我想将蓝色液体放入红色玻璃杯中。
BRIAN: All right, so I want to put the blue liquid inside the red glass.

2124
01:44:28,869 --> 01:44:30,577
因此，我认为我需要做的第一件事是，
So the first thing I need to do, I think,

2125
01:44:30,578 --> 01:44:34,040
只是清空红色玻璃，为蓝色液体腾出空间。
is just to empty out the red glass to make space for the blue liquid.

2126
01:44:34,039 --> 01:44:36,309
所以我要服用红色液体，我只是
So I'm going to take the red liquid, and I'm just

2127
01:44:36,310 --> 01:44:38,470
将其倒入此额外的玻璃杯中。
going to pour it into this extra glass.

2128
01:44:38,470 --> 01:44:39,520
戴维·马兰（DAVID MALAN）：暂时，对吧？
DAVID MALAN: Temporarily though, right?

2129
01:44:39,520 --> 01:44:39,870
布莱恩：是的，是的。
BRIAN: Temporarily, yeah.

2130
01:44:39,869 --> 01:44:40,569
戴维·马兰：好的。
DAVID MALAN: OK.

2131
01:44:40,569 --> 01:44:42,619
布莱恩：只是为了保存它在那里。
BRIAN: Just to keep it to store it there.

2132
01:44:42,619 --> 01:44:45,099
现在，我想我可以倒入蓝色液体
And now, I think I can just pour the blue liquid

2133
01:44:45,100 --> 01:44:48,942
放入原始的红色玻璃杯中，因为现在我可以这样做了。
into the original red glass, because now I'm free to do so.

2134
01:44:48,942 --> 01:44:50,400
因此，我将蓝色液体倒入那里。
So I'll pour the blue liquid there.

2135
01:44:53,229 --> 01:44:56,219
我想我现在要做的最后一件事就是，现在这蓝色
And I think the last thing I need to do now is, now this blue--

2136
01:44:56,220 --> 01:44:59,680
原来装有蓝色液体的玻璃杯现在是空的。
this glass that originally held the blue liquid is now empty.

2137
01:44:59,680 --> 01:45:03,130
因此，在此临时玻璃内部的红色液体
So the red liquid, which was inside of this temporary glass over here,

2138
01:45:03,130 --> 01:45:07,350
我可以把红色的液体倒入这里。
I can take the red liquid and just pour it into this glass here.

2139
01:45:07,350 --> 01:45:10,290
现在，我没有调换眼镜的位置。
And now, I didn't swap the positions of the glasses.

2140
01:45:10,289 --> 01:45:12,389
但是液体实际上已经切换了位置。
But the liquids have actually switched places.

2141
01:45:12,390 --> 01:45:15,355
现在，蓝色液体在左侧，红色液体在右侧。
Now, the blue liquid is on the left and the red liquid is on the right.

2142
01:45:15,354 --> 01:45:16,229
戴维·马兰（David MALAN）：太好了。
DAVID MALAN: Awesome.

2143
01:45:16,229 --> 01:45:18,659
是的，我认为这是一个更实际的实现
Yeah, I think that is a more literal implementation

2144
01:45:18,659 --> 01:45:21,149
你上周所做的事情和理所当然的事情，
of what you were doing and taking for granted last week,

2145
01:45:21,149 --> 01:45:24,181
在两个不同的位置交换两个值。
swapping the two values in two separate locations.

2146
01:45:24,181 --> 01:45:25,639
因此，这似乎很简单。
So it seems pretty straightforward.

2147
01:45:25,640 --> 01:45:27,210
我只需要一点空间。
I just need a little more space.

2148
01:45:27,210 --> 01:45:29,670
如果需要的话，我需要代码中的一个临时变量。
I need a temporary variable in code, if you will.

2149
01:45:29,670 --> 01:45:31,545
看来我需要三个步骤。
And it seems I need three steps.

2150
01:45:31,545 --> 01:45:34,670
我需要倒一个，倒另一个，然后倒另一个。
I need to pour one out, pour the other one out, pour the other one back in.

2151
01:45:34,670 --> 01:45:37,122
所以我想我可以在这里将其翻译成代码。
So I think I can translate that into code here.

2152
01:45:37,122 --> 01:45:39,330
让我继续给自己一个临时变量，
Let me go ahead and give myself a temporary variable,

2153
01:45:39,329 --> 01:45:40,839
就像布赖恩一样。
like a glass, like Brian did.

2154
01:45:40,840 --> 01:45:43,650
我将其称为tmp，TMP，
And I'll call it tmp, T-M-P, which is pretty conventional when

2155
01:45:43,649 --> 01:45:45,179
您想交换代码中的两件事。
you want to swap two things in code.

2156
01:45:45,180 --> 01:45:47,850
我将暂时签署a的价值。
And I'm going to sign it, temporarily, the value of a.

2157
01:45:47,850 --> 01:45:51,550
然后我将把a的内容更改为等于B的任何内容
I'm going to then change the contents of a to equal whatever the contents of B

2158
01:45:51,550 --> 01:45:52,050
是。
are.

2159
01:45:52,050 --> 01:45:56,010
然后，我将b更改为tmp的内容。
And then I'm going to change b to be whatever the contents of tmp were.

2160
01:45:56,010 --> 01:45:58,650
所以这感觉很合理也很正确，
So this feels pretty reasonable and pretty correct,

2161
01:45:58,649 --> 01:46:01,229
因为这只是文字转换为代码，
because it's just a literal translation into code,

2162
01:46:01,229 --> 01:46:03,699
现在，布莱恩在现实世界中所做的事情。
now, of what Brian did in the real world.

2163
01:46:03,699 --> 01:46:05,609
而且我认为这会编译。
And I think this will compile.

2164
01:46:05,609 --> 01:46:08,039
因此，让我们从那里开始，进行交换。
So let's start there, make swap.

2165
01:46:08,039 --> 01:46:09,689
可以-哦，不可以编译。
It does-- oh, doesn't compile.

2166
01:46:09,689 --> 01:46:13,409
好吧，以前的隐式声明，哦，天哪，有这么多错误。
OK, previous implicit declaration, oh, so many errors, my god.

2167
01:46:13,409 --> 01:46:15,686
函数交换的隐式声明-
Implicit declaration of function swap--

2168
01:46:15,686 --> 01:46:16,269
等一下。
wait a minute.

2169
01:46:16,270 --> 01:46:17,230
我以前见过。
I've seen that before.

2170
01:46:17,229 --> 01:46:18,479
我以前犯过这个错误。
I've made this mistake before.

2171
01:46:18,479 --> 01:46:20,049
您可能也有。
You might have as well.

2172
01:46:20,050 --> 01:46:23,293
每当您看到此内容时，请记住这只是您缺少原型。
Anytime you see this, recall it's just that you're missing your prototype.

2173
01:46:23,292 --> 01:46:25,709
请记住，编译器将按字面意义带您进入。
Remember that the compiler is going to take you literally.

2174
01:46:25,710 --> 01:46:28,500
而且，如果看到它时不知道swap这个词存在，
And if it doesn't know the word swap exists when it sees it,

2175
01:46:28,500 --> 01:46:30,310
它不会成功编译。
it's not going to compile successfully.

2176
01:46:30,310 --> 01:46:33,030
因此，我们需要将原型包含在文件的顶部。
So we need to include my prototype at the top of my file.

2177
01:46:33,029 --> 01:46:35,459
现在，让我再试一次，进行交换。
Now, let me try this again, make swap.

2178
01:46:35,460 --> 01:46:36,780
好的，可以编译。
OK, that compiles.

2179
01:46:36,779 --> 01:46:40,949
现在让我继续进行交换，并回想一下，主要是我所做的
Let me go ahead now and run swap and recall that, in main, what I did

2180
01:46:40,949 --> 01:46:43,379
将x初始化为1，y初始化为2。
was initialize x to 1, y to 2.

2181
01:46:43,380 --> 01:46:45,900
然后，我打印出x是和y是什么。
I then print out what x is and what y is.

2182
01:46:45,899 --> 01:46:50,039
我调用swap，然后再次打印出x和y。
I call swap, and then I print out what x is and y is again.

2183
01:46:50,039 --> 01:46:52,769
所以我应该看到1、2，然后是2、1。
So I should see 1, 2, and then 2, 1.

2184
01:46:52,770 --> 01:46:55,430
因此，让我们按Enter键。
So lets hit Enter.

2185
01:46:55,430 --> 01:46:58,800
呵呵，似乎没有用。
Huh, it does not seem to be working.

2186
01:46:58,800 --> 01:47:01,740
好吧，让我们再试一次，以防万一-
Well, let's try it again, just in case--

2187
01:47:01,739 --> 01:47:04,019
不，不工作。
no, not working.

2188
01:47:04,020 --> 01:47:05,530
好吧，让我尝试一下。
Well, let me try this.

2189
01:47:05,529 --> 01:47:07,589
让我补充一点-printf是我的朋友。
Let me add some-- printf is my friend.

2190
01:47:07,590 --> 01:47:10,971
让我继续说a是百分之一。
Let me go ahead and say a is percent i.

2191
01:47:10,970 --> 01:47:14,459
b是我反斜杠n，a，b的百分比。
b is percent i backslash n, a, b.

2192
01:47:14,460 --> 01:47:15,510
因此，让我们将其打印出来。
So let's print that out.

2193
01:47:15,510 --> 01:47:16,650
让我们将其打印两次。
And let's print that out twice.

2194
01:47:16,649 --> 01:47:18,479
因此，这将是一种合理的调试技术。
So this would be a reasonable debugging technique.

2195
01:47:18,479 --> 01:47:21,604
如果您想知道引擎盖下面发生了什么，请添加一些printf。
If you want to know what's going on underneath the hood, add some printf's.

2196
01:47:21,604 --> 01:47:23,759
让我继续进行交换。
Let me go ahead and make swap.

2197
01:47:23,760 --> 01:47:26,520
编译后，点斜杠交换。
That compiles, dot slash swap.

2198
01:47:26,520 --> 01:47:32,880
让我们看一下，a是1，b是2，a是2，b是1。
And let's see, a is 1, b is 2, a is 2, b is 1.

2199
01:47:32,880 --> 01:47:35,470
但是x和y不变。
But then x and y are unchanged.

2200
01:47:35,470 --> 01:47:37,170
所以我觉得我的逻辑是对的。
So I feel like my logic is right.

2201
01:47:37,170 --> 01:47:38,550
它正在切换a和b。
It's switching a and b.

2202
01:47:38,550 --> 01:47:41,490
但是实际上并没有切换x和y。
But it's not actually switching x and y.

2203
01:47:41,489 --> 01:47:43,339
我可以确认很多，对吗？
And I could confirm as much, right?

2204
01:47:43,340 --> 01:47:45,510
调试此功能的更强大的方法是
The more powerful way to debug this would

2205
01:47:45,510 --> 01:47:49,890
要运行debug50，设置一个断点，例如在第17行
be to run debug50, set a break point, for instance, at line 17,

2206
01:47:49,890 --> 01:47:54,270
逐步完成我的代码，逐步进入交换功能。
step through my code, step by step, stepping into the swap function.

2207
01:47:54,270 --> 01:47:57,030
但就目前而言，交换似乎很有效。
But for now, it seems clear that swap works.

2208
01:47:57,029 --> 01:48:00,249
但是main并没有真正看到那些结果。
But main isn't really seeing those results.

2209
01:48:00,250 --> 01:48:01,449
那么到底是怎么回事？
So what's actually going on?

2210
01:48:01,449 --> 01:48:04,169
好吧，让我们考虑一下我的记忆在现实世界中的化身
Well, let's consider this real world incarnation of what my memory is

2211
01:48:04,170 --> 01:48:05,712
所以我实际上可以四处移动。
so I can actually move things around.

2212
01:48:05,712 --> 01:48:08,820
这一切都要归功于我们在剧院后面的道具店里的朋友们。
And this is all thanks to our friends in the theater's prop shop in back.

2213
01:48:08,819 --> 01:48:10,829
如果我们将此视为我的计算机的记忆，
If we think of this as my computer's memory,

2214
01:48:10,829 --> 01:48:12,539
最初，所有都是垃圾值。
initially, it's all garbage values.

2215
01:48:12,539 --> 01:48:16,079
但是我可以将其用作画布以开始在内存中分配内容。
But I can use this as a canvas to start laying things out in memory.

2216
01:48:16,079 --> 01:48:19,019
到目前为止，调用函数是我们理所当然的事情。
But calling functions is something we've taken for granted thus far.

2217
01:48:19,020 --> 01:48:22,200
事实证明，当您调用函数时，默认情况下是计算机，
And it turns out, when you call functions, the computer, by default,

2218
01:48:22,199 --> 01:48:25,499
以一种标准方式使用此内存。
uses this memory in kind of a standard way.

2219
01:48:25,500 --> 01:48:29,849
实际上，让我继续绘制更多的图片。
In fact, let me go ahead and draw a more pictorial picture.

2220
01:48:29,850 --> 01:48:33,440
如果可以的话，让我在这里更直观地描述计算机的内存
Let me draw a more literal picture here, if you will, of the computer's memory

2221
01:48:33,439 --> 01:48:33,939
再次。
again.

2222
01:48:33,939 --> 01:48:36,659
因此，如果这是计算机的内存，并且我们放大其中一个芯片，
So if this is the computer's memory and we zoom in on one of the chips,

2223
01:48:36,659 --> 01:48:39,119
我们认为该芯片具有这样的一堆字节。
and we think of the chip as having a whole bunch of bytes like this.

2224
01:48:39,119 --> 01:48:42,389
让我们抽象出实际的硬件，并像往常一样思考它。
Let's abstract away the actual hardware and think of it as we have been.

2225
01:48:42,390 --> 01:48:45,720
只是这个大的矩形存储区域，与所有那些奥斯卡奖不同
It's just this big rectangular region of memory, not unlike all of those Oscar

2226
01:48:45,720 --> 01:48:47,520
片刻之前的Grouches。
the Grouches a moment ago.

2227
01:48:47,520 --> 01:48:51,150
但是按照惯例，您的计算机不仅会放东西
But by convention, your computer does not just plop things

2228
01:48:51,149 --> 01:48:52,709
在内存中的随机位置。
in random locations in memory.

2229
01:48:52,710 --> 01:48:55,710
它具有一定的经验法则。
It has certain rules of thumb that it adheres to.

2230
01:48:55,710 --> 01:48:59,460
特别是，它会处理计算机内存的不同部分
In particular, it treats different portions of your computer's memory

2231
01:48:59,460 --> 01:49:00,330
以不同的方式。
in different ways.

2232
01:49:00,329 --> 01:49:03,569
它以标准方式使用它，因此它不是完全随机的。
It uses it in a standard way so that it's not completely random.

2233
01:49:03,569 --> 01:49:08,909
例如，当您通过在CS50 IDE上执行点斜杠来运行程序时
For instance, when you run a program by doing dot slash something on CS50 IDE

2234
01:49:08,909 --> 01:49:12,269
或更一般地在Linux上，或者双击Mac OS上的图标
or on Linux more generally, or you double click an icon on Mac OS

2235
01:49:12,270 --> 01:49:16,590
或Windows，会触发计算机的-
or Windows, that triggers the computer's--

2236
01:49:16,590 --> 01:49:21,030
该程序的0和1存储在您的硬盘上，可以在此处加载，
the program's 0's and 1's stored on your hard drive to be loaded up here,

2237
01:49:21,029 --> 01:49:23,741
称为机器代码，也就是0和1。
to what we'll call machine code, which again, is the 0's and 1's.

2238
01:49:23,742 --> 01:49:25,950
因此，如果您再次隐喻地思考，作为您的记忆
So if you think again, metaphorically, as your memory

2239
01:49:25,949 --> 01:49:29,729
是这个矩形区域，然后是机器代码，
is this rectangular region, then the machine code,

2240
01:49:29,729 --> 01:49:35,731
组成您的程序的0和1被加载到内存的顶部。
the 0's and 1's composing your program are loaded into the top part of memory.

2241
01:49:35,731 --> 01:49:38,939
同样，顶部，底部，左侧，右侧没有基本的技术含义。
And again, top, bottom, left, right, it has no fundamental technical meaning.

2242
01:49:38,939 --> 01:49:40,469
这只是艺术家的作品。
It's just an artist's rendition.

2243
01:49:40,470 --> 01:49:42,960
但是它确实进入标准位置。
But it does go into a standard location.

2244
01:49:42,960 --> 01:49:45,700
在此之下是所有全局变量。
Below that are all of your global variables.

2245
01:49:45,699 --> 01:49:48,249
放在函数之外的常量也是如此。
So are your constants that you put outside of your functions.

2246
01:49:48,250 --> 01:49:50,500
这些将最终在机器代码之下，
Those are going to end up just below the machine code,

2247
01:49:50,500 --> 01:49:53,339
同样，在计算机内存的顶部。
so again, at the top of your computer's memory.

2248
01:49:53,340 --> 01:49:55,200
在此之下是所谓的堆。
Below that is what's called the heap.

2249
01:49:55,199 --> 01:49:56,939
这是一个技术术语。
And this is a technical term.

2250
01:49:56,939 --> 01:50:00,779
它指的是分配给内存的很大一块
And it refers to a big chunk of memory that malloc

2251
01:50:00,779 --> 01:50:03,639
用于为您提供一些备用内存。
uses to get you some spare memory.

2252
01:50:03,640 --> 01:50:09,270
每次调用malloc时，都会获得一些内存块的地址
Any time you call malloc, you are given the address of some chunk of memory

2253
01:50:09,270 --> 01:50:13,200
在此区域中，在机器代码下方，在全局变量下方。
up in this region, below the machine code, below your global variables.

2254
01:50:13,199 --> 01:50:15,269
这是一个很大的区域。
And it's kind of a big zone.

2255
01:50:15,270 --> 01:50:19,120
但是要注意的是，您内存的其他部分的使用方式有所不同。
But the catch is that other parts of your memory are used differently.

2256
01:50:19,119 --> 01:50:24,569
实际上，尽管堆被认为处于关闭状态，
In fact, whereas the heap is considered to be here on down, somewhat

2257
01:50:24,569 --> 01:50:28,829
令人担忧的是，堆栈被认为位于此处。
worrisomely, the stack is considered to be here on up.

2258
01:50:28,829 --> 01:50:32,069
也就是说，当您调用malloc并请求内存时，
This is to say, when you call malloc and ask for memory,

2259
01:50:32,069 --> 01:50:35,669
在这里分配。
that gets allocated up here.

2260
01:50:35,670 --> 01:50:39,540
但是，当您调用一个函数时，这些函数
When you call a function, though, those functions

2261
01:50:39,539 --> 01:50:42,899
使用所谓的堆栈空间而不是堆空间。
use what's called stack space instead of heap space.

2262
01:50:42,899 --> 01:50:48,449
因此，任何时候调用函数，main或swap或strlang或string比较
So any time you call a function, main or swap or strlang or string compare

2263
01:50:48,449 --> 01:50:51,329
或您到目前为止使用的任何功能，
or any of the functions you've used thus far,

2264
01:50:51,329 --> 01:50:54,149
您的计算机将自动存储任何
your computer will automatically store any

2265
01:50:54,149 --> 01:50:58,859
这些函数中的局部变量或参数。
of the local variables or parameters from those functions down here.

2266
01:50:58,859 --> 01:51:00,839
现在，这不一定是最好的设计，
Now, this is not necessarily the best design,

2267
01:51:00,840 --> 01:51:02,550
因为您可以看到两个箭头指向一个
because you can see the two arrows pointing at one

2268
01:51:02,550 --> 01:51:05,383
另一辆火车就像是两列火车相互冲撞而下。
another is like two trains barreling down the tracks at one another.

2269
01:51:05,382 --> 01:51:07,267
坏事最终可能会发生。
Bad things can eventually happen.

2270
01:51:07,268 --> 01:51:09,060
幸运的是，我们通常有足够的内存
Thankfully, we typically have enough memory

2271
01:51:09,060 --> 01:51:12,370
这两件事不会发生冲突，但仅此而已。
that these two things don't collide, but more on that in just a bit.

2272
01:51:12,369 --> 01:51:15,569
同样，当您调用函数时，将使用此处的内存。
So again, when you call functions, memory down here is used.

2273
01:51:15,569 --> 01:51:17,709
当您使用malloc时，将使用此处的内存。
When you use malloc, memory up here is used.

2274
01:51:17,710 --> 01:51:19,710
现在，对于我的交换功能，我没有使用malloc。
Now, for my swap function, I'm not using malloc.

2275
01:51:19,710 --> 01:51:21,690
因此，我不必担心堆。
So I don't think I have to worry about heap.

2276
01:51:21,689 --> 01:51:23,282
而且我没有任何全局变量。
And I don't have any global variables.

2277
01:51:23,283 --> 01:51:25,200
而且我并不真正在乎我的机器代码。
And I don't really care about my machine code.

2278
01:51:25,199 --> 01:51:27,239
我只需要知道它存储在某个地方即可。
I just need to know that it's stored somewhere.

2279
01:51:27,239 --> 01:51:30,209
但是，让我们考虑一下堆栈到底是什么。
But let's consider, then, what the stack is all about.

2280
01:51:30,210 --> 01:51:32,670
实际上，堆栈就是这种动态的地方
The stack, indeed, is this sort of dynamic place

2281
01:51:32,670 --> 01:51:34,860
内存不断使用和重用的地方。
where memory keeps getting used and reused.

2282
01:51:34,859 --> 01:51:40,439
因此，例如，当您调用main时，就像您在使用该交换程序时一样
So for instance, when you call main, as you might when this swap program is

2283
01:51:40,439 --> 01:51:45,009
运行时，main会在此图片的底部使用一小段内存（如果您愿意的话）。
run, main uses a sliver of memory at the bottom of this picture, if you will.

2284
01:51:45,010 --> 01:51:47,910
所以main中的局部变量，例如x和y，
So the local variables in main, like x and y,

2285
01:51:47,909 --> 01:51:49,919
最终在内存的此底部。
end up at this bottom portion of memory.

2286
01:51:49,920 --> 01:51:53,790
当您调用swap时，swap会在main上方使用一块内存，
When you call swap, swap uses a chunk of memory just above main,

2287
01:51:53,789 --> 01:51:58,349
象形图，在此图中，例如变量a和b以及temp，
pictorally, in this diagram, such as variables a and b and temp,

2288
01:51:58,350 --> 01:51:59,410
对于这个问题。
for that matter.

2289
01:51:59,409 --> 01:52:04,679
然后，一旦交换返回并完成执行，那一小段内存
And then, once swap returns and is done executing, that sliver of memory

2290
01:52:04,680 --> 01:52:06,010
本质上消失了。
essentially goes away.

2291
01:52:06,010 --> 01:52:07,230
现在，它并没有消失。
Now, it doesn't disappear.

2292
01:52:07,229 --> 01:52:09,609
显然，那里仍然有物理内存。
Obviously, there's still physical memory there.

2293
01:52:09,609 --> 01:52:12,809
但这是我们再次讨论垃圾值的时候。
But that's when we get into the discussion of garbage values again.

2294
01:52:12,810 --> 01:52:15,540
他们仍然像整个地方的《食尸鬼奥斯卡》一样。
They're still like Oscar the Grouches all over the place.

2295
01:52:15,539 --> 01:52:18,599
您只是不知道或目前不在乎这些值是什么。
You just don't know, or at this point care, what the values are.

2296
01:52:18,600 --> 01:52:20,010
但是那里有价值。
But there are values there.

2297
01:52:20,010 --> 01:52:23,640
这就是为什么刚才我打印出未初始化得分的原因
And that's why, a moment ago, when I printed out that uninitialized score's

2298
01:52:23,640 --> 01:52:26,970
数组，我确实看到了一些伪造的值，因为仍然存在
array, I did see some bogus values, because there's still

2299
01:52:26,970 --> 01:52:30,510
将会是之前剩下的0和1。
going to be 0's and 1's there that are left over from before.

2300
01:52:30,510 --> 01:52:31,750
但是，问题是这样的。
The problem, though, is this.

2301
01:52:31,750 --> 01:52:35,069
让我谈谈我们对记忆的身体化身
Let me go over to this physical incarnation of our memory

2302
01:52:35,069 --> 01:52:38,009
并认为这是我们的堆栈，因此它正在不断发展。
and consider this as being our stack, so it's growing on up.

2303
01:52:38,010 --> 01:52:42,060
实际上，如果我想像我一样拥有两个局部变量x和y，
And in fact, if I want to have two local variables like I do, x and y,

2304
01:52:42,060 --> 01:52:47,400
让我们继续，以这里的这行内存为主，
let's go ahead and think of this row of memory here as being main,

2305
01:52:47,399 --> 01:52:48,869
例如，在这里。
for instance, here.

2306
01:52:48,869 --> 01:52:51,629
我将继续替换所有这些垃圾值
And I'm going to go ahead and replace all these garbage values

2307
01:52:51,630 --> 01:52:53,790
具有我关心的实际价值。
with an actual value that I care about.

2308
01:52:53,789 --> 01:52:57,659
而我关心的实际值，我们将称为x和y，就像
And the actual values that I care about, we're going to call x and y, just as

2309
01:52:57,659 --> 01:52:58,479
前。
before.

2310
01:52:58,479 --> 01:53:01,019
因此，每个奥斯卡奖都是一个字节。
So each of these Oscars happens to be one byte.

2311
01:53:01,020 --> 01:53:02,068
但是一个int是4个字节。
But an int is 4 bytes.

2312
01:53:02,068 --> 01:53:04,110
因此，值得庆幸的是，我们在道具店里的朋友们，
So thankfully, from our friends in the prop shop,

2313
01:53:04,109 --> 01:53:06,177
我们有这些更大的整数块。
we have these bigger integer-sized blocks.

2314
01:53:06,177 --> 01:53:08,219
我将继续将其滑入此处。
And I'm going to go ahead and slide this in here.

2315
01:53:08,220 --> 01:53:10,740
稍后，我们将其视为x。
And we're going to think of this, in a moment, as x.

2316
01:53:10,739 --> 01:53:14,339
实际上，我将继续使用标记将其称为x。
And indeed, I'm going to go ahead and call this x with a marker.

2317
01:53:14,340 --> 01:53:17,760
然后我要继续给自己一个整数，大小为4，
And then I'm going to go ahead and give myself another integer, a size 4,

2318
01:53:17,760 --> 01:53:19,300
放到这里
and put it down here.

2319
01:53:19,300 --> 01:53:21,300
我们将认为这是y。
And we're going to think of this as y.

2320
01:53:21,300 --> 01:53:23,940
回想一下，我将这些值初始化为什么？
And recall, what do I initialize these values to?

2321
01:53:23,939 --> 01:53:27,689
好吧，初始值为1，初始值为2。
Well, the value 1, initially, and the value 2.

2322
01:53:27,689 --> 01:53:29,369
但是后来我调用了交换功能。
But then I called the swap function.

2323
01:53:29,369 --> 01:53:32,159
swap函数有两个参数，a和b。
And the swap function has two arguments, a and b.

2324
01:53:32,159 --> 01:53:38,399
由于我将x逗号y传递给了我，所以这些在设计上成为x和y的副本。
And those, by design, become copies of x and y, because I passed in x comma y.

2325
01:53:38,399 --> 01:53:41,279
我将swap定义为逗号b。
And I defined swap as taking a comma b.

2326
01:53:41,279 --> 01:53:44,969
所以我认为实际上我现在需要做的是
So I think what I need to do, physically here, is now

2327
01:53:44,970 --> 01:53:50,170
认为这第二行内存现在属于交换功能，
think of this second row of memory as now belonging to the swap function,

2328
01:53:50,170 --> 01:53:51,210
不主要。
not to main.

2329
01:53:51,210 --> 01:53:54,090
在第二行的内存中，我将
And inside of this second row of memory, I'll

2330
01:53:54,090 --> 01:53:57,540
认为这属于交换。
think of this as belonging to swap.

2331
01:53:57,539 --> 01:54:02,099
在交换行中，我将拥有另一个大小为4的整数。
And within the swap row, I'm going to have another integer of size 4.

2332
01:54:02,100 --> 01:54:07,500
我们将其称为“ a”，如下面所示。
And we're going to call this one a, as down there, a.

2333
01:54:07,500 --> 01:54:10,350
然后，我将再得到另一个大小为4的块。
And then I'm going to have another chunk of size 4.

2334
01:54:10,350 --> 01:54:12,600
我们将其称为b。
And we're going to call this b.

2335
01:54:12,600 --> 01:54:16,050
再说一次，因为这些只是参数，x逗号y，否则
And again, because those are just the arguments, x comma y, otherwise

2336
01:54:16,050 --> 01:54:20,760
现在称为逗号b，我将1和2复制到这些值中。
now known as a comma b, I copy 1 and 2 into those values.

2337
01:54:20,760 --> 01:54:22,770
但是swap具有第三个变量。
But swap has a third variable.

2338
01:54:22,770 --> 01:54:24,730
布赖恩提出了一个临时变量。
Brian proposed a temporary variable.

2339
01:54:24,729 --> 01:54:27,479
所以我要继续给自己四个字节，
So I'm going to go ahead and give myself four more bytes,

2340
01:54:27,479 --> 01:54:30,209
从而摆脱那里的垃圾值
thereby getting rid of whatever the garbage value's there

2341
01:54:30,210 --> 01:54:34,260
并将其实际设置为整数调用tmp。
and actually setting it to an integer call tmp.

2342
01:54:34,260 --> 01:54:39,030
因此，我将继续将其称为tmp，TMP。
So I'm going to go ahead and call this thing tmp, T-M-P.

2343
01:54:39,029 --> 01:54:40,439
我首先做了什么？
And what did I do first?

2344
01:54:40,439 --> 01:54:43,844
我将tmp设置为a。
I set tmp equals to a.

2345
01:54:43,845 --> 01:54:45,120
因此，tmp等于a。
So tmp equals to a.

2346
01:54:45,119 --> 01:54:47,519
因此，如果a为1，则tmp为1。
So if a is 1, tmp is 1.

2347
01:54:47,520 --> 01:54:48,750
那我怎么办
Then what did I do?

2348
01:54:48,750 --> 01:54:51,779
然后我做了一个等于b。
I then did a equals b.

2349
01:54:51,779 --> 01:54:55,149
所以b是2。
So b is 2.

2350
01:54:55,149 --> 01:54:57,799
a也为2。
a is 2 as well.

2351
01:54:57,800 --> 01:55:00,030
最后，我做了什么？
And then lastly, what did I do?

2352
01:55:00,029 --> 01:55:02,144
我没有b获得tmp。
I did b gets tmp.

2353
01:55:02,145 --> 01:55:05,020
所以我必须继续将其更改为tmp的值
So I have to go ahead and change this to be whatever the value of tmp

2354
01:55:05,020 --> 01:55:07,630
是，现在是数字1。
is, which is now the number 1.

2355
01:55:07,630 --> 01:55:10,150
这样一来，您就可以看到交换是正确的
So you can see that swap is correct insofar

2356
01:55:10,149 --> 01:55:12,654
因为它交换a和b的值。
as it is swapping the values of a and b.

2357
01:55:12,654 --> 01:55:16,689
但是当交换返回时，这些返回
But the moment swap returns, these return

2358
01:55:16,689 --> 01:55:18,999
被认为是垃圾值。
to being thought of as garbage values.

2359
01:55:19,000 --> 01:55:20,860
Main仍在运行中。
Main is still in the middle of running.

2360
01:55:20,859 --> 01:55:22,299
交换不再运行。
Swap is no longer running.

2361
01:55:22,300 --> 01:55:23,743
但是这些价值观仍然存在。
But these values stay there.

2362
01:55:23,743 --> 01:55:24,910
所以这些是垃圾值。
So those are garbage values.

2363
01:55:24,909 --> 01:55:27,849
我们碰巧知道它们是什么，但它们不再有效，
We happen to know what they are, but they're no longer valid,

2364
01:55:27,850 --> 01:55:32,560
因为当我第二次打印x和y时，x和y是什么？
because when I go to print out x and y for the second time, what are x and y?

2365
01:55:32,560 --> 01:55:33,820
他们还是一样。
They're still the same.

2366
01:55:33,819 --> 01:55:37,869
这就是说，当您实际编写带有参数的代码时
And so this is to say, when you actually write code that takes arguments

2367
01:55:37,869 --> 01:55:40,749
然后您将参数从一个函数传递给另一个函数，
and you pass arguments from one function to another,

2368
01:55:40,750 --> 01:55:43,930
这些参数从一个函数复制到另一个函数。
those arguments are copied from one function to another.

2369
01:55:43,930 --> 01:55:47,140
实际上，x和y被复制到a和b中。
And indeed, x and y are copied into a and b.

2370
01:55:47,140 --> 01:55:51,670
因此，您的代码可能会正确切换，因此看起来很正确。
So your code may very well look correct in that it's swopping correctly.

2371
01:55:51,670 --> 01:55:55,750
但这只是在交换上下文中正确交换，
But it's only swapping correctly in the context of swap,

2372
01:55:55,750 --> 01:55:58,370
不触及原始值。
not touching the original values.

2373
01:55:58,369 --> 01:56:00,729
所以我认为从根本上说我们需要做的是
So what I think we need to do, fundamentally,

2374
01:56:00,729 --> 01:56:06,129
重新实现交换的方式是，我们实际上
is reimplement swap in such a way that we actually

2375
01:56:06,130 --> 01:56:10,450
更改x和y的值。
change the values of x and y.

2376
01:56:10,449 --> 01:56:11,499
但是，我们该怎么做呢？
But how can we do this?

2377
01:56:11,500 --> 01:56:13,810
布莱恩，如果我们可以在这里打电话的话。
Brian, if we could call in someone here.

2378
01:56:13,810 --> 01:56:18,340
我如何从概念上更改我的交换实现
How could I conceptually change my implementation of swap

2379
01:56:18,340 --> 01:56:26,110
从而以某种方式授权我更改x和y，而不更改x和y的副本？
so that it somehow empowers me to change x and y, not change copies of x and y?

2380
01:56:26,109 --> 01:56:28,569
我可以将什么兑换成货币，Brian？
What could I pass into swap, Brian?

2381
01:56:28,569 --> 01:56:31,149
布莱恩：伊戈尔建议我们改用指针。
BRIAN: Igor is suggesting that we use pointers instead.

2382
01:56:31,149 --> 01:56:33,732
大卫·马兰（David MALAN）：是的，所以今天也许是这里的首要问题。
DAVID MALAN: Yeah, so perhaps the leading question here today.

2383
01:56:33,733 --> 01:56:36,010
但是指针似乎可以为我们提供解决方案。
But pointers would seem to give us a solution.

2384
01:56:36,010 --> 01:56:38,170
如果指针本质上像是宝藏
If pointers are essentially like a treasure

2385
01:56:38,170 --> 01:56:41,500
映射到计算机内存中的特定地址，我应该真正
map to a specific address in your computer's memory, what I should really

2386
01:56:41,500 --> 01:56:45,940
从main到swap的字面意义上不是传递x和y，
do from main to swap is pass in not x and y literally,

2387
01:56:45,939 --> 01:56:49,629
但是为什么我不传递x的地址和y的地址，
but why don't I pass in the address of x and the address of y,

2388
01:56:49,630 --> 01:56:53,230
这样交换就可以转到这些地址了
so that swap can now go to those addresses

2389
01:56:53,229 --> 01:56:57,459
并实际执行了Brian亲自进行的那种互换。
and actually do the sort of swap that Brian enacted in person.

2390
01:56:57,460 --> 01:57:02,050
因此，请为函数提供这些值的映射，指向这些值的指针，
So give the function a sort of map to those values, pointers to those values,

2391
01:57:02,050 --> 01:57:03,560
然后转到这些值。
and then go to those values.

2392
01:57:03,560 --> 01:57:04,580
那我该怎么办呢？
So how might I do this?

2393
01:57:04,579 --> 01:57:06,579
好吧，现在的代码必须有所不同。
Well, the code has to be a little different now.

2394
01:57:06,579 --> 01:57:09,639
这次我打电话给swap时，我真正需要做的是
When I call swap this time, what I really need to do

2395
01:57:09,640 --> 01:57:12,710
是传递这两个变量的地址。
is pass in the addresses of these two variables.

2396
01:57:12,710 --> 01:57:14,950
因此，我不一定知道这些地址是什么。
So I don't necessarily know what those addresses are.

2397
01:57:14,949 --> 01:57:16,899
但是为了这个故事，我们可以
But for the sake of the story, we can just

2398
01:57:16,899 --> 01:57:21,339
假设该地址例如为0x123。
assume that this address, for instance, is like, 0x123.

2399
01:57:21,340 --> 01:57:25,142
然后，距离该值的四个字节可能是0x127。
And then four bytes away from that might be 0x127, for instance.

2400
01:57:25,141 --> 01:57:27,099
但是再次，它到底是什么并不重要。
But again, it doesn't really matter what it is.

2401
01:57:27,100 --> 01:57:29,440
但是它们确实有地址x和y。
But they do have addresses, x and y.

2402
01:57:29,439 --> 01:57:31,561
因此，指针的回忆往往很大。
So a pointer recall tends to be pretty big.

2403
01:57:31,561 --> 01:57:33,519
所以我们需要拿出一块更大的木头，
So we needed to get out a bigger piece of wood,

2404
01:57:33,520 --> 01:57:35,590
代表一个指针的八个字节。
eight bytes that represents a pointer.

2405
01:57:35,590 --> 01:57:38,830
实际上，我现在需要在交换中使用更多的内存。
And I actually need to use a bit more memory in swap now.

2406
01:57:38,829 --> 01:57:42,489
如果我现在声明a为非整数，
If I now declare a to be, not an integer,

2407
01:57:42,489 --> 01:57:47,019
但是一个指向int的指针，这是一个int星型变量，
but a pointer to an int, that is a int star variable,

2408
01:57:47,020 --> 01:57:49,330
我现在可以称呼这件事。
I could call this thing a now.

2409
01:57:49,329 --> 01:57:54,339
我可以在其中存储x的地址，例如0x123。
And I could store, in it, the address of x, like 0x123.

2410
01:57:54,340 --> 01:57:57,640
如果我然后将b的定义更改为
If I then change the definition of b to be

2411
01:57:57,640 --> 01:58:01,390
不是整数，而是指向整数的指针，
not an integer, but a pointer to an integer,

2412
01:58:01,390 --> 01:58:04,810
那是另一个int星，恰好是八个字节。
that is another int star, which happens to be eight bytes.

2413
01:58:04,810 --> 01:58:07,780
我将为此使用更多的内存，但是没关系。
I'm going to use a little more memory for this thing, but that's OK.

2414
01:58:07,779 --> 01:58:10,029
它的名字现在将是b。
And its name is going to be b now.

2415
01:58:10,029 --> 01:58:13,599
它将包含0x127。
And it's going to contain 0x127.

2416
01:58:13,600 --> 01:58:15,820
我仍然需要一个临时变量。
I still need a temporary variable.

2417
01:58:15,819 --> 01:58:18,649
我仍然需要一个临时变量，但这很好。
I still need a temporary variable, but that's fine.

2418
01:58:18,649 --> 01:58:20,979
我只需要四个字节，因为变量
I just need four bytes for that, because the variable

2419
01:58:20,979 --> 01:58:25,989
本身只需要存储一个int，就像Brian暂时将其存储在玻璃杯中一样。
itself just needs to store an int, like Brian temporarily stored it in a glass.

2420
01:58:25,989 --> 01:58:29,259
所以我只需要一个额外的四个字节，就像以前一样。
So I just need an additional four bytes, like before, for that.

2421
01:58:29,260 --> 01:58:31,720
现在，让我们考虑一下逻辑。
And now, let's just consider the logic.

2422
01:58:31,720 --> 01:58:32,710
这是主要的。
Here's main.

2423
01:58:32,710 --> 01:58:34,990
现在，swap正在使用这些3--
And swap is now using these 3--

2424
01:58:34,989 --> 01:58:36,549
2和1/2行内存。
2 and 1/2 rows of memory.

2425
01:58:36,550 --> 01:58:37,240
很好。
And that's fine.

2426
01:58:37,239 --> 01:58:39,639
正如我建议的那样，它正在向上发展。
It's growing upward as I proposed.

2427
01:58:39,640 --> 01:58:41,860
X位于地址0x123。
X is at address 0x123.

2428
01:58:41,859 --> 01:58:44,559
y位于地址0x127。
y is at address 0x127.

2429
01:58:44,560 --> 01:58:48,370
因此，我在概念上提出a和b，就像Igor提出的那样，
Therefore, a and b, I propose conceptually, like Igor proposed,

2430
01:58:48,369 --> 01:58:52,279
分别存储a，x和y的地址。
store the addresses of a, x and y, respectively.

2431
01:58:52,279 --> 01:58:55,059
现在，我想我的代码需要这么说。
And now my code, I think, needs to say this.

2432
01:58:55,060 --> 01:59:00,025
将变量a中的任何内容存储在地址t中。
Go and store, in the variable tmp, whatever is at the address a.

2433
01:59:00,024 --> 01:59:02,649
因此，您可以将其视为此处的箭头。
So you can kind of think of this as being an arrow down here.

2434
01:59:02,649 --> 01:59:03,909
跟随箭头，确定。
Follow the arrow, OK.

2435
01:59:03,909 --> 01:59:06,009
地址0x123是什么？
What is at address 0x123?

2436
01:59:06,010 --> 01:59:06,910
数字1。
The number 1.

2437
01:59:06,909 --> 01:59:09,249
因此，就像以前一样，我们在tmp中放入了一个。
So we put one in tmp, just like before.

2438
01:59:09,250 --> 01:59:10,310
那我们该怎么办？
Then what do we do?

2439
01:59:10,310 --> 01:59:13,540
好吧，现在，我要继续改变，而不是改变a的价值，
Well, now, I'm going to go ahead and change, not the value of a,

2440
01:59:13,539 --> 01:59:18,009
但我要更改的位置是
but I'm going to change what is at the location in a to be

2441
01:59:18,010 --> 01:59:24,790
b中的位置是什么，这是一个指向此处向下的箭头，0x127。
whatever is at the location in b, which is an arrow pointing down here, 0x127.

2442
01:59:24,789 --> 01:59:27,849
因此，我现在将其更改为2。
So I'm going to change this 1, now, to be a 2.

2443
01:59:27,850 --> 01:59:30,910
回忆起来，第三步也是最后一步，对我来说，
And the third and final step, recall, is for me, now,

2444
01:59:30,909 --> 01:59:37,149
去，而不是去b，而是去b指向的位置，恰好是y，
to go, not to b, but to go where b points to, which happens to be y,

2445
01:59:37,149 --> 01:59:42,439
并将其更改为tmp的值，当然这是在这里。
and change that to be the value of tmp, which of course, is up here.

2446
01:59:42,439 --> 01:59:45,429
在故事的这一点上，它仍然只是三行代码。
And at this point in the story, it's still just three lines of code.

2447
01:59:45,430 --> 01:59:47,380
它们是不同类型的代码行。
They're different types of lines of code.

2448
01:59:47,380 --> 01:59:48,950
这是三行代码。
It's three lines of code.

2449
01:59:48,949 --> 01:59:52,179
但是当交换完成执行后，请注意我们已经完成了。
But when swap is done executing, notice what we've done.

2450
01:59:52,180 --> 01:59:55,190
通过让我们成功地交换了x和y
We have successfully swapped x and y by letting

2451
01:59:55,189 --> 01:59:59,269
交换去那些地址，而不是天真地得到
swap go to those addresses as opposed to just naively getting

2452
01:59:59,270 --> 02:00:02,180
其中的值的副本。
copies of the values therein.

2453
02:00:02,180 --> 02:00:05,150
现在，即使这段代码看起来有些晦涩，
Now, even though this code is going to look a little cryptic,

2454
02:00:05,149 --> 02:00:10,819
坦白说，它只是到目前为止所见逻辑的一种应用。
it's, frankly, just an application of the logic we've seen thus far.

2455
02:00:10,819 --> 02:00:13,859
我将继续并返回旧的越野车版本。
I'm going to go ahead and go back to my old buggy version.

2456
02:00:13,859 --> 02:00:15,859
我将更改交换的定义
And I'm going to change the definition of swap

2457
02:00:15,859 --> 02:00:19,189
说它不需要两个整数a和b，而是两个
to say that it doesn't take two integers, a and b, but two

2458
02:00:19,189 --> 02:00:20,809
指向整数a和b的指针。
pointers to integers a and b.

2459
02:00:20,810 --> 02:00:24,080
声明指针调用的方式就是变量的类型
And the way you declare a pointer recall is the type of variable

2460
02:00:24,079 --> 02:00:26,766
您指向后跟一个星星，然后是它的名称。
you point at followed by a star and then the name of it.

2461
02:00:26,766 --> 02:00:28,849
诚然，在上下文中我们还没有看到它
And we haven't seen it, admittedly, in the context

2462
02:00:28,850 --> 02:00:31,550
带有参数的函数。
of a function taking parameters yet.

2463
02:00:31,550 --> 02:00:33,170
但这很简单。
But it's quite simply that.

2464
02:00:33,170 --> 02:00:34,610
我加了星星。
I added the stars.

2465
02:00:34,609 --> 02:00:40,039
在这里，我需要说的是，无论存储在tmp中是什么。
Down here, I need to say, store in tmp, whatever is at a.

2466
02:00:40,039 --> 02:00:41,869
我该如何表达去？
How do I express go to a?

2467
02:00:41,869 --> 02:00:43,519
只需在此处添加星星。
Just add a star here.

2468
02:00:43,520 --> 02:00:46,880
我该如何表达去a并把b处的任何值放进去？
How do I express go to a and put whatever is at b?

2469
02:00:46,880 --> 02:00:48,500
我在那里加星。
I add stars there.

2470
02:00:48,500 --> 02:00:51,560
我怎么说，去b并存储tmp中的所有内容？
How do I say, go to b and store whatever is at tmp?

2471
02:00:51,560 --> 02:00:53,190
我在那里加一颗星。
I add one star there.

2472
02:00:53,189 --> 02:00:55,519
因此，tmp只是一个简单的整数。
So tmp is just a simple integer.

2473
02:00:55,520 --> 02:00:57,380
就像布赖恩一样，这只是一个空杯子。
It's just an empty glass like Brian had.

2474
02:00:57,380 --> 02:00:58,620
那里没有幻想。
There's nothing fancy there.

2475
02:00:58,619 --> 02:01:00,649
因此，我们不需要tmp周围的星星。
So we don't need stars around tmp.

2476
02:01:00,649 --> 02:01:04,969
但是我现在确实需要更改我使用a和b的方式，
But I do, now, need to change how I'm using a and b,

2477
02:01:04,970 --> 02:01:08,330
因为现在它们是我实际要访问的地址。
because now they are addresses that I actually want to go to.

2478
02:01:08,329 --> 02:01:12,139
在这种情况下，不需要操作员的地址。
There's no need for the address of operator in this context.

2479
02:01:12,140 --> 02:01:14,330
但是在这里，我将需要进行更改。
But up here, I'm going to need to make a change.

2480
02:01:14,329 --> 02:01:16,379
我确实需要更改原型以使其匹配。
I do need to change the prototype to match.

2481
02:01:16,380 --> 02:01:18,200
所以这只是一个复制粘贴。
So that's just a copy paste.

2482
02:01:18,199 --> 02:01:23,119
但我敢打赌，您可以想象最后需要改变的地方。
But I bet you can imagine what, lastly, needs to change.

2483
02:01:23,119 --> 02:01:26,749
调用swap时，我不想天真地传递x和y，因为同样，
When calling swap, I don't want to pass in naively x and y, because again,

2484
02:01:26,750 --> 02:01:27,979
他们将被复制。
they're going to get copied.

2485
02:01:27,979 --> 02:01:31,999
我想输入x的地址和y的地址，
I want to pass in the address of x and the address of y,

2486
02:01:32,000 --> 02:01:35,689
这样交换现在具有某种特殊的访问权限
so that swap now has sort of special access

2487
02:01:35,689 --> 02:01:38,749
到内存中那些位置的内容
to the contents of those locations in memory

2488
02:01:38,750 --> 02:01:42,740
以便它实际上可以在其中进行一些更改。
so that it actually can make some changes therein.

2489
02:01:42,739 --> 02:01:47,779
而且，确实，如果我现在重新编译该程序，进行交换，然后执行
And that, indeed, if I now recompile this program, make swap, and I do

2490
02:01:47,779 --> 02:01:50,389
点交换，交叉我的手指，瞧。
dot swap and cross my fingers, voila.

2491
02:01:50,390 --> 02:01:53,855
现在，我已经成功交换了代码行。
Now, I have successfully swapped lines of code.

2492
02:01:53,854 --> 02:01:55,729
所以上周，如果您想知道，
So last week, if you were wondering, perhaps,

2493
02:01:55,729 --> 02:01:58,249
为什么我们不向您展示如何进行交换，我们本来可以的。
why we didn't show you how to do swap, we could have.

2494
02:01:58,250 --> 02:01:59,899
而且我们不需要特殊功能。
And we didn't need a special function.

2495
02:01:59,899 --> 02:02:03,199
如果我们主要进行了所有这些操作，则不一定需要指针。
You don't necessarily need pointers if we did all of this in main.

2496
02:02:03,199 --> 02:02:06,469
但是我试图引入一个抽象，这个函数
But I'm trying to introduce an abstraction, this function that

2497
02:02:06,470 --> 02:02:09,740
确实像Brian为我们交换了那些眼镜一样进行了交换。
does swap just like Brian swapped those glasses for us.

2498
02:02:09,739 --> 02:02:12,649
并将值从一个函数传递给另一个函数，
And to pass values from one function to another,

2499
02:02:12,649 --> 02:02:15,989
您确实需要了解计算机内存中正在发生的事情
you do need to understand what's going on in your computer's memory

2500
02:02:15,989 --> 02:02:18,829
以便您实际上可以再次传入小面包屑，
so that you can actually pass in little breadcrumbs again,

2501
02:02:18,829 --> 02:02:23,329
再次感谢这些东西，将藏宝图映射到这些位置和记忆
treasure maps to those locations and memories, again, thanks to these things

2502
02:02:23,329 --> 02:02:25,099
称为指针。
called pointers.

2503
02:02:25,100 --> 02:02:27,770
好吧，让我提出并强调，
All right, well let me propose and emphasize,

2504
02:02:27,770 --> 02:02:30,770
然后，将堆的设计放在顶部，
then, that this design of the heap being up at the top,

2505
02:02:30,770 --> 02:02:33,200
其中malloc使用内存，而堆栈是
where malloc uses memory and the stack being

2506
02:02:33,199 --> 02:02:35,539
在您自己的函数使用内存的底部，
at the bottom where your own functions use memory,

2507
02:02:35,539 --> 02:02:37,729
这显然是一个等待发生的问题。
this is a problem clearly waiting to happen.

2508
02:02:37,729 --> 02:02:39,459
这些问题实际上都有名称。
And those problems actually have names.

2509
02:02:39,460 --> 02:02:41,210
还有一些以前编程的人
And some of you who have programmed before

2510
02:02:41,210 --> 02:02:45,230
可能知道其中一些术语，无论是堆溢出还是栈溢出。
might know some of these terms, either heap overflow or stack overflow.

2511
02:02:45,229 --> 02:02:48,649
实际上，您中的许多人可能只是将stackoverflow.com视为一个网站。
And in fact, many of you might know stackoverflow.com as just a website.

2512
02:02:48,649 --> 02:02:50,839
好吧，有一个起源故事的名字。
Well, there is an origin story to its name.

2513
02:02:50,840 --> 02:02:56,240
堆栈溢出是指多次调用函数的过程
A stack overflow refers to the process of calling a function so many times

2514
02:02:56,239 --> 02:02:58,549
它溢出了堆。
that it overflows the heap.

2515
02:02:58,550 --> 02:03:00,320
也就是说，每次您调用该函数时，
That is, every time you call the function,

2516
02:03:00,319 --> 02:03:04,949
就像我在这里所做的那样，可以说，您使用了越来越多的内存行。
like I did here, you use more and more rows, so to speak, of memory.

2517
02:03:04,949 --> 02:03:07,729
如果您一次又一次调用这么多函数，
And if you call so many functions again and again,

2518
02:03:07,729 --> 02:03:11,689
最终，您很可能会在称为堆的内存区域中运行。
eventually, you may very well run over the area of memory called heap.

2519
02:03:11,689 --> 02:03:14,089
到那时，您的程序将崩溃。
And at that point, your program will crash.

2520
02:03:14,090 --> 02:03:18,950
除了不做之外，没有根本的解决方案。
There is no fundamental solution to that problem other than don't do that.

2521
02:03:18,949 --> 02:03:20,419
不要使用过多的内存。
Don't use too much memory.

2522
02:03:20,420 --> 02:03:21,680
但这很难做到。
But that can be hard to do.

2523
02:03:21,680 --> 02:03:24,138
实际上，那是当今编程的危险之一。
And indeed, that's one of the dangers of programming today.

2524
02:03:24,137 --> 02:03:27,799
实际上，我们可以自己故意对此进行一些诱导。
And we can actually induce this a little bit deliberately ourselves.

2525
02:03:27,800 --> 02:03:30,620
实际上，例如，我认为我们可以重新考虑一下，
And in fact, I thought we could revisit, for instance,

2526
02:03:30,619 --> 02:03:34,219
我们上次与马里奥（Mario）离开的地方是这张照片。
where we left off with Mario last time, which was this picture here.

2527
02:03:34,220 --> 02:03:37,580
回想一下，这当然是一座金字塔，
Recall that this was a pyramid, of course,

2528
02:03:37,579 --> 02:03:40,399
比您可能遇到的问题（0）更简单。
simpler than the one you might have played with for problems at 0.

2529
02:03:40,399 --> 02:03:44,359
但这是递归金字塔，您可以定义高度为4的金字塔
But it's a recursive pyramid in that you can define a pyramid of height 4,

2530
02:03:44,359 --> 02:03:47,689
就高度3的金字塔而言，就高度2的金字塔而言
in terms of a pyramid of height 3, in terms of a pyramid of height 2

2531
02:03:47,689 --> 02:03:48,379
身高1。
and a height 1.

2532
02:03:48,380 --> 02:03:52,580
的确，我上周使用这些代码块构建了该代码。
And indeed, I built that last week using these very blocks.

2533
02:03:52,579 --> 02:03:56,179
好吧，你可以像这样实现马里奥的金字塔
Well, you can implement Mario's pyramid like this

2534
02:03:56,180 --> 02:03:57,660
以几种不同的方式。
in a couple of different ways.

2535
02:03:57,659 --> 02:04:01,159
一个只是使用循环，使用第一个星期的样式迭代。
One is just using week one style iteration, using a loop.

2536
02:04:01,159 --> 02:04:03,889
实际上，让我继续快速提出一个解决方案，
And in fact, let me go ahead and whip up a quick solution that

2537
02:04:03,890 --> 02:04:05,340
确实做到了。
does exactly that.

2538
02:04:05,340 --> 02:04:07,730
让我继续将此电话称为mario.c。
Let me go ahead and call this mario.c.

2539
02:04:07,729 --> 02:04:10,609
我将继续进行，并包含cs50.h。
And I'm going to go ahead and include cs50.h.

2540
02:04:10,609 --> 02:04:12,289
因此，我们可以使用我们的get函数之一。
So we can use one of our get functions.

2541
02:04:12,289 --> 02:04:14,299
我将使用标准io点h。
I'm going to use standard io dot h.

2542
02:04:14,300 --> 02:04:16,160
而且我将做int main void。
And I'm going to do int main void.

2543
02:04:16,159 --> 02:04:18,589
我要做的就是打印出这个金字塔。
And all I want to do is print out this pyramid.

2544
02:04:18,590 --> 02:04:20,340
但是我想问一下使用者的身高。
But I want to ask the user for the height.

2545
02:04:20,340 --> 02:04:23,090
所以我要说的是int height等于get int。
So I'm going to say int height equals get int.

2546
02:04:23,090 --> 02:04:26,870
就像您对问题1所做的那样，我们将询问用户身高。
And we'll ask the user for the height, just like you did for problem set 1.

2547
02:04:26,869 --> 02:04:29,999
然后，我将继续绘制该高度的金字塔。
And then I'm going to go ahead and draw a pyramid of that height.

2548
02:04:30,000 --> 02:04:31,340
现在，绘图不存在。
Now, draw doesn't exist.

2549
02:04:31,340 --> 02:04:32,030
但这很好。
But that's fine.

2550
02:04:32,029 --> 02:04:34,734
我现在要继续进行绘制，自己实施绘制。
I'm going to go ahead and draw this now, implement draw myself.

2551
02:04:34,734 --> 02:04:36,859
它不需要返回值，因为我只是
It doesn't need to return a value, because I'm just

2552
02:04:36,859 --> 02:04:38,272
在屏幕上打印东西。
printing stuff on the screen.

2553
02:04:38,273 --> 02:04:40,190
该函数称为“绘制”，它将用到
Function's called draw, and it's going to take

2554
02:04:40,189 --> 02:04:42,709
例如，一个名为h的输入。 h为高度，
an input called h, for instance. h for height,

2555
02:04:42,710 --> 02:04:45,080
但是我可以随便说它的说法。
but I could call its argument anything I want.

2556
02:04:45,079 --> 02:04:48,649
然后我将要执行此操作，因为我得到1，
And then I'm just going to do this, for int i gets 1,

2557
02:04:48,649 --> 02:04:52,849
我小于或等于h，我++。
i less than or equal to h, i++.

2558
02:04:52,850 --> 02:04:56,170
然后，在其中，您可能会从问题集一中回忆起这一点，
And then inside of this, this is where you might recall, from problem set one,

2559
02:04:56,170 --> 02:04:58,700
发现嵌套循环很有用。
have found a nested loop to be useful.

2560
02:04:58,699 --> 02:05:04,149
我来做int j等于1，j小于或等于i，j ++。
Let me do int j gets 1, j less than or equal to i, j++.

2561
02:05:04,149 --> 02:05:08,177
这将与不舒适或更舒适的情况相似但不相同
This will be similar but not identical to either the less comfortable or more

2562
02:05:08,177 --> 02:05:09,969
过去舒适版本的马里奥，
comfortable version of Mario from the past,

2563
02:05:09,970 --> 02:05:13,240
因为这个金字塔的形状朝着不同的方向。
because this pyramid is shaped in a different direction.

2564
02:05:13,239 --> 02:05:15,609
现在，您在此处打印一个哈希值。
Now, you print a hash there.

2565
02:05:15,609 --> 02:05:17,829
然后让我继续在这里打印新行。
And then let me go ahead and print a new line here.

2566
02:05:17,829 --> 02:05:19,569
所以我很快就做到了。
So I did this super quickly.

2567
02:05:19,569 --> 02:05:21,879
但是从逻辑上讲，我正在做的是迭代
But logically, what I'm doing is iterating

2568
02:05:21,880 --> 02:05:29,710
在每一行上，从1到h，例如第1、2、3、4行。
over every row, so from 1 through h, so row 1, 2, 3, 4, for instance.

2569
02:05:29,710 --> 02:05:34,210
然后在每一行上，我故意从1迭代到i。
And then on each row, I'm deliberately iterating from 1 through i.

2570
02:05:34,210 --> 02:05:37,870
所以我先打印1，然后2，然后3，然后4。
So I print 1, then 2, then 3, then 4.

2571
02:05:37,869 --> 02:05:39,639
再说一次，如果需要的话，我可以将索引设为零。
And again, I could zero index if I want.

2572
02:05:39,640 --> 02:05:44,170
我发现在这种情况下，对用户更友好，更易懂
I find that in this context, more user friendly, more intelligible to me

2573
02:05:44,170 --> 02:05:46,660
从1开始索引，如果您认为完全合理
to index from 1, totally reasonable if you think

2574
02:05:46,659 --> 02:05:48,309
有一个引人注目的设计论点。
there's a compelling design argument.

2575
02:05:48,310 --> 02:05:50,030
因此，让我继续制作Mario。
So let me go ahead and make Mario.

2576
02:05:50,029 --> 02:05:51,519
啊，该死。
Ah, darn it.

2577
02:05:51,520 --> 02:05:53,980
哦，我错过了我的原型。
Oh, I missed my prototype.

2578
02:05:53,979 --> 02:05:55,869
所以请注意，它不是在理解平局。
So notice, it's not understanding draw.

2579
02:05:55,869 --> 02:05:58,899
所以解决办法是要么移动整个功能
So the fix for that is to either move the whole function

2580
02:05:58,899 --> 02:06:02,979
或者，正如我们所鼓吹的那样，只是将您的原型放在首位。
or, as we've preached instead, to just put your prototype up top.

2581
02:06:02,979 --> 02:06:05,049
让我重新编译Mario。
Let me recompile Mario.

2582
02:06:05,050 --> 02:06:06,430
好的，现在成功了。
OK, now successful.

2583
02:06:06,430 --> 02:06:08,710
马里奥，让我们将高度设为4，瞧。
Mario, let's do a height of 4, and voila.

2584
02:06:08,710 --> 02:06:11,350
现在，我有一个相对简单的-尽管我当然
Now, I have a relatively simple-- though I certainly

2585
02:06:11,350 --> 02:06:13,600
没有您的练习，它的速度比您更快-
did it faster than you might without some practice--

2586
02:06:13,600 --> 02:06:15,760
实施马里奥金字塔。
implementation of Mario's pyramid.

2587
02:06:15,760 --> 02:06:17,980
但是，这里的事情变得很酷。
But here's where things get kind of cool.

2588
02:06:17,979 --> 02:06:20,799
让我规定那是一个正确的迭代解决方案，即使
Let me stipulate that that is a correct iterative solution, even

2589
02:06:20,800 --> 02:06:24,970
如果它可能需要您执行一些步骤或反复试验
if it might take you some number of steps or trial and error

2590
02:06:24,970 --> 02:06:28,180
以获得正确的基于循环的迭代代码。
to get that iterative loop-based code correct.

2591
02:06:28,180 --> 02:06:30,580
现在让我将其更改为递归。
Let me change this, now, to be recursive.

2592
02:06:30,579 --> 02:06:34,509
回想一下，递归函数是一个可以自我调用的函数。
And recall, a recursive function is one that calls itself.

2593
02:06:34,510 --> 02:06:37,660
您如何打印高度为h的金字塔？
How do you print a pyramid of height h?

2594
02:06:37,659 --> 02:06:41,979
好吧，回想一下，您打印了一个高度为h减去1的金字塔。
Well, recall that you print a pyramid of height h minus 1,

2595
02:06:41,979 --> 02:06:45,339
然后您继续打印另一行块。
and then you proceed to print one more row of blocks.

2596
02:06:45,340 --> 02:06:48,970
因此，让我从字面上理解。因为我得到零。
So let me take that literally. for int i gets zero.

2597
02:06:48,970 --> 02:06:51,550
我小于h，我++。
i is less than h, i++.

2598
02:06:51,550 --> 02:06:54,550
我继续打印那排砖
Let me go ahead and just print that extra row of bricks

2599
02:06:54,550 --> 02:06:58,480
像这样，然后换行。
like this, followed by a new line.

2600
02:06:58,479 --> 02:07:00,259
所以现在，我做了这样的快速。
So now, I did this kind of fast.

2601
02:07:00,260 --> 02:07:01,340
但是我在这里做什么？
But what am I doing here?

2602
02:07:01,340 --> 02:07:06,520
好吧，如果高度等于1，我希望此循环迭代一次。
Well, if the height equals 1, I want this loop to iterate one time.

2603
02:07:06,520 --> 02:07:10,760
如果高度等于2，我想迭代两次，等等，依此类推。
If the height equals 2, I wanted to iterate two times, 3, and so forth.

2604
02:07:10,760 --> 02:07:14,260
因此，我认为，使用这里的零索引技术，这也将起作用。
So I think, using my zero-indexing technique here, this will work too.

2605
02:07:14,260 --> 02:07:17,080
但是，如果您愿意，我当然可以将其更改为1
But if you prefer, I could certainly just change this to a 1

2606
02:07:17,079 --> 02:07:18,637
并更改此2。
and change this 2.

2607
02:07:18,637 --> 02:07:19,929
但是我要继续前进-
But I'm going to go ahead and--

2608
02:07:19,930 --> 02:07:20,500
实际上，不。
actually, no.

2609
02:07:20,500 --> 02:07:23,350
在这种情况下，我想保留它，零索引，
In this case, I want to leave it as such, zero index,

2610
02:07:23,350 --> 02:07:25,450
就像我们通常所做的一样。
just like we typically do.

2611
02:07:25,449 --> 02:07:29,199
好吧，让我继续编译一下，使Mario成为可能。
All right, let me go ahead and compile this, make Mario.

2612
02:07:29,199 --> 02:07:31,869
好的，糟糕，很有趣。
OK, oops, interesting.

2613
02:07:31,869 --> 02:07:34,939
通过此函数的所有路径都将自行调用。
All paths through this function will call itself.

2614
02:07:34,939 --> 02:07:37,779
因此，这里的clang有点聪明，因此，
So clang is being kind of smart here, whereby,

2615
02:07:37,779 --> 02:07:42,259
注意到在我的draw函数中，我正在调用我的draw函数。
it's noticing that in my draw function, I'm calling my draw function.

2616
02:07:42,260 --> 02:07:44,358
这是一个永不改变的过程。
And that's a process that never changes.

2617
02:07:44,358 --> 02:07:46,150
实际上，让我看看是否可以覆盖它。
In fact, let me see if I can override that.

2618
02:07:46,149 --> 02:07:51,309
让我手动使用clang并使用mario.c编译一个名为mario的程序。
Let me use clang manually and compile a program called mario using mario.c.

2619
02:07:51,310 --> 02:07:53,140
让我继续并链接到CS50。
And let me go ahead and link in cs50.

2620
02:07:53,140 --> 02:07:55,960
所以我从第二周开始使用旧式语法。
So I'm using our old school syntax from week two.

2621
02:07:55,960 --> 02:07:56,980
好的，编译完成。
OK, that compiled.

2622
02:07:56,979 --> 02:07:58,269
那为什么编译呢？
And why did that compile?

2623
02:07:58,270 --> 02:08:01,872
好吧，make还是一个使用编译器clang的程序。
Well, make is, again, a program that uses your compiler clang.

2624
02:08:01,872 --> 02:08:05,080
而且我们将make配置为更加用户友好和更多
And we've configured make to be a little more user-friendly and a little more

2625
02:08:05,079 --> 02:08:07,449
通过打开特殊功能来保护您
protective of you by turning on special features

2626
02:08:07,449 --> 02:08:09,249
我们在那里发现类似的问题。
where we detect problems like that.

2627
02:08:09,250 --> 02:08:12,729
通过现在直接使用clang，我将禁用那些特殊检查。
By using clang directly now, I'm disabling those special checks.

2628
02:08:12,729 --> 02:08:16,839
看看当我现在跑马里奥车到高度为4时会发生什么。
And watch what happens when I run Mario now for height of 4, for instance.

2629
02:08:16,840 --> 02:08:18,730
繁荣，它崩溃了。
Boom, it crashed.

2630
02:08:18,729 --> 02:08:20,499
它甚至什么也没打印。
It didn't even print anything.

2631
02:08:20,500 --> 02:08:21,953
它很快崩溃了。
It crashed pretty quickly.

2632
02:08:21,953 --> 02:08:25,120
同样，分段错误意味着您接触了不应该的内存。
And again, a segmentation fault means you touched memory that you shouldn't.

2633
02:08:25,119 --> 02:08:26,199
发生什么了？
So what's going on?

2634
02:08:26,199 --> 02:08:30,301
好吧，如果您认为此记忆代表主要静止物体，然后绘制，
Well, if you think of this memory as representing main still, but then draw,

2635
02:08:30,301 --> 02:08:33,609
画，画，画，画，画。
draw, draw, draw, draw, draw.

2636
02:08:33,609 --> 02:08:37,539
如果您的每一次抽奖电话都导致再次抽奖，
If every one of your calls to draw just cause draw again,

2637
02:08:37,539 --> 02:08:39,069
为什么会停止？
why would it ever stop?

2638
02:08:39,069 --> 02:08:41,589
似乎并不一定要在这里停止。
It wouldn't seem to stop here, necessarily.

2639
02:08:41,590 --> 02:08:45,070
因此，似乎我的递归版本中缺少一个关键细节。
So it seems that I'm missing a key detail in my recursive version.

2640
02:08:45,069 --> 02:08:45,669
你知道吗？
You know what?

2641
02:08:45,670 --> 02:08:51,130
如果没有要绘制的东西，如果高度等于0，让我继续前进，那么，
If there's nothing to draw, if height equals equals 0, let me go ahead, then,

2642
02:08:51,130 --> 02:08:54,260
并立即返回。
and just return immediately.

2643
02:08:54,260 --> 02:08:57,250
否则，我会继续绘制金字塔的一部分
Otherwise, I'll go ahead and draw part of the pyramid

2644
02:08:57,250 --> 02:08:59,259
然后添加新行。
and then add the new row.

2645
02:08:59,260 --> 02:09:02,110
因此，您需要这种所谓的基本情况，从字面上看
So you need this so-called base case, which you literally

2646
02:09:02,109 --> 02:09:05,409
选择等于一些简单值，例如height为0，height为1
choose to equal some simple value, like height of 0, height of 1,

2647
02:09:05,409 --> 02:09:10,879
任何硬编码的值，以便最终draw不会自行调用。
any hardcoded value, so that eventually, draw does not call itself.

2648
02:09:10,880 --> 02:09:15,040
因此，让我继续使用clang或make进行重新编译。
So let me go ahead and recompile this with clang or make.

2649
02:09:15,039 --> 02:09:18,429
让我重新运行它，高度为4，瞧。
Let me rerun it, height of 4, and voila.

2650
02:09:18,430 --> 02:09:20,680
它仍然像内部版本一样工作，
It's still working just like the interior version,

2651
02:09:20,680 --> 02:09:22,340
但现在正在使用递归。
but it's now using recursion.

2652
02:09:22,340 --> 02:09:24,250
所以这是一种设计问题。
So here's a sort of design question.

2653
02:09:24,250 --> 02:09:26,020
迭代比递归好吗？
Is iteration better than recursion?

2654
02:09:26,020 --> 02:09:26,680
这取决于。
It depends.

2655
02:09:26,680 --> 02:09:28,270
迭代将始终有效。
Iteration will always work.

2656
02:09:28,270 --> 02:09:32,290
使用迭代版本时，我永远不会溢出堆栈
When using the iterative version, I will never overflow the stack

2657
02:09:32,289 --> 02:09:33,139
然后撞上堆
and hit the heap.

2658
02:09:33,140 --> 02:09:33,640
为什么？
Why?

2659
02:09:33,640 --> 02:09:35,723
因为我不会一次又一次地调用函数。
Because I'm not calling functions again and again.

2660
02:09:35,722 --> 02:09:38,409
只有主次和一次平局调用。
There's only main and one invocation of draw.

2661
02:09:38,409 --> 02:09:42,549
但是对于递归版本，这是一种很酷，功能强大的方法
But with the recursive version, it's kind of a cool, powerful way

2662
02:09:42,550 --> 02:09:43,270
做事情。
to do things.

2663
02:09:43,270 --> 02:09:45,610
就像，哦，我可以给你画一个高度为h的金字塔。
Like, oh, I can draw you a pyramid of height h.

2664
02:09:45,609 --> 02:09:48,369
让我给你画一个高度为h减去1的金字塔
Let me just have you draw me a pyramid of height h minus 1,

2665
02:09:48,369 --> 02:09:49,749
然后我将添加一行。
and then I'll add a row.

2666
02:09:49,750 --> 02:09:54,950
这种聪明的循环论证确实非常优雅地工作。
It's kind of this clever, cyclical argument that does work very elegantly.

2667
02:09:54,949 --> 02:09:56,149
但是有危险。
But there's a danger.

2668
02:09:56,149 --> 02:10:00,829
实际上，即使这种基本情况确保了这种情况不会永远持续下去，
And in fact, even though this base case ensures that it doesn't go forever,

2669
02:10:00,829 --> 02:10:05,179
它可能会持续很长时间-也许让我们尝试10,000次调用。
it could go on so long-- maybe let's try 10,000 invocations.

2670
02:10:05,180 --> 02:10:06,290
这样就可以了。
So that worked OK.

2671
02:10:06,289 --> 02:10:07,819
有点慢。
It's a little slow.

2672
02:10:07,819 --> 02:10:09,319
我失去了对键盘的控制。
I'm losing control over my keyboard.

2673
02:10:09,319 --> 02:10:10,729
因此，Control C是您的朋友。
So Control C is your friend.

2674
02:10:10,729 --> 02:10:12,049
让我再试一次。
Let me try this once more.

2675
02:10:12,050 --> 02:10:16,700
让我继续进行约20亿次的尝试，看看是否可行。
Let me go ahead and do something like 2 billion and see if that works.

2676
02:10:16,699 --> 02:10:17,539
繁荣。
Boom.

2677
02:10:17,539 --> 02:10:19,109
因此，即使这样也不起作用。
So even that doesn't work.

2678
02:10:19,109 --> 02:10:21,709
因此，递归存在固有的危险，因此，
So there's this inherent danger with recursion, whereby,

2679
02:10:21,710 --> 02:10:25,010
即使它使我们上周有能力更有效地解决问题
even though it empowered us last week to solve a problem even more efficiently

2680
02:10:25,010 --> 02:10:29,810
通过合并排序，我们有点幸运，因为我们并没有试图疯狂
with merge sort, we kind of got lucky, in that we weren't trying to crazy big

2681
02:10:29,810 --> 02:10:33,080
东西放在Brian的书架上，因为如果您使用递归，这似乎
things on Brian's shelf, because it would seem if you use recursion

2682
02:10:33,079 --> 02:10:35,329
并一次又一次地给自己打电话，
and call yourself again and again and again and again,

2683
02:10:35,329 --> 02:10:40,339
即使是有限的多次，您最终也可能会碰到不应该使用的内存。
even finitely many times, you might eventually touch memory you shouldn't.

2684
02:10:40,340 --> 02:10:42,290
那这里的解决方案是什么？
And what's the solution here?

2685
02:10:42,289 --> 02:10:44,509
不幸的是，它不是那样做的。
Unfortunately, it's don't do that.

2686
02:10:44,510 --> 02:10:48,020
设计算法，以这种方式选择输入
Design your algorithms, choose your inputs in such a way

2687
02:10:48,020 --> 02:10:49,560
就是没有那种风险。
that there just isn't that risk.

2688
02:10:49,560 --> 02:10:51,800
我们将在几周后再次使用递归
And we'll use recursion again in a few weeks

2689
02:10:51,800 --> 02:10:54,800
是时候我们看一下更复杂的数据结构了。
time when we look at more sophisticated data structures.

2690
02:10:54,800 --> 02:10:56,600
但同样，总会有这种权衡。
But again, there's always this trade off.

2691
02:10:56,600 --> 02:10:58,725
只是因为您可以设计更多一点
Just because you can design something a little more

2692
02:10:58,725 --> 02:11:03,120
优雅地不一定意味着它总会为您工作。
elegantly doesn't necessarily mean that it's always going to work for you.

2693
02:11:03,119 --> 02:11:06,559
但是更常见的是，您是否还会遇到其他问题？
But more commonly, are you likely to run into other problems as well?

2694
02:11:06,560 --> 02:11:08,540
有一种叫做缓冲区溢出的东西。
There's something called a buffer overflow.

2695
02:11:08,539 --> 02:11:10,879
这肯定会在未来几周内完成。
And this you will surely trip over in the coming weeks.

2696
02:11:10,880 --> 02:11:13,610
缓冲区溢出是在分配数组时
A buffer overflow is when you allocate an array

2697
02:11:13,609 --> 02:11:15,589
并走得太远了。
and go too far past the end of it.

2698
02:11:15,590 --> 02:11:18,650
或者您使用malloc，但是您走得更远
Or you use malloc and you, nonetheless, go farther

2699
02:11:18,649 --> 02:11:21,019
比您分配的内存块的末尾要多。
than the end of the chunk of memory that you allocated.

2700
02:11:21,020 --> 02:11:25,010
缓冲区只是一块内存，可以这么说，您可以使用它
A buffer it's just a chunk of memory, so to speak, that you can use as you see

2701
02:11:25,010 --> 02:11:25,550
合身。
fit.

2702
02:11:25,550 --> 02:11:30,230
缓冲区溢出意味着超出该数组的范围。
Buffer overflow means going beyond the boundaries of that array.

2703
02:11:30,229 --> 02:11:32,929
您可能会使用-您现在正在使用视频。
You might use-- you're using, right now, video.

2704
02:11:32,930 --> 02:11:35,125
您可能知道视频中的短语缓冲，
You might know the phrase buffering from videos,

2705
02:11:35,125 --> 02:11:37,250
就像在Netflix上缓冲和烦扰您一样，
like sort of buffering and annoying you on Netflix,

2706
02:11:37,250 --> 02:11:39,050
因为那里有一个旋转的图标或其他。
because there's a spinning icon or whatnot.

2707
02:11:39,050 --> 02:11:40,700
好吧，这就是这个意思。
Well, that means exactly this.

2708
02:11:40,699 --> 02:11:44,089
在YouTube或Zoom或Netflix的上下文中，
A buffer, in the context of YouTube or Zoom or Netflix,

2709
02:11:44,090 --> 02:11:46,910
表示已检索的一些内存
means some chunk of memory that was retrieved

2710
02:11:46,909 --> 02:11:49,879
通过malloc或一些类似的工具来填充
via malloc or some similar tool that gets filled

2711
02:11:49,880 --> 02:11:52,580
包含您的视频的字节。
with bytes comprising your video.

2712
02:11:52,579 --> 02:11:56,209
这是有限的，这就是为什么您只能缓冲这么多秒
And it's finite, which is why you can only buffer so many seconds

2713
02:11:56,210 --> 02:11:59,520
或几分钟的视频，如果您不在线，那么最终，
or minutes of video before, eventually, if you're offline,

2714
02:11:59,520 --> 02:12:01,220
您的视频内容用完了，无法观看。
you run out of video content to watch.

2715
02:12:01,220 --> 02:12:02,930
然后出现愚蠢的图标，您可以
And the stupid icon comes up, and you can

2716
02:12:02,930 --> 02:12:07,680
不用再看了，因为缓冲区只是一块内存，是一个内存数组。
watch no more, because a buffer is just a chunk of memory, an array of memory.

2717
02:12:07,680 --> 02:12:12,830
如果Netflix，Google或其他公司不安全地实施其代码，
And if Netflix or Google or others were to implement their code unsafely,

2718
02:12:12,829 --> 02:12:16,739
他们也很可能会越过这个边界。
they might very well go too far past that boundary as well.

2719
02:12:16,739 --> 02:12:22,069
因此，在最后的几分钟中，让我们考虑一下
So with all this said, let's consider, in some of our final minutes

2720
02:12:22,069 --> 02:12:25,999
今天在这里，我们从这些培训轮中学到了什么，
here today, just what else we've been getting from these training wheels,

2721
02:12:26,000 --> 02:12:28,830
因为我们确实想把它们主要带给您。
because we do want to take them mostly off for you.

2722
02:12:28,829 --> 02:12:30,889
因此，CS50库不仅为您提供
So the CS50 library not only provides you

2723
02:12:30,890 --> 02:12:33,855
有了这种字符串类型的抽象，这又是
with this abstraction of a string type, which again,

2724
02:12:33,854 --> 02:12:35,479
没有为您提供任何新功能。
doesn't give you any new functionality.

2725
02:12:35,479 --> 02:12:38,599
C中的字符串存在，只是不存在该名称。
Strings in C exist, just not by that name.

2726
02:12:38,600 --> 02:12:40,850
它们被更恰当地称为“ char star”。
They're known more properly as char stars.

2727
02:12:40,850 --> 02:12:43,730
但是所有这些功能都在CS50库中
But all of these functions in the CS50 library

2728
02:12:43,729 --> 02:12:49,489
可以用CS50以外的其他实际C函数来实现，
can be implemented with other actual C functions that weren't from CS50,

2729
02:12:49,489 --> 02:12:51,739
即使用一种叫做scanf的文件。
namely using one called scanf.

2730
02:12:51,739 --> 02:12:54,259
但是您马上就会看到一些危险
But you're going to see, immediately, some of the dangers

2731
02:12:54,260 --> 02:12:57,980
使用scanf之类的东西，这是一种古老的功能。
of using something like scanf, which is an old school function.

2732
02:12:57,979 --> 02:13:01,279
它并非像CS50的库那样具有自卫性。
It was not designed to be self-defensive like CS50's library.

2733
02:13:01,279 --> 02:13:03,509
因此，很容易犯错误。
And so it's very easy to make mistakes.

2734
02:13:03,510 --> 02:13:06,650
例如，让我继续，并创建一个文件
Let me go ahead, for instance, and create a file

2735
02:13:06,649 --> 02:13:09,859
名为scanf.c只是为了演示此功能。
called scanf.c, just to demonstrate this function.

2736
02:13:09,859 --> 02:13:13,199
我将不使用CS50库，而仅使用标准io点h。
I'm not going to use the CS50 library, just standard io dot h.

2737
02:13:13,199 --> 02:13:15,469
而且我要给自己int主要空白。
And I'm going to give myself int main void.

2738
02:13:15,470 --> 02:13:18,110
我要继续给自己一个变量x。
And I'm going to go ahead and give myself a variable x.

2739
02:13:18,109 --> 02:13:21,259
我将继续打印引号unquote“ x：”
And I'm going to go ahead and print out quote unquote, "x:"

2740
02:13:21,260 --> 02:13:24,060
就像CS50的get int函数一样。
just like CS50's get int function does.

2741
02:13:24,060 --> 02:13:25,940
然后我将调用scanf。
And then I'm going to call scanf.

2742
02:13:25,939 --> 02:13:30,169
我将继续说，从用户的键盘扫描，一个整数，
And I'm going to go ahead and say, scan from the user's keyboard, an integer,

2743
02:13:30,170 --> 02:13:33,708
并将其存储在x的位置。
and store it in the location of x.

2744
02:13:33,707 --> 02:13:35,749
然后，我将继续进行打印，
Then, I'm going to go ahead and print out, again,

2745
02:13:35,750 --> 02:13:40,339
x，冒号和反斜杠百分比我反斜杠n。
x, and a colon and a backslash percent i backslash n.

2746
02:13:40,340 --> 02:13:41,420
我要打印x。
And I'm going to print x.

2747
02:13:41,420 --> 02:13:42,830
那么这是怎么回事？
So what's going on here?

2748
02:13:42,829 --> 02:13:46,579
在第5行中，我声明了一个名为x的变量，就像第一周一样。
In line 5, I'm declaring a variable called x, just like in week one.

2749
02:13:46,579 --> 02:13:49,219
第6行，仅在第一周就使用printf。
Line 6, just using printf, like in week one.

2750
02:13:49,220 --> 02:13:52,460
有趣的东西似乎在第7行中。
The interesting stuff seems to be in line 7.

2751
02:13:52,460 --> 02:13:56,870
Scanf是一个需要用户输入的函数，就像get int，get
Scanf is a function that takes input from the user, just like get int, get

2752
02:13:56,869 --> 02:13:58,499
字符串，获取浮点数，依此类推。
string, get float, and so forth.

2753
02:13:58,500 --> 02:14:02,629
但这只有在您必须了解指针的情况下才能实现，
But it does it only by you having to understand pointers,

2754
02:14:02,630 --> 02:14:07,790
因为回想一下我们的交换示例，如果您想拥有一个功能，
because recall from our swap example, if you want to have a function,

2755
02:14:07,789 --> 02:14:12,109
像我们对a和b所做的那样更改变量的内容
change the contents of a variable, as we did with a and b

2756
02:14:12,109 --> 02:14:15,919
x和y，您必须传入变量的地址，
and x and y, you have to pass in the address of the variable, whose

2757
02:14:15,920 --> 02:14:17,060
您要更改的值。
value you want to change.

2758
02:14:17,060 --> 02:14:19,200
您不能只传递x本身。
You can't just pass in x itself.

2759
02:14:19,199 --> 02:14:22,262
因此，如果我们在第一周不使用CS50库，
So if we didn't use the CS50 library in week one,

2760
02:14:22,262 --> 02:14:25,429
您可能只是为了从用户那里获取一个int而编写这样的代码。
you would have been writing code like this just to get an int from the user.

2761
02:14:25,430 --> 02:14:27,347
而且您将不得不了解指针。
And you would have had to understand pointers.

2762
02:14:27,346 --> 02:14:30,169
而且您将必须了解＆符和星号等。
And you would have to understand ampersand and stars and so forth.

2763
02:14:30,170 --> 02:14:32,712
当我们在头几周内关心所有事情时，这太过分了
It's just too much, when all we care about in the first weeks

2764
02:14:32,712 --> 02:14:35,990
是循环，变量，条件和基本原理。
are loops and variables and conditions and sort of the fundamentals.

2765
02:14:35,989 --> 02:14:39,229
但是在这里，我们现在可以调用scanf，告诉它
But here, we now have the ability to call scanf, tell it

2766
02:14:39,229 --> 02:14:41,149
从用户的键盘进行扫描，可以这么说，
to scan from the user's keyboard, so to speak,

2767
02:14:41,149 --> 02:14:45,379
整数或f百分比会给我们一个浮点数或其他类似的代码，
an integer, or percent f would give us a float or other such codes,

2768
02:14:45,380 --> 02:14:49,040
并传递x的地址，以便scanf可以转到该地址
and pass in the address of x so that scanf can go to that address

2769
02:14:49,039 --> 02:14:51,439
然后将用户键盘上的整数放在此处。
and put the integer from the user's keyboard there.

2770
02:14:51,439 --> 02:14:53,029
第8行就像第一周的东西。
Line 8 is like week one stuff.

2771
02:14:53,029 --> 02:14:54,679
我只是打印出价值。
I'm just printing out the value.

2772
02:14:54,680 --> 02:14:55,950
这很安全。
And this is pretty safe.

2773
02:14:55,949 --> 02:14:57,799
我将继续进行扫描。
I'm going to go ahead and make scanf.

2774
02:14:57,800 --> 02:14:58,495
编译就可以了。
It compiles OK.

2775
02:14:58,494 --> 02:14:59,869
我要继续运行它。
I'm going to go ahead and run it.

2776
02:14:59,869 --> 02:15:00,979
我要输入50。
I'm going to type in 50.

2777
02:15:00,979 --> 02:15:03,179
瞧，它会打印出50。
And voila, it prints out a 50.

2778
02:15:03,180 --> 02:15:06,920
但是有些奇怪，因为如果您也运行此程序
But there's some weirdness, because if you run this program too

2779
02:15:06,920 --> 02:15:09,410
并输入cat，那么x为0。
and type in cat, well then x is 0.

2780
02:15:09,409 --> 02:15:10,939
而且没有错误检查。
And there's no error checking.

2781
02:15:10,939 --> 02:15:12,766
所以立即，您应该瞥见那一个
So immediately, you should glimpse that one

2782
02:15:12,766 --> 02:15:14,599
CS50库的功能，召回，
of the features of the CS50 library, recall,

2783
02:15:14,600 --> 02:15:17,630
是我们会不断提示用户，如果他们不是
is that we keep prompting the user again and again if they're not

2784
02:15:17,630 --> 02:15:19,310
合作并给您一个情报。
cooperating and giving you an int.

2785
02:15:19,310 --> 02:15:21,740
这就是您从库中获得的功能。
So that's one feature you get from the library.

2786
02:15:21,739 --> 02:15:26,119
但是事实证明，获取字符串甚至更强大，
But it turns out that get string is even more powerful,

2787
02:15:26,119 --> 02:15:28,999
因为如果我现在去更改此程序，而不是获取整数，
because if I go and change this program now, not to get an int,

2788
02:15:29,000 --> 02:15:30,709
但是像字符串这样的幻想者
but something fancier like a string--

2789
02:15:30,710 --> 02:15:33,223
或等待，我们现在将其称为char star。
or wait, we're calling it char star now.

2790
02:15:33,222 --> 02:15:35,389
我将继续做类似的事情。
I'm going to go ahead and do something very similar.

2791
02:15:35,390 --> 02:15:37,640
我将提示用户输入字符串s。
I'm going to prompt the user for string s.

2792
02:15:37,640 --> 02:15:39,020
我将使用scanf。
And I'm going to use scanf.

2793
02:15:39,020 --> 02:15:42,320
我将使用percent，就像printf使用percent一样。
And I'm going to use percent s, just like printf uses percent s.

2794
02:15:42,319 --> 02:15:44,509
我要传递s。
And I'm going to pass in s.

2795
02:15:44,510 --> 02:15:48,890
现在，要明确一点，我不需要在这里使用＆号，
Now, to be clear, I don't need to do ampersand s here,

2796
02:15:48,890 --> 02:15:53,010
因为现在，我们都知道s从根本上是一个地址。
because now, we all know that s is fundamentally an address.

2797
02:15:53,010 --> 02:15:56,270
因此只需传递您已经拥有的地址即可。
So it suffices just to pass in the address that you already have.

2798
02:15:56,270 --> 02:16:01,280
现在，我将继续打印冒号，百分号的反斜杠n，
Now, I'm going to go ahead and print out s colon, percent s backslash n,

2799
02:16:01,279 --> 02:16:02,929
并打印出来。
and print out s.

2800
02:16:02,930 --> 02:16:07,730
但是当我编译它时，使scanf，它不喜欢它
But when I compile this, make scanf, it doesn't like it

2801
02:16:07,729 --> 02:16:10,969
当我在这里使用未编译的变量s时。
when I compile variable s's uninitialized when used here.

2802
02:16:10,970 --> 02:16:14,390
好吧，如果我真的想冒险，
All right, well if I really want to be sort of adventurous,

2803
02:16:14,390 --> 02:16:16,350
我可以覆盖make的保护。
I can override make's protections.

2804
02:16:16,350 --> 02:16:19,880
而且我可以自己自己使用scanf手动编译它-
And I can just compile this manually myself using scanf--

2805
02:16:19,880 --> 02:16:21,260
直接使用clang。
using clang directly.

2806
02:16:21,260 --> 02:16:23,600
可行，点斜杠scanf。
That worked, dot slash scanf.

2807
02:16:23,600 --> 02:16:26,870
让我继续输入例如“ HI！”。
Let me go ahead and type in, for instance, "HI!"

2808
02:16:26,869 --> 02:16:28,999
然后你会觉得很奇怪
and you see weirdness, nul.

2809
02:16:29,000 --> 02:16:31,189
好吧，幸运的是，然后再发出叮当声，
Well, fortunately, make, and in turn clang,

2810
02:16:31,189 --> 02:16:33,829
是帮助我们在那里自助的一种方式。
were kind of helping us help ourselves there.

2811
02:16:33,829 --> 02:16:35,839
指出您声明了s。
It was pointing out that you declared s.

2812
02:16:35,840 --> 02:16:38,660
因此，您被声明为一个指针的8个字节。
So you were declared 8 bytes for a pointer.

2813
02:16:38,659 --> 02:16:39,859
但是那里什么也没有。
But there's nothing there.

2814
02:16:39,860 --> 02:16:41,459
这是一个垃圾值。
It's a garbage value.

2815
02:16:41,459 --> 02:16:43,170
因此，无处可放。
And so there's nowhere to put this.

2816
02:16:43,170 --> 02:16:45,889
幸运的是，printf和scanf足够聪明
And thankfully, printf and scanf are being smart enough

2817
02:16:45,888 --> 02:16:48,869
不只是盲目地走到那儿，我，
by not just blindly going there and plopping H, I,

2818
02:16:48,870 --> 02:16:50,760
nul字符中的感叹号。
exclamation point in a nul character.

2819
02:16:50,760 --> 02:16:52,010
他们只是不理会它。
They're just leaving it alone.

2820
02:16:52,010 --> 02:16:55,910
这个括号只是一个printf功能，说，你搞砸了。
And this parenthetical nul is just a printf feature saying, you screwed up.

2821
02:16:55,909 --> 02:16:58,099
如果看到nul，说明您做错了什么。
If you see nul, you've done something wrong.

2822
02:16:58,100 --> 02:17:00,830
它只是大方而不会崩溃。
It's just being generous and not crashing on you.

2823
02:17:00,829 --> 02:17:04,878
如果我确实想获得用户的输入，则需要比这更聪明。
If I actually want to get user's input, I need to be smarter than this.

2824
02:17:04,879 --> 02:17:10,040
正如我们今天早些时候所做的那样，我需要为自己分配4个字节。
And I need to either allocate myself 4 bytes, as we've done earlier today.

2825
02:17:10,040 --> 02:17:14,209
或者我可以回到第二周，说些类似的话，给我4个字节。
Or I could go back to week two stuff and say something like, give me 4 bytes.

2826
02:17:14,209 --> 02:17:18,830
不过，这给了我4个字节的堆栈空间
This, though, gives me 4 bytes on the stack somewhere

2827
02:17:18,829 --> 02:17:21,409
可以这么说。
down here in main's frame, so to speak.

2828
02:17:21,409 --> 02:17:23,269
这些行称为框架。
These rows are called frames.

2829
02:17:23,270 --> 02:17:27,260
如果我改用malloc，它来自所谓的堆，
If I use malloc instead, it comes from the so-called heap,

2830
02:17:27,260 --> 02:17:29,780
没有画出来的，有点像在这里。
which not pictured, is sort of up here.

2831
02:17:29,780 --> 02:17:34,309
唯一的区别是，如果我使用的是malloc，则必须使用free。
And the only difference is that if I'm using malloc, I have to use free.

2832
02:17:34,308 --> 02:17:38,929
如果像第二周那样使用堆栈，则不必使用免费。
If I'm using the stack, as I did in week two, I don't have to use free.

2833
02:17:38,930 --> 02:17:40,730
它会自动为我管理。
It's automatically managed for me.

2834
02:17:40,729 --> 02:17:42,589
坦率地说，今天有很多新东西。
So frankly, there's so much new stuff today.

2835
02:17:42,590 --> 02:17:46,280
我喜欢坚持旧派的想法。
I like the idea of sticking with the old school arrays.

2836
02:17:46,280 --> 02:17:51,379
所以现在，尽管如此，如果我继续进行scanf的制作，现在它会使用make进行编译。
So now, though, if I go ahead and make scanf, now it compiles with make.

2837
02:17:51,379 --> 02:17:55,610
如果然后运行scanf并输入HI !，瞧，这似乎可行。
If I then run scanf and type in, HI!, voila, it seems to work.

2838
02:17:55,610 --> 02:17:58,549
但这是因为我很聪明，并期待HI，
But that's because I was smart and anticipated that H-I,

2839
02:17:58,549 --> 02:17:59,660
确定四个字符。
OK four characters.

2840
02:17:59,659 --> 02:18:00,979
我给了自己4个字节。
I gave myself 4 bytes.

2841
02:18:00,979 --> 02:18:06,109
但是，如果用户键入HI THERE，DAVID，您好吗？
But what if the user types in, HI THERE, DAVID, HOW ARE YOU?

2842
02:18:06,110 --> 02:18:08,059
显然，超过四个字节。
Clearly, more than four bytes.

2843
02:18:08,058 --> 02:18:11,958
我现在按Enter键，发生了一些奇怪的事情。
And I hit Enter now, something weird there happened.

2844
02:18:11,959 --> 02:18:13,790
剩下的就是丢失。
The rest is just lost.

2845
02:18:13,790 --> 02:18:16,670
这真的很烦人，非常令人沮丧
And this would really be annoying and very frustrating

2846
02:18:16,670 --> 02:18:19,520
如果您尝试在课程的第一周获得用户输入。
if you-- trying to get user input in the first week of the class.

2847
02:18:19,520 --> 02:18:21,500
获取字符串可以避免这种情况。
Get string avoids this for you.

2848
02:18:21,500 --> 02:18:23,718
为您获取字符串调用malloc。
Get string calls malloc for you.

2849
02:18:23,718 --> 02:18:27,199
它要求它像字符串一样占用大量内存
And it calls it for as big a chunk of memory as the string

2850
02:18:27,200 --> 02:18:28,070
人类输入。
the human types in.

2851
02:18:28,069 --> 02:18:30,979
长话短说，我们有点看着他们在打字
Long story short, we sort of watch what they're typing character

2852
02:18:30,979 --> 02:18:32,208
逐个字符地。
by character by character.

2853
02:18:32,209 --> 02:18:34,340
并且我们确保分配或重新分配
And we make sure to allocate or reallocate

2854
02:18:34,340 --> 02:18:38,879
足够的内存来适应人类键入的内容。
just enough memory to fit whatever it is the human has typed in.

2855
02:18:38,879 --> 02:18:42,107
因此，scanf本质上是一个类似于CS50库的函数
So scanf is, essentially, how a function like the CS50 library

2856
02:18:42,106 --> 02:18:43,189
在引擎盖下工作。
works underneath the hood.

2857
02:18:43,190 --> 02:18:46,650
但这是为您做的所有事情。
But it is doing all of this for you.

2858
02:18:46,649 --> 02:18:49,548
坦白说，一旦您拿走了这样的训练轮，
And as soon as you take away training wheels like that, or frankly,

2859
02:18:49,549 --> 02:18:52,469
像这样的库，实际上是一天结束了。
libraries like that, which it really is at the end of the day.

2860
02:18:52,468 --> 02:18:53,718
它不仅是一种教学工具。
It's not just a teaching tool.

2861
02:18:53,718 --> 02:18:55,069
这是一个有用的库。
It's a useful library.

2862
02:18:55,069 --> 02:18:58,468
您必须自己开始实施更多此类低级内容。
You have to start implementing more of this low-level stuff yourself.

2863
02:18:58,468 --> 02:18:59,809
因此，这是一个折衷方案。
So again, there is a trade off.

2864
02:18:59,809 --> 02:19:02,726
如果您不想使用CS50库之类的东西，那就很好。
If you don't want to use something like the CS50 library, that's fine.

2865
02:19:02,727 --> 02:19:08,400
现在，您有责任避免所有这些可能的错误情况。
Now, the onus is on you to avoid all of these possible error conditions.

2866
02:19:08,399 --> 02:19:11,208
好了，这么说，我们有一个最后的功能
All right, with that said, we have one final feature

2867
02:19:11,209 --> 02:19:14,270
为了激发您本周的问题，其中
to give you in order to motivate this week's problems, wherein

2868
02:19:14,270 --> 02:19:18,230
您实际上将探索，操纵和编写代码来更改文件。
you'll actually explore and manipulate and write code to change files.

2869
02:19:18,229 --> 02:19:22,789
为此，我们需要文件I / O的最后一个主题。文件I / O
And for that, we need one final topic of file I/O. File I/O

2870
02:19:22,790 --> 02:19:27,350
是一种术语，它描述了从文件中获取输入和输出。
is the term of art that describes taking input and output from files.

2871
02:19:27,350 --> 02:19:30,980
到目前为止，几乎我们编写的每个程序都只使用内存，就像这样
Pretty much every program we've written thus far just uses memory, like this

2872
02:19:30,979 --> 02:19:32,923
在这里，您可以将内容放入内存中。
here, whereby, you can put stuff in memory.

2873
02:19:32,924 --> 02:19:34,549
但是，一旦您的程序结束，便会蓬勃发展。
But as soon as your program ends, boom.

2874
02:19:34,549 --> 02:19:35,330
它消失了。
It's gone.

2875
02:19:35,329 --> 02:19:37,069
内存的内容不见了。
The contents of memory are gone.

2876
02:19:37,069 --> 02:19:39,769
文件，当然是您和我在计算世界中的位置
Files, of course, are where you and I in the computing world

2877
02:19:39,770 --> 02:19:42,020
保存我们的论文，文件和简历
save our essays and documents and resumes

2878
02:19:42,020 --> 02:19:44,629
并将所有这些永久存储在您的计算机上。
and all of that permanently on your computer.

2879
02:19:44,629 --> 02:19:48,590
当然，在C语言中，您有能力自己编写代码，
In C, you have the ability, certainly, to write code yourself that

2880
02:19:48,590 --> 02:19:50,730
长期保存文件。
saves files long term.

2881
02:19:50,729 --> 02:19:53,449
例如，让我继续在这里编写自己的程序，
So for instance, let me go ahead and write my own program here,

2882
02:19:53,450 --> 02:19:59,260
在文件中存储姓名和电话号码的电话簿程序。
a phonebook program that stores names and numbers in a file.

2883
02:19:59,260 --> 02:20:02,380
为了方便起见，我将继续介绍CS50库
I'm going to go ahead and include, just for convenience, the CS50 library

2884
02:20:02,379 --> 02:20:04,479
再次，因为我不想处理scanf。
again, because I don't want to deal with scanf.

2885
02:20:04,479 --> 02:20:08,199
我将继续将其保存为phonebook.c。
I'm going to go ahead and save this, incidentally, as phonebook.c.

2886
02:20:08,200 --> 02:20:12,370
我将继续前进，不仅包括CS50库，还包括标准io。
I'm going to go ahead and include, not just the CS50 library, but standard io.

2887
02:20:12,370 --> 02:20:18,373
而且，我将抢先一步，并包括string.h。
And preemptively, I'm going to go ahead and include string.h as well.

2888
02:20:18,372 --> 02:20:20,289
我将继续执行我的主要职能。
And I'm going to go ahead in my main function.

2889
02:20:20,290 --> 02:20:23,990
我将使用一些新功能，在这里我们将仅简要介绍这些功能。
And I'm going to use a few new functions that we'll see only briefly here.

2890
02:20:23,989 --> 02:20:27,259
但是在下一个问题集中，您将更详细地探讨这些问题。
But in the next problem set, will you explore these in more detail.

2891
02:20:27,260 --> 02:20:29,980
我要给自己一个指向文件的指针。
I'm going to give myself a pointer to a file.

2892
02:20:29,979 --> 02:20:33,819
奇怪的是，在所有大写字母中，FILE，
It turns out, weirdly, that in all caps, FILE,

2893
02:20:33,819 --> 02:20:38,539
这是C附带的代表文件的新数据类型。
this is a new data type that does come with C that represents a file.

2894
02:20:38,540 --> 02:20:42,383
所以我要继续给自己一个指向文件的指针，
So I'm going to go ahead and give myself a pointer to a file,

2895
02:20:42,382 --> 02:20:43,299
文件的地址。
the address of a file.

2896
02:20:43,299 --> 02:20:44,799
我将调用变量文件。
And I'm going to call the variable file.

2897
02:20:44,799 --> 02:20:46,299
我可以称它为x。
I could call it f I could call it x.

2898
02:20:46,299 --> 02:20:49,129
为了清楚起见，我将其称为小写文件。
I'm going to call it lowercase file, just to be clear.

2899
02:20:49,129 --> 02:20:52,179
我将使用一个称为f open的新函数，这意味着文件打开。
And I'm going to use a new function called f open, which means file open.

2900
02:20:52,180 --> 02:20:54,077
和文件打开有两个参数。
And file open takes two arguments.

2901
02:20:54,076 --> 02:20:57,159
它采用第一个参数，即您要打开的文件的名称。
It takes the first argument, which is the name of a file you want to open.

2902
02:20:57,159 --> 02:20:59,637
我将打开一个名为phonebook.csv的文件。
I'm going to open a file called phonebook.csv.

2903
02:20:59,638 --> 02:21:02,680
然后，我将继续打开它，特别是在附加模式下打开它。
And then I'm going to go ahead and open it, specifically, in append mode.

2904
02:21:02,680 --> 02:21:05,050
长话短说，您可以用不同的方式打开文件，
Long story short, you can open files in different ways,

2905
02:21:05,049 --> 02:21:08,449
读它们，就是看它们的内容，写它们，
to read them, that is just look at their contents, to write them,

2906
02:21:08,450 --> 02:21:10,780
就是要完全改变他们的内容，
which is to change their contents entirely,

2907
02:21:10,780 --> 02:21:15,730
或附加到它们的后面，即表示逐行添加到它们，
or to append to them, a, which means to add row by row to them,

2908
02:21:15,729 --> 02:21:18,369
以便继续向他们提供更多信息。
so to keep tacking on more information to them.

2909
02:21:18,370 --> 02:21:20,210
我要继续前进，为了安全起见，
I'm going to go ahead and, just to be safe,

2910
02:21:20,209 --> 02:21:23,649
我要说的是，如果file equals等于nul，
I'm going to say if file equals equals nul,

2911
02:21:23,649 --> 02:21:26,179
因为记得nul表示出了点问题，
because recall that nul signifies something went wrong,

2912
02:21:26,180 --> 02:21:27,280
让我们现在就回来。
let's just return now.

2913
02:21:27,280 --> 02:21:28,960
也许我输错了文件名。
Maybe I mistyped the name of the file.

2914
02:21:28,959 --> 02:21:29,949
也许它不存在。
Maybe it doesn't exist.

2915
02:21:29,950 --> 02:21:31,420
可能出了点问题。
Something went wrong, potentially.

2916
02:21:31,420 --> 02:21:34,660
我要说的是，如果file equals等于nul，
I'm going to check for that by saying, if file equals equals nul, just

2917
02:21:34,659 --> 02:21:36,177
现在退出该程序。
quit out of the program now.

2918
02:21:36,177 --> 02:21:38,469
但是在那之后，我将继续进行操作。
But after that, I'm going to go ahead and get a string.

2919
02:21:38,469 --> 02:21:41,919
但是我们现在可以将其称为char star，称为name。
But we can call that char star now, called name.

2920
02:21:41,920 --> 02:21:44,440
我要问用户一个名字。
And I'm going to ask the user for a name.

2921
02:21:44,440 --> 02:21:45,820
我们之前已经做到了。
And we've done this before.

2922
02:21:45,819 --> 02:21:48,609
我要去问他们一个电话号码。
I'm going to go ahead and ask them for a number, phone number.

2923
02:21:48,610 --> 02:21:49,970
我们之前已经做到了。
And we've done this before.

2924
02:21:49,969 --> 02:21:52,689
现在，唯一的区别是，我称字符串char star。
The only difference, now, is I'm calling string char star.

2925
02:21:52,690 --> 02:21:54,400
现在，这是最酷的部分。
And now, here's the cool part.

2926
02:21:54,399 --> 02:21:56,829
原来，如果我要保存此姓名和电话号码
It turns out, if I want to save this name and number

2927
02:21:56,829 --> 02:21:58,989
以CSV格式永久保存到该文件中，
to that file permanently in a CSV--

2928
02:21:58,989 --> 02:22:02,169
如果不熟悉，则在咨询界，分析界流行。
if unfamiliar, popular in the consulting world, the analytics world.

2929
02:22:02,170 --> 02:22:04,900
这只是一个电子表格，以逗号分隔的值
It's just a spreadsheet, a comma-separated value

2930
02:22:04,899 --> 02:22:08,469
您可以在Excel或数字或Google电子表格中打开的文件。
file that you can open in Excel or numbers or Google spreadsheet.

2931
02:22:08,469 --> 02:22:13,659
我要继续，而不是printf，而是fprintf到该文件，
I'm going to go ahead and, not printf, but fprintf to that file,

2932
02:22:13,659 --> 02:22:18,579
一个字符串，后跟一个逗号，然后是一个字符串，然后是一个新行，
a string followed by a comma, followed by a string, followed by a new line,

2933
02:22:18,579 --> 02:22:21,069
插入姓名和电话号码。
plugging in the name and the number.

2934
02:22:21,069 --> 02:22:25,279
然后在这里，我将关闭文件。
And then down here, I'm going to close the file.

2935
02:22:25,280 --> 02:22:28,570
所以这是新的。 fprintf不是printf，它将打印到您的屏幕上。
So this is new. fprintf is not printf, which prints to your screen.

2936
02:22:28,569 --> 02:22:30,306
fprintf打印到文件。
fprintf prints to a file.

2937
02:22:30,307 --> 02:22:32,890
因此，您必须再传递一个参数，第一个，
So you have to pass in one more argument, the first one, which

2938
02:22:32,889 --> 02:22:37,149
是指向您要将这些新字符串发送到的文件的指针。
is the pointer to the file that you want to send these new strings to.

2939
02:22:37,149 --> 02:22:40,179
然后，您仍然提供一个格式字符串，它说，嘿，fprintf，
Then you still provide a format string, which says, hey fprintf,

2940
02:22:40,180 --> 02:22:43,060
这是我要打印到文件中的数据。
this is the kind of data I want to print to the file.

2941
02:22:43,059 --> 02:22:46,929
然后插入变量，就像我们对printf所做的一样。
And then you plug in the variables, just like we've always done with printf.

2942
02:22:46,930 --> 02:22:49,610
最后，我们关闭文件。
And then lastly, we close the file.

2943
02:22:49,610 --> 02:22:53,200
简而言之，该程序似乎会提示人们输入姓名和电话号码。
So in short, this program would seem to prompt a human for a name and number.

2944
02:22:53,200 --> 02:22:55,420
然后继续写那些名字
And then it's going to go ahead and write those names

2945
02:22:55,420 --> 02:22:56,990
和文件编号。
and numbers to the file.

2946
02:22:56,989 --> 02:22:59,034
因此，让我继续制作电话簿。
So let me go ahead and make phonebook.

2947
02:22:59,034 --> 02:23:07,809
好的，到目前为止，没有问题，点斜线电话簿，David，949-468-2750。
OK, no mistake so far, dot slash phonebook, David, 949-468-2750.

2948
02:23:07,809 --> 02:23:11,139
好的，尽管似乎什么都没发生，但让我再次运行它。
OK, let me run it once more, even though nothing seems to have happened.

2949
02:23:11,139 --> 02:23:15,729
布赖恩，请问617-495-1000，输入。
Brian, how about 617-495-1000, Enter.

2950
02:23:15,729 --> 02:23:17,949
让我在这里检查我的文件浏览器。
Let me check my file browser here.

2951
02:23:17,950 --> 02:23:22,240
请注意，我们今天创建的所有文件，包括如果我放大的文件，
Notice, all of the files we've created today, including, if I zoom in,

2952
02:23:22,239 --> 02:23:25,389
不只是phonebook.c，还有phonebook.csv。
not just phonebook.c, but phonebook.csv.

2953
02:23:25,389 --> 02:23:29,289
如果我双击该按钮，请注意其中的内容。
And if I double click that, notice what's inside of this.

2954
02:23:29,290 --> 02:23:33,700
Voila，David的名字，Brian的名字以及我们每个电话号码。
Voila, David's name, Brian's name, and each of our numbers.

2955
02:23:33,700 --> 02:23:36,280
甚至比这更酷，让我继续并关闭它。
And even cooler than that, let me go ahead and close this.

2956
02:23:36,280 --> 02:23:40,213
让我继续并使用IDE下载此文件。
Let me go ahead and download this file using the IDE.

2957
02:23:40,212 --> 02:23:42,379
并将其放入我的“下载”文件夹中。
And that's going to put it into my Downloads folder.

2958
02:23:42,379 --> 02:23:43,419
让我继续并单击它。
Let me go ahead and click on it.

2959
02:23:43,420 --> 02:23:45,545
然后将打开Excel或Numbers或其他
And it's going to open Excel or Numbers or whatever

2960
02:23:45,545 --> 02:23:47,470
您恰好在Mac或PC上。
you happen to have on your Mac or PC.

2961
02:23:47,469 --> 02:23:50,739
我将继续进行。
I'm going to go ahead and just proceed.

2962
02:23:50,739 --> 02:23:54,399
瞧，这种格式看起来有点愚蠢。
And voila, looks a little stupid in this formatting here.

2963
02:23:54,399 --> 02:23:57,159
但是我打开了我自己生成的电子表格
But I've opened up a spreadsheet that I, myself, generated

2964
02:23:57,159 --> 02:24:01,389
使用fopen，fprintf和fclose。
using fopen, fprintf, and fclose.

2965
02:24:01,389 --> 02:24:04,179
因此，既然已经有了我们可以使用的指针，
So already, now that we have pointers at our disposal,

2966
02:24:04,180 --> 02:24:08,292
我们可以实际操作诸如文件之类的东西吗，这很酷。
can we actually manipulate things like files, which is quite cool.

2967
02:24:08,291 --> 02:24:09,999
但是我们本周要这样做，而不是
But we're going to do that this week, not

2968
02:24:10,000 --> 02:24:12,939
带有文本，但带有实际特定类型的文件。
with text, but with actual specific types of files.

2969
02:24:12,940 --> 02:24:16,840
的确，在这里回想一下这种想法。
And indeed, recall this kind of thinking here.

2970
02:24:16,840 --> 02:24:19,150
如果您看一眼，这可能很神秘。
If you glance at this, it's probably pretty cryptic.

2971
02:24:19,149 --> 02:24:21,399
它看起来像机器代码，但事实并非如此。
It looks like machine code, but it's not.

2972
02:24:21,399 --> 02:24:24,069
这也许是最简单的表示
This is, perhaps, the simplest representation

2973
02:24:24,069 --> 02:24:26,409
文件里面的笑脸的轮廓。
of a smiley face inside of a file.

2974
02:24:26,409 --> 02:24:30,999
如果您有位图文件，位图，位网格，这些位，
If you have a bitmap file, a map of bits, a grid of bits, those bits,

2975
02:24:31,000 --> 02:24:33,129
很简单，实际上可以是0和1。
quite simply, could literally be 0's and 1's.

2976
02:24:33,129 --> 02:24:37,239
如果您将黑色分配为0，将白色分配为1，
And if you assign the color black to 0 and the color white to 1,

2977
02:24:37,239 --> 02:24:40,659
您实际上可以将0和1的相同网格表示为
you could actually think of this same grid of 0's and 1's as representing,

2978
02:24:40,659 --> 02:24:41,929
的确，一张笑脸。
indeed, a smiley face.

2979
02:24:41,930 --> 02:24:43,690
换句话说，这是一些像素。
In other words, here are some pixels.

2980
02:24:43,690 --> 02:24:45,520
我们谈到了零周的像素。
We talked about pixels in week zero.

2981
02:24:45,520 --> 02:24:49,567
像素只是组成计算机上图形文件的点。
Pixels are just the dots that compose a graphic file on your computer.

2982
02:24:49,566 --> 02:24:50,649
像素无处不在。
And pixels are everywhere.

2983
02:24:50,649 --> 02:24:53,319
现在，我们所有人都可以通过Zoom或YouTube等实时进行调整，
All of us, now, tuning in live via Zoom or YouTube or the like,

2984
02:24:53,319 --> 02:24:56,799
我们正在观看像素流，这些像素流由多个图像和多个
we're watching streams of pixels, which compose multiple images and multiple

2985
02:24:56,799 --> 02:25:02,289
图像组成的视频似乎正在以20或30左右的速度移动
images compose video that appears to be moving at, like, 20 something or 30

2986
02:25:02,290 --> 02:25:04,670
每秒帧数，每秒图像数。
frames per second, images per second.

2987
02:25:04,670 --> 02:25:08,530
当然，现在这些图像的保真度很高。
Now, of course, there's only so much fidelity in these kinds of images.

2988
02:25:08,530 --> 02:25:11,097
这在电视和电影中非常普遍，
And it's quite common in the case on TV and in movies,

2989
02:25:11,096 --> 02:25:13,929
如果有一些坏人通过监视被发现
if there's some bad guy that's been picked up with some surveillance

2990
02:25:13,930 --> 02:25:17,050
镜头或类似内容，总是涉及法律与秩序等方面的人
footage or the like, invariably, the folks on Law &amp; Order and the like

2991
02:25:17,049 --> 02:25:19,929
可以改善视频并放大并查看
can just kind of enhance the video and zoom in and see

2992
02:25:19,930 --> 02:25:24,710
恰恰是人眼中的一闪一闪，显示出谁犯了罪。
exactly the glint in the person's eye that reveals who committed some crime.

2993
02:25:24,709 --> 02:25:26,139
好吧，那真是胡说八道。
Well, that's all kind of nonsense.

2994
02:25:26,139 --> 02:25:29,366
它源自我们在第零周引入的一些原语。
And it derives from some of the primitives we introduced in week zero.

2995
02:25:29,367 --> 02:25:31,450
实际上，只是为了取笑，让我继续
In fact, just to poke fun at this, let me go ahead

2996
02:25:31,450 --> 02:25:34,990
并在美国这里播放此电视节目的几秒钟
and play on a few seconds of this TV show here in the US

2997
02:25:34,989 --> 02:25:39,669
称为CSI，只是让您了解这种逻辑有多么普遍
called CSI, just to give you a sense of just how commonplace this kind of logic

2998
02:25:39,670 --> 02:25:40,180
是。
is.

2999
02:25:40,180 --> 02:25:41,140
[视频回放]
[VIDEO PLAYBACK]

3000
02:25:41,139 --> 02:25:43,329
- 我们知道。
- We know.

3001
02:25:43,329 --> 02:25:46,929
-在9:15，雷·桑托亚（Ray Santoya）在自动取款机上。
- That at 9:15, Ray Santoya was at the ATM.

3002
02:25:46,930 --> 02:25:50,380
-问题是，他在9:16做什么？
- So the question is, what was he doing at 9:16?

3003
02:25:50,379 --> 02:25:53,179
-向某物射击9毫米。
- Shooting the 9 millimeter at something.

3004
02:25:53,180 --> 02:25:54,820
也许他看到了狙击手。
Maybe he saw the sniper.

3005
02:25:54,819 --> 02:25:56,919
-或者正在和他一起工作。
- Or was working with him.

3006
02:25:56,920 --> 02:25:59,490
-等一下，回去。
- Wait, go back one.

3007
02:25:59,489 --> 02:26:00,480
- 你看到了什么？
- What do you see?

3008
02:26:00,480 --> 02:26:05,290
[哭声]
[CLICKING]

3009
02:26:07,700 --> 02:26:11,420
-全屏显示他的脸。
- Bring his face up, full screen.

3010
02:26:11,420 --> 02:26:12,530
-他的眼镜。
- His glasses.

3011
02:26:12,530 --> 02:26:13,982
-有一个反思。
- There's a reflection.

3012
02:26:13,981 --> 02:26:17,425
[打字]
[TYPING]

3013
02:26:23,840 --> 02:26:25,620
-那是Neuvitas棒球队。
- That's Neuvitas baseball team.

3014
02:26:25,620 --> 02:26:26,630
那是他们的标志。
That's their logo.

3015
02:26:26,629 --> 02:26:29,074
-他在跟穿那件夹克的人说话。
- And he's talking to whoever's wearing that jacket.

3016
02:26:29,075 --> 02:26:31,160
-我们可能有证人。
- We may have a witness.

3017
02:26:31,159 --> 02:26:32,699
-两次射击。
- To both shootings.

3018
02:26:32,700 --> 02:26:33,283
[结束播放]
[END PLAYBACK]

3019
02:26:33,282 --> 02:26:36,407
大卫·马兰（David MALAN）：很遗憾，今天宁愿毁掉许多电视和电影
DAVID MALAN: So unfortunately, today will rather ruin a lot of TV and movie

3020
02:26:36,407 --> 02:26:38,649
对你来说，因为你不能无限放大
for you, because you can't just zoom in infinitely

3021
02:26:38,649 --> 02:26:41,249
并查看更多信息（如果该信息不存在）。
and see more information if that information is not there.

3022
02:26:41,250 --> 02:26:43,750
在一天结束时，只有有限的位数。
At the end of the day, there's only a finite number of bits.

3023
02:26:43,750 --> 02:26:46,120
举例来说，这是布莱恩（Brian）的照片。
And case in point, here's a photograph of Brian.

3024
02:26:46,120 --> 02:26:48,580
而且您可能会看到，哦，他的眼中闪着光芒。
And you might see that, oh, there's a glint in his eye.

3025
02:26:48,579 --> 02:26:50,929
让我们看看他的眼睛在那反映了什么。
Let's see what was being reflected in his eye there.

3026
02:26:50,930 --> 02:26:53,410
因此，如果我们在此处放大Brian的这张图片，
And so if we Zoom in on this image here of Brian,

3027
02:26:53,409 --> 02:26:57,729
也许我们再放大一点，那就是实际的全部。
and maybe we zoom in a little further, that's all that's actually there.

3028
02:26:57,729 --> 02:27:00,159
您不仅可以点击增强按钮来查看更多信息，
You can't just click the enhance button and see more,

3029
02:27:00,159 --> 02:27:02,367
因为归根结底，这些只是像素。
because at the end of the day, these are just pixels.

3030
02:27:02,368 --> 02:27:06,310
每周为零的像素只有0和1，而且有限地很多。
And pixels, per week zero, are just 0's and 1's, and finitely, many so.

3031
02:27:06,309 --> 02:27:08,469
因此，所见即所得。
So what you see is what you get.

3032
02:27:08,469 --> 02:27:12,189
现在，话虽如此-实际上，我们也可以在这里对此取笑。
Now, with that said-- and actually, we can poke fun of this, too, here.

3033
02:27:12,190 --> 02:27:14,830
我来播放Futurama的另一个短片
Let me just play one other short clip from Futurama,

3034
02:27:14,829 --> 02:27:18,422
哪种锤子也可以说明这一点，但是更有趣。
which kind of hammers home this point as well, but more playfully so.

3035
02:27:18,423 --> 02:27:19,090
[视频回放]
[VIDEO PLAYBACK]

3036
02:27:19,090 --> 02:27:23,250
-放大死亡速度。
- Magnify that death speed.

3037
02:27:23,250 --> 02:27:24,770
为什么仍然模糊？
Why is it still blurry?

3038
02:27:24,770 --> 02:27:26,710
-这就是我们的所有决议。
- That's all the resolution we have.

3039
02:27:26,709 --> 02:27:29,049
加大它并不能使它更清晰。
Making it bigger doesn't make it clearer.

3040
02:27:29,049 --> 02:27:31,219
-确实在CSI：迈阿密。
- It does on CSI: Miami.

3041
02:27:31,219 --> 02:27:32,019
-[SIGH]
- [SIGH]

3042
02:27:32,020 --> 02:27:32,170
[结束播放]
[END PLAYBACK]

3043
02:27:32,170 --> 02:27:35,212
戴维·马兰（DAVID MALAN）：因此，在这里，我们有两个剪辑互相交谈。
DAVID MALAN: So there, we have two clips talking, rather, to one another.

3044
02:27:35,211 --> 02:27:37,329
但我必须为2020年更新内容。
But I have to update things for 2020.

3045
02:27:37,329 --> 02:27:41,971
这些天，你真的无法上网，或者杂志，
You can't really pick up the internet these days or magazine these days,

3046
02:27:41,971 --> 02:27:43,929
如果您愿意的话，也不会提及
if you even would, that doesn't somehow mention

3047
02:27:43,930 --> 02:27:45,850
机器学习和人工智能
machine learning and artificial intelligence

3048
02:27:45,850 --> 02:27:48,005
和花哨的算法，通过它们您可以执行操作
and fancy algorithms via which you can do things

3049
02:27:48,004 --> 02:27:49,629
以前不太可能。
that previously weren't quite possible.

3050
02:27:49,629 --> 02:27:51,459
这实际上是一种情况。
And that's actually kinda sorta the case.

3051
02:27:51,459 --> 02:27:56,289
您可能记得从零周开始，我们发现了这种美丽的水彩画
You might recall from week zero, that we found this beautiful watercolor

3052
02:27:56,290 --> 02:28:00,250
哈佛档案馆里的这幅画只有大约11英寸高。
painting in the Harvard archives that's only about 11 inches tall total.

3053
02:28:00,250 --> 02:28:03,700
但是不知何故，它在我身后高13英尺。
And yet somehow, it's 13 feet tall here behind me.

3054
02:28:03,700 --> 02:28:06,533
现在，通常，如果您只是要增强这幅水彩画，
Now, normally, if you were to just enhance this watercolor painting,

3055
02:28:06,532 --> 02:28:08,657
它很快就会开始看起来很愚蠢
it would start to look pretty stupid pretty quickly

3056
02:28:08,657 --> 02:28:10,569
像素很多，即使您
with lots and lots of pixelation, even if you

3057
02:28:10,569 --> 02:28:12,939
像档案馆一样，使用了非常精美的相机，
used a very fancy camera, as the archives do,

3058
02:28:12,940 --> 02:28:14,440
捕获原始图像。
to capture the original image.

3059
02:28:14,440 --> 02:28:16,810
但是我们想把它炸到13英尺高
But we wanted to blow it up to 13 feet tall

3060
02:28:16,809 --> 02:28:21,109
这样一来，它就可以始终以高品质站在我们身后。
so that it would stand at high quality behind us this whole time.

3061
02:28:21,110 --> 02:28:24,790
从某种意义上讲，我们实际上确实使用过增强功能。
And there, we actually did use enhance, in some sense.

3062
02:28:24,790 --> 02:28:28,640
因此，使用长话短说，比上周更好的算法，
So using, long story short, fancier algorithms than those last week,

3063
02:28:28,639 --> 02:28:31,689
您可以使用人工智能，机器学习，
you can use artificial intelligence, machine learning,

3064
02:28:31,690 --> 02:28:36,130
实际分析数据并找到没有的模式-
to actually analyze data and find patterns where there weren't--

3065
02:28:36,129 --> 02:28:38,279
不一定是人眼可见的。
that aren't necessarily visible to the human eye.

3066
02:28:38,280 --> 02:28:41,590
因此，例如，如果我们将原始图像放在这里并开始放大，
So for instance, if we take the original here and start to zoom in,

3067
02:28:41,590 --> 02:28:43,600
在这个分辨率上看起来还不错。
it looks pretty good at this resolution.

3068
02:28:43,600 --> 02:28:44,720
但这很顺利。
But it's pretty smooth.

3069
02:28:44,719 --> 02:28:48,729
您并没有真正看到这是在实际画布上绘制的事实。
You don't really see the fact that this was paint on an actual canvas.

3070
02:28:48,729 --> 02:28:50,706
因此，这只是放大Photoshop。
So this was just zooming in on Photoshop.

3071
02:28:50,707 --> 02:28:52,540
但是当您实际运行这样的图像时
But when you actually run an image like this

3072
02:28:52,540 --> 02:28:55,990
通过基于花式机器学习的软件，人工智能，
through fancy machine learning-based software, artificial intelligence,

3073
02:28:55,989 --> 02:28:58,569
您可以开始对其进行改进，然后实际看到，
you can begin to improve it and actually see,

3074
02:28:58,569 --> 02:29:01,389
不只是一栋建筑物顶部的窗户，
not just this window from the top of one of the buildings, which

3075
02:29:01,389 --> 02:29:03,519
在Photoshop中非常漂亮
is pretty glossed over here in Photoshop,

3076
02:29:03,520 --> 02:29:05,480
您可以开始查看更多详细信息。
you can start to see more detail.

3077
02:29:05,479 --> 02:29:08,749
因此，这实际上是以前的事情，只是放大Photoshop。
So this is literally the before, just zooming in Photoshop.

3078
02:29:08,750 --> 02:29:12,572
这是在实际应用花哨的人工智能算法之后
This is after, actually applying fancy artificial intelligence algorithms

3079
02:29:12,572 --> 02:29:15,280
通知，等一下，那里有一点变色。
that notice, wait a minute, there's a little discoloration there.

3080
02:29:15,280 --> 02:29:17,072
等一下，那里有些变色。
Wait, there's a little discoloration there.

3081
02:29:17,072 --> 02:29:20,830
如今，增强变得越来越重要。
And nowadays, enhance is increasingly becoming a thing.

3082
02:29:20,829 --> 02:29:22,449
它仍在推断。
It's still inferring.

3083
02:29:22,450 --> 02:29:25,270
并不是要复现必须存在的信息。
It's not resurrecting information that was necessarily there.

3084
02:29:25,270 --> 02:29:28,240
确实是算法上的最佳猜测
It's doing its best guess, really, algorithmically,

3085
02:29:28,239 --> 02:29:30,486
重建图像实际是什么。
to reconstruct what the image actually was.

3086
02:29:30,486 --> 02:29:32,319
如果我们进一步放大，也许可以
And if we zoom in further, you can, perhaps,

3087
02:29:32,319 --> 02:29:35,439
看到如果只是使用Photoshop，这真的开始变得模糊了
see that this is really starting to get blurry if you just use Photoshop

3088
02:29:35,440 --> 02:29:36,578
并继续放大。
and keep zooming in.

3089
02:29:36,577 --> 02:29:38,619
但是，如果您通过足够好的算法来运行它
But if you run it through fancy enough algorithms

3090
02:29:38,620 --> 02:29:40,780
并开始注意到轻微的变色
and start to notice slight discolorations that

3091
02:29:40,780 --> 02:29:44,920
不是人眼所能看到的，我们可以进一步增强它。
aren't super visible to the human eye, we can enhance that even further.

3092
02:29:44,920 --> 02:29:46,540
而且您不能无限地这样做。
And you can't do it infinitely so.

3093
02:29:46,540 --> 02:29:48,550
从某种意义上说，我们正在创造信息
And in some sense, we're creating information

3094
02:29:48,549 --> 02:29:51,281
那里不一定有该信息。
where there isn't necessarily that information there.

3095
02:29:51,281 --> 02:29:54,489
因此，这类事情是否在法庭上成立是另一个问题。
So whether or not these kinds of things hold up in court is another question.

3096
02:29:54,489 --> 02:29:56,919
但是，这样可以提高图像的保真度。
But it can improve the fidelity of images like this.

3097
02:29:56,920 --> 02:30:02,570
确实，它使我们能够从11英寸放大到13英尺。
And indeed, it allowed us to zoom in from 11 inches to 13 feet instead.

3098
02:30:02,569 --> 02:30:05,919
因此，当涉及到图像处理时，我们最终
So when it comes to manipulating images, ultimately, we

3099
02:30:05,920 --> 02:30:10,030
确实具有一些编程功能，包括此文件指针，
do have some programmatic capabilities, including this file pointer,

3100
02:30:10,030 --> 02:30:13,280
就像我们刚刚看到的一样，还有其他一些功能。
like we just saw, and also, a few other functions as well.

3101
02:30:13,280 --> 02:30:15,550
我们这里的最终示例将奠定基础
And our final examples, here, will lay the foundation

3102
02:30:15,549 --> 02:30:17,379
对于下周您将要做的事情，
for what you'll do this coming week, which

3103
02:30:17,379 --> 02:30:21,249
以新发现的方式操作您自己的图形文件
is manipulate your very own graphical files with a newfound understanding

3104
02:30:21,250 --> 02:30:25,269
指针和地址，现在是文件以及输入和输出。
of pointers and addresses and now files and input and output.

3105
02:30:25,270 --> 02:30:30,010
例如，我要继续在这里打开一个程序-
For instance, I'm going to go ahead and open up a program here called--

3106
02:30:30,010 --> 02:30:32,110
给我一秒钟。
give me just one second.

3107
02:30:32,110 --> 02:30:37,660
我将在这里打开一个名为jpeg.c的程序。
I'm going to open up a program here called jpeg.c.

3108
02:30:37,659 --> 02:30:40,609
我事先写的这个程序jpeg.c，
And this program, jpeg.c, which I wrote in advance,

3109
02:30:40,610 --> 02:30:43,400
该课程的网站上的内容，请执行以下操作。
which is on the course's website, does the following.

3110
02:30:43,399 --> 02:30:46,509
它首先声明一个称为字节的类型。
It first declares a type called byte.

3111
02:30:46,510 --> 02:30:49,990
事实证明，在C语言中，关于字节是什么没有通用定义。
It turns out, in C, there's no common definition of what a byte is.

3112
02:30:49,989 --> 02:30:51,609
正如我们所知，咬一口就好了。
A bite, as we know it, is a bit.

3113
02:30:51,610 --> 02:30:53,680
事实证明，最简单的创建方法
And it turns out, the simplest way to create

3114
02:30:53,680 --> 02:30:57,250
字节是定义我们自己的字节，就像我们定义了字符串一样，
a byte is to define our own, just like we've defined a string,

3115
02:30:57,250 --> 02:31:01,839
就像我们也定义了其他类型一样，例如学生，
just like we've defined other types too, like a student, in order--

3116
02:31:01,840 --> 02:31:04,640
一个人，而是为了给我们一个字节。
a person, rather, in order to give us a byte.

3117
02:31:04,639 --> 02:31:07,209
所以第一行代码只是声明了一个数据类型
So this first line of code just declares a data type

3118
02:31:07,209 --> 02:31:11,829
称为字节，使用另一种更神秘的数据类型，称为u int下划线t。
called byte, using another, more arcane data type called u int a underscore t.

3119
02:31:11,829 --> 02:31:13,329
但是，有关问题的更多信息。
But more on that in the problem set.

3120
02:31:13,329 --> 02:31:15,819
这样做确实发明了一种叫做字节的东西。
That this just did invent something called byte.

3121
02:31:15,819 --> 02:31:17,927
注意，在这个程序中，我正在重提这个想法
Notice, in this program, I'm resurrecting the idea

3122
02:31:17,927 --> 02:31:21,219
从命令行参数的第二周开始，我们可以从用户那里获取输入。
from week two of command line arguments, where we can take input from the user.

3123
02:31:21,219 --> 02:31:23,859
注意，我正在检查用户是否输入了两个参数。
Notice that I'm checking if the user typed in two arguments.

3124
02:31:23,860 --> 02:31:27,520
如果没有，我将立即返回一个以表示错误。
And if not, I'm returning one immediately to signify error.

3125
02:31:27,520 --> 02:31:30,490
在第17行中，我正在使用新技术。
In line 17, I'm using my new technique.

3126
02:31:30,489 --> 02:31:34,209
我正在使用文件名打开文件
I'm opening a file using the name of the file

3127
02:31:34,209 --> 02:31:36,049
该人员在命令行中键入的内容。
that the human typed at the command line.

3128
02:31:36,049 --> 02:31:40,269
这次，我将其打开以使用引号unquote而不是a来阅读它。
And this time, I'm opening it to read it with quote unquote, r instead of a.

3129
02:31:40,270 --> 02:31:41,660
但是如果没有文件，
But if there's not a file--

3130
02:31:41,659 --> 02:31:44,919
因此，如果是爆炸文件（即感叹号文件），
so if bang file, that is, if exclamation point file,

3131
02:31:44,920 --> 02:31:47,990
或者，如果file equals等于NULL，则它们表示同一件事。
or if file equals equals NULL, those mean the same thing.

3132
02:31:47,989 --> 02:31:51,039
我可以继续并返回一个，表示错误。
I can go ahead and return one, signifying an error.

3133
02:31:51,040 --> 02:31:53,710
在这里，我正在做一些聪明的事情。
Down here, I'm doing something a little clever.

3134
02:31:53,709 --> 02:31:56,889
事实证明，很有可能，
It turns out that with very high probability,

3135
02:31:56,889 --> 02:32:01,639
您可以通过仅查看前三个文件来确定任何文件是否为jpeg。
you can determine if any file is a jpeg by looking only at its first three

3136
02:32:01,639 --> 02:32:02,139
个字节。
bytes.

3137
02:32:02,139 --> 02:32:04,719
许多文件格式都有所谓的幻数
A lot of file formats have what are called magic numbers

3138
02:32:04,719 --> 02:32:06,349
在文件的开头。
at the beginning of their files.

3139
02:32:06,350 --> 02:32:10,990
这些是行业标准编号，其中1或2或3或更多，
And these are industry standard numbers, 1 or 2 or 3 or more of them,

3140
02:32:10,989 --> 02:32:13,909
通常只希望它位于文件的开头，
that is just commonly expected to be at the beginning of a file,

3141
02:32:13,909 --> 02:32:16,239
以便程序可以快速检查，这是jpeg吗？
so that a program can quickly check, is this a jpeg?

3142
02:32:16,239 --> 02:32:16,959
这是gif吗？
Is this a gif?

3143
02:32:16,959 --> 02:32:18,069
这是Word文档吗？
Is this a Word document?

3144
02:32:18,069 --> 02:32:19,299
这是Excel文件吗？
Is this an Excel file?

3145
02:32:19,299 --> 02:32:21,909
他们往往在开始时就有这些数字。
They tend to have these numbers at the beginning of them.

3146
02:32:21,909 --> 02:32:26,019
jpeg具有一系列我们将要看到的字节。
And jpegs have a sequence of bytes that we're about to see.

3147
02:32:26,020 --> 02:32:29,770
您将在下一个问题集中看到此处的这行代码24，
This line of code 24 here, as you'll see in the next problem set,

3148
02:32:29,770 --> 02:32:33,070
您可能会如何为自己提供字节缓冲区，特别是
is how you might give yourself a buffer of bytes, specifically

3149
02:32:33,069 --> 02:32:35,319
三个字节的数组。
an array of three bytes.

3150
02:32:35,319 --> 02:32:38,379
您将在下周看到的下一行代码称为fread。
This next line of code, as you'll see this coming week, is called fread.

3151
02:32:38,379 --> 02:32:40,719
顾名思义，fread从文件读取。
fread, as the name suggests, reads from a file.

3152
02:32:40,719 --> 02:32:42,939
也就是说，它从文件中获取字节。
That is, it grabs bytes from a file.

3153
02:32:42,940 --> 02:32:45,790
使用起来有点花哨，但您会更舒适
And it's a little fancy to use, but you'll get more comfortable

3154
02:32:45,790 --> 02:32:47,140
随着时间的流逝。
with this over time.

3155
02:32:47,139 --> 02:32:52,059
它将读取该缓冲区的第一个参数，该数据类型的大小，
It reads into this buffer, its first argument, the size of this data type,

3156
02:32:52,059 --> 02:32:53,049
一个字节的大小。
the size of a byte.

3157
02:32:53,049 --> 02:32:58,249
并且它从该文件中读取许多这样的数据类型。
And it reads in this many of those data types from this file.

3158
02:32:58,250 --> 02:33:01,479
同样，它是用于参数的，与我们所看到的相比，这是很多的。
So again, it's for arguments, which is kind of a lot from what we've seen.

3159
02:33:01,479 --> 02:33:08,229
但是它从这个文件中读取了三个字节到这个数组中，
But it reads from this file, three bytes into this array,

3160
02:33:08,229 --> 02:33:09,769
aka缓冲区，称为字节。
a.k.a. buffer, called bytes.

3161
02:33:09,770 --> 02:33:13,460
因此，这就是您编写不会将数据存储在文件中的代码的方式，
So this is just how you write code that doesn't put data in a file,

3162
02:33:13,459 --> 02:33:14,649
但请从中阅读。
but read it from it.

3163
02:33:14,649 --> 02:33:16,699
然后在这里，注意我们的十六进制。
And then here, notice our hexadecimal.

3164
02:33:16,700 --> 02:33:18,190
因此，我们走了一个完整的圈子。
So we've come full circle.

3165
02:33:18,190 --> 02:33:23,110
如果字节括号0等于0xff，则字节等于
If bytes bracket 0 equals equals 0xff and bytes

3166
02:33:23,110 --> 02:33:27,080
括号1等于0xd8，字节括号2等于0xff，
bracket 1 equals 0xd8 and bytes bracket 2 equals 0xff,

3167
02:33:27,079 --> 02:33:28,959
对您来说，这绝对是个秘密。
this definitely looks cryptic to you.

3168
02:33:28,959 --> 02:33:31,569
但这仅仅是因为我在手册中查找了jpeg，
But that's just because I looked up in the manual for jpegs,

3169
02:33:31,569 --> 02:33:34,899
事实证明，几乎所有jpeg都可以，
and it turns out that almost any jpeg, rather,

3170
02:33:34,899 --> 02:33:39,429
必须以0xff，0xd8、0xff开头。
must start with 0xff, 0xd8, 0xff.

3171
02:33:39,430 --> 02:33:43,450
这些是Mac，PC上jpeg的前三个字节，
Those are the first three bytes of any jpeg on your Mac, your PC,

3172
02:33:43,450 --> 02:33:44,350
在网上。
on the internet.

3173
02:33:44,350 --> 02:33:46,300
总是有这三个字节。
There are always those three bytes.

3174
02:33:46,299 --> 02:33:50,499
事实证明，第四个字节进一步决定是否
It turns out, the fourth byte further decides whether or not

3175
02:33:50,500 --> 02:33:51,729
文件实际上是jpeg。
a file is actually a jpeg.

3176
02:33:51,729 --> 02:33:54,639
但是，这样做的算法比较简单，因此我保持了简单性。
But the algorithm for that's a little fancier, so I kept it simple.

3177
02:33:54,639 --> 02:33:59,019
如果文件的前三个字节是这些字节，则可能是jpeg。
If the first three bytes of a file are those, maybe you have a jpeg.

3178
02:33:59,020 --> 02:34:01,150
但是如果您没有这三个字节，
But if you don't have exactly those three bytes,

3179
02:34:01,149 --> 02:34:02,919
您绝对没有jpeg。
you definitely don't have a jpeg.

3180
02:34:02,920 --> 02:34:05,270
因此，我在这里可以做的如下。
And so what I can do, here, is as follows.

3181
02:34:05,270 --> 02:34:09,700
在今天的代码中-让我继续获取另外两个文件
In today's code-- let me go ahead and grab two other files

3182
02:34:09,700 --> 02:34:11,620
我带来的
that I brought with me.

3183
02:34:11,620 --> 02:34:16,210
碰巧又是一张照片。
And one happens to be a photograph again.

3184
02:34:16,209 --> 02:34:18,159
给我一秒钟。
Give me one second.

3185
02:34:18,159 --> 02:34:24,009
我带来了一些文件，其中一个叫做brian.jpeg，
I brought with me a few files, one of which is called brian.jpeg,

3186
02:34:24,010 --> 02:34:25,870
这是布莱恩的照片。
which is the same photo of Brian.

3187
02:34:25,870 --> 02:34:28,030
然后我有一个gif，当然不是
And then I have a gif, which of course, is not

3188
02:34:28,030 --> 02:34:31,210
jpeg，就是这只猫在这里打字。
a jpeg, that is this cat typing here.

3189
02:34:31,209 --> 02:34:33,249
而我现在所拥有的实际上是我面前的东西
And what I, effectively, have in front of me now

3190
02:34:33,250 --> 02:34:37,870
是一个程序，如果我制作jpeg，因为这个文件是jpeg.c，
is a program that if I do make jpeg, because this file is jpeg.c,

3191
02:34:37,870 --> 02:34:43,360
然后运行点斜线jpeg，我可以输入cat.gif之类的内容
and I run dot slash jpeg, I can type in something like cat.gif

3192
02:34:43,360 --> 02:34:46,990
在命令行中将其作为参数，按Enter键，我应该看不到。
at the command line as an argument, hit Enter, and I should see no.

3193
02:34:46,989 --> 02:34:51,549
相比之下，如果我在命令行中将Brian的jpeg作为参数传递，
By contrast, if I pass in Brian's jpeg at the command line as an argument,

3194
02:34:51,549 --> 02:34:52,629
我知道了。
I see maybe.

3195
02:34:52,629 --> 02:34:54,429
再说一次，也许只是因为算法
And again, maybe only because the algorithm

3196
02:34:54,430 --> 02:34:56,638
实际判断某物是否为jpeg
for actually adjudicating whether something is a jpeg

3197
02:34:56,638 --> 02:34:58,550
比这复杂一点。
is a little more complicated than that.

3198
02:34:58,549 --> 02:35:02,589
但是确实，我现在可以访问各个字节，因此也可以访问像素，
But indeed, I can now access the individual bytes, and therefore pixels,

3199
02:35:02,590 --> 02:35:06,310
似乎是图像文件。
it would seem, of an image file.

3200
02:35:06,309 --> 02:35:08,574
实际上，我们甚至可以做到这一点。
And in fact, we can even do this.

3201
02:35:08,575 --> 02:35:10,450
让我继续向您展示最后一个程序
Let me go ahead and show you one last program

3202
02:35:10,450 --> 02:35:13,960
我们特意事先写的，只是为了让您了解一下
that we wrote deliberately in advance, just to give you a taste of what's

3203
02:35:13,959 --> 02:35:15,789
伴随着下一个问题集。
coming with the next problem set.

3204
02:35:15,790 --> 02:35:19,480
该程序是您可能已经重新实现的程序
This program is a reimplementation of the program you've probably

3205
02:35:19,479 --> 02:35:21,819
使用了一次或多次称为CP。
used one or more times called CP.

3206
02:35:21,819 --> 02:35:25,569
回想一下CP是IDE和Linux中的一个程序，
Recall that CP is a program in the IDE and in Linux,

3207
02:35:25,569 --> 02:35:27,729
更一般而言，它允许您复制文件。
more generally, that allows you to copy a file.

3208
02:35:27,729 --> 02:35:31,659
您执行CP，空格，文件名，空格，新文件名。
You do CP, space, the filename, space, the new filename.

3209
02:35:31,659 --> 02:35:32,649
这是如何运作的？
How does this work?

3210
02:35:32,649 --> 02:35:37,089
现在，我拥有了用于自己复制文件的所有构建块。
I now have all of the building blocks with which to copy files myself.

3211
02:35:37,090 --> 02:35:39,100
再说一次，我在这里定义一个字节。
So again, I'm defining a byte up here.

3212
02:35:39,100 --> 02:35:41,930
我在这里将main定义为接受命令行参数。
I'm defining main as taking command line arguments here.

3213
02:35:41,930 --> 02:35:43,000
并注意一项更改。
And notice one change.

3214
02:35:43,000 --> 02:35:44,800
我没有使用CS50库。
I'm not using the CS50 library.

3215
02:35:44,799 --> 02:35:52,089
因此，即使以前在第二周中使用的字符串现在也变成了char star。
So even what was previously string in week two is now char star.

3216
02:35:52,090 --> 02:35:55,450
即使在这里使用argv，我也要确保人类类型
Even here for argv, I'm making sure that the human types

3217
02:35:55,450 --> 02:36:00,580
用三个词，程序的名称，源文件和目标
in three words, the program's name and the source file and the destination

3218
02:36:00,579 --> 02:36:01,179
文件。
file.

3219
02:36:01,180 --> 02:36:02,410
我再次使用fopen。
I'm using fopen again.

3220
02:36:02,409 --> 02:36:06,099
我在这里从argv1打开源文件。
I'm opening the source file here from argv1.

3221
02:36:06,100 --> 02:36:07,358
我确定它不是nul。
I'm making sure it's not nul.

3222
02:36:07,358 --> 02:36:08,650
然后我退出了。
And then I'm quitting if it is.

3223
02:36:08,649 --> 02:36:13,029
我是-这是新东西，也在这里打开目标文件
I'm then-- here's something new, opening the destination file here, also

3224
02:36:13,030 --> 02:36:13,870
与fopen。
with fopen.

3225
02:36:13,870 --> 02:36:15,700
但是我使用的是引号unquote，“ w”。
But I'm using quote unquote, "w."

3226
02:36:15,700 --> 02:36:19,630
我要用r打开一个文件，用w打开一个文件，因为我想从其中一个读取
I'm opening one file with r, one file for w, because I want to read from one

3227
02:36:19,629 --> 02:36:21,159
并写给其他人。
and write to the other.

3228
02:36:21,159 --> 02:36:25,359
然后在这里，这个循环是一个聪明的方法
And then down here, this loop is a clever way

3229
02:36:25,360 --> 02:36:27,370
将一个文件复制到另一个文件。
of copying one file to another.

3230
02:36:27,370 --> 02:36:30,790
我给自己一个字节的缓冲区，所以只是一个临时变量，
I'm giving myself a buffer of one byte, so just a temporary variable, just

3231
02:36:30,790 --> 02:36:33,090
像布莱恩的临时工或空杯子。
like Brian's temp or empty glass.

3232
02:36:33,090 --> 02:36:35,160
我正在使用此功能，fread。
And I'm using this function, fread.

3233
02:36:35,159 --> 02:36:39,749
我正在通过其地址，一个字节的大小读入该缓冲区，
I'm reading into that buffer via its address, the size of a byte,

3234
02:36:39,750 --> 02:36:42,870
特别是源文件中的一个字节。
specifically one byte from the source file.

3235
02:36:42,870 --> 02:36:47,940
然后，在同一个循环中，我从那个缓冲区写一个字节的大小，
And then, in that same loop, I'm writing from that buffer, the size of a byte,

3236
02:36:47,940 --> 02:36:50,950
到目的地的一个字节。
specifically one byte, to the destination.

3237
02:36:50,950 --> 02:36:53,760
所以从字面上看，您可能已经看到我使用过的CP程序
So literally, the CP program you might have seen me use

3238
02:36:53,760 --> 02:36:57,090
或者您自己曾经用来复制文件，实际上就是这样做。
or you yourself have used to copy files, is literally doing this.

3239
02:36:57,090 --> 02:36:59,790
它正在打开一个文件，遍历其所有字节，
It's opening one file, iterating over all of its bytes,

3240
02:36:59,790 --> 02:37:02,010
并将它们从源复制到目标。
and copying them from source to destination.

3241
02:37:02,010 --> 02:37:04,260
最后，它正在关闭文件。
And then lastly, it's closing the file.

3242
02:37:04,260 --> 02:37:06,360
最后两个例子刻意快速，
And these last two examples deliberately fast,

3243
02:37:06,360 --> 02:37:11,130
因为这整整一周将用于深入研究文件I / O和映像
because this whole week will be spent diving into file I/O and images

3244
02:37:11,129 --> 02:37:11,889
其。
thereof.

3245
02:37:11,889 --> 02:37:16,559
但是我们要做的就是使用这些fread，fopen，fwrite和f close，
But all that we've done is use these fread, fopen, and fwrite and f close,

3246
02:37:16,559 --> 02:37:18,609
操纵那些文件。
to manipulate those very files.

3247
02:37:18,610 --> 02:37:21,975
例如，如果现在执行此操作，请让我执行cp。
So for instance, if I now do this, let me do make cp.

3248
02:37:21,975 --> 02:37:25,800
OK，似乎可以编译了，点斜线cp，brian.jpeg。
OK, seems to compile, dot slash cp, brian.jpeg.

3249
02:37:25,799 --> 02:37:27,749
brian2.jpeg怎么样？
How about brian2.jpeg?

3250
02:37:27,750 --> 02:37:28,680
然后按Enter。
And hit Enter.

3251
02:37:28,680 --> 02:37:29,880
似乎什么都没发生。
Nothing seems to happen.

3252
02:37:29,879 --> 02:37:33,239
但是如果我进入这里并双击brian2，
But if I go in here and double click on brian2,

3253
02:37:33,239 --> 02:37:37,419
我们看到我们有了Brian实际文件的第二份副本。
we see that we have a second copy of Brian's actual file.

3254
02:37:37,420 --> 02:37:41,560
因此，在下周，您将尝试使用多种文件格式的图像。
So this coming week, you'll experiment with multiple file formats for images.

3255
02:37:41,559 --> 02:37:42,579
首先是jpegs。
The first is jpegs.

3256
02:37:42,579 --> 02:37:44,999
我们将为您提供所谓的取证图像
And we will give you a so-called forensic image

3257
02:37:45,000 --> 02:37:47,938
数码存储卡中的一大堆照片。
of a whole bunch of photographs from a digital memory card.

3258
02:37:47,938 --> 02:37:50,730
实际上，在执法部门，这几天确实很常见，
In fact, it's very common these days, certainly in law enforcement,

3259
02:37:50,729 --> 02:37:53,579
取取硬盘驱动器，媒体棒的取证副本，
to take forensic copies of hard drives, of media sticks,

3260
02:37:53,579 --> 02:37:55,919
手机和其他设备，然后对其进行分析
of phones and other devices, and then analyze them

3261
02:37:55,920 --> 02:37:58,650
用于丢失，损坏或删除的数据。
for data that's been lost or corrupted or deleted.

3262
02:37:58,649 --> 02:38:01,979
我们将严格执行此操作，从而您将编写一个可以恢复的程序
We'll do exactly that, whereby, you'll write a program that recovers

3263
02:38:01,979 --> 02:38:05,849
从数码存储卡中意外删除的jpeg。
jpegs that have been accidentally deleted from a digital memory card.

3264
02:38:05,850 --> 02:38:08,100
我们会给您该存储卡的所有副本
And we'll give you all copies of that memory card

3265
02:38:08,100 --> 02:38:11,220
通过制作取证图像，即复制所有0和1
by making a forensic image of it, that is copying all of the 0's and 1's

3266
02:38:11,219 --> 02:38:13,709
从相机中并将其以文件形式提供给您
from a camera and giving them to you in a file

3267
02:38:13,709 --> 02:38:16,709
您可以读取然后从中写入。
that you can fread and then fwrite from.

3268
02:38:16,709 --> 02:38:18,929
我们还将向您介绍位图文件，
We'll also introduce you to bitmap files,

3269
02:38:18,930 --> 02:38:22,290
BMP，由Windows操作系统普及
BMP's, popularized by the Windows operating

3270
02:38:22,290 --> 02:38:24,160
墙纸之类的系统。
system for wallpaper's and the like.

3271
02:38:24,159 --> 02:38:28,469
但是我们将使用它们来实现使用指针和文件I / O的功能，
But we'll use them to implement using pointers and using file I/O,

3272
02:38:28,469 --> 02:38:30,549
您自己的类似Instagram的过滤器。
your very own Instagram-like filter.

3273
02:38:30,549 --> 02:38:33,539
因此，我们将在此处拍摄Weeks行人天桥的这张照片
So we'll take this picture, here, of the Weeks footbridge

3274
02:38:33,540 --> 02:38:35,578
哈佛大学在马萨诸塞州剑桥市。
here in Cambridge, Massachusetts by Harvard.

3275
02:38:35,577 --> 02:38:37,619
我们将为您实现许多过滤器，
And we'll have you implement a number of filters,

3276
02:38:37,620 --> 02:38:39,328
以这个原始图像为例，
taking this original image, for instance,

3277
02:38:39,327 --> 02:38:41,909
然后去饱和，使其变成黑色和白色，
and desaturating it, making it black and white,

3278
02:38:41,909 --> 02:38:45,209
通过遍历从上到下，从左到右的所有像素，
by iterating over all of the pixels top to bottom, left to right,

3279
02:38:45,209 --> 02:38:49,349
并识别出任何颜色，例如红色，绿色或蓝色或介于两者之间的任何颜色，
and recognizing any colors, like red or green or blue or anything in between,

3280
02:38:49,350 --> 02:38:53,467
然后将它们更改为灰色阴影，进行棕褐色过滤，
and changing them to some shade of gray, doing a sepia filter,

3281
02:38:53,467 --> 02:38:55,800
使事物看起来像是老派，就像这张照片一样
making things look old school, like this photo was taken

3282
02:38:55,799 --> 02:39:00,809
许多年前，通过类似地应用启发式方法来改变所有物体的颜色
many years ago, by similarly applying a heuristic that alters the colors of all

3283
02:39:00,809 --> 02:39:02,344
图片中的像素数。
of the pixels in this picture.

3284
02:39:02,344 --> 02:39:05,219
我们将其翻转，因此您必须将这个像素放在此处
We'll have you flip it around so you have to put this pixel over here

3285
02:39:05,219 --> 02:39:06,629
还有那个像素
and this pixel over there.

3286
02:39:06,629 --> 02:39:09,689
而且您会确切地了解文件的实现方式
And you'll appreciate exactly how files are implemented

3287
02:39:09,690 --> 02:39:12,180
在您自己的硬盘驱动器和手机中。
within your own hard drive and phone.

3288
02:39:12,180 --> 02:39:17,580
而且您甚至将实现一个模糊过滤器，这绝非偶然，
And you'll even implement, for instance, a blur filter, which no accident,

3289
02:39:17,579 --> 02:39:20,009
使得查看这里发生的事情变得更加困难，
makes it harder to see what's going on here,

3290
02:39:20,010 --> 02:39:23,700
因为您现在开始将附近的像素平均在一起
because you're starting to, now, average together pixels that are nearby

3291
02:39:23,700 --> 02:39:27,090
互相故意把东西弄光
each other to kind of gloss things over and deliberately

3292
02:39:27,090 --> 02:39:28,990
使得在这里很难看到。
make it harder to see here.

3293
02:39:28,989 --> 02:39:30,732
因此，即使您选择，我们也将拥有
And so we'll even, if you so choose, have

3294
02:39:30,733 --> 02:39:33,150
您实施边缘检测，如果感觉更舒适，
you implement edge detection, if feeling more comfortable,

3295
02:39:33,149 --> 02:39:37,019
在这些图片中找到所有物理对象的边缘的地方，
where you find the edges of all of the physical objects in these pictures,

3296
02:39:37,020 --> 02:39:43,350
为了在代码中实际检测到它们并像这样创建视觉艺术。
in order to actually detect them in code and create visual art like this.

3297
02:39:43,350 --> 02:39:44,220
现在，很多。
Now, this was a lot.

3298
02:39:44,219 --> 02:39:45,959
而且我知道通常会考虑使用指针
And I know pointers are generally considered

3299
02:39:45,959 --> 02:39:47,819
成为C更具挑战性的功能之一，
to be among the more challenging features of C,

3300
02:39:47,819 --> 02:39:49,402
当然，一般来说，编程也是如此。
and certainly, programming in general.

3301
02:39:49,403 --> 02:39:52,140
因此，如果您感觉已经有很多事情了，那就是。
So if you're feeling like it's been quite a bit, it was.

3302
02:39:52,139 --> 02:39:55,289
但是你现在确实有能力，无论是今天
But you do now have the ability, either today

3303
02:39:55,290 --> 02:39:59,040
或在不久的将来，甚至可以理解这样的XKCD漫画
or in the very near term, to understand even XKCD comics like this that most

3304
02:39:59,040 --> 02:40:00,990
那里的任何计算机科学家都已经看到过。
any computer scientist out there has seen.

3305
02:40:00,989 --> 02:40:05,129
因此，今天我们对您的最终期待是在这里开玩笑。
So our final look for you, today, is on this joke here.

3306
02:40:05,129 --> 02:40:10,049
即使我不一定能从远方听到你的声音，
And even though I can't necessarily hear you from afar,

3307
02:40:10,049 --> 02:40:12,689
我只是假设，在今天的最后时刻，
I'll just assume, in our final moments today,

3308
02:40:12,690 --> 02:40:16,650
每个人都大笑起来。
that everyone is breaking out into a very geeky laughter.

3309
02:40:16,649 --> 02:40:19,529
我至少看到一些微笑，这令人放心。
And I see some smiles, at least, which is reassuring.

3310
02:40:19,530 --> 02:40:21,480
这就是CS50。
This was, then, CS50.

3311
02:40:21,479 --> 02:40:23,009
下次见。
We'll see you next time.

3312
02:40:23,010 --> 02:40:26,360
[音乐播放]
[MUSIC PLAYING]

