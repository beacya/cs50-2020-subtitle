1
00:00:00,000 --> 00:00:06,461
[音乐响起--字幕精校中--By Persisan]
[MUSIC PLAYING]

2
00:00:48,561 --> 00:00:49,519
戴维·马兰：好的。
DAVID MALAN: All right.

3
00:00:49,520 --> 00:00:52,400
这是CS50，这是第6周。
This is CS50, and this is week 6.

4
00:00:52,399 --> 00:00:55,949
再次，这是那些罕见的日子之一，在短短的时间内
And this is, again, one of those rare days where in just a bit of time

5
00:00:55,950 --> 00:00:58,338
您将可以说您学习了一门新语言。
you'll be able to say that you learned a new language.

6
00:00:58,338 --> 00:01:01,130
今天的语言将是称为Python的语言。
And that language today is going to be this language called Python.

7
00:01:01,130 --> 00:01:04,430
而且我们以为我们将从介绍Python开始
And we'd thought we'd begin by introducing Python

8
00:01:04,430 --> 00:01:06,110
通过一些更熟悉的朋友。
by way of some more familiar friends.

9
00:01:06,109 --> 00:01:08,747
因此，这当然是我们在第0周开始的课程
So this, of course, is where we began the course back in week 0

10
00:01:08,748 --> 00:01:10,790
当我们介绍Scratch时，一个简单的程序
when we introduced Scratch, a simple program that

11
00:01:10,790 --> 00:01:12,860
简单地说：“你好，世界。”
quite simply says "hello, world."

12
00:01:12,859 --> 00:01:16,099
然后很快，事情就升级了，变成了
And then very quickly, things escalated and became

13
00:01:16,099 --> 00:01:19,524
更加神秘，更神秘，我们介绍了C和语法
a lot more cryptic, a lot more arcane, and we introduced C and syntax

14
00:01:19,525 --> 00:01:21,650
这样，当然可以做完全一样的事情，
like this, which of course do the exact same thing,

15
00:01:21,650 --> 00:01:25,430
只是在屏幕上打印出“你好，世界”，但有要求
just printing out "hello, world" on the screen, but with the requirement

16
00:01:25,430 --> 00:01:28,880
您了解并包含所有这些各种语法。
that you understand and you include all of this various syntax.

17
00:01:28,879 --> 00:01:34,519
所以今天，所有这些复杂性，所有来自C的语法，
So today, all of this complexity, all of the syntax from C,

18
00:01:34,519 --> 00:01:38,779
突然开始融化，以至于我们
suddenly begins to melt away, such that we're

19
00:01:38,780 --> 00:01:40,880
留下了这种称为Python的新语言
left with this new language called Python

20
00:01:40,879 --> 00:01:44,529
这行代码就能达到完全相同的目标
that's going to achieve the exact same goal simply with this line of code

21
00:01:44,530 --> 00:01:45,030
这里。
here.

22
00:01:45,030 --> 00:01:48,440
也就是说，Python往往更易于访问，
Which is to say that Python tends to be more accessible,

23
00:01:48,439 --> 00:01:50,269
它往往会容易一些。
it tends to be a little easier.

24
00:01:50,269 --> 00:01:53,749
但这是因为它建立在开始的传统基础上，
But that's because it's built on this tradition of having started,

25
00:01:53,750 --> 00:01:57,290
像人类几年前一样，构建诸如C之类的底层语言，
as humans years ago, building these low-level languages like C,

26
00:01:57,290 --> 00:02:00,240
意识到缺少哪些功能，哪些痛点，
realizing what features are missing, what some of the pain points are,

27
00:02:00,239 --> 00:02:04,339
然后在这些较旧的语言之上叠加新的思想，新功能，
and then layering on top of those older languages new ideas, new features,

28
00:02:04,340 --> 00:02:05,730
以及新的语言。
and in turn new languages.

29
00:02:05,730 --> 00:02:09,210
因此，实际上有数十种，数百种编程语言。
So there are dozens, hundreds really, of programming languages out there.

30
00:02:09,210 --> 00:02:13,400
但总会有一些子集会很受欢迎，非常流行
But there's always a subset of them that tend to be very popular, very in vogue

31
00:02:13,400 --> 00:02:14,210
在任何给定时间。
at any given time.

32
00:02:14,210 --> 00:02:17,090
Python是那些非常流行的语言之一。
Python is among those very popular languages.

33
00:02:17,090 --> 00:02:20,270
实际上，这是我们要研究的第三种语言，
And it's the third of our languages that we'll look at, indeed,

34
00:02:20,270 --> 00:02:22,290
在学期的这一点上。
at this point in the term.

35
00:02:22,289 --> 00:02:25,069
因此，让我们继续介绍Python的一些语法，
So let's go ahead and introduce some of the syntax of Python,

36
00:02:25,069 --> 00:02:28,279
确实是通过与过去的比较来进行的。
really by way of comparison with what we've seen in the past.

37
00:02:28,280 --> 00:02:31,130
因为无论今天的某些话题有多新，
Because no matter how new some of today's topics are,

38
00:02:31,129 --> 00:02:34,759
在我们将再次看到循环的意义上，他们应该都很熟悉，
they should all be familiar in the sense that we're going to see loops again,

39
00:02:34,759 --> 00:02:38,539
条件，变量，函数，返回值。
conditions, variables, functions, return values.

40
00:02:38,539 --> 00:02:41,809
几乎就是功能的翻译
There's pretty much just going to be a translation of features

41
00:02:41,810 --> 00:02:43,378
过去到现在的功能。
past to now features present.

42
00:02:43,377 --> 00:02:45,169
因此，当然，在Scratch的世界中，
So this of course, in the world of Scratch,

43
00:02:45,169 --> 00:02:48,379
只是一个拼图或一个功能，其目的是生命
was just one puzzle piece or a function, whose purpose in life

44
00:02:48,379 --> 00:02:50,299
在屏幕上说“你好，世界”。
is to say "hello, world" on the screen.

45
00:02:50,300 --> 00:02:54,320
在第1周，我们在这里将其翻译为更隐秘的语法，
In week 1, we translated this to the more cryptic syntax here,

46
00:02:54,319 --> 00:02:58,849
关键的细节是它是printf，引号，字符串，
key details being that it's printf, that you have the quote, the string,

47
00:02:58,849 --> 00:03:03,629
“您好，世界”，您使用反斜杠n表示换行符。
"hello, world," you have this backslash n to represent a new line character.

48
00:03:03,629 --> 00:03:06,799
然后，当然，这种陈述必须以分号结尾。
And then of course, this kind of statement has to end with a semicolon.

49
00:03:06,800 --> 00:03:10,310
如今使用该语言的等效代码行
The equivalent line of code today on out in this language

50
00:03:10,310 --> 00:03:12,930
被称为Python的将非常简单。
called Python is going to be quite simply this.

51
00:03:12,930 --> 00:03:16,850
因此，它看起来确实很相似，但是现在是print而不是printf。
So it looks similar, certainly, but it's now print instead of printf.

52
00:03:16,849 --> 00:03:21,619
我们仍然有双引号，但是反斜杠n和
We still have the double quotes, but gone are the backslash n as well as

53
00:03:21,620 --> 00:03:22,470
分号。
the semicolon.

54
00:03:22,469 --> 00:03:25,302
因此，如果您过于频繁地踢自己，以至于忘记
So if you've been kicking yourself all too frequently for forgetting

55
00:03:25,302 --> 00:03:29,149
像分号这样的愚蠢事物，Python现在将成为您的朋友。
stupid things like the semicolons, Python will now be your friend.

56
00:03:29,150 --> 00:03:31,160
好吧，让我们看另一个例子
Well, let's take a look at another example

57
00:03:31,159 --> 00:03:35,149
在这里，我们也将如何获取用户输入。
here, how we might go about getting user input as well.

58
00:03:35,150 --> 00:03:38,360
好吧，在这里请注意，我们有一个名为Ask的拼图。
Well, here notice that we have a puzzle piece called Ask.

59
00:03:38,360 --> 00:03:40,610
它说，问“你叫什么名字？”等一下
And it says, ask "What's your name?" and wait.

60
00:03:40,610 --> 00:03:43,580
接下来的拼图说，无论人类输入了什么，
And the next puzzle piece said, whatever the human had typed in,

61
00:03:43,580 --> 00:03:45,290
在其前面加上“你好”一词。
precede it with the word "hello."

62
00:03:45,289 --> 00:03:47,959
在C中，我们看到了这样的代码-string_answer
In C we saw code like this-- string_answer

63
00:03:47,960 --> 00:03:50,360
等于get_string“你叫什么名字？”
equals get_string "what's your name?"

64
00:03:50,360 --> 00:03:54,080
然后使用printf“你好％s”进行打印
and then printing out with printf, "hello %s,"

65
00:03:54,080 --> 00:03:56,810
为另一个插入一个值。
plugging in one value for the other.

66
00:03:56,810 --> 00:04:00,230
在Python中，这种复杂性也将消失。
In Python, some of this complexity is about to melt away, too.

67
00:04:00,229 --> 00:04:03,689
在Python中，我们将看到一些类似的东西。
And in Python, we're going to see a little something like this.

68
00:04:03,689 --> 00:04:07,099
因此，不再提及变量类型。
So no longer present is the mention of the type of variable.

69
00:04:07,099 --> 00:04:10,109
分号末尾不再存在。
No longer present is the semicolon at the end.

70
00:04:10,110 --> 00:04:15,102
不再显示％s和要打印的其他参数。
And no longer present is the %s and that additional argument to print.

71
00:04:15,102 --> 00:04:17,519
因此，事实上，让我们继续来看这些事情。
So in fact, let's go ahead and see these things in action.

72
00:04:17,519 --> 00:04:21,320
我将继续讨论此处，然后转到CS50 IDE。
I'm going to go ahead and go over to CS50 IDE here for just a moment.

73
00:04:21,319 --> 00:04:24,829
在CS50 IDE中，我将继续编写
And within CS50 IDE, I'm going to go ahead and write

74
00:04:24,829 --> 00:04:26,929
我的第一个Python程序。
my very first Python program.

75
00:04:26,930 --> 00:04:30,140
为此，我将继续创建一个文件，该文件我们最初将
And to do that, I'm going to go ahead and create a file that we'll initially

76
00:04:30,139 --> 00:04:31,729
叫做hello.py。
called hello.py.

77
00:04:31,730 --> 00:04:35,870
就像在C语言世界中一样，Python程序具有标准的文件扩展名
Much like in the world of C, Python programs have a standard file extension

78
00:04:35,870 --> 00:04:38,270
是.py而不是.c。
being .py instead of .c.

79
00:04:38,269 --> 00:04:41,389
我要去做我建议的最简单的翻译。
And I'm just going to do what I proposed was the simplest translation.

80
00:04:41,389 --> 00:04:45,169
我只是继续说打印，“你好，世界”。
I'm just going to go ahead and say print, "hello, world."

81
00:04:45,170 --> 00:04:46,430
我要保存文件。
I'm going to save my file.

82
00:04:46,430 --> 00:04:48,110
然后我要进入终端窗口。
And then I'm going to go down to my terminal window.

83
00:04:48,110 --> 00:04:50,420
当然，在过去，我们会使用make
And in the past, of course, we would have used make,

84
00:04:50,420 --> 00:04:54,420
然后我们会完成./hello之类的。
and then we would have done ./hello or the like.

85
00:04:54,420 --> 00:04:58,940
但是今天，我非常简单地将运行一个本身称为Python的命令。
But today, I'm quite simply going to run a command that itself is called Python.

86
00:04:58,939 --> 00:05:01,429
我要传递我刚才的文件名
I'm going to pass in the name of the file I just

87
00:05:01,430 --> 00:05:03,620
创建为其命令行参数。
created as its command line argument.

88
00:05:03,620 --> 00:05:08,630
瞧，按下Enter键，是我的第一个Python程序。
And voila, hitting Enter, there is my very first program in Python.

89
00:05:08,629 --> 00:05:09,959
因此，该功能非常强大。
So that's pretty powerful.

90
00:05:09,959 --> 00:05:14,397
让我们继续创建我刚才提出的第二个程序。
Let's go ahead and create the second program that I proposed a moment ago.

91
00:05:14,398 --> 00:05:16,190
而不是只打印“你好，世界”
Instead of just printing out "hello, world"

92
00:05:16,189 --> 00:05:18,769
整个时间，我这次也要继续
the whole time, I'm also going to go ahead this time

93
00:05:18,769 --> 00:05:22,069
并给自己一个变量，我将其称为答案。
and give myself a variable that I'll call answer.

94
00:05:22,069 --> 00:05:25,649
我现在要继续进行，并从用户那里获取输入。
I'm going to go ahead now and get input from the user.

95
00:05:25,649 --> 00:05:28,024
我将继续使用熟悉的get_string
And I'm going to go ahead and use the familiar get_string

96
00:05:28,024 --> 00:05:29,539
我们确实在C中看到了
that we did see in C.

97
00:05:29,540 --> 00:05:33,080
我将继续问“您叫什么名字”问号。
I'm going to go ahead and ask, "What's your name" question mark.

98
00:05:33,079 --> 00:05:35,369
我不会打分号。
I'm not going to bother with a semicolon.

99
00:05:35,370 --> 00:05:40,160
但是在这里，我要继续说打印“你好”，逗号，然后
But down here, I'm going to go ahead and say print "hello," comma, and then

100
00:05:40,160 --> 00:05:41,870
引号内有一个空格。
a space inside of the quotes.

101
00:05:41,870 --> 00:05:46,340
而且，我实际上不会继续执行％s，而是继续
And instead of doing something like %s, I'm actually going to go ahead and just

102
00:05:46,339 --> 00:05:50,509
做一个加号运算符，然后按字面意思是“答案”。
do a plus operator, and then literally the word "answer."

103
00:05:50,509 --> 00:05:53,526
但是要注意的是，这还行不通。
But the catch is that this isn't going to work just yet.

104
00:05:53,526 --> 00:05:56,359
这暂时还行不通，因为事实证明，使用get_string，
This isn't going to work just yet, because get_string, it turns out,

105
00:05:56,360 --> 00:05:59,357
就像它不是C附带的一样，它也不是Python附带的。
just like it doesn't come with C, it also doesn't come with Python.

106
00:05:59,357 --> 00:06:01,190
所以我需要做一件事
So I need to do one thing that's going to be

107
00:06:01,189 --> 00:06:02,731
与过去有些不同。
a little bit different from the past.

108
00:06:02,732 --> 00:06:05,870
我要说的不是散列，而是说一些东西
Instead of hash including something, I'm going to literally say

109
00:06:05,870 --> 00:06:09,110
从cs50导入get_string。
from cs50 import get_string.

110
00:06:09,110 --> 00:06:11,310
因此，在C语言世界中，我们记得
So in the world of C, recall that we included

111
00:06:11,310 --> 00:06:15,680
cs50.h，其中具有诸如get_string和get_int之类的函数的声明
cs50.h, which had declarations for functions like get_string and get_int

112
00:06:15,680 --> 00:06:16,430
等等。
and so forth.

113
00:06:16,430 --> 00:06:19,350
在Python的世界中，我们将向您展示一些类似的精神，
In the world of Python, we're going to show you something similar in spirit,

114
00:06:19,350 --> 00:06:21,100
但语法略有不同。
but the syntax is just a little different.

115
00:06:21,100 --> 00:06:25,460
我们将从cs50说起，这是我们工作人员的Python库
We're going to say from cs50, which is our Python library that we the staff

116
00:06:25,459 --> 00:06:28,879
编写，导入，即专门包含一个功能
wrote, import, that is, include a function specifically

117
00:06:28,879 --> 00:06:29,914
称为get_string。
called get_string.

118
00:06:29,915 --> 00:06:32,870
现在，我刚才在屏幕上可能看到的任何错误
And now any errors that I might have seen a moment ago on the screen

119
00:06:32,870 --> 00:06:33,770
已经消失了。
have disappeared.

120
00:06:33,769 --> 00:06:39,589
如果我继续保存该文件，然后在python空间中添加hello.py并按Enter，
If I go ahead and save this file and now do python space hello.py and hit Enter,

121
00:06:39,589 --> 00:06:44,089
现在我可以输入我的真实姓名，瞧，我看到“你好”，逗号，
now I can go ahead and type in my actual name, and voila, I see "hello," comma,

122
00:06:44,089 --> 00:06:44,629
“大卫。”
"David."

123
00:06:44,629 --> 00:06:47,119
因此，让我们来梳理一下这段代码的不同之处
So let's tease apart what's different about this code

124
00:06:47,120 --> 00:06:50,040
考虑一下此后我们还能做些什么。
and consider what more we can do after this.

125
00:06:50,040 --> 00:06:53,870
再次提醒您，在第3行上，不再提及字符串。
So again, notice-- on line 3, there's no mention of string anymore.

126
00:06:53,870 --> 00:06:56,150
如果我想要一个变量，我就继续给自己
If I want a variable, I just go ahead and give myself

127
00:06:56,149 --> 00:06:57,619
称为答案的变量。
a variable called answer.

128
00:06:57,620 --> 00:07:01,010
该函数仍称为get_string，它仍然需要一个参数
The function is still called get_string, and it still takes an argument just

129
00:07:01,009 --> 00:07:04,519
类似于C版本，但该行不再以分号结尾。
like the C version, but the line no longer ends with a semicolon.

130
00:07:04,519 --> 00:07:09,019
在我这里的最后一行代码中，现在确实是print而不是printf。
On my final line of code here, print is now indeed print instead of printf.

131
00:07:09,019 --> 00:07:10,504
然后这是新的语法。
And then this is new syntax.

132
00:07:10,504 --> 00:07:13,129
但是从某种意义上讲，它将变得更加简单。
But in some sense, it's going to be a lot more straightforward.

133
00:07:13,129 --> 00:07:17,329
不必提前考虑我想要％s和占位符的位置，
Instead of having to think in advance where I want the %s and my placeholder,

134
00:07:17,329 --> 00:07:20,749
这个加号运算符似乎正在为我做某事。
this plus operator seems to be doing something for me.

135
00:07:20,750 --> 00:07:23,209
让我继续，在这里向小组提问。
And let me go ahead and ask a question of the group here.

136
00:07:23,209 --> 00:07:26,299
那个加号运算符似乎在做什么？
What does that plus operator seem to be doing?

137
00:07:26,300 --> 00:07:29,840
因为它不是算术意义上的加法。
Because it's not addition in the arithmetic sense.

138
00:07:29,839 --> 00:07:32,179
我们不喜欢将数字相加。
We're not like adding numbers together.

139
00:07:32,180 --> 00:07:35,790
但是，加号显然在做些可以给我们视觉效果的事情。
But the plus is clearly doing something that gives us a visual result.

140
00:07:35,790 --> 00:07:37,850
彼得有什么想法吗？
Any thoughts from Peter?

141
00:07:37,850 --> 00:07:39,080
这是做什么加上什么？
What's this plus doing?

142
00:07:39,079 --> 00:07:40,972
听众：它是连接字符串。
AUDIENCE: It's concatenating strings.

143
00:07:40,973 --> 00:07:42,890
大卫·马兰（David MALAN）：是的，它是连接字符串，
DAVID MALAN: Yeah, it's concatenating strings,

144
00:07:42,889 --> 00:07:47,219
这是用来描述一根弦和另一根弦的连接的技术术语。
which is the term of art to describe the joining of one string and the other.

145
00:07:47,220 --> 00:07:50,240
因此，这非常类似于Scratch自己的Join块。
So it's quite like, therefore, Scratch's own Join block.

146
00:07:50,240 --> 00:07:53,360
现在，我们有了该Join块的字面翻译，
We now have a literal translation of that Join block,

147
00:07:53,360 --> 00:07:57,458
这在C中是没有的。在C中，我们必须使用printf，而我们必须使用％s。
which we didn't have in C. In C we had to use printf, we had to use %s.

148
00:07:57,458 --> 00:07:59,750
Python将变得更加用户友好，例如
Python is going to be a little more user friendly, such

149
00:07:59,750 --> 00:08:01,833
如果您想连接两个字符串，例如“ hello”，
that if you want to join two strings like "hello,"

150
00:08:01,833 --> 00:08:04,490
逗号，空格和该变量的内容，
comma, space, and the contents of that variable,

151
00:08:04,490 --> 00:08:06,770
我们可以直接使用加号运算符。
we can just use this plus operator instead.

152
00:08:06,769 --> 00:08:09,379
当然，我们要做的最后一件事是，
And the last thing that we had to do was, of course,

153
00:08:09,379 --> 00:08:11,869
导入该库，以便我们可以访问
import this library so that we have access

154
00:08:11,870 --> 00:08:13,493
到get_string函数本身。
to the get_string function itself.

155
00:08:13,492 --> 00:08:16,159
好吧，让我们继续浏览其他功能
Well, let's go ahead and take a tour of just some other features

156
00:08:16,160 --> 00:08:20,730
的Python知识，然后主要学习当今的许多动手实例。
of Python and then dive in primarily to a lot of hands-on examples today.

157
00:08:20,730 --> 00:08:23,850
所以回想一下，在我们刚才看到的示例中，
So recall that in the example we just saw,

158
00:08:23,850 --> 00:08:26,600
我们有第一行代码，它从用户那里得到一个字符串，
we had this first line of code, which gets a string from the user,

159
00:08:26,600 --> 00:08:29,000
将其存储在一个名为answer的变量中。
stores it in a variable called answer.

160
00:08:29,000 --> 00:08:31,250
我们有第二行代码，正如彼得所说，
We had this second line of code, which as Peter notes,

161
00:08:31,250 --> 00:08:33,500
将两个值串联在一起。
concatenated two values together.

162
00:08:33,500 --> 00:08:38,360
事实证明，尽管这绝对比使用C语言更方便
But it turns out, even though this is definitely more convenient than in C

163
00:08:38,360 --> 00:08:40,700
在那你可以只用一个现有的字符串和另一个
in that you can just take an existing string and another

164
00:08:40,700 --> 00:08:44,480
并将它们连接在一起，而不必使用格式字符串等，
and join them together without having to use format strings or the like,

165
00:08:44,480 --> 00:08:47,150
好吧，事实证明那是另一种方式，坦率地说，
well, it turns out there's another way, there's frankly many

166
00:08:47,149 --> 00:08:50,059
像Python这样的语言中实现相同结果的方法。
ways in languages like Python to achieve the same result.

167
00:08:50,059 --> 00:08:53,539
我将继续建议在此更改此行
And I'm going to go ahead and propose that we now change this line here

168
00:08:53,539 --> 00:08:55,159
这种时髦的语法。
to this funky syntax.

169
00:08:55,159 --> 00:08:57,709
乍看之下绝对是丑陋的，那就是
So definitely ugly at first glance, and that's

170
00:08:57,710 --> 00:09:01,100
部分原因是这是Python的一个相对较新的功能。
partly because this is a relatively new feature of Python.

171
00:09:01,100 --> 00:09:06,170
但是请注意，在Python中我们可以使用这些花括号，所以花括号
But notice that in Python can we use these curly braces, so curly braces

172
00:09:06,169 --> 00:09:11,279
我们在C语言中使用过的方法，可以在此处插入变量的实际值。
that we have used in C, to plug in an actual value of a variable here.

173
00:09:11,279 --> 00:09:15,979
因此，Python的print函数使用％大括号代替了％s，
So instead of %s, Python's print function uses these curly braces that

174
00:09:15,980 --> 00:09:18,950
本质上说，在这里插入一个值。
essentially say, plug in a value here.

175
00:09:18,950 --> 00:09:20,660
但是这里有一个奇怪的地方。
But there's one oddity here.

176
00:09:20,659 --> 00:09:25,219
您不能只是开始将大括号和变量名放入字符串中，
You can't just start putting curly braces and variable names into strings,

177
00:09:25,220 --> 00:09:27,230
在Python中用引号引起来的字符串。
that is quoted strings in Python.

178
00:09:27,230 --> 00:09:32,750
您还必须告诉该语言，其后是格式化的字符串。
You also have to tell the language that what follows is a formatted string.

179
00:09:32,750 --> 00:09:35,060
所以这也许是我们迄今为止所见过的最奇怪的事情。
So this is perhaps the weirdest thing we've seen yet.

180
00:09:35,059 --> 00:09:36,949
但是当您确实有一对双引号时
But when you do have a pair of double quotes

181
00:09:36,950 --> 00:09:41,240
就像我在这里一样，在它前面加上一个f实际上
like I have here, prefixing it with an f will actually

182
00:09:41,240 --> 00:09:44,060
告诉计算机格式化该字符串的内容，
tell the computer to format the contents of that string,

183
00:09:44,059 --> 00:09:47,149
在当前括号之间插入值，而不是
plugging in values between those currently braces, as opposed to

184
00:09:47,149 --> 00:09:50,539
从字面上打印这些花括号本身。
literally printing those curly braces themselves.

185
00:09:50,539 --> 00:09:54,739
因此，让我继续并转换到我的实际代码，然后尝试一下。
So let me go ahead and transition to my actual code here and try this out.

186
00:09:54,740 --> 00:09:58,490
与其使用彼得描述的并置运算符，
Instead of using the concatenation operator as Peter described it,

187
00:09:58,490 --> 00:10:01,070
这个加号运算符，让我从字面上讲
this plus operator, let me literally go ahead

188
00:10:01,070 --> 00:10:04,860
最初说“你好，回答”。
and say, "hello, answer," initially.

189
00:10:04,860 --> 00:10:07,580
因此，这可能不是正确的方法，
So this is probably not going to be the right approach,

190
00:10:07,580 --> 00:10:10,760
因为如果我重新运行该程序，hello.py的python，
because if I rerun this program, python of hello.py,

191
00:10:10,759 --> 00:10:12,259
会问我叫什么名字。
it's going to ask me what's my name.

192
00:10:12,259 --> 00:10:14,092
我要输入“ David”，
I'm going to type in "David," and it's going

193
00:10:14,092 --> 00:10:18,139
完全不理我，因为我在字面上硬编码了“你好，答案”。
to ignore me altogether, because I literally hardcoded "hello, answer."

194
00:10:18,139 --> 00:10:20,989
但是，开始也不是很正确。
But it's also not going to be quite right to just start

195
00:10:20,990 --> 00:10:25,520
将其放在花括号中，因为如果再次运行该程序，python
putting that in curly braces, because if I again run this program, python

196
00:10:25,519 --> 00:10:28,189
的hello.py，然后输入我的名字，现在开始
of hello.py, and type in my name, now it's going

197
00:10:28,190 --> 00:10:31,350
说“你好，大方地回答”。
to say "hello, squiggly brace answer."

198
00:10:31,350 --> 00:10:33,620
所以这只是我的微妙变化
So here is just a subtle change where I have

199
00:10:33,620 --> 00:10:38,390
告诉Python实际上双引号之间的这种类型的字符串
to tell Python that this type of string between the double quotes is in fact

200
00:10:38,389 --> 00:10:39,829
格式化的字符串。
a formatted string.

201
00:10:39,830 --> 00:10:43,370
现在，如果我重新运行hello.py的python并输入“ David”，
And now if I rerun python of hello.py and type in "David,"

202
00:10:43,370 --> 00:10:45,347
我现在得到“你好，大卫”。
I now get "hello, David."

203
00:10:45,346 --> 00:10:47,929
因此，它比C更加方便，因为，再次，您
So it's marginally more convenient than C, because, again, you

204
00:10:47,929 --> 00:10:50,721
不必在这里有占位符，在这里有占位符，然后
don't have to have a placeholder here, a placeholder here, and then

205
00:10:50,721 --> 00:10:52,729
以逗号分隔的其他参数列表。
a comma separated list of additional arguments.

206
00:10:52,730 --> 00:10:55,500
因此，如果您愿意的话，这只是一种更为简洁的方法，
So it's just a more succinct way, if you will,

207
00:10:55,500 --> 00:10:59,900
实际将更多值引入要创建的字符串中。
to actually introduce more values into a string that you want to create.

208
00:10:59,899 --> 00:11:03,469
这些称为格式字符串，或简称为短f字符串。
These are called format strings, or for short f-strings.

209
00:11:03,470 --> 00:11:06,740
这是我们编程时工具包中现在拥有的一项新功能
And it's a new feature that we now have in our toolkit when programming

210
00:11:06,740 --> 00:11:08,540
使用这种称为Python的新语言。
with this new language called Python.

211
00:11:08,539 --> 00:11:11,659
好吧，让我们看一下拼图的其他一些翻译
Well, let's take a look at a few other translation of puzzle pieces

212
00:11:11,659 --> 00:11:13,759
看，然后转到Python，然后开始
to see, and then turn to Python and then start

213
00:11:13,759 --> 00:11:16,049
建立我们自己的一些程序。
building some programs of our own.

214
00:11:16,049 --> 00:11:19,999
因此，在Scratch中，这是一个变量的早期示例
So here in Scratch, this was an example early on of a variable

215
00:11:20,000 --> 00:11:22,640
称为计数器，将其初始化为0。
called counter, initializing it to 0.

216
00:11:22,639 --> 00:11:26,989
在第1周的C语言中，我们开始将其翻译成这样的代码-int counter
In C, in week 1, we started translating that to code like this-- int counter

217
00:11:26,990 --> 00:11:28,910
等于0分号。
equals 0 semicolon.

218
00:11:28,909 --> 00:11:33,019
这给了我们一个int类型的变量，其初始值为0。
And that gave us a variable of type int whose initial value was 0.

219
00:11:33,019 --> 00:11:35,689
在Python中，代码将相似-
In Python, the code is going to be similar--

220
00:11:35,690 --> 00:11:39,590
相似，但将会更加简单。
similar, but it's going to be a little simpler still.

221
00:11:39,590 --> 00:11:44,030
注意，我不必在Python中提及我想要的变量类型。
Notice that I don't have to in Python mention the type of variable I want.

222
00:11:44,029 --> 00:11:46,519
它会根据上下文推断出它是什么。
It will infer from context what it is.

223
00:11:46,519 --> 00:11:48,929
而且我也不必在那里有分号。
And I also don't have to have the semicolon there.

224
00:11:48,929 --> 00:11:53,749
因此，Python中的counter等于0将为您提供一个名为counter的变量。
So counter equals 0 in Python is going to give you a variable called counter.

225
00:11:53,750 --> 00:11:57,410
并且因为您要为其分配值0，所以Python本身
And because you're assigning it the value 0, Python itself

226
00:11:57,409 --> 00:11:59,779
语言会推断出，哦，你必须
the language will infer that, oh, you must

227
00:11:59,779 --> 00:12:02,509
表示这是一个整数或整数。
mean this to be an int or an integer.

228
00:12:02,509 --> 00:12:04,009
我们在Scratch中看到了什么？
What else did we see in Scratch?

229
00:12:04,009 --> 00:12:05,539
换计数器加1。
Change counter by 1.

230
00:12:05,539 --> 00:12:08,779
因此，这是将变量的值增加1的一种方法。
So this was a way of increasing the value of a variable by 1.

231
00:12:08,779 --> 00:12:11,599
在C语言中，我们有几种不同的方法来实现这一点。
In C, we had a few different ways to implement this.

232
00:12:11,600 --> 00:12:14,360
我们可以说计数器等于计数器加1。
We could say counter equals counter plus 1.

233
00:12:14,360 --> 00:12:17,160
这是一种学究的方式，打字时既冗长又乏味。
It's kind of pedantic, it's kind of long and tedious to type.

234
00:12:17,159 --> 00:12:19,609
因此，我们有一些简写形式表示
So instead, we had some shorthand notation that

235
00:12:19,610 --> 00:12:23,140
允许我们这样做。
allowed us to do it this way instead.

236
00:12:23,139 --> 00:12:27,199
在C语言中，我们可以做反加等于1
In C, we were able to do counter plus equals 1,

237
00:12:27,200 --> 00:12:29,850
这将达到相同的结果。
and that was going to achieve the same result.

238
00:12:29,850 --> 00:12:32,940
嗯，在Python中，我们实际上也有两种方法。
Well, in Python we actually have a couple of approaches as well.

239
00:12:32,940 --> 00:12:37,130
就像在C语言中一样，我们可以像这样明确地说出来
We can, much like in C, say it explicitly like this

240
00:12:37,129 --> 00:12:38,699
但只需省略分号即可。
but just omit the semicolon.

241
00:12:38,700 --> 00:12:40,730
因此，counter等于counter加1。
So counter equals counter plus 1.

242
00:12:40,730 --> 00:12:44,420
Python中的逻辑与C中的逻辑完全相同。
The logic in Python is exactly the same as in C.

243
00:12:44,419 --> 00:12:48,799
至于这种简写形式，同样在Python中也存在
And as for this shorthand notation, this also exists in Python, again

244
00:12:48,799 --> 00:12:50,149
没有分号。
without the semicolon.

245
00:12:50,149 --> 00:12:55,309
故事中的这一点在Python中还不存在的一件事是
The one thing that does not exist in Python at this point in the story is

246
00:12:55,309 --> 00:13:01,849
花哨的柜台++语法，或i ++，使它变得均匀的语法糖
that fancy counter++ syntax, or i++, that syntactic sugar that made it even

247
00:13:01,850 --> 00:13:04,040
更简洁地只是增加一个变量，
more succinct to just increment a variable,

248
00:13:04,039 --> 00:13:06,709
不幸的是在Python中不存在。
unfortunately does not exist in Python.

249
00:13:06,710 --> 00:13:12,170
但是您可以做计数器加等于1或任何您碰巧的变量。
But you can do counter plus equals 1, or whatever your variable happens to be.

250
00:13:12,169 --> 00:13:14,419
好吧，我们在Scratch和C之后还看到了什么？
Well, what else did we see in Scratch and then C?

251
00:13:14,419 --> 00:13:15,359
回想一下。
recall this.

252
00:13:15,360 --> 00:13:18,290
当然，我们很早就引入了条件。
We introduced, of course, conditions pretty early on.

253
00:13:18,289 --> 00:13:20,299
这些条件使用布尔表达式
And those conditions use Boolean expressions

254
00:13:20,299 --> 00:13:23,569
决定是要执行此操作，还是执行此其他操作，还是执行其他操作
to decide whether to do this, or this other thing, or something else

255
00:13:23,570 --> 00:13:24,410
共。
altogether.

256
00:13:24,409 --> 00:13:28,849
在C语言中，我们将其转换为看起来类似的内容。
In C, we converted this to what looked kind of similar.

257
00:13:28,850 --> 00:13:32,300
的确，花括号紧紧地扣住了printf线，只是
Indeed, the curly braces kind of hug the printf line, just

258
00:13:32,299 --> 00:13:36,019
就像这里的黄色状态拥抱了紫色的说块一样。
like the yellow condition here hugs the purple Say block.

259
00:13:36,019 --> 00:13:41,059
而且我们在布尔表达式周围有括号，例如x小于y。
And we had parentheses around the Boolean expression, like x less than y.

260
00:13:41,059 --> 00:13:43,729
我们再次在花括号内使用了printf
We again used printf inside of the curly braces

261
00:13:43,730 --> 00:13:48,500
其中带有双引号，换行符的反斜杠n和分号。
which had double quotes, a backslash n for a new line, and a semicolon.

262
00:13:48,500 --> 00:13:52,129
很好的是，Python的精神将完全相同
Python, nicely enough, is going to be sort of identical in spirit

263
00:13:52,129 --> 00:13:54,079
但在语法上更简单。
but simpler syntactically.

264
00:13:54,080 --> 00:13:57,930
Python今后将是这样的。
What Python is going to look like henceforth is just this.

265
00:13:57,929 --> 00:14:01,699
因此，x小于y的括号消失了。
So the parentheses around the x less than y go away.

266
00:14:01,700 --> 00:14:03,980
花括号消失。
The curly braces go away.

267
00:14:03,980 --> 00:14:05,540
新线消失了。
The new line goes away.

268
00:14:05,539 --> 00:14:07,549
分号消失了。
And the semicolon goes away.

269
00:14:07,549 --> 00:14:11,509
在这里，您仅看到人类编程进化的一个小例子
And here you see just a tiny example of evolution of humans programming

270
00:14:11,509 --> 00:14:12,439
语言。
languages.

271
00:14:12,440 --> 00:14:14,900
如果你和我对所有的事情都感到沮丧
If you and I have been frustrated for some time about all

272
00:14:14,899 --> 00:14:17,629
到处都是愚蠢的分号和花括号，
the stupid semicolons and curly braces all over the place,

273
00:14:17,629 --> 00:14:20,039
从某种意义上讲，这会使您的代码更难阅读，
it makes it harder, in some sense, for your code to read,

274
00:14:20,039 --> 00:14:23,467
更不用说是正确的了，人类在发明新语言时就决定了
let alone being correct, humans decided when inventing new languages

275
00:14:23,467 --> 00:14:25,759
那，你知道什么，为什么我们不只是说我们的意思
that, you know what, why don't we just say what we mean

276
00:14:25,759 --> 00:14:29,329
不用担心所有这些语法复杂性吗？
and not worry as much about all of this syntactic complexity?

277
00:14:29,330 --> 00:14:30,560
让我们保持简单。
Let's keep things simpler.

278
00:14:30,559 --> 00:14:34,249
的确，这就是我们在这里看到的，是Python中的一个示例。
And indeed, that's what we see here, is one example in Python.

279
00:14:34,250 --> 00:14:35,929
但是有一个关键的细节。
But there's a key detail.

280
00:14:35,929 --> 00:14:37,939
如果您有任何习惯，什么时候
If any of you have been in the habit, when

281
00:14:37,940 --> 00:14:41,630
用C编写代码，到时有点草率
writing code in C, of being a little sloppy when it comes

282
00:14:41,629 --> 00:14:44,899
根据您的缩进，也许style50一直在
to your indentation, and maybe style50 is constantly

283
00:14:44,899 --> 00:14:49,009
大喊大叫您要添加空格，添加空格或删除空格或线条，
yelling at you to add spaces, add spaces, or remove spaces or lines,

284
00:14:49,009 --> 00:14:55,099
好吧，在Python中，现在有必要正确缩进您的代码。
well, in Python it is now necessary to indent your code correctly.

285
00:14:55,100 --> 00:14:58,820
当然，在C语言中，我们，CS50和世界上很多地方
In C, of course, we, CS50 and a lot of the world in general

286
00:14:58,820 --> 00:15:03,260
建议您将代码缩进4个空格（通常是一个制表符）。
recommend that you indent your code by 4 spaces, typically, or one tab.

287
00:15:03,259 --> 00:15:06,589
在Python的上下文中，您必须这样做。
In the context of Python, you must do so.

288
00:15:06,590 --> 00:15:11,420
如果您不小心忽略了打印语句左侧的这些空格
If you accidentally omit these spaces just to the left of the print statement

289
00:15:11,419 --> 00:15:14,479
在这里，您的Python代码根本不会运行。
here, your Python code is not going to run at all.

290
00:15:14,480 --> 00:15:17,400
Python程序将无法正常工作。
The Python program just won't work.

291
00:15:17,399 --> 00:15:19,256
这样就不再草率了。
So no more sloppiness.

292
00:15:19,256 --> 00:15:20,839
Python将强加给您。
Python is going to impose this on you.

293
00:15:20,840 --> 00:15:24,152
但是，好处是您不必费劲包括花括号。
But the upside is you don't have to bother including the curly braces.

294
00:15:24,152 --> 00:15:26,360
哪里有更复杂的情况呢
What about a more complicated condition where there's

295
00:15:26,360 --> 00:15:30,470
您是否可以遵循两条路径？
two paths you can follow, if or else?

296
00:15:30,470 --> 00:15:34,460
好吧，在这种情况下，在C中，我们像这样直接翻译了它。
Well, in this case in C, we translated it pretty straightforwardly like this.

297
00:15:34,460 --> 00:15:38,960
同样，在这里加上括号，在这里和这里使用花括号，反斜杠n，
Again, parentheses up here, curly braces here and here, backslash n,

298
00:15:38,960 --> 00:15:40,640
反斜杠n和分号。
backslash n, and semicolon.

299
00:15:40,639 --> 00:15:42,439
您也许可以在Python中猜到这
You can perhaps guess in Python that this

300
00:15:42,440 --> 00:15:45,140
会变得更紧凑，因为动臂，
is going to get a little more compact, because boom,

301
00:15:45,139 --> 00:15:47,699
现在我们不再需要括号了。
now we don't need the parentheses anymore.

302
00:15:47,700 --> 00:15:50,380
我们确实需要缩进，但是不需要花括号。
We do we need to indent, but we don't need the curly braces.

303
00:15:50,379 --> 00:15:53,449
我们不需要换行，也不需要分号。
We don't need the new line, and we don't need the semicolon.

304
00:15:53,450 --> 00:15:57,670
因此，我们正在减少一些可以立即视为理所当然的功能。
So we're sort of shedding features that can be taken now for granted.

305
00:15:57,669 --> 00:16:01,429
在Scratch中，当我们在路上有一个三向叉时，这个例子怎么样？
What about this example in Scratch when we had a three-way fork in the road,

306
00:16:01,429 --> 00:16:03,789
如果，否则，如果，否则？
if, else, if, else?

307
00:16:03,789 --> 00:16:07,959
好吧，在Python中-或更确切地说，在C语言中，我们将这样翻译。
Well, in Python-- or rather in C, we would have translated this like this.

308
00:16:07,960 --> 00:16:09,560
而且那里没有太多的事情。
And there's not much going on there.

309
00:16:09,559 --> 00:16:13,089
但这是相当数量的代码行，大约12行，
But it's pretty substantive number of lines of code, some 12 lines,

310
00:16:13,090 --> 00:16:14,980
只是为了实现这个简单的想法。
just to achieve this simple idea.

311
00:16:14,980 --> 00:16:17,800
在Python中，请注意这里将要消失的内容
In Python, notice what's going to go away here

312
00:16:17,799 --> 00:16:22,344
再次是括号，再次是花括号，再次是反斜杠n，
is, again those parentheses, again those curly braces, again the backslash n,

313
00:16:22,345 --> 00:16:24,340
和分号。
and the semicolon.

314
00:16:24,340 --> 00:16:26,890
这里只有一个奇怪的地方。
There's only one oddity here.

315
00:16:26,889 --> 00:16:28,119
只有一个奇怪的地方。
There's only one oddity.

316
00:16:28,120 --> 00:16:31,120
对您来说看起来是错还是奇怪？
What looks wrong or weird to you?

317
00:16:31,120 --> 00:16:34,720
也许，看起来像错字了吗？
Maybe, what looks like a typo to you?

318
00:16:34,720 --> 00:16:38,550
我保证我不会在这里搞砸。
And I promise I haven't screwed up here.

319
00:16:38,549 --> 00:16:40,619
也许在其他地方，但不在这里。
Maybe elsewhere, but not here.

320
00:16:40,620 --> 00:16:42,130
安德鲁？
Andrew?

321
00:16:42,129 --> 00:16:46,524
听众：如果在语法上有所不同，我想说的是elif而不是else。
AUDIENCE: I would say the elif instead of else if is different syntactically.

322
00:16:46,524 --> 00:16:47,399
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

323
00:16:47,399 --> 00:16:53,099
因此，在C语言中，如果人类在多年前使用Python，我们会直言不讳
So whereas in C we would literally say else if, in Python, humans years ago,

324
00:16:53,100 --> 00:16:57,960
决定，哎呀，为什么要说否则，并浪费所有时间将其键入，如果您
decided, heck, why say else if and waste all of that time typing that out if you

325
00:16:57,960 --> 00:17:02,640
可以更简洁地说出“ elif”作为一个词，即ELIF。所以的确
can more succinctly say "elif" as one word, E-L-I-F. So indeed,

326
00:17:02,639 --> 00:17:04,019
这是正确的语法。
this is correct syntax here.

327
00:17:04,019 --> 00:17:05,311
而且您可以拥有更多这些。
And you can have more of those.

328
00:17:05,311 --> 00:17:10,439
您可以在路上有四个叉子，之后有五个，六个，任何数量。
You can have four forks in the road, five, six, any number thereafter.

329
00:17:10,440 --> 00:17:12,425
但是语法确实有所不同。
But the syntax is indeed a little different.

330
00:17:12,424 --> 00:17:13,799
但这有点紧，对不对？
But it's a little tighter, right?

331
00:17:13,799 --> 00:17:17,368
当您看一下这段代码时，语法上的注意力就会减少。
There's less syntactic distraction when you glance at this code.

332
00:17:17,368 --> 00:17:19,828
您不必忽略许多分号和卷曲
You don't have to ignore as many semicolons and curly

333
00:17:19,828 --> 00:17:21,239
大括号之类的。
braces and the like.

334
00:17:21,240 --> 00:17:23,807
Python在语法上趋向于变得更加简洁。
Python tends to just be a little cleaner syntactically.

335
00:17:23,807 --> 00:17:25,890
确实，这是许多其他功能的特征
And indeed, that's characteristic of a lot of more

336
00:17:25,890 --> 00:17:28,260
最近，更现代的语言喜欢它。
recent, more modern languages like it.

337
00:17:28,259 --> 00:17:31,769
好吧，让我们看一下Scratch以及C的其他几个块。
All right, let's take a look at a few other blocks in Scratch and in turn C.

338
00:17:31,769 --> 00:17:34,889
在Scratch中，当我们想一次又一次地循环做某事时，
In Scratch, when we wanted to do something again and again as a loop,

339
00:17:34,890 --> 00:17:38,040
也许永远，我们会从字面上使用Forever块。
perhaps forever, we would literally use the Forever block.

340
00:17:38,039 --> 00:17:41,459
在C语言中，我们可以通过几种不同的方式来实现它。
In C, we could implement this in a few different ways.

341
00:17:41,460 --> 00:17:46,230
我们很简单地提出了这一建议，而真正的印刷版是“你好，世界”，
And we proposed quite simply this one-- while true print out "hello, world,"

342
00:17:46,230 --> 00:17:47,940
一遍又一遍。
again and again and again.

343
00:17:47,940 --> 00:17:50,200
而且由于布尔表达式永远不变，
And because the Boolean expression never changes,

344
00:17:50,200 --> 00:17:51,960
它确实将永远执行。
it's going to indeed execute forever.

345
00:17:51,960 --> 00:17:54,180
因此，Python实际上非常相似，但是
So Python is actually pretty similar, but there

346
00:17:54,180 --> 00:17:55,990
有一些细微的差异。
are a couple of subtle differences.

347
00:17:55,990 --> 00:17:58,350
因此，您要根深蒂固这里的样子。
So ingrain in your mind what this looks like here.

348
00:17:58,349 --> 00:18:03,419
括号，花括号，换行符和分号都为真。
We have true in parentheses, the curly braces, the new line, the semicolon.

349
00:18:03,420 --> 00:18:06,090
许多都将消失，但它们仍然存在
A lot of that's about to go away, but they're still

350
00:18:06,089 --> 00:18:07,439
会有细微的差别。
going to be a slight difference.

351
00:18:07,440 --> 00:18:11,070
请注意，正如我一直强调的那样，我们正在缩进。
Notice that we're indenting, as I keep emphasizing.

352
00:18:11,069 --> 00:18:14,519
我们不再需要换行，分号或当前的花括号，
We no longer have the new line or the semicolon or the currently braces,

353
00:18:14,519 --> 00:18:15,719
但是是真的 -
but True--

354
00:18:15,720 --> 00:18:17,280
结果是，错了-
and it turns out, False--

355
00:18:17,279 --> 00:18:18,909
现在必须大写。
now must be capitalized.

356
00:18:18,910 --> 00:18:23,610
因此，在C语言中，小写为false，在小写为true，在Python中
So whereas in C it was lowercase false, lowercase true, in Python

357
00:18:23,609 --> 00:18:26,279
它会大写False，大写True。
it's going to be capitalized False, capitalized True.

358
00:18:26,279 --> 00:18:26,999
为什么？
Why?

359
00:18:27,000 --> 00:18:28,139
只是因为。
Just because.

360
00:18:28,140 --> 00:18:32,550
但是还有另外一个值得注意的细节，我们的循环都需要
But there is one other detail that's important to note, both with our loops

361
00:18:32,549 --> 00:18:35,009
在这里，以及我们的条件。
here, as well as with our conditions.

362
00:18:35,009 --> 00:18:38,039
和以前一样，如果我倒退到最新状态，
Just as before, if I rewind to our most recent condition,

363
00:18:38,039 --> 00:18:40,769
请注意，即使我们摆脱了花括号
notice that even though we've gotten rid of the curly braces

364
00:18:40,769 --> 00:18:43,619
我们已经摆脱了括号，我们现在
and we've gotten rid of the parentheses, we now

365
00:18:43,619 --> 00:18:47,639
已经引入了这些冒号，这是在表达之后所必需的，
have introduced these colons, which are necessary after this expression,

366
00:18:47,640 --> 00:18:50,580
这个表达式和这个表达式，以使Python更加清楚
this expression, and this one, to make clear to Python

367
00:18:50,579 --> 00:18:54,149
在下面缩进的代码行
that the lines of code that follow indented underneath

368
00:18:54,150 --> 00:18:57,910
确实与if，elif或else有关。
are indeed relevant to that if, elif, or else.

369
00:18:57,910 --> 00:19:01,540
而且我们在循环上下文中再次看到了相同的功能。
And we see that same feature again here in the context of a loop.

370
00:19:01,539 --> 00:19:02,789
当然，我们看到了其他循环。
We saw other loops, of course.

371
00:19:02,789 --> 00:19:04,559
在Scratch中，当我们想做某事时
In Scratch, when we wanted to do something

372
00:19:04,559 --> 00:19:08,909
有限的次数（例如3次），我们将重复以下三遍。
a finite number of times like 3, we would repeat the following three times.

373
00:19:08,910 --> 00:19:11,770
在C语言中，我们有几种不同的处理方法。
In C, we had a few different approaches to this.

374
00:19:11,769 --> 00:19:14,099
我敢说，所有这些都是非常机械的。
And all of them, I dare say, were very mechanical.

375
00:19:14,099 --> 00:19:17,519
就像，如果您想做三遍，那么C中的责任
Like, if you want to do something three times, the onus in C

376
00:19:17,519 --> 00:19:21,239
在您声明变量，跟踪多少次
is on you to declare a variable, keep track of how many times

377
00:19:21,240 --> 00:19:23,250
你已经数过了，增加东西。
you've counted already, increment the thing.

378
00:19:23,250 --> 00:19:24,840
就像，有很多活动部件。
Like, there's a lot of moving parts.

379
00:19:24,839 --> 00:19:27,969
因此在C语言中，一种方法看起来像这样。
And so in C, one approach looked like this.

380
00:19:27,970 --> 00:19:30,270
我们声明一个名为i的变量等于0--
We declare a variable called i equals 0--

381
00:19:30,269 --> 00:19:32,109
但我们可以称其为我们想要的任何东西-
but we could call it anything we wan--

382
00:19:32,109 --> 00:19:35,879
我们这里有一个while块，再次询问布尔表达式
we have a while block here that's asking a Boolean expression again

383
00:19:35,880 --> 00:19:37,770
再一次，我是否小于0--
and again, is i less than 0--

384
00:19:37,769 --> 00:19:39,479
我小于3吗？
is i less than 3?

385
00:19:39,480 --> 00:19:42,240
然后在循环内部，我们打印出“你好，世界”。
And then inside of the loop, we printed out "hello, world."

386
00:19:42,240 --> 00:19:46,200
并使用C的语法糖，加号和加号，
And using C's syntactic sugar, the plus plus notation,

387
00:19:46,200 --> 00:19:49,800
我们一直将i加1，将i加1，将i加1，
we kept adding 1 to i, add 1 to i, add 1 to i,

388
00:19:49,799 --> 00:19:51,839
直到我们隐式地跳出循环
until we implicitly break out of the loop

389
00:19:51,839 --> 00:19:54,809
因为它当然不小于3
because it's, of course, no longer less than 3.

390
00:19:54,809 --> 00:19:59,219
因此，在Python中，其精神相似，但又有些杂乱无章。
So in Python, similar in spirit, but again, some of that clutter goes away.

391
00:19:59,220 --> 00:20:03,300
我等于0是我们需要给自己一个变量的一切。
i equals 0 is all we need say to give ourselves a variable.

392
00:20:03,299 --> 00:20:07,679
虽然我不足3，但我们只需要说一个冒号即可。
While i less than 3 is all we need to say there but with a colon.

393
00:20:07,680 --> 00:20:11,220
然后，在其中适当缩进后，我们打印出“ hello，world”。
Then inside of that, indented properly, we print out "hello, world."

394
00:20:11,220 --> 00:20:15,610
而且-我们无法做到正负加倍，如此令人失望的是-
And-- we can't do the plus plus, so minor disappointment--

395
00:20:15,609 --> 00:20:18,299
但是我加上等于1的增量i。
but i plus equals 1 increments i.

396
00:20:18,299 --> 00:20:23,069
因此，这将是在Python中实现完全相同的循环的一种方式
So this would be one way of implementing in Python the exact same thing a loop

397
00:20:23,069 --> 00:20:24,719
执行三遍。
that executes three times.

398
00:20:24,720 --> 00:20:27,750
但是我们当然在C语言中看到了其他方法，
But we saw other approaches, of course, in C,

399
00:20:27,750 --> 00:20:30,600
在Python中还有其他可能的方法。
and there's other approaches possible in Python as well.

400
00:20:30,599 --> 00:20:33,526
您可能还记得在C中我们看到了这种方法，即for循环。
You might recall in C that we saw this approach, the for loop.

401
00:20:33,527 --> 00:20:35,610
而且很可能您一直在寻求for循环
And odds are you've been reaching for the for loop

402
00:20:35,609 --> 00:20:38,526
相当频繁，因为尽管看起来有些神秘，
pretty frequently, because even though it looks a little more cryptic,

403
00:20:38,527 --> 00:20:41,400
您可以将更多功能打包到这一行代码中
you can pack more features into that one line of code

404
00:20:41,400 --> 00:20:43,510
在这些分号之间，如果可以的话。
in between those semicolons, if you will.

405
00:20:43,509 --> 00:20:47,069
同样的逻辑，它只是打印出这个“你好，世界”
So same exact logic, it just prints out this "hello, world"

406
00:20:47,069 --> 00:20:49,589
使用for循环代替3次。
three times using a for loop instead.

407
00:20:49,589 --> 00:20:54,179
现在，在Python中，事情开始变得有些优雅。
In Python, things start to get a little elegant here now.

408
00:20:54,180 --> 00:20:57,210
乍一看有点奇怪，但绝对更加简洁。
It's a little weird at first glance, but it's definitely more succinct.

409
00:20:57,210 --> 00:21:01,320
如果您想做三遍，可以在Python中找到
If you want to do something three times, it turns out in Python

410
00:21:01,319 --> 00:21:05,279
您可以为for循环使用更简洁的语法-对于我
you can use a more succinct syntax for the for loop-- for i

411
00:21:05,279 --> 00:21:09,429
，然后放在方括号中的是值列表。
in, and then in square brackets a list of values.

412
00:21:09,430 --> 00:21:13,110
就像我们过去在不同地方使用方括号一样
So just as we used in the past square brackets in a few different places

413
00:21:13,109 --> 00:21:18,119
在Python的世界中，无论何时表示数组并索引到数组
to connote arrays and indexing into arrays, in the world of Python whenever

414
00:21:18,119 --> 00:21:22,769
您围绕一堆价值观，而价值观本身之间用逗号隔开，
you surround a bunch of values that themselves have commas in between them,

415
00:21:22,769 --> 00:21:26,637
然后用方括号将它们全部封装起来，
and you encapsulate them all using square brackets,

416
00:21:26,637 --> 00:21:28,679
这就是我们将在Python中称为列表的内容。
that's what we're going to call in Python a list.

417
00:21:28,680 --> 00:21:30,900
而且它在本质上与数组非常相似，
And it's very similar in spirit to an array,

418
00:21:30,900 --> 00:21:33,490
但我们将在Python上下文中将其称为列表。
but we'll call it in the context of Python a list.

419
00:21:33,490 --> 00:21:38,250
所以这行代码说的是，对于i in 0，1，2--这意味着什么？
And so what this line of code says is, for i in 0, 1, 2-- what does that mean?

420
00:21:38,250 --> 00:21:42,660
这是Python中的for循环，它说给我一个变量i。
This is a for loop in Python that says, give me a variable called i.

421
00:21:42,660 --> 00:21:45,780
并且在此循环的第一次迭代中，将i设为0。
And on the first iteration of this loop set i equal to 0.

422
00:21:45,779 --> 00:21:48,269
在此循环的第二次迭代中，i等于1。
On the second iteration of this loop set i equal to 1.

423
00:21:48,269 --> 00:21:51,659
在此循环的最后一次迭代中，为我设置i等于2。
And on the last iteration of this loop, set i equal to 2 for me.

424
00:21:51,660 --> 00:21:53,583
它只是为您完成所有这些工作。
It just does all of that for you.

425
00:21:53,583 --> 00:21:55,500
现在，实际上一天结束时
Now, at the end of the day it actually doesn't

426
00:21:55,500 --> 00:21:59,549
不管我本身是什么，因为我没有打印i的值。
matter what i is per se, because I'm not printing the value of i.

427
00:21:59,549 --> 00:22:00,549
那完全没问题。
And that's totally fine.

428
00:22:00,549 --> 00:22:03,507
奇怪的是，您已经习惯了一次又一次地做某事的循环，
Odds are you've used for loops where you did something again and again,

429
00:22:03,508 --> 00:22:06,120
就像打印“你好，世界”一样，即使你没有打印出来
like printing "hello, world," even though you didn't print out

430
00:22:06,119 --> 00:22:07,319
i的价值
the value of i.

431
00:22:07,319 --> 00:22:10,599
所以从技术上讲，我可以将任何3件事放在方括号中
So technically, I could have put any 3 things in the square brackets

432
00:22:10,599 --> 00:22:11,099
如果我想要的话。
if I want.

433
00:22:11,099 --> 00:22:15,449
但是约定只是枚举，就像在C，0、1、2中一样
But the convention would be just enumerate, just like in C, 0, 1, 2,

434
00:22:15,450 --> 00:22:18,330
就像计算机科学家从0开始计数一样。
just like a computer scientist counting from 0.

435
00:22:18,329 --> 00:22:22,529
但这很容易分解。
But this could break down pretty easily.

436
00:22:22,529 --> 00:22:25,499
这可能很快变得非常丑陋。
This could become very ugly very quickly.

437
00:22:25,500 --> 00:22:29,519
有人看到Python中的for循环有问题吗
Does anyone see a problem with for loops in Python

438
00:22:29,519 --> 00:22:33,119
如果您必须在这些方括号之间放置值列表
if you have to put in between those square brackets the list of values

439
00:22:33,119 --> 00:22:36,059
您想遍历吗？
that you want to iterate over?

440
00:22:36,059 --> 00:22:37,109
诺亚？
Noah?

441
00:22:37,109 --> 00:22:40,289
观众：如果您想做某件事，例如50次，
AUDIENCE: If you want to do, for example, a thing 50 times,

442
00:22:40,289 --> 00:22:42,929
您必须写出0、1、2、3、4、5、6。
you'd have to write out 0, 1, 2, 3, 4, 5, 6.

443
00:22:42,930 --> 00:22:43,680
戴维·马兰：是的。
DAVID MALAN: Yeah.

444
00:22:43,680 --> 00:22:45,330
天哪，它很快就会开始显得丑陋。
My God, it would start to look hideous quickly.

445
00:22:45,329 --> 00:22:47,454
提到50很有趣，因为在准备
And it's funny you mention 50, because in preparing

446
00:22:47,454 --> 00:22:51,059
今天的演讲演示，我回到了第0周，
this demonstration for lecture today, I went back to week 0,

447
00:22:51,059 --> 00:22:55,349
实际上在第0周的模拟是要打印出“你好，世界”
when actually the analog in week 0 was to indeed print out "hello, world"

448
00:22:55,349 --> 00:22:56,041
50次。
50 times.

449
00:22:56,041 --> 00:22:57,749
我心想，该死的，这是
And I thought to myself, damn it, this is

450
00:22:57,750 --> 00:22:59,910
现在看起来很残酷，因为我从字面上看
going to look atrocious now, because I literally

451
00:22:59,910 --> 00:23:03,960
必须放在方括号内0、1、2、3、4、5、6、7、8
have to put inside of square brackets 0, 1, 2, 3, 4, 5, 6, 7, 8,

452
00:23:03,960 --> 00:23:07,807
从9到49，就像诺亚所说的那样，这看起来简直是残酷的。
9, all the way to 49, as Noah says, which would just look atrocious.

453
00:23:07,807 --> 00:23:09,640
就像，肯定有一种更好的方法。
Like, surely there's got to be a better way.

454
00:23:09,640 --> 00:23:10,560
还有。
And there is.

455
00:23:10,559 --> 00:23:12,809
尽管这对于极短的值可能很有吸引力，
While this might be compelling for very short values,

456
00:23:12,809 --> 00:23:14,759
如果需要，Python中有一种更简单的方法
there's a simpler way in Python when you want

457
00:23:14,759 --> 00:23:16,859
做一些事情。
to do something some number of times.

458
00:23:16,859 --> 00:23:21,149
我们可以用这个替换这三个值的列表，
We can replace this list of three values with this,

459
00:23:21,150 --> 00:23:25,350
一个称为范围的函数，它接受输入，即事物的数量
a function called range that takes an input, which is the number of things

460
00:23:25,349 --> 00:23:26,429
你想回来的。
that you want to return.

461
00:23:26,430 --> 00:23:30,540
从本质上讲，传递3这样的输入对您的范围有什么影响，
And essentially, what range will do for you passed an input like 3,

462
00:23:30,539 --> 00:23:35,579
它将自动为您生成三个值（0、1和2）的列表。
it will automatically generate for you a list of three values, 0, 1, and 2.

463
00:23:35,579 --> 00:23:39,359
然后，Python将为您迭代这三个值。
And then Python will iterate over those three values for you.

464
00:23:39,359 --> 00:23:43,169
所以刚才挪亚很关心，如果我现在想重复50次，
So to Noah's concern a moment ago, if I now want to iterate 50 times,

465
00:23:43,170 --> 00:23:45,690
我只是将3更改为50，我没有
I just change the 3 to a 50, I don't have

466
00:23:45,690 --> 00:23:51,300
造成这种疯狂的混乱，包括手动输入的0到49列表，
to create this crazy mess of a manually typed out list of 0 through 49,

467
00:23:51,299 --> 00:23:55,559
当然，这并不是一个设计得很好的程序，
which, of course, would not be a very well designed a program, it would seem,

468
00:23:55,559 --> 00:23:59,709
只是因为它的长度和混乱的机会之类的东西。
just because of the length of it and the opportunity to mess up and the like.

469
00:23:59,710 --> 00:24:04,080
因此，在Python中，如果可能的话，这可能是现在的最Pythonic方式
So in Python, this is perhaps now, if you will, the most Pythonic way

470
00:24:04,079 --> 00:24:05,952
做一些事情。
to do something some number of times.

471
00:24:05,952 --> 00:24:08,369
确实，这是Python社区中的艺术术语。
And indeed, this is a term of art in the Python community.

472
00:24:08,369 --> 00:24:10,769
长话短说，技术人员，程序员，
Long story short, technical people, programmers,

473
00:24:10,769 --> 00:24:12,989
从某种意义上讲，他们倾向于非常虔诚
they tend to be pretty religious in some sense

474
00:24:12,990 --> 00:24:15,420
当谈到做事的“正确方法”时。
when it comes to the "right way" of doing things.

475
00:24:15,420 --> 00:24:18,000
实际上，在Python编程世界中，
And indeed, within the world of Python programming,

476
00:24:18,000 --> 00:24:22,450
很多Python程序员确实有两种意见
a lot of Python programmers do have both opinions

477
00:24:22,450 --> 00:24:26,940
而且还有规范的建议，这些建议决定了您应该如何“做”
but also standardized recommendations that dictate how you "should"

478
00:24:26,940 --> 00:24:28,350
编写Python代码。
write Python code.

479
00:24:28,349 --> 00:24:31,619
像这样的技巧被认为是Pythonic。
And tricks like this are what are considered Pythonic.

480
00:24:31,619 --> 00:24:35,099
如果您正在用引号，取消引号进行Python操作
You are doing something Pythonically if you're doing it the quote, unquote

481
00:24:35,099 --> 00:24:37,829
“正确的方法”，这绝对不是正确的，
"right way," which doesn't mean right in the absolute,

482
00:24:37,829 --> 00:24:40,889
就大多数其他人而言，
it means right in the sense that most other people, rather,

483
00:24:40,890 --> 00:24:42,500
在这种意义上同意你的看法。
agree with you in this sense.

484
00:24:42,500 --> 00:24:43,000
好的。
All right.

485
00:24:43,000 --> 00:24:46,500
在开始之前，让我们看一下Python的一些最终功能
Let's see a few final features of Python before we now start

486
00:24:46,500 --> 00:24:48,030
建立我们自己的一些功能。
to build some of our own features.

487
00:24:48,029 --> 00:24:51,701
回想一下，在C语言中，我们拥有整个数据类型列表。
In C, recall, we had this whole list of data types.

488
00:24:51,701 --> 00:24:54,159
当然，还有更多，您可以创建自己的。
And there are more, and you can create your own, of course.

489
00:24:54,160 --> 00:24:56,100
但是我们最初看过的原语
But the primitives that we looked at initially

490
00:24:56,099 --> 00:25:00,689
是这些-bool，char，double，float，int，long，string等。
were these-- bool, char, double, float, int, long, string, and so forth.

491
00:25:00,690 --> 00:25:04,290
在Python中，即使我不需要它们，
In Python, even though I haven't needed them,

492
00:25:04,289 --> 00:25:08,609
因为我可以给自己一个像字符串或整数这样的变量，
because I can give myself a variable like a string or an int,

493
00:25:08,609 --> 00:25:13,379
只要给它起一个名字，例如counter或i或answer，
just by giving it a name like counter or i or answer,

494
00:25:13,380 --> 00:25:15,300
然后为它分配一个值，然后使用Python
and then assigning it a value, and Python

495
00:25:15,299 --> 00:25:18,479
从您为其分配的内容中推断出应该为哪种数据类型，
infers from what you're assigning it what data type it should be,

496
00:25:18,480 --> 00:25:20,040
Python确实有数据类型。
Python does have data types.

497
00:25:20,039 --> 00:25:21,959
这就是编程中所知道的
It's just what's known in the programming

498
00:25:21,960 --> 00:25:24,390
世界是一种松散的语言。
world as a loosely typed language.

499
00:25:24,390 --> 00:25:28,560
在C语言世界中，C是一种强类型语言，
In the world of C, C is a strongly typed language,

500
00:25:28,559 --> 00:25:32,759
在哪里，不仅存在类型，还必须显式地使用它们。
where, not only do types exist, you must use them explicitly.

501
00:25:32,759 --> 00:25:34,919
在Python的世界中，您拥有所谓的
In the world of Python, you have what's called

502
00:25:34,920 --> 00:25:39,960
一种存在类型的松散类型语言，
a loosely typed language, in which types exist,

503
00:25:39,960 --> 00:25:43,380
但您通常可以隐式推断它们。
but you can often infer them implicitly.

504
00:25:43,380 --> 00:25:46,770
负担不是由程序员来指定的
The burden is not on you the programmer to specify

505
00:25:46,769 --> 00:25:48,479
这些数据类型不断。
those data types incessantly.

506
00:25:48,480 --> 00:25:50,740
让计算机为您解决。
Let the computer figure it out for you.

507
00:25:50,740 --> 00:25:52,950
这是我们C的清单。
So this is our list from C.

508
00:25:52,950 --> 00:25:56,790
现在，这将成为我们在Python世界中的类似列表。
This now is going to be our analogous list in the world of Python.

509
00:25:56,789 --> 00:25:59,229
我们将仍然布尔，对与错，
We're going to have bool still, True and False,

510
00:25:59,230 --> 00:26:01,470
但是大写字母T，大写字母F。我们将要有浮存金，
but capital T, capital F. We're going to have floats,

511
00:26:01,470 --> 00:26:03,210
是带小数点的实数。
which are real numbers with decimal points.

512
00:26:03,210 --> 00:26:06,127
我们将要有整数，当然是负1这样的数字
We're going to have ints, which of course are numbers like negative 1,

513
00:26:06,126 --> 00:26:07,599
0和1，依此类推。
0, and 1, and so forth.

514
00:26:07,599 --> 00:26:10,949
然后，字符串本身不是字符串，而是“ stirs”。
And then not strings per se, but "stirs", S-T-R.

515
00:26:10,950 --> 00:26:15,930
在C语言的世界里，从技术上讲，没有“字符串类型”
And where is in the world of C, there was technically no "string type"--

516
00:26:15,930 --> 00:26:20,010
这是cs50库提供的功能，它使更多内容
that was a feature offered by the cs50 library, which just made more

517
00:26:20,009 --> 00:26:22,619
可以使用char明星的想法-
accessible the idea of a char star--

518
00:26:22,619 --> 00:26:24,449
回想一下C有字符串。
recall that C has strings.

519
00:26:24,450 --> 00:26:27,630
它们被称为字符串，但是没有称为字符串的数据类型。
And they're called strings, but there's no data type called string.

520
00:26:27,630 --> 00:26:29,910
您给自己一个字符串的方式，当然是在C语言中
The way you give yourself a string, of course, in C

521
00:26:29,910 --> 00:26:31,890
是要宣布某人为char星。
is to declare something as a char star.

522
00:26:31,890 --> 00:26:34,650
在CS50的资料库中，我们给了那个char星
And in cs50's library, we just gave that char star

523
00:26:34,650 --> 00:26:37,620
别名，昵称，别名，称为“字符串”。
a synonym, a nickname, an alias, called "string."

524
00:26:37,619 --> 00:26:40,429
在Python中，有实际的-
In Python, there are actual--

525
00:26:40,430 --> 00:26:42,560
字符串有实际的数据类型。
there is an actual data type for strings.

526
00:26:42,559 --> 00:26:45,999
简称为STR。
And for short, it's called S-T-R.

527
00:26:46,000 --> 00:26:46,500
好的。
All right.

528
00:26:46,500 --> 00:26:49,549
这么说，我们还有哪些其他功能
So with that said, what other features do we

529
00:26:49,549 --> 00:26:51,659
我们可以在这里使用Python吗？
have from Python that we can use here?

530
00:26:51,660 --> 00:26:53,690
嗯，还有其他数据类型
Well, there's other data types as well in

531
00:26:53,690 --> 00:26:57,050
开始时实际上将证明超级有用的Python
Python that are actually going to prove super useful as we begin

532
00:26:57,049 --> 00:26:59,209
开发更复杂的程序并做
to develop more sophisticated programs and do

533
00:26:59,210 --> 00:27:00,980
语言甚至更酷的东西。
even cooler things with the language.

534
00:27:00,980 --> 00:27:02,570
我们已经看到了范围。
We've seen range already.

535
00:27:02,569 --> 00:27:05,959
严格来说，这是Python中的一种数据类型
Strictly speaking, this is a data type of sorts within Python

536
00:27:05,960 --> 00:27:09,560
会给您返回一系列值，默认情况下为0，
that gives you back a range of values, by default 0 on up,

537
00:27:09,559 --> 00:27:10,969
根据您提供的输入。
based on the input you provide.

538
00:27:10,970 --> 00:27:12,860
清单，我一直在口头提及。
List, I keep mentioning verbally.

539
00:27:12,859 --> 00:27:18,919
列表是Python中合适的数据类型，其本质类似于数组。
A list is a proper data type in Python that's similar in spirit to arrays.

540
00:27:18,920 --> 00:27:20,300
但是在数组中
But whereas in arrays--

541
00:27:20,299 --> 00:27:23,389
回想一下，过去几周我们一直非常重视
recall, we've spent great emphasis over the past few weeks

542
00:27:23,390 --> 00:27:25,970
注意数组是固定大小的。
noting that arrays are a fixed size.

543
00:27:25,970 --> 00:27:28,960
您必须预先确定该阵列的大小。
You have to decide in advance how big that array is going to be.

544
00:27:28,960 --> 00:27:31,940
就像上周一样，如果您决定，哎呀，我需要更多的内存，
And like last week, if you decide, oops, I need more memory,

545
00:27:31,940 --> 00:27:34,260
您必须为其动态分配更多空间，
you have to dynamically allocate more space for it,

546
00:27:34,259 --> 00:27:36,829
复制值，然后释放旧的内存。
copy values over, and then free up the old memory.

547
00:27:36,829 --> 00:27:39,739
就像，有这么多跳铁圈，可以这么说，
Like, there's so much jumping through hoops, so to speak,

548
00:27:39,740 --> 00:27:44,030
当您想要在C中使用数组时，如果想要增大它们甚至缩小它们。
when you want to use arrays in C if you want to grow them or even shrink them.

549
00:27:44,029 --> 00:27:49,169
Python和其他类似的高级语言为您完成了所有这些工作。
Python and other higher-level languages like it do all of that for you.

550
00:27:49,170 --> 00:27:53,330
因此，列表就像一个自动调整自身大小的数组，
So a list is like an array that automatically resizes itself,

551
00:27:53,329 --> 00:27:54,499
越来越大。
bigger and smaller.

552
00:27:54,500 --> 00:27:57,350
现在，可以免费获得该功能的语言版本。
That feature now you get for free in the language, so to speak.

553
00:27:57,349 --> 00:27:59,239
您不必自己实施。
You don't have to implement it yourself.

554
00:27:59,240 --> 00:28:00,860
Python具有所谓的元组。
Python has what are called tuples.

555
00:28:00,859 --> 00:28:03,529
在数学或GPS等环境中，您可能
In the context of like math, or GPS, you might

556
00:28:03,529 --> 00:28:06,499
具有x和y坐标或纬度和经度坐标，
have x- and y-coordinates, or latitude and longitude coordinates,

557
00:28:06,500 --> 00:28:08,270
就像逗号分隔的值一样。
so like comma separated values.

558
00:28:08,269 --> 00:28:11,509
元组是用Python实现的一种方法。
Tuples are one way of implementing those in Python.

559
00:28:11,509 --> 00:28:13,219
字典或字典。
Dict, or dictionaries.

560
00:28:13,220 --> 00:28:17,690
因此，Python具有允许您存储键和值的字典。
So Python has dictionaries that allow you to store keys and values.

561
00:28:17,690 --> 00:28:21,150
或者从字面上看，在我们的人类世界中，如果您在这里拥有人类词典，
Or literally in our human world, if you have a human dictionary here,

562
00:28:21,150 --> 00:28:24,650
例如英语，很像物理形式的字典，
for instance for English, much like a dictionary in physical form,

563
00:28:24,650 --> 00:28:29,450
可让您存储单词及其定义，Python中的字典，
lets you store words and their definitions, a dictionary in Python,

564
00:28:29,450 --> 00:28:33,350
更一般而言，可让您存储任何键和任何值。
more generally, lets you store any keys and any values.

565
00:28:33,349 --> 00:28:35,539
您可以将一件事与另一件事相关联。
You can associate one thing with another.

566
00:28:35,539 --> 00:28:39,154
我们将看到这是一个非常有用且用途广泛的数据结构。
And we'll see that this is a wonderfully useful and versatile data structure.

567
00:28:39,154 --> 00:28:41,029
最后，出于今天的目的，
And then lastly for today's purposes, there's

568
00:28:41,029 --> 00:28:44,089
这些东西叫做集合，如果你从数学上回想起，
these things called sets which, if you recall from math,

569
00:28:44,089 --> 00:28:49,099
集合是值的集合，例如a，b，c或1、2、3，没有重复项。
a set is a collection of values, like a, b, c or 1, 2, 3, without duplicates.

570
00:28:49,099 --> 00:28:50,809
但是Python为您管理。
But Python manages that for you.

571
00:28:50,809 --> 00:28:54,049
您可以将项目添加到集合中，也可以从集合中删除项目。
You can add items to a set, you can remove items from a set.

572
00:28:54,049 --> 00:28:57,109
Python将确保您没有重复项，
Python will make sure that there are no duplicates for you,

573
00:28:57,109 --> 00:29:01,229
并且它将为您管理所有内存。
and it will manage all of the memory for you as well.

574
00:29:01,230 --> 00:29:06,920
因此，与此同时，我们在功能方面所拥有的只是一些熟悉的朋友。
So what we have in the way of functions, meanwhile, is a few familiar friends.

575
00:29:06,920 --> 00:29:10,910
回想一下，在C语言中，我们使用了CS50库来获取字符，
Recall that in C we used the cs50 library to get chars,

576
00:29:10,910 --> 00:29:13,430
双打，浮点数，整数，多头和字符串。
doubles, floats, ints, longs, and strings.

577
00:29:13,430 --> 00:29:17,330
幸运的是，在Python中，我们不必担心双精度或多长时间。
In Python, thankfully, we don't have to worry about doubles or longs anymore.

578
00:29:17,329 --> 00:29:18,449
一点点更多。
More on that in a bit.

579
00:29:18,450 --> 00:29:23,000
但是几分钟前您看到我导入了Python的cs50库，
But the cs50 library for Python, which you saw me import a few minutes ago,

580
00:29:23,000 --> 00:29:25,040
确实为您提供了一个名为get_float的函数。
does give you a function called get_float.

581
00:29:25,039 --> 00:29:26,959
它确实为您提供了一个名为get_int的函数，
It does give you a function called get_int,

582
00:29:26,960 --> 00:29:29,110
它确实为您提供了一个名为get_string的函数，
it does give you a function called get_string,

583
00:29:29,109 --> 00:29:31,279
至少就本周而言，这仅仅是
that, at least for this week's purposes, are just

584
00:29:31,279 --> 00:29:32,719
将使您的生活更轻松。
going to make your life easier.

585
00:29:32,720 --> 00:29:36,140
这两个是训练轮，我们将很快将其起飞
These two are training wheels that we will very quickly take off

586
00:29:36,140 --> 00:29:39,800
这样您最终只会使用本机Python代码，
so that you're only using native Python code ultimately,

587
00:29:39,799 --> 00:29:41,719
而不是CS50自己的库。
and not CS50'S own library.

588
00:29:41,720 --> 00:29:44,750
但是为了本周从C过渡到Python，
But for the sake of transitioning this week from C to Python,

589
00:29:44,750 --> 00:29:48,589
您会发现这些会让我们放松之前的生活变得更轻松
you'll find that these will just make your life easier before we relax

590
00:29:48,589 --> 00:29:52,019
并把它们拿走。
and take those away, too.

591
00:29:52,019 --> 00:29:56,419
因此，在C语言中，要使用该库，您必须包含cs50.h。
So in C, to use the library you had to include cs50.h.

592
00:29:56,420 --> 00:29:58,860
在Python中，您将再次继续导入
In Python, again you're going to go ahead and import

593
00:29:58,859 --> 00:30:03,619
cs50，或更明确地讲，您可能要导入的特定功能。
cs50, or more explicitly, the specific function that you might want to import.

594
00:30:03,619 --> 00:30:06,019
事实证明，有多种导入方法。
So it turns out there's different ways to import things.

595
00:30:06,019 --> 00:30:08,839
他们最终实现了基本相同的目标。
They ultimately achieve essentially the same goal.

596
00:30:08,839 --> 00:30:11,329
您可以使用类似这样的行来显式
You can, with lines like this, explicitly

597
00:30:11,329 --> 00:30:15,639
一次导入一个函数，就像我之前使用get_string所做的一样，
import one function at a time, like I did earlier using get_string,

598
00:30:15,640 --> 00:30:18,290
或者您可以一次导入整个库
or you can import the whole library all at once

599
00:30:18,289 --> 00:30:21,184
简而言之，导入cs50。
by just saying more succinctly, import cs50.

600
00:30:21,184 --> 00:30:24,199
这将影响我们此后必须使用的语法，
It's going to affect the syntax we have to use hereafter,

601
00:30:24,200 --> 00:30:28,530
但您会在此处的示例中看到执行此操作的多种方法。
but you'll see multiple ways of doing this in our examples here on out.

602
00:30:28,529 --> 00:30:30,349
您也可以简化一下，然后
You can also simplify this a bit, and you

603
00:30:30,349 --> 00:30:35,899
可以从像我们这样的库中导入以逗号分隔的函数列表。
can import a comma separated list of functions from a library like ours.

604
00:30:35,900 --> 00:30:38,810
这是一个惯例，我们也会经常看到。
And this is a convention we'll see quite frequently as well.

605
00:30:38,809 --> 00:30:43,129
因为如果我们开始使用流行的第三方库编写
Because if we start using popular third-party libraries written

606
00:30:43,130 --> 00:30:46,130
通过互联网上的其他程序员，他们通常会
by other programmers on the internet, they will very commonly

607
00:30:46,130 --> 00:30:48,830
给我们很多我们可以使用的功能，
give us lots of functions that we ourselves can use,

608
00:30:48,829 --> 00:30:52,489
我们将能够一个接一个地导入这些文件，
and we will be able to import those one after the other,

609
00:30:52,490 --> 00:30:56,080
通过以这种方式在此处指定它们。
by just specifying them here in this way.

610
00:30:56,079 --> 00:30:56,579
好的。
All right.

611
00:30:56,579 --> 00:31:01,939
让我在这里暂停一下，看看是否对Python语法有任何疑问。
Let me pause here just to see if there's any questions on Python syntax.

612
00:31:01,940 --> 00:31:06,080
就像，对于我们的Python语法速成班来说，基本上就是这样。
Like, that's essentially it for our crash course in Python syntax.

613
00:31:06,079 --> 00:31:10,134
现在，我们将开始构建事物并探索Python的功能
We're now going to start building things and explore what the features of Python

614
00:31:10,134 --> 00:31:13,009
是，有些细微差别是什么，实际上是Python的功能。
are and what some of the nuances are, and really the power of Python.

615
00:31:13,009 --> 00:31:17,889
但是首先，对语法有任何疑问吗？
But first, any questions on syntax?

616
00:31:17,890 --> 00:31:20,980
我们已经看到了循环，条件，变量。
We've seen loops, conditions, variables.

617
00:31:20,980 --> 00:31:25,220
奥利维亚（Olivia），问题或评论。
Olivia, question or comment.

618
00:31:25,220 --> 00:31:28,880
听众：在for循环中，如果您想增加1以外的值，
AUDIENCE: In a for loop, if you want to increment by something besides 1,

619
00:31:28,880 --> 00:31:32,843
但是您不想显式地键入列表，您将如何处理？
but you don't want to explicitly type out the list, how would you do that?

620
00:31:32,843 --> 00:31:34,260
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

621
00:31:34,259 --> 00:31:39,149
因此，如果您想使用for循环并在一系列值上进行迭代，
So if you wanted to use a for loop and iterate over a range of values,

622
00:31:39,150 --> 00:31:46,070
但您希望该范围为0、2、4、6、8，而不是0、1、2、3，
but you wanted that range to be 0, 2, 4, 6, 8, instead of 0, 1, 2, 3,

623
00:31:46,069 --> 00:31:48,979
让我继续，回到刚才的幻灯片。
let me go ahead and go back to that slide from a moment ago.

624
00:31:48,980 --> 00:31:51,710
实际上，我可以即时更改此设置。
And I can actually change this on the fly.

625
00:31:51,710 --> 00:31:54,840
让我进入这张幻灯片。
Let me go into that slide, which was right here.

626
00:31:54,839 --> 00:31:59,629
实际上，我可以做的是指定另一个值，可能是这个。
And what I can do, actually, is specify another value, which might be this.

627
00:31:59,630 --> 00:32:04,790
如果我将输入范围更改为不是一个值而是两个值，
If I change the input to range to be not one value but two values,

628
00:32:04,789 --> 00:32:07,519
这将是计算机的一个线索
that's going to be a clue to the computer

629
00:32:07,519 --> 00:32:10,309
它应该计算总共三个值，
that it should count a total of three values,

630
00:32:10,309 --> 00:32:14,021
但是它应该一次增加2，而不是默认值1。
but it should increment 2 at a time instead of the default, which is 1.

631
00:32:14,021 --> 00:32:15,979
那里甚至还有其他功能。
And there's even other capabilities there, too.

632
00:32:15,980 --> 00:32:17,563
您不必从0开始计数。
You don't have to start counting at 0.

633
00:32:17,563 --> 00:32:20,870
您也可以调整它，也就是说，使用Python，您可以
You can adjust that as well, which is to say that with Python, you're

634
00:32:20,869 --> 00:32:23,629
会发现该语言附带更多功能，
going to find a lot more features come with the language,

635
00:32:23,630 --> 00:32:28,160
甚至更强大的功能，您可以编写
and even more powerfully, the functions that you can write

636
00:32:28,160 --> 00:32:31,010
以及您可以在Python中使用的功能
and the functions that you can use in Python

637
00:32:31,009 --> 00:32:34,219
也可以采用不同数量的参数。
also can take different numbers of arguments.

638
00:32:34,220 --> 00:32:36,830
有时为0，有时为1，有时为2。
Sometimes it's 0, sometimes it's 1, sometimes it's 2.

639
00:32:36,829 --> 00:32:40,309
但这最终往往取决于您。
But it's ultimately often up to you.

640
00:32:40,309 --> 00:32:40,819
接得好。
Good catch.

641
00:32:40,819 --> 00:32:42,019
还有其他问题吗？
Other questions?

642
00:32:42,019 --> 00:32:45,859
听众：我们会主要在for循环中看到序列吗？
AUDIENCE: Will we see sequences primarily in the for loops?

643
00:32:45,859 --> 00:32:48,619
还是还有其他非常有用的应用程序？
Or are there other applications where they're very useful?

644
00:32:48,619 --> 00:32:50,161
DAVID MALAN：序列的含义是什么？
DAVID MALAN: Sequences in what sense?

645
00:32:50,162 --> 00:32:53,030
在范围或列表的意义上还是其他？
In the sense of ranges or lists or something else?

646
00:32:53,029 --> 00:32:55,534
听众：是的，特别是在范围上。
AUDIENCE: Yeah, in terms of ranges, specifically.

647
00:32:55,535 --> 00:32:56,660
戴维·马兰：好的问题。
DAVID MALAN: Good question.

648
00:32:56,660 --> 00:32:58,118
我们会在其他情况下使用它们吗？
Will we use them in other contexts?

649
00:32:58,117 --> 00:33:01,109
一般来说，这是非常罕见的。
Generally speaking, it's pretty rare.

650
00:33:01,109 --> 00:33:04,249
我的意思是，我现在正在为其他用例而绞尽脑汁
I mean, I'm racking my brain now as to other use cases

651
00:33:04,250 --> 00:33:06,257
我用过的范围。
that I have used range for.

652
00:33:06,257 --> 00:33:08,090
而且我确信我可以提出一些建议。
And I'm sure I could come up with something.

653
00:33:08,089 --> 00:33:12,049
但是我认为，最常见的情况是在迭代的背景下，
But I think hands down, the most common case is in the context of iteration,

654
00:33:12,049 --> 00:33:13,307
如在for循环中。
as in a for loop.

655
00:33:13,307 --> 00:33:15,349
我会考虑使用它来查看其他应用程序。
And I'll think on that to see other applications.

656
00:33:15,349 --> 00:33:18,109
但是任何时候您想要生成一长串值
But any time you want to generate a long list of values

657
00:33:18,109 --> 00:33:21,949
遵循某种模式，无论是0、1、2还是Olivia指出，
that follow some pattern, whether it's 0, 1, 2, or as Olivia points out,

658
00:33:21,950 --> 00:33:24,650
一定范围内的值与范围，范围将允许
a range of values with gaps, range will allow

659
00:33:24,650 --> 00:33:26,870
您可以避免完全对其进行硬编码。
you to avoid having to hardcode it entirely.

660
00:33:26,869 --> 00:33:29,839
实际上，您可以编写自己的生成器函数，可以这么说，
And you can actually write your own generator function, so to speak,

661
00:33:29,839 --> 00:33:34,259
返回所需值的任何模式的函数。
a function that returns whatever pattern of values that you want.

662
00:33:34,259 --> 00:33:36,869
还有其他疑问或困惑吗？
Other questions or confusion?

663
00:33:39,609 --> 00:33:43,899
Brian，无论您是聊天还是其他人，对您有好处吗？
Anything on your end, Brian, from the chat or beyond?

664
00:33:43,900 --> 00:33:46,150
布莱恩：看来所有问题都在这里回答了。
BRIAN: Looks like all the questions are answered here.

665
00:33:46,150 --> 00:33:46,850
戴维·马兰：好的。
DAVID MALAN: All right.

666
00:33:46,849 --> 00:33:48,819
好吧，让我们继续吧，做一些更有趣的事情
Well, let's go ahead now and do something more interesting

667
00:33:48,819 --> 00:33:49,569
比你好，世界。
than hello, world.

668
00:33:49,569 --> 00:33:52,659
因为毕竟这是编程真正有趣的地方，
Because after all, this is where programming really gets fun,

669
00:33:52,660 --> 00:33:55,810
当你和我不再
really gets powerful, when you and I no longer

670
00:33:55,809 --> 00:33:59,049
必须在何时实施这些低级实施细节
have to implement those low-level implementation details, when

671
00:33:59,049 --> 00:34:02,379
您必须为哈希表实现内存管理，
you had to implement memory management for your hash table,

672
00:34:02,380 --> 00:34:06,040
或用于链表的内存管理，或在数组中复制值。
or memory management for a linked list, or copying values in an array.

673
00:34:06,039 --> 00:34:08,499
在过去的几周中，我们专注于
We've spent the past several weeks focusing really

674
00:34:08,500 --> 00:34:12,069
在一些有助于理解的低级基元上，
on some low-level primitives that are useful to understand,

675
00:34:12,070 --> 00:34:13,989
但是他们写的不好玩。
but they're not fun to write.

676
00:34:13,989 --> 00:34:17,322
我也承认，以问题集的形式写书可能并不有趣。
And I concede that they might not be fun to write in problem set form.

677
00:34:17,322 --> 00:34:20,530
在以后的生活中，写作肯定不会很有趣，
And they're certainly not going to be fun to write for the rest of your life,

678
00:34:20,530 --> 00:34:23,219
每次您只想编写代码来解决一些问题。
every time you want to just write code to solve some problem.

679
00:34:23,219 --> 00:34:24,969
但是，那又是库进入的地方。
But again, that's where libraries come in.

680
00:34:24,969 --> 00:34:27,159
现在，这就是其他语言的用武之地。
And now, this is where other languages come in.

681
00:34:27,159 --> 00:34:31,900
事实证明，Python更好，更简单
It turns out that Python is a much better, a much easier

682
00:34:31,900 --> 00:34:35,080
用于解决某些类型问题的语言，
language to use for solving certain types of problems,

683
00:34:35,079 --> 00:34:39,198
其中有一些我们在过去的习题集中一直在解决的问题。
among them some of the problems we have been solving in past problems sets.

684
00:34:39,199 --> 00:34:41,750
因此，实际上，让我继续执行此操作。
So in fact, let me go ahead and do this.

685
00:34:41,750 --> 00:34:46,030
我要继续在这里抓文件-
I'm going to go ahead and grab a file here--

686
00:34:46,030 --> 00:34:47,710
给我片刻-
give me one moment--

687
00:34:47,710 --> 00:34:52,389
名为bridge.bmp，您可能会从过去的问题集中回忆起它。
called bridge.bmp, which you might recall from a past problem set.

688
00:34:52,389 --> 00:34:56,500
这是马萨诸塞州剑桥市查尔斯河旁美丽的Weeks桥
This is the beautiful Weeks bridge down by the Charles River in Cambridge, Mass

689
00:34:56,500 --> 00:34:57,160
由哈佛。
by Harvard.

690
00:34:57,159 --> 00:35:00,429
这是CS50的一名团队成员拍摄的非常清晰的照片。
And this is a very clear photograph taken by one of CS50's team members.

691
00:35:00,429 --> 00:35:02,589
当然，最近几周，您编写了代码
And in recent weeks, of course, you wrote code

692
00:35:02,590 --> 00:35:06,850
进行此图像的各种变异，其中包括使图像模糊。
to do all sorts of mutations of this image, among them blurring the image.

693
00:35:06,849 --> 00:35:10,509
我敢说，模糊不是最容易解决的问题。
And blur, I dare say, was not the easiest problem to solve.

694
00:35:10,510 --> 00:35:13,240
您必须向上，向下，向左和向右查找平均值
You had to look up, down, left, and right, sort of average

695
00:35:13,239 --> 00:35:14,079
所有这些像素。
all of those pixels.

696
00:35:14,079 --> 00:35:17,299
您必须了解如何一次将图像表示为一个像素。
You had to understand how an image is represented one pixel at a time.

697
00:35:17,300 --> 00:35:20,300
所以那里有很多低级细节，当一天结束时，
So there's a lot of low-level minutia there, when at the end of the day,

698
00:35:20,300 --> 00:35:22,600
您要做的只是模糊图像。
all you want to do is just blur an image.

699
00:35:22,599 --> 00:35:26,739
因此，在过去的几周中，我们不得不思考并写在较低的水平
So whereas in past weeks we sort of had to think at and write at this lower

700
00:35:26,739 --> 00:35:29,769
级别，现在有了Python，事实证明我们
level, now with Python it turns out we're

701
00:35:29,769 --> 00:35:33,069
将有能力在更高的抽象水平上进行思考
going to have the ability to think at a higher level of abstraction

702
00:35:33,070 --> 00:35:35,328
并为自己编写更少的代码。
and write far less code for ourselves.

703
00:35:35,327 --> 00:35:36,619
因此，让我继续执行此操作。
So let me go ahead and do this.

704
00:35:36,619 --> 00:35:39,429
我将为此使用Mac而不是CS50 IDE，
I'm going to use my Mac for this instead of CS50 IDE,

705
00:35:39,429 --> 00:35:41,581
这样我可以更快地打开图像。
so I can open the images more quickly.

706
00:35:41,581 --> 00:35:43,539
这就是说，即使我们继续
This is to say that, even though we'll continue

707
00:35:43,539 --> 00:35:47,049
将CS50 IDE用于Python和其他语言
using CS50 IDE for Python and for other languages

708
00:35:47,050 --> 00:35:51,220
在本课程的其余部分中，您还可以安装必需的软件
over the remainder of the course, you can also install the requisite software

709
00:35:51,219 --> 00:35:54,879
在Mac，PC上，有时甚至是某种手机上
on a Mac, on a PC, sometimes even kind of sort of a phone

710
00:35:54,880 --> 00:35:59,950
今天，您可以在自己的设备上使用Python并以其他语言进行浏览。
today, to use Python and sort of see, in other languages, on your own devices.

711
00:35:59,949 --> 00:36:02,599
但是再次，我们倾向于在上课时使用CS50 IDE
But again, we tend to CS50 IDE during the class

712
00:36:02,599 --> 00:36:05,207
以便拥有一个可以正常工作的标准环境。
so as to have a standard environment that just works.

713
00:36:05,208 --> 00:36:07,000
所以我要继续写，
So I'm going to go ahead and write, though,

714
00:36:07,000 --> 00:36:11,679
在我的计算机上，当然有一个名为blur.py，py的程序，
on my computer a program called blur.py, py, of course,

715
00:36:11,679 --> 00:36:13,629
是Python程序的文件扩展名。
being the file extension for Python programs.

716
00:36:13,630 --> 00:36:15,460
所以我的程序现在看起来有些不同。
So my program looks a little different now.

717
00:36:15,460 --> 00:36:17,620
我有这个黑色和蓝色和白色的窗户。
I've got this black and blue and white window.

718
00:36:17,619 --> 00:36:21,129
但这只是我个人Mac上的文本编辑器。
But this is just a text editor on my own personal Mac here.

719
00:36:21,130 --> 00:36:22,870
我将继续执行此操作。
I'm going to go ahead and do this.

720
00:36:22,869 --> 00:36:25,869
我需要一些与图像相关的功能
I need to have some functionality related to images

721
00:36:25,869 --> 00:36:27,319
为了使图像模糊。
in order to blur an image.

722
00:36:27,320 --> 00:36:30,370
因此，我将继续从PIL库中进行导入，
So I'm going to go ahead and import from a PIL library,

723
00:36:30,369 --> 00:36:34,479
枕头库，可以这么说，一个特殊功能
a Pillow library, so to speak, a special feature

724
00:36:34,480 --> 00:36:37,510
称为Image，还有一个称为ImageFilter的特殊功能。
called Image and a special feature called ImageFilter.

725
00:36:37,510 --> 00:36:39,970
也就是说，这些本质上是两个功能
That is to say, these are essentially two functions

726
00:36:39,969 --> 00:36:43,359
在图像处理方面，有一个比我聪明的人写道，
that someone else smarter than me when it comes to image manipulation wrote,

727
00:36:43,360 --> 00:36:46,970
他们在互联网上免费和开源地免费提供了他们的代码，
they made their code freely available on the internet free and open source,

728
00:36:46,969 --> 00:36:49,629
这意味着任何人都可以使用该代码，现在我可以了
which means anyone can use the code, and I am allowed now

729
00:36:49,630 --> 00:36:54,190
导入到我的程序中，因为我在上课之前就已经下载并安装了
to import it into my program, because I before class downloaded and installed

730
00:36:54,190 --> 00:36:55,437
它事先。
it beforehand.

731
00:36:55,436 --> 00:36:57,019
现在，我要继续执行此操作。
Now I'm going to go ahead and do this.

732
00:36:57,019 --> 00:36:59,109
我要给自己一个叫做before的变量。
I'm going to give myself a variable called before.

733
00:36:59,110 --> 00:37:03,460
我将在bridge.bmp上调用Image.open。
And I'm going to call Image.open on bridge.bmp.

734
00:37:03,460 --> 00:37:06,700
再说一次，即使我们之前从未见过，也从未使用过，
So again, even though we've never seen this before, never used this before,

735
00:37:06,699 --> 00:37:09,129
您可以从句法上了解发生了什么。
you can kind of glean syntactically what's going on.

736
00:37:09,130 --> 00:37:11,500
我左侧有一个变量，之前曾被调用过。
I've got a variable on the left called before.

737
00:37:11,500 --> 00:37:15,129
我在右边有一个名为Image.open的函数，
I've got a function on the right called Image.open,

738
00:37:15,130 --> 00:37:17,410
我传入的名字是bridge.bmp。
and I'm passing in the name bridge.bmp.

739
00:37:17,409 --> 00:37:21,129
因此，这听起来像是C语言世界中的fopen。
So it sounds like this is kind of like fopen in the world of C.

740
00:37:21,130 --> 00:37:24,430
现在注意，该点在这里起着新的作用。
Now notice, this dot is kind of serving a new role here.

741
00:37:24,429 --> 00:37:29,529
过去，我们仅将运算符用于C中的结构，
In the past, we've used the operator only for structs in C,

742
00:37:29,530 --> 00:37:34,160
当我们想进入一个人对象或一个节点对象时，
when we want to go into a person object, or into a node object,

743
00:37:34,159 --> 00:37:37,419
我们想进入它并在其中访问一些变量。
and we want to go inside of it and access some variable therein.

744
00:37:37,420 --> 00:37:42,310
嗯，事实证明，在Python中，您的精神与结构相似
Well, it turns out in Python, you have things similar in spirit to structs

745
00:37:42,309 --> 00:37:49,779
在C中。但是，不只包含变量或数据，例如名称和数字
in C. But instead of containing only variables or data, like name and number

746
00:37:49,780 --> 00:37:52,780
就像我们几周前对那个人的结构所做的一样，
like we did for the person struct a few weeks back,

747
00:37:52,780 --> 00:37:56,200
在Python中，您可以在结构内部
in Python you can have inside of a structure

748
00:37:56,199 --> 00:37:59,409
不仅是数据，即变量，还可以
not only data, that is variables, you can also

749
00:37:59,409 --> 00:38:01,899
在结构内部具有功能。
have functions inside of structures.

750
00:38:01,900 --> 00:38:05,080
这就开始打开各种可能性
And that starts to open up all sorts of possibilities

751
00:38:05,079 --> 00:38:07,369
就可用功能而言。
in terms of features available to you.

752
00:38:07,369 --> 00:38:13,479
看来我有了这个Image对象，这个Image结构，
So it seems that I've got this Image object, this Image struct that I've,

753
00:38:13,480 --> 00:38:15,040
再次，是从别人那里进口的。
again, imported from someone else.

754
00:38:15,039 --> 00:38:17,709
它的内部是一个期望的开放功能
Inside of it is an open function that expects

755
00:38:17,710 --> 00:38:19,880
输入打开的文件名。
as input the name of a file to open.

756
00:38:19,880 --> 00:38:23,110
因此，在今天的示例过程中，我们将越来越多地看到这种语法。
So we'll see this syntax increasingly over the course of today's examples.

757
00:38:23,110 --> 00:38:25,370
接下来，让我给自己第二个变量。
Let me give myself a second variable, after.

758
00:38:25,369 --> 00:38:27,999
现在让我继续并将其分配给名为
Let me go ahead now and assign to this variable called

759
00:38:28,000 --> 00:38:33,610
在图像的过滤器函数之前调用的结果之后，
after the results of calling that before image's filter function,

760
00:38:33,610 --> 00:38:37,747
传入1的ImageFilter.BoxBlur。
passing in ImageFilter.BoxBlur of 1.

761
00:38:37,746 --> 00:38:39,579
现在，这有点神秘，我们不是
Now, this is a little cryptic, and we're not

762
00:38:39,579 --> 00:38:41,859
将花时间在这种特定的语法上，因为赔率是，
going to spend time on this particular syntax, because odds are,

763
00:38:41,860 --> 00:38:44,100
生活中您不会有太多想要的机会
in life you're not going to have that many opportunities to want

764
00:38:44,099 --> 00:38:46,682
使要运行的图像模糊并编写代码。
to blur an image for which you're going to run and write code.

765
00:38:46,682 --> 00:38:50,699
但是出于今天的目的，请注意，在我的before变量中，
But for today's purposes, notice that inside of my before variable,

766
00:38:50,699 --> 00:38:54,569
因为我为其分配了此新功能的返回值，
because I assigned it the return value of this new feature,

767
00:38:54,570 --> 00:38:59,280
它不仅具有数据而且还具有功能，其中之一
it has inside of it not just data but also functions, one of them

768
00:38:59,280 --> 00:39:00,450
现在称为过滤器。
now called filter.

769
00:39:00,449 --> 00:39:04,859
并且该过滤器函数将其他函数的返回值作为输入
And this filter function takes as input the return value of some other function

770
00:39:04,860 --> 00:39:08,190
长话短说，它将使我的图像模糊
called that, long story short, will blur my image using

771
00:39:08,190 --> 00:39:12,130
半径为1像素的盒子。
a box of a 1-pixel radius.

772
00:39:12,130 --> 00:39:15,210
因此，就像您自己的代码一样，如果您在C语言中实现了模糊处理，
So just like your own code, if you implemented blur in C,

773
00:39:15,210 --> 00:39:18,840
该代码将告诉我的代码向上，向下，向左和向右查找
this code is going to tell my code to look up, down, left, and right

774
00:39:18,840 --> 00:39:23,380
并通过取像素周围的平均值来模糊像素。
and blur the pixels by taking the average around them.

775
00:39:23,380 --> 00:39:24,300
就是这样。
And that's kind of it.

776
00:39:24,300 --> 00:39:26,250
之后，我要执行after.save。
After that I'm going to do after.save.

777
00:39:26,250 --> 00:39:28,500
我将其另存为out.bmp。
And I'm going to save this as out.bmp.

778
00:39:28,500 --> 00:39:30,990
我只想创建一个名为out.bmp的新文件。
I just want to create a new file called out.bmp.

779
00:39:30,989 --> 00:39:33,449
如果我没有犯错，请让我现在继续
And if I've made no mistakes, let me go ahead now

780
00:39:33,449 --> 00:39:37,829
并运行blur.py的python，然后按Enter。
and run python of blur.py and hit Enter.

781
00:39:37,829 --> 00:39:40,199
没有错误消息，因此通常是一件好事。
No error messages, so that's usually a good thing.

782
00:39:40,199 --> 00:39:43,979
如果我现在输入ls，请注意我有bridge.bmp，
If I type ls now, notice that I've got bridge.bmp,

783
00:39:43,980 --> 00:39:48,330
我已经打开过的，刚刚写的blur.py和out.bmp。
which I already opened, blur.py, which I just wrote, and out.bmp.

784
00:39:48,329 --> 00:39:52,859
如果我继续打开open.bmp，让我们继续看看。
And if I go ahead and open out.bmp, let's go ahead and take a look.

785
00:39:52,860 --> 00:39:55,720
这里是之前，这里是之后。
Here's before, here's after.

786
00:39:55,719 --> 00:39:56,219
嗯
Huh.

787
00:39:56,219 --> 00:39:58,609
之前，之后。
Before, after.

788
00:39:58,610 --> 00:40:00,360
现在，通过互联网可能不会
Now, over the internet it probably doesn't

789
00:40:00,360 --> 00:40:03,068
看起来很模糊，尽管在几英寸外的Mac上，
look that blurred, though on my Mac right here a few inches away,

790
00:40:03,068 --> 00:40:04,238
它肯定看起来很模糊。
it definitely looks blurred.

791
00:40:04,237 --> 00:40:06,029
但是，让我们做些更引人注目的事情。
But let's do it a little more compellingly.

792
00:40:06,030 --> 00:40:09,030
怎么样，而不是向上，向下，向左和向右看一个像素，
How about, instead of looking one pixel up, down, left, and right,

793
00:40:09,030 --> 00:40:10,930
为什么我们一次不看10个像素？
why don't we look 10 pixels at a time?

794
00:40:10,929 --> 00:40:15,389
因此，我们通过查看更多的值和更多的平均值来模糊它。
So we really blur it by looking at more values and averaging more.

795
00:40:15,389 --> 00:40:19,019
现在让我继续并运行blur.py的python。
Let me go ahead now and run python of blur.py.

796
00:40:19,019 --> 00:40:20,879
现在让我继续并重新打开。
Now let me go ahead and reopen.

797
00:40:20,880 --> 00:40:24,820
现在您可以看到之前和之后。
And now you see before and after.

798
00:40:24,820 --> 00:40:27,220
之前和之后。
Before and after.

799
00:40:27,219 --> 00:40:28,479
那么这是什么意思呢？
So what is this to say?

800
00:40:28,480 --> 00:40:33,270
好吧，这是在四行代码中使图像模糊的问题集4。
Well, here is, what, problem set 4 in four lines of code blurring an image.

801
00:40:33,269 --> 00:40:34,889
非常酷，非常强大。
So pretty cool, pretty powerful.

802
00:40:34,889 --> 00:40:37,799
通过站在他人的肩膀上并利用他们的图书馆，可以
By standing on the shoulders of others and using their libraries can

803
00:40:37,800 --> 00:40:40,320
我们很快就会做其他事情。
we do other things quite quickly.

804
00:40:40,320 --> 00:40:45,670
注意，我在这里也可以解决最近的问题。
Notice what I can also do here, too, is solve a more recent problem.

805
00:40:45,670 --> 00:40:50,340
让我转到另一个目录，我已经在该目录中了-
Let me go over to a different directory, where I have in advance--

806
00:40:50,340 --> 00:40:53,070
您可以从课程的网站上下载这些文件，
and you can download these files off of the course's website--

807
00:40:53,070 --> 00:40:55,920
我们在上课之前写的一些文件。
a few files that we wrote before class.

808
00:40:55,920 --> 00:40:58,110
一个叫做speller.py。
One is called speller.py.

809
00:40:58,110 --> 00:41:03,090
长话短说，speller.py是C语言的翻译
So long story short, speller.py is a translation from C

810
00:41:03,090 --> 00:41:06,065
到Python中speller.c的代码。
into Python the code for speller.c.

811
00:41:06,065 --> 00:41:08,940
回想一下，这是问题集5的分发代码的一部分。
Recall that that was part of the distribution code for problem set 5,

812
00:41:08,940 --> 00:41:11,910
然后在speller.c中，我们现在将其翻译为speller.py。
and in speller.c, we translated it now to speller.py.

813
00:41:11,909 --> 00:41:15,449
在字典和文字中，我们看到的是相同的文件，
And in dictionaries and in texts, we see the same files,

814
00:41:15,449 --> 00:41:19,199
如习题集5，两个不同大小的字典和一整堆
as in problem set 5, two different sized dictionaries and a whole bunch

815
00:41:19,199 --> 00:41:21,059
短文本和长文本。
of short and long texts.

816
00:41:21,059 --> 00:41:25,499
尚未创建的相当于字典。c，又名
What hasn't been created yet is the equivalent of a dictionary.c, a.k.a.

817
00:41:25,500 --> 00:41:27,540
现在，dictionary.py。
now, dictionary.py.

818
00:41:27,539 --> 00:41:30,239
因此，让我继续并在Python中实现我的拼写检查器。
So let me go ahead and implement my spell checker in Python.

819
00:41:30,239 --> 00:41:34,089
让我继续创建一个名为dictionary.py的文件，同样，
Let me go ahead and create a file called dictionary.py, as is again,

820
00:41:34,090 --> 00:41:34,980
惯例。
the convention.

821
00:41:34,980 --> 00:41:36,218
让我们继续吧。
And let's go ahead.

822
00:41:36,217 --> 00:41:38,009
我们必须实现四个功能，对不对？
We have to implement four functions, right?

823
00:41:38,010 --> 00:41:40,950
我们必须实现检查，加载，大小和卸载。
We have to implement check, load, size, and unload.

824
00:41:40,949 --> 00:41:44,519
但是我可能需要一个全局变量来存储字典。
But I probably need like a global variable here to store my dictionary.

825
00:41:44,519 --> 00:41:47,699
这就是大家都用指针实现哈希表的地方，
And this is where you all implemented your hash table with a pointer,

826
00:41:47,699 --> 00:41:50,934
然后是链表和数组，所有这些都非常复杂。
and then linked lists, and arrays, and all of that, a lot of complexity.

827
00:41:50,934 --> 00:41:54,059
你知道吗，我要继续给自己一个变量，叫做
You know what, I'm just going to go ahead and give myself a variable called

828
00:41:54,059 --> 00:41:56,339
并将其声明为集合。
words and declare it as a set.

829
00:41:56,340 --> 00:41:58,920
所以回想一下，集合只是值的集合
So recall that a set is just a collection of values

830
00:41:58,920 --> 00:42:01,140
为您处理重复项。
that handles duplicates for you.

831
00:42:01,139 --> 00:42:02,819
坦白说，这就是我真正需要的。
And frankly, that's all I really need.

832
00:42:02,820 --> 00:42:05,730
我需要能够将所有单词存储在字典中
I need to be able to store all of the words in a dictionary

833
00:42:05,730 --> 00:42:09,180
并把它们放到一个集合中，这样就不会有重复的值
and just throw them into a set, so that there's no duplicate values

834
00:42:09,179 --> 00:42:13,019
我可以检查一下，是集合中的一个单词还是不是。
and I can just check, is one word in the set or is it not.

835
00:42:13,019 --> 00:42:15,767
好吧，让我们现在继续并将单词加载到该集合中。
Well, let's go ahead now and load words into that set.

836
00:42:15,768 --> 00:42:18,060
我将继续定义一个名为load的函数
I'm going to go ahead and define a function called load

837
00:42:18,059 --> 00:42:20,159
需要打开文件的名称。
that takes the name of a file to open.

838
00:42:20,159 --> 00:42:22,649
诚然，这里有一些新语法。
And here is some admittedly some new syntax.

839
00:42:22,650 --> 00:42:27,760
到目前为止，我们仅在文件本身中键入了代码。
So thus far, we've only typed code into the file itself.

840
00:42:27,760 --> 00:42:30,300
实际上，迄今为止最显着的差异是
In fact, the most striking difference thus far,

841
00:42:30,300 --> 00:42:33,480
敢于说，关于Python与C，是我从来没有
dare say, about Python versus C, is that I have never

842
00:42:33,480 --> 00:42:36,307
甚至曾经写过一个主要功能。
once even written a main function.

843
00:42:36,306 --> 00:42:37,889
这也是Python的功能。
And that, too, is a feature of Python.

844
00:42:37,889 --> 00:42:39,599
如果您要编写程序，则不需要
If you want to write a program, you don't

845
00:42:39,599 --> 00:42:43,199
必须在名为main的函数中编写默认代码。
have to bother writing your default code in a function called main.

846
00:42:43,199 --> 00:42:44,459
只需开始编写代码即可。
Just start writing your code.

847
00:42:44,460 --> 00:42:46,920
这就是我们能够取得世界问候的方式
And that's how we were able to get hello, world

848
00:42:46,920 --> 00:42:50,850
从C语言中的这么多代码行到Python语言中的一行代码。
down from this many lines of code in C to one line in Python.

849
00:42:50,849 --> 00:42:52,529
我们甚至不需要main。
We didn't even need to have main.

850
00:42:52,530 --> 00:42:57,060
但是，如果我想定义自己的函数，事实证明是在Python中，
But if I want to define my own functions, it turns out in Python,

851
00:42:57,059 --> 00:43:01,079
您使用关键字def进行定义，然后输入函数的名称，
you use the key word def for define, then you put the name of the function ,

852
00:43:01,079 --> 00:43:04,679
然后在括号中（如在C中），将变量的名称放入
and then in parentheses, like in C, you put the names of the variables

853
00:43:04,679 --> 00:43:07,259
或您希望函数采用的参数。
or parameters that you want the function to take.

854
00:43:07,260 --> 00:43:09,600
不过，您不必指定数据类型。
You don't have to specify data types, though.

855
00:43:09,599 --> 00:43:13,389
同样，我们不使用花括号，而是使用冒号。
And again, we don't use curly braces, we're instead using a colon.

856
00:43:13,389 --> 00:43:16,979
所以说，嘿，Python，给我一个叫做load的函数
So this says, hey, Python, give me a function called load that

857
00:43:16,980 --> 00:43:19,410
接受一个称为字典的参数。
takes an argument called dictionary.

858
00:43:19,409 --> 00:43:21,249
该功能应该做什么？
And what should this function do?

859
00:43:21,250 --> 00:43:23,669
好吧，拼写器中加载功能的目的
Well, the purpose of the load function in speller

860
00:43:23,670 --> 00:43:25,650
是要从字典中加载每个单词
was to load each word from the dictionary

861
00:43:25,650 --> 00:43:27,517
并以某种方式将其放入您的哈希表中。
and somehow put it into your hash table.

862
00:43:27,516 --> 00:43:30,599
我将继续进行相同的操作-从字典中读取每个单词
I'm going to go ahead and do the same-- read each word from the dictionary

863
00:43:30,599 --> 00:43:33,751
并将其放入这个所谓的集合中，我的变量称为单词。
and put it into this so-called set, my variable called words.

864
00:43:33,751 --> 00:43:36,959
因此，我将继续打开文件，我可以使用此功能
So I'm going to go ahead and open the file, which I can do with this function

865
00:43:36,960 --> 00:43:37,590
这里。
here.

866
00:43:37,590 --> 00:43:39,730
在Python中，您不使用fopen。
In Python, you don't use fopen.

867
00:43:39,730 --> 00:43:41,490
您只需使用一个称为open的函数。
You just use a function called open.

868
00:43:41,489 --> 00:43:45,629
我将把open的返回值签名到一个名为file的变量中。
And I'm going to sign the return value of open to a variable called file.

869
00:43:45,630 --> 00:43:47,790
但是我可以说任何我想要的东西。
But I could call that anything I want.

870
00:43:47,789 --> 00:43:49,709
这就是Python真正酷的地方。
This is where Python gets really cool.

871
00:43:49,710 --> 00:43:52,560
回想一下从Python中读到的代码-
Recall that reading the lines from Python--

872
00:43:52,559 --> 00:43:55,919
从C中的文件有点辛苦吧？
from the file in C was kind of arduous, right?

873
00:43:55,920 --> 00:43:59,790
您必须使用fread或其他功能
You had to use fread or some other function

874
00:43:59,789 --> 00:44:02,249
为了阅读一个又一个字符
in order to read character after character

875
00:44:02,250 --> 00:44:04,231
字符之后，一次一行。
after character, one line at a time.

876
00:44:04,231 --> 00:44:05,939
好吧，在Python中，如果我知道
Well, here in Python, you know what, if I

877
00:44:05,940 --> 00:44:08,280
要遍历文件中的所有行，
want to iterate over all the lines in the file,

878
00:44:08,280 --> 00:44:10,770
我们只说文件中的一行。
we'll just say for line in file.

879
00:44:10,769 --> 00:44:15,719
这将自动给我一个for循环，
This is going to automatically give me a for loop that

880
00:44:15,719 --> 00:44:22,049
为我将变量行分配给文件中的每个连续行。
assigns the variable line to each successive line in the file for me.

881
00:44:22,050 --> 00:44:25,140
它将找出所有这些行的位置。
It will figure out where all of those lines are.

882
00:44:25,139 --> 00:44:27,209
我想对每一行做什么？
What do I want to do with each line?

883
00:44:27,210 --> 00:44:31,410
好吧，我想继续添加到该行中的单词集。
Well, I want to go ahead and add to my set of words that line.

884
00:44:31,409 --> 00:44:33,599
就每个字而言-
Insofar as each word--

885
00:44:33,599 --> 00:44:39,659
每行代表一个单词，我只想将其添加到全局变量单词中
each line represents a word, I just want to add to my global variable words

886
00:44:39,659 --> 00:44:40,509
那条线。
that line.

887
00:44:40,510 --> 00:44:42,300
那是不对的，因为那是什么
And that's not quite right, because what's

888
00:44:42,300 --> 00:44:45,000
在文件中每一行的末尾？
at the end of every line in my file?

889
00:44:45,000 --> 00:44:48,600
根据定义，我文件中的每一行都有一个反斜杠n，对吗？
Every line in my file by definition has a backslash n, right?

890
00:44:48,599 --> 00:44:51,089
这就是为什么大词典中所有单词的原因
That is why all of the words in the big dictionary

891
00:44:51,090 --> 00:44:53,020
我们给你每行一个。
we gave you are one per line.

892
00:44:53,019 --> 00:44:57,149
那么，如何删除字符串末尾的新行呢？
So how do you get rid of the new line at the end of a string?

893
00:44:57,150 --> 00:45:01,470
好吧，在C中，我的天哪，我们将不得不使用malloc进行复制，
Well, in C, my God, we would have to use malloc to make a copy,

894
00:45:01,469 --> 00:45:04,859
然后将所有字符移开，然后将其缩短一点
and then move all of the characters over, and then shorten it a little bit

895
00:45:04,860 --> 00:45:06,480
通过消除反斜杠
by getting rid of the backslash n.

896
00:45:06,480 --> 00:45:07,050
嗯
Uh-uh.

897
00:45:07,050 --> 00:45:12,960
在Python中，如果您要在字符串末尾删除新行，
In Python, if you want to strip off the new line at the end of a string,

898
00:45:12,960 --> 00:45:15,030
只是做rstrip。
just do rstrip.

899
00:45:15,030 --> 00:45:18,510
剥离字符默认情况下意味着剥离空白。
To strip characters means by default to strip off white space.

900
00:45:18,510 --> 00:45:21,960
空白包括空格键，制表符和反斜杠n。
White space includes the space bar, the tab character, and backslash n.

901
00:45:21,960 --> 00:45:25,320
因此，如果您想把每一行都扔掉
And so if you want to take each line and throw away

902
00:45:25,320 --> 00:45:30,150
在末尾的尾随新行，您可以简单地说line.rstrip。
the trailing new line at the end of it, you can simply say line.rstrip.

903
00:45:30,150 --> 00:45:33,120
这就是Python中字符串再次强大的地方。
And this is where strings again in Python are powerful.

904
00:45:33,119 --> 00:45:37,199
因为它们是自己的数据类型，所以它们包含在其中，
Because they are their own data type, they have inside of them,

905
00:45:37,199 --> 00:45:42,809
不仅是构成字符串的所有字符，而且还有功能，
not only all of the characters composing the string, but also functions,

906
00:45:42,809 --> 00:45:46,079
就像rstrip从行尾开始剥离
like rstrip which strips from the end of the line

907
00:45:46,079 --> 00:45:48,209
任何可能存在的空白。
any white space that might be there.

908
00:45:48,210 --> 00:45:50,370
你知道吗，在此之后我想我完成了。
You know what, after this I think I'm done.

909
00:45:50,369 --> 00:45:52,739
我将继续关闭文件，
I'm just going to go ahead and close the file,

910
00:45:52,739 --> 00:45:55,269
我将继续并返回True。
and I'm going to go ahead and return True.

911
00:45:55,269 --> 00:45:56,009
就是这样了。
So that's it.

912
00:45:56,010 --> 00:45:58,110
那就是Python中的load函数。
That's the load function in Python.

913
00:45:58,110 --> 00:46:01,200
打开字典，针对文件中的每一行
Open the dictionary, for each line in the file

914
00:46:01,199 --> 00:46:04,889
将其添加到全局变量，关闭文件，返回True。
add it to your global variable, close the file, return True.

915
00:46:04,889 --> 00:46:08,909
我的意思是，我非常确定我的代码可能是几行，并且当然
I mean, I'm pretty sure that my code is probably several lines, and certainly

916
00:46:08,909 --> 00:46:11,639
很多小时，比您的代码可能要短
many hours, shorter than your code might have

917
00:46:11,639 --> 00:46:13,379
也是为了实现这一点。
been for implementing that as well.

918
00:46:13,380 --> 00:46:14,700
好吧，检查呢？
Well, what about checking?

919
00:46:14,699 --> 00:46:16,499
也许复杂性就在别处。
Maybe the complexity is just elsewhere.

920
00:46:16,500 --> 00:46:18,292
好吧，让我继续定义一个函数
Well, let me go ahead and define a function

921
00:46:18,291 --> 00:46:22,379
称为检查，它以一个特定的单词作为输入作为其参数。
called check that takes a specific word as input as its argument.

922
00:46:22,380 --> 00:46:26,760
然后，我将检查该给定单词是否在我的单词集中。
And then I'm just going to check if that given word is in my set of words.

923
00:46:26,760 --> 00:46:28,710
好吧，事实证明在C中，您可能会
Well, it turns out in C you would probably

924
00:46:28,710 --> 00:46:30,752
必须使用for循环或while循环，
have to use a for loop or a while loop, and you'd

925
00:46:30,751 --> 00:46:32,909
必须遍历整个单词列表
have to iterate over the whole list of words

926
00:46:32,909 --> 00:46:35,799
使用二进制搜索或线性搜索等加载的内容。
that you've loaded using binary search or linear search or the like.

927
00:46:35,800 --> 00:46:39,000
gh，我已经过去了这么多星期。
Ugh, I'm so past that at this point so many weeks in.

928
00:46:39,000 --> 00:46:48,359
我只是要说，如果一个字接一个字，请继续并返回True，否则返回
I'm just going to say, if word in words, go ahead and return True, else return

929
00:46:48,360 --> 00:46:49,500
错误的。
False.

930
00:46:49,500 --> 00:46:52,410
现在，这就是我对check的实现。
And that now is my implementation of check.

931
00:46:52,409 --> 00:46:53,729
现在，这是一个小车。
Now, it's a little buggy.

932
00:46:53,730 --> 00:46:55,140
我会解决这个问题。
And I will fix this.

933
00:46:55,139 --> 00:46:56,459
有人发现了这个错误吗？
Does anyone spot the bug?

934
00:46:56,460 --> 00:47:00,300
即使您以前从未见过Python，但花了数小时实施
Even if you've never seen Python before, but having spent hours implementing

935
00:47:00,300 --> 00:47:07,950
您自己的支票版本，在逻辑上我缺少某些步骤吗？
your own version of check, is there some step I'm missing logically?

936
00:47:07,949 --> 00:47:10,339
这里有一个错误。
There is a bug here.

937
00:47:10,340 --> 00:47:13,640
有没有人发现我没有做什么，你可能
Does anyone spot what I'm not doing that you probably

938
00:47:13,639 --> 00:47:19,279
检查字典中是否确实有给定单词时该怎么办？
did do when checking if a given word is in fact in the dictionary?

939
00:47:19,280 --> 00:47:22,030
布莱恩：几个人对区分大小写发表评论。
BRIAN: A couple of people are commenting on case sensitivity.

940
00:47:22,030 --> 00:47:23,530
大卫·马兰（David MALAN）：是的，区分大小写。
DAVID MALAN: Yeah, case sensitivity.

941
00:47:23,530 --> 00:47:26,180
很有可能，在C中的实现中，您可能
So odds are, in your implementation in C you probably

942
00:47:26,179 --> 00:47:29,869
将单词强制全部大写，或者将单词强制全部小写。
forced the word to all uppercase, or you forced it to all lowercase.

943
00:47:29,869 --> 00:47:33,169
完全可行，但是您可能必须像对待每个角色一样做到这一点。
Totally doable, but you probably had to do it like character for character.

944
00:47:33,170 --> 00:47:36,380
您可能不得不使用malloc复制输入，或将其放入
You might have had to copy the input using malloc, or putting it

945
00:47:36,380 --> 00:47:38,240
变成一个字符数组，然后
into an array character for character, then

946
00:47:38,239 --> 00:47:43,369
使用大写字母或小写字母将每个字母大写或小写。
using a toupper or tolower to capitalize or lowercase each individual letter.

947
00:47:43,369 --> 00:47:46,619
像这样，呃，那将是永远的，确实如此。
Ugh, like, that would take forever, as indeed it might have.

948
00:47:46,619 --> 00:47:50,179
因此，您知道什么，如果您想接受一个给定的单词并将其小写，
So you know what, if you want to take a given word and lowercase it,

949
00:47:50,179 --> 00:47:51,769
只说一句话。
just say word.lower.

950
00:47:51,769 --> 00:47:54,919
Python将负责所有这些迭代步骤
And Python will take care of all of those steps of iterating

951
00:47:54,920 --> 00:47:58,730
在每个字符上，将每个字符都更改为小写，然后返回给您
over every character, changing each one to lowercase, and returning to you

952
00:47:58,730 --> 00:48:02,000
新结果。实际上，我现在想，
the new result. And indeed, this now, I would think,

953
00:48:02,000 --> 00:48:05,390
也与您在示例中所做的一致。
is consistent with what you did in your example as well.

954
00:48:05,389 --> 00:48:06,529
好吧，尺寸呢？
Well, how about size?

955
00:48:06,530 --> 00:48:09,020
好吧，在尺寸记忆中，您必须定义
Well, in size recall that you had to define

956
00:48:09,019 --> 00:48:13,939
一个不接受任何输入但返回字数的函数
a function that doesn't take any inputs but returns the number of words

957
00:48:13,940 --> 00:48:15,630
在这组话中。
in the set of words.

958
00:48:15,630 --> 00:48:17,630
我将继续在这里-实际上，我
And I'm going to go ahead here-- and actually, I

959
00:48:17,630 --> 00:48:19,850
我的邀请到这里了。
got my invitation slightly off here.

960
00:48:19,849 --> 00:48:22,789
让我快速解决这个问题。
Let me fix this real fast.

961
00:48:22,789 --> 00:48:25,399
如果您要返回字典的大小，
If you want to return the size of your dictionary,

962
00:48:25,400 --> 00:48:27,660
或实际上是您集合中的单词数，
or really the number of words in your set,

963
00:48:27,659 --> 00:48:31,159
您可以只返回该全局变量字的长度。
you can just return the length of that global variable words.

964
00:48:31,159 --> 00:48:32,129
完毕。
Done.

965
00:48:32,130 --> 00:48:35,660
最后，如果您要卸载字典，
And lastly, if you want to unload the dictionary,

966
00:48:35,659 --> 00:48:37,219
让我继续卸货。
let me go ahead and unload things.

967
00:48:37,219 --> 00:48:38,599
也不接受输入。
Doesn't take input as well.

968
00:48:38,599 --> 00:48:41,689
老实说，因为我还没有做过等同于malloc的工作，
Honestly, because I've not done any equivalent of malloc,

969
00:48:41,690 --> 00:48:43,880
我还没有执行任何内存管理-为什么？
I've not done any memory management-- why?

970
00:48:43,880 --> 00:48:46,010
您不必使用Python
You don't have to in Python--

971
00:48:46,010 --> 00:48:51,560
我可以在所有情况下都可以返回True，因为毫无疑问，我的代码
I can literally just return True in all cases, because my code is undoubtedly

972
00:48:51,559 --> 00:48:55,189
正确，因为我不必理会指针，地址和内存
correct, because I didn't have to bother with pointers and addresses and memory

973
00:48:55,190 --> 00:48:55,920
管理。
management.

974
00:48:55,920 --> 00:48:58,962
因此，过去几周可能引起的所有压力
So all of the stress that might have been induced over the past few weeks

975
00:48:58,961 --> 00:49:01,879
当您了解了内存管理的较低级别的详细信息时
as you understood the lower level details of memory management now

976
00:49:01,880 --> 00:49:09,710
走开，不是因为它不在引擎盖下发生，
go away, not because it's not happening underneath the hood,

977
00:49:09,710 --> 00:49:12,080
但是因为Python正在为您做这件事。
but because Python is doing it for you.

978
00:49:12,079 --> 00:49:14,299
我确实在这里发现了一个错误。
And I did spot one bug here actually.

979
00:49:14,300 --> 00:49:16,760
注意，我在这里有点陷入了C代码中。
Notice I kind of relapsed into C code here.

980
00:49:16,760 --> 00:49:20,660
我在这里应该说的是它实际上是file.close。
What I should have said here is it's actually file.close.

981
00:49:20,659 --> 00:49:25,129
所以在这里，当我关闭正在加载的文件时，我实际上必须调用file.close，
So here when I close the file in load, I actually have to call file.close,

982
00:49:25,130 --> 00:49:30,360
因为现在该函数close与该变量相关联。
because now that function close is associated with that variable for me.

983
00:49:30,360 --> 00:49:33,380
同样，内存管理也在发生。
So again, there is memory management happening.

984
00:49:33,380 --> 00:49:37,550
Malloc和free或realloc都是为您而发生的
Malloc and free or realloc are all happening sort of for you

985
00:49:37,550 --> 00:49:38,390
引擎盖下。
underneath the hood.

986
00:49:38,389 --> 00:49:40,309
但是该语言在做什么Python
But what Python the language is doing for

987
00:49:40,309 --> 00:49:42,522
您现在正在为您管理所有这些。
you now is managing all of that for you.

988
00:49:42,523 --> 00:49:45,440
那就是通过使用所谓的高级语言获得的
That's what you get by using a so-called higher-level language instead

989
00:49:45,440 --> 00:49:47,030
一种较低级的语言。
of a lower-level language.

990
00:49:47,030 --> 00:49:49,490
您可以获得更多功能，在这种情况下，
You get more features, and in turn in this case,

991
00:49:49,489 --> 00:49:52,609
您会为您解决所有这些问题，
you get all of those problems taken care of for you,

992
00:49:52,610 --> 00:49:55,430
这样您和我就可以专注于构建我们的拼写检查器，
so that you and I can focus on building our spell checker,

993
00:49:55,429 --> 00:49:58,189
这样您和我就可以专注于构建我们的Instagram过滤器，
so you and I can focus on building our Instagram filters,

994
00:49:58,190 --> 00:50:02,078
而不是分配内存，复制字符串，大写字母和其他东西，
not on allocating memory, copying strings, uppercase and things, which

995
00:50:02,077 --> 00:50:05,119
老实说，虽然这可能很有趣，而且第一次让我很满意
honestly, while it might have been fun and very gratifying the first time

996
00:50:05,119 --> 00:50:08,389
你使那些事情起作用了，编程很快就会变成
you got those things working, programming would very quickly become

997
00:50:08,389 --> 00:50:11,149
如果有的话，这是世界上最乏味的事情
the most tedious thing in the world if any time you

998
00:50:11,150 --> 00:50:16,320
想要编写一个程序，您必须在这样的低级水平上思考和编写代码。
want to write a program you have to think and write code at that low level.

999
00:50:16,320 --> 00:50:16,820
好的。
All right.

1000
00:50:16,820 --> 00:50:20,480
让我继续前进，真正跨过我没有在这里弄糟的手指，
Let me go ahead and really cross my fingers that I didn't screw up here,

1001
00:50:20,480 --> 00:50:22,200
并继续运行此代码。
and go ahead and run this code.

1002
00:50:22,199 --> 00:50:25,087
因此，我将继续运行speller.py的python--
So I'm going to go ahead and run python of speller.py--

1003
00:50:25,088 --> 00:50:28,130
坦率地说，我事先写过，因为就像分布
which, admittedly, I wrote in advance, because just like the distribution

1004
00:50:28,130 --> 00:50:32,248
拼写中的代码，我们为您编写了speller.c，我们事先编写了speller.py。
code in speller, we wrote speller.c for you, we wrote speller.py in advance.

1005
00:50:32,248 --> 00:50:34,040
但是，我们不会研究它的内部。
But we won't look at the internals of that.

1006
00:50:34,039 --> 00:50:35,831
我将继续进行测试，如何
I'm going to go ahead and test this on, how

1007
00:50:35,831 --> 00:50:37,879
关于莎士比亚这样的大事。
about something big like Shakespeare.

1008
00:50:37,880 --> 00:50:40,070
我将在这里用手指交叉。
And I'm going to cross my fingers here.

1009
00:50:40,070 --> 00:50:41,810
到目前为止，一切都很好。
And so far so good.

1010
00:50:41,809 --> 00:50:44,029
这个词有点飞过去。
The words are kind of flying by.

1011
00:50:44,030 --> 00:50:46,273
我将假设它们是正确的。
I'm going to assume they're correct.

1012
00:50:46,273 --> 00:50:47,690
希望我们能得到输出。
Hopefully we'll get to the output.

1013
00:50:47,690 --> 00:50:50,870
是的，是的，我想我在这里看到了一些熟悉的数字。
And it looks like, yeah, I think I see some familiar numbers here.

1014
00:50:50,869 --> 00:50:53,449
我有143,091个字。
I've got 143,091 words.

1015
00:50:53,449 --> 00:50:57,329
然后在这里，所涉及的总时间不到1秒。
And then down here, the total time involved was just under 1 second.

1016
00:50:57,329 --> 00:50:58,789
所以这真是太快了。
So that's pretty darn fast.

1017
00:50:58,789 --> 00:51:01,009
需要明确的是，我使用的是Mac而不是IDE，
And to be clear, I'm using my Mac instead of the IDE,

1018
00:51:01,010 --> 00:51:05,150
因此我的数字可能与云中的数字略有不同，但为0.9
so my numbers might be a little different than in the cloud, but 0.9

1019
00:51:05,150 --> 00:51:05,840
秒。
seconds.

1020
00:51:05,840 --> 00:51:09,560
但是出于好奇，您知道什么让我快速打开另一个标签，
But you know what, out of curiosity, let me open up a different tab real quick,

1021
00:51:09,559 --> 00:51:13,339
让我继续，从问题5开始拼写。
and let me go ahead and make speller from problem set 5.

1022
00:51:13,340 --> 00:51:17,240
因此，我提前带来了我们自己的拼写工具实施人员
So I brought in advance our own implementation of speller, the staff

1023
00:51:17,239 --> 00:51:21,529
解决方案，用C语言编写的dictionary.c和speller.c，
solution, written in C in dictionary.c and speller.c,

1024
00:51:21,530 --> 00:51:23,330
而且我刚刚用make对其进行了编译。
and I've just compiled it with make.

1025
00:51:23,329 --> 00:51:29,039
然后让我继续使用莎士比亚上的相同文字来运行./speller。
And let me go ahead and run ./speller using the same text on Shakespeare.

1026
00:51:29,039 --> 00:51:31,309
再说一次，我现在运行的是Python版本
So again, I just ran the Python version, now

1027
00:51:31,309 --> 00:51:37,139
我想使用人员的实现来运行C版本。
I want to run the C version using the staff's implementation.

1028
00:51:37,139 --> 00:51:37,639
好的。
All right.

1029
00:51:37,639 --> 00:51:38,609
哇。
Wow.

1030
00:51:38,610 --> 00:51:42,140
好吧，它飞得更快，快两倍。
All right, it flew by way faster, kind of twice as fast.

1031
00:51:42,139 --> 00:51:47,089
请注意，即使上面的数字相同，但时间却不同。
And notice, even though the numbers are the same up above, the times are not.

1032
00:51:47,090 --> 00:51:51,290
我的C版本花了0.52秒，所以花了半秒钟。
My C version took 0.52 seconds, so half a second.

1033
00:51:51,289 --> 00:51:55,309
我的Python版本花了0.9，或大约1秒。
My Python version took 0.9, or roughly 1 second.

1034
00:51:55,309 --> 00:52:01,219
因此，看来我的C版本更快，而我的Python版本则慢。
So it would seem that my C version is faster, my Python version is slower.

1035
00:52:01,219 --> 00:52:04,849
为什么会这样呢？
Why might that be?

1036
00:52:04,849 --> 00:52:07,309
为什么会这样呢？
Why might that be?

1037
00:52:07,309 --> 00:52:10,549
因为如果我们花这么长时间都让我感到失望
Because I'm kind of disappointed if we just spent all this time

1038
00:52:10,550 --> 00:52:13,130
宣讲Python的优点，但在这里我们
preaching the virtues of Python, and yet here we

1039
00:52:13,130 --> 00:52:15,410
从某种意义上说，他们正在编写更糟糕的代码。
are writing worse code, in some sense.

1040
00:52:15,409 --> 00:52:17,329
圣地亚哥？
Santiago?

1041
00:52:17,329 --> 00:52:21,269
听众：可能是因为C即使水平很低，
AUDIENCE: Could it be because C, even though it's low level,

1042
00:52:21,269 --> 00:52:24,659
它明确地告诉计算机该怎么做，
it explicitly tells the computer what to do,

1043
00:52:24,659 --> 00:52:29,491
这样可以使其更快一点，而在Python中则可以
and so that makes it a little faster, whilst in Python it all

1044
00:52:29,492 --> 00:52:31,700
就像你说的那样，发生在引擎盖下面
happens like underneath the hood, as you were saying,

1045
00:52:31,699 --> 00:52:33,559
这样可能会使速度变慢。
so that could make it a little slower.

1046
00:52:33,559 --> 00:52:34,309
戴维·马兰：是的。
DAVID MALAN: Yeah.

1047
00:52:34,309 --> 00:52:36,979
在Python中，您有一个通用的解决方案
In Python, you have a general-purpose solution

1048
00:52:36,980 --> 00:52:39,787
关于内存管理和大小写的问题，
to the problem of memory management, and capitalization,

1049
00:52:39,786 --> 00:52:41,869
以及我们自己的所有其他功能
and all of these other features, that we ourselves

1050
00:52:41,869 --> 00:52:45,889
必须使用C来实现自己。Python具有通用实现
have to implement ourselves in C. Python has general-purpose implementations

1051
00:52:45,889 --> 00:52:46,819
所有这些。
of all of those.

1052
00:52:46,820 --> 00:52:50,750
但是使用其他人的代码来实现需要付出一定的代价
But there's a price you pay by using someone else's code to implement

1053
00:52:50,750 --> 00:52:53,270
所有这些东西都给你。
all of those things for you.

1054
00:52:53,269 --> 00:52:57,139
而且您使用语言的类型会付出更大的代价
And you pay an even greater price by using the type of language

1055
00:52:57,139 --> 00:52:58,654
Python在某种意义上是。
that Python is in a sense.

1056
00:52:58,655 --> 00:53:00,530
所以还有其他明显的不同
So there's been this other salient difference

1057
00:53:00,530 --> 00:53:03,020
在使用C和使用Python之间。
between using C and using Python.

1058
00:53:03,019 --> 00:53:08,149
当我编写C代码时，我将从源代码编译我的代码
When I wrote C code, I would compile my code from source code

1059
00:53:08,150 --> 00:53:09,080
变成机器代码。
into machine code.

1060
00:53:09,079 --> 00:53:11,449
并记得机器码是0和1的理解
And recall that machine code are 0's and 1's understood

1061
00:53:11,449 --> 00:53:14,749
由计算机的大脑，即所谓的CPU或中央处理器。
by the computer's brain, the so-called CPU, or Central Processing Unit.

1062
00:53:14,750 --> 00:53:17,750
每当更改源代码时，我们总是不得不编译我们的代码。
We always had to compile our code every time we changed the source code.

1063
00:53:17,750 --> 00:53:21,149
然后我们确实希望./hello运行该程序。
And then we did like ./hello to run the program.

1064
00:53:21,150 --> 00:53:25,860
但是到目前为止，在Python中的每个演示都没有使用过make或clang。
But every demo thus far in Python, I haven't used make or clang.

1065
00:53:25,860 --> 00:53:32,690
我没有使用./hello，而是使用python空格来命名程序。
I have used not ./hello, but rather python space the name of the program.

1066
00:53:32,690 --> 00:53:33,870
那为什么呢？
And why is that?

1067
00:53:33,869 --> 00:53:36,559
好吧，事实证明，Python通常被实现为
Well, it turns out that Python is often implemented as what

1068
00:53:36,559 --> 00:53:38,989
我们用口译员来描述。
we describe with an interpreter.

1069
00:53:38,989 --> 00:53:42,119
因此，Python不仅是我们一直在写的语言，
So Python is not only a language like we've been writing,

1070
00:53:42,119 --> 00:53:44,459
它本身也是一个程序。
it's also a program unto itself.

1071
00:53:44,460 --> 00:53:48,800
我一直运行的Python程序是一个同名程序
The Python program I keep running is an identically named program

1072
00:53:48,800 --> 00:53:51,330
理解Python语言。
that understands the Python language.

1073
00:53:51,329 --> 00:53:56,149
但是，发生的事情是，可以使用口译员，可以这么说，
And what's happening, though, is that by using an interpreter, so to speak,

1074
00:53:56,150 --> 00:53:59,810
要运行我的程序，您会产生一些开销。
to run my programs you're incurring some amount of overhead.

1075
00:53:59,809 --> 00:54:01,489
您要支付性能价格。
You're paying a performance price.

1076
00:54:01,489 --> 00:54:02,251
为什么？
Why?

1077
00:54:02,251 --> 00:54:04,709
好吧，回想起从第0周开始的计算机，
Well, computers, recall from week 0, at the end of the day,

1078
00:54:04,710 --> 00:54:06,380
只了解0和1。
only understand 0's and 1's.

1079
00:54:06,380 --> 00:54:08,390
这就是让他们打勾的原因。
That's what makes them tick.

1080
00:54:08,389 --> 00:54:11,239
但是我还没有输出0和1。
But I have not outputted any 0's and 1's.

1081
00:54:11,239 --> 00:54:13,789
我人类只是在写Python。
I the human have only been writing Python.

1082
00:54:13,789 --> 00:54:18,859
因此，我的Python代码之间需要进行某种翻译，
So there needs to be some kind of translation between my Python code,

1083
00:54:18,860 --> 00:54:23,120
以这种类似于英语的语法，将其转化为计算机本身可以理解的内容。
in this English-like syntax, into what the computer itself understands.

1084
00:54:23,119 --> 00:54:25,669
如果您不打算进行编译，
And if you're not going to go through the effort of compiling

1085
00:54:25,670 --> 00:54:27,963
每次进行更改时，您的代码，但是
your code every time you make a change, but instead

1086
00:54:27,963 --> 00:54:30,380
您将要通过解释器运行代码，
you're just going to run your code through an interpreter,

1087
00:54:30,380 --> 00:54:33,470
就像Python世界中的规范一样，
as is the norm in the Python world, you're

1088
00:54:33,469 --> 00:54:37,759
要付出代价，因为有人必须为您实现翻译。
going to pay a price, because someone had to implement a translator for you.

1089
00:54:37,760 --> 00:54:40,610
实际上，对此有正式的术语。
And in fact, there's formal terminology for this.

1090
00:54:40,610 --> 00:54:45,150
例如，在Python的世界中，
In the world of Python we have, for instance,

1091
00:54:45,150 --> 00:54:47,240
看起来更像这样的图片。
a picture that looks more like this.

1092
00:54:47,239 --> 00:54:50,629
而在C语言世界中，我们实际上将源代码作为输入
Whereas in the world of C, we would actually take our source code as input

1093
00:54:50,630 --> 00:54:52,970
然后输出，首先输出机器码，
and output, first machine code is output,

1094
00:54:52,969 --> 00:54:56,479
然后运行机器代码，到目前为止在Python的世界中，
and then run the machine code, in the world of Python thus far,

1095
00:54:56,480 --> 00:54:59,450
我正在编写源代码，然后立即运行它。
I'm writing source code, and then I'm immediately running it.

1096
00:54:59,449 --> 00:55:01,939
我没有事先将其编译为0和1。
I'm not compiling it into 0's and 1's in advance.

1097
00:55:01,940 --> 00:55:05,150
我相信这里有一个程序，恰好叫做Python，
I'm trusting that there's a program, coincidentally called Python,

1098
00:55:05,150 --> 00:55:09,920
他一生的目的是为我翻译代码
whose purpose in life is to translate that code for me

1099
00:55:09,920 --> 00:55:12,470
变成计算机可以理解的东西。
into something the computer does understand.

1100
00:55:12,469 --> 00:55:15,559
这实际上意味着什么呢？
And what does that actually mean in real terms?

1101
00:55:15,559 --> 00:55:17,959
好吧，这意味着如果我回想一下
Well, it means that if I were to think back

1102
00:55:17,960 --> 00:55:22,250
像这样的算法，可能对你们许多人来说都是个秘密
to an algorithm like this, which probably cryptic to many of you,

1103
00:55:22,250 --> 00:55:25,669
虽然不是全部，但可能是西班牙语算法
though not all, might be a Spanish algorithm

1104
00:55:25,670 --> 00:55:27,890
用于搜索某人的电话簿。
for searching a phone book for someone.

1105
00:55:27,889 --> 00:55:30,379
并且假设我一点也不说西班牙语。
And suppose that I don't speak Spanish at all.

1106
00:55:30,380 --> 00:55:35,000
理想情况下，我可能会将此程序，该算法编译成某种形式
I might, ideally, compile this program, this algorithm, into something

1107
00:55:35,000 --> 00:55:39,410
我确实通过使用将西班牙语翻译成英语的编译器来理解。
I do understand by using a compiler that translates Spanish to English.

1108
00:55:39,409 --> 00:55:43,069
像voila这样的英文版本，要更好地阅读和理解，
Like voila, this English version, much better reading and understanding this,

1109
00:55:43,070 --> 00:55:45,050
我可以很快地执行该算法，
I can execute this algorithm pretty fast,

1110
00:55:45,050 --> 00:55:46,700
因为我英文很好。
because I'm pretty good at English.

1111
00:55:46,699 --> 00:55:50,299
但是如果您只给我西班牙语版本的源代码，
But if you only give me the Spanish version, the source code,

1112
00:55:50,300 --> 00:55:54,725
并且您需要我逐行翻译或解释它，
and you require that I translate it or interpret it line by line,

1113
00:55:54,724 --> 00:55:56,599
老实说那真的会让我慢下来，
honestly that's really going to slow me down,

1114
00:55:56,599 --> 00:55:59,659
因为就像我必须像西班牙语字典一样
because it's like me having to go take like a Spanish dictionary

1115
00:55:59,659 --> 00:56:01,489
然后看每个字-
and look up every word--

1116
00:56:01,489 --> 00:56:02,989
“夺回圭亚那电信。”
"Recoge guia telefonica."

1117
00:56:02,989 --> 00:56:04,911
好吧，什么是“补偿”？
All right, well, what's "recoge"?

1118
00:56:04,911 --> 00:56:05,869
我必须查一下。
I have to look that up.

1119
00:56:05,869 --> 00:56:07,879
什么是“ guia”，什么是“ telefonica”？
What's "guia", what's "telefonica"?

1120
00:56:07,880 --> 00:56:08,630
哦好的。
Oh, OK.

1121
00:56:08,630 --> 00:56:09,710
拿起电话簿。
Pick up phone book.

1122
00:56:09,710 --> 00:56:10,230
知道了。
Got that.

1123
00:56:10,230 --> 00:56:10,730
第一步。
Step one.

1124
00:56:10,730 --> 00:56:11,397
第二步是什么？
What's step two?

1125
00:56:11,396 --> 00:56:13,579
“ Abre a la mitad de guia telefonica。”
"Abre a la mitad de guia telefonica."

1126
00:56:13,579 --> 00:56:16,639
因此，“向中间敞开”-好吧，等等，我不知道。
So "open to the middle"-- well, wait, I don't know that.

1127
00:56:16,639 --> 00:56:17,419
剧透
Spoiler.

1128
00:56:17,420 --> 00:56:18,738
“ abre”是什么意思？
What does that mean, "abre"?

1129
00:56:18,737 --> 00:56:20,029
好吧，让我查一下。
All right, let me look that up.

1130
00:56:20,030 --> 00:56:20,900
它的意思是“开放”。
And it means "open."

1131
00:56:20,900 --> 00:56:23,870
“ la mitad”，意思是“到中间”。
"A la mitad," that means "to the middle."

1132
00:56:23,869 --> 00:56:26,299
“电话簿”，“电话簿”。
"De guia telefonica," "of the phone book."

1133
00:56:26,300 --> 00:56:28,710
哦，这意味着“打开电话簿的中间”。
Oh, that means "open to the middle of the phone book."

1134
00:56:28,710 --> 00:56:31,040
所以，我很努力地在这里来回走动。
So I'm struggling to go back and forth here, clearly.

1135
00:56:31,039 --> 00:56:32,869
但这显然是一个较慢的过程。
But it's clearly a slower process.

1136
00:56:32,869 --> 00:56:36,109
如果我继续走，“ Ve la pagina”，“看看页面”，
And if I keep going, "Ve la pagina," "Look at the page,"

1137
00:56:36,110 --> 00:56:39,260
抬头看，翻译每一行，无疑
looking up, translating every line, it's undoubtedly

1138
00:56:39,260 --> 00:56:40,890
会减慢这个过程。
going to slow down the process.

1139
00:56:40,889 --> 00:56:43,159
因此，这实际上是我们正在发生的事情
And so that's effectively what's happening for us

1140
00:56:43,159 --> 00:56:44,899
当我们运行这些Python程序时。
when we run these Python programs.

1141
00:56:44,900 --> 00:56:48,350
可以说，有一个翻译，中间是一个人，
There is a translator, a man in the middle, so to speak,

1142
00:56:48,349 --> 00:56:51,419
在查看您的源代码并从上至下阅读它，
that's looking at your source code and reading it top to bottom,

1143
00:56:51,420 --> 00:56:55,550
从左到右，基本上分别翻译了每一行
left to right, and essentially translating each line respectively

1144
00:56:55,550 --> 00:56:59,340
转换为计算机可以理解的相应代码。
into the corresponding code that the computer understands.

1145
00:56:59,340 --> 00:57:01,550
因此，幸运的是，我们的好处是
So the upside of this is that, thankfully, we

1146
00:57:01,550 --> 00:57:02,930
不必运行make或clang。
don't have to run make or clang.

1147
00:57:02,929 --> 00:57:04,799
我们不必再编译代码了。
We don't have to compile our code anymore.

1148
00:57:04,800 --> 00:57:07,480
就像，这里有多少人做了改变
Like, how many people here have made a change

1149
00:57:07,480 --> 00:57:11,830
到C中的较早pset，忘记了保存文件，但是您重新运行了-
to an earlier pset in C, forgotten to save the file but you rerun the--

1150
00:57:11,829 --> 00:57:14,679
抱歉，您忘记了重新编译文件，然后重新运行它，
sorry, you forgot to recompile the file, and you rerun it,

1151
00:57:14,679 --> 00:57:16,449
而且程序显然没有改变
and the program obviously has not changed

1152
00:57:16,449 --> 00:57:19,839
因为您实际上并没有保存，而是重新编译了它？
because you haven't actually, not only saved but recompiled it?

1153
00:57:19,840 --> 00:57:22,720
这样，愚蠢而烦人的步骤就消失了。
So that stupid, annoying human step is gone.

1154
00:57:22,719 --> 00:57:25,959
在Python的世界中，如果您更改文件，请继续并重新运行它，
In the world of Python, if you change your file, go ahead and just rerun it,

1155
00:57:25,960 --> 00:57:26,950
重新解释它。
reinterpret it.

1156
00:57:26,949 --> 00:57:28,416
您可以保存该步骤。
You can save that step.

1157
00:57:28,416 --> 00:57:30,999
但是，您要支付的价格有些开销。
But the price you're going to pay is a little bit of overhead.

1158
00:57:31,000 --> 00:57:34,660
确实，我们在这里以我的Python版本来看
And indeed, we see that here in terms of my Python version

1159
00:57:34,659 --> 00:57:37,569
花大约1秒钟来拼写莎士比亚，
taking roughly 1 second to spellcheck Shakespeare,

1160
00:57:37,570 --> 00:57:41,450
而我的C版本只花了半秒的时间。
and my C version taking only one half of a second.

1161
00:57:41,449 --> 00:57:44,319
因此，在过去的几周中，我也曾承诺要权衡这一主题。
So here, too, I promised in past weeks this theme of trade-offs.

1162
00:57:44,320 --> 00:57:47,320
这在计算机科学和编程领域非常普遍，
This is so prevalent in the world of computer science and programming,

1163
00:57:47,320 --> 00:57:48,730
坦率地说，在现实世界中。
and frankly in the real world.

1164
00:57:48,730 --> 00:57:51,940
任何时候只要您有所改善或获得收益，
Any time you make some improvement or gain some benefit,

1165
00:57:51,940 --> 00:57:53,860
赔率是您付出了一些代价。
odds are you are paying some price.

1166
00:57:53,860 --> 00:57:57,610
也许是时间，也许是空间，也许是金钱，也许是复杂性，
Maybe it's time, maybe it's space, maybe it's money, maybe it's complexity,

1167
00:57:57,610 --> 00:57:58,840
也许还有别的。
maybe it's anything else.

1168
00:57:58,840 --> 00:58:01,720
存在这种资源的永久权衡。
There's this perpetual trade-off of resources.

1169
00:58:01,719 --> 00:58:03,669
最终，成为一名优秀的程序员是
And being a good programmer, ultimately, is

1170
00:58:03,670 --> 00:58:06,520
关于找到那些拐点并最终了解
about finding those inflection points and knowing ultimately

1171
00:58:06,519 --> 00:58:09,759
使用什么工具进行交易。
what tools to use for the trade.

1172
00:58:09,760 --> 00:58:12,250
好吧，让我们继续前进，休息5分钟。
All right, let's go ahead here, take a 5-minute break.

1173
00:58:12,250 --> 00:58:14,833
当我们回来时，我们将看看Python的其他功能，
And when we come back, we'll look at other features of Python,

1174
00:58:14,833 --> 00:58:19,330
我们最终将在今天结束时带来一些真正强大的功能。
we'll end ultimately today with some really powerful capabilities.

1175
00:58:19,329 --> 00:58:21,129
回到五。
Back in five.

1176
00:58:21,130 --> 00:58:21,850
好的。
All right.

1177
00:58:21,849 --> 00:58:22,539
我们回来了。
We are back.

1178
00:58:22,539 --> 00:58:24,729
首先，如果可以的话，我要退缩。
And first, a retraction if I may.

1179
00:58:24,730 --> 00:58:28,330
布莱恩（Brian）友善地指出，我对奥利维亚（Olivia）和诺亚（Noah）的后续问题的回答
Brian kindly pointed out that my answer to Olivia and Noah's follow-up question

1180
00:58:28,329 --> 00:58:31,299
不幸的是错过了分数，因为我是在忙着做事
unfortunately missed the mark, as I was doing things on the fly instead

1181
00:58:31,300 --> 00:58:32,890
阅读文档。
of reading the documentation.

1182
00:58:32,889 --> 00:58:36,099
因此，让我在这里为我们回顾一下这个例子，
So let me recall for us this example here,

1183
00:58:36,099 --> 00:58:38,989
其中，我们有一个range函数返回了三个值。
wherein we had the range function returning three values.

1184
00:58:38,989 --> 00:58:43,329
这样代码正确，我们得到的值分别为0、1和2。
So that code correct, that gives us the values 0, 1, and 2.

1185
00:58:43,329 --> 00:58:46,449
但是我认为奥利维亚（Olivia）问的是，如果您想跳过价值观，
But what I think Olivia asked was that if you wanted to skip values,

1186
00:58:46,449 --> 00:58:49,154
例如每两位数字，我们该怎么做？
and for instance do every two digits, how do we do that?

1187
00:58:49,155 --> 00:58:51,280
不幸的是，我为此搞砸了语法，
And I unfortunately screwed up the syntax for that,

1188
00:58:51,280 --> 00:58:54,610
仅提供两个范围内的输入，而不是三个，
providing only two inputs to range instead of three,

1189
00:58:54,610 --> 00:58:56,000
如此处所需。
as would be needed here.

1190
00:58:56,000 --> 00:58:58,810
例如，假设我们要打印
So for instance, suppose that we wanted to print out

1191
00:58:58,809 --> 00:59:02,499
0到100之间（包括0和100）的所有数字，
all of the numbers between 0 and 100, inclusive,

1192
00:59:02,500 --> 00:59:06,519
但彼此跳过-所以0、2、4、6、8等
but skipping every other-- so, 0, 2, 4, 6, 8, so all the even

1193
00:59:06,519 --> 00:59:09,229
最多可以有100个数字。
numbers on up through 100.

1194
00:59:09,230 --> 00:59:12,430
实际上，我们实际上想做这样的事情。
We would actually want to do something like this instead.

1195
00:59:12,429 --> 00:59:17,199
我们可以说，因为i在0逗号101逗号2的范围内。
We would say, for i in range of 0 comma 101 comma 2.

1196
00:59:17,199 --> 00:59:18,209
这是为什么？
Why is that?

1197
00:59:18,210 --> 00:59:20,600
好吧，我们稍后会整理文档，
Well, we'll pull up the documentation in just a moment,

1198
00:59:20,599 --> 00:59:23,529
但是0是您要开始计数的位置。
but 0 is where you want to start counting.

1199
00:59:23,530 --> 00:59:26,770
第二个值101是您要停止计数的位置。
The second value, 101, is where you want to stop counting.

1200
00:59:26,769 --> 00:59:29,889
但这是排他性的，所以我们有
But it is by definition exclusive, so we have

1201
00:59:29,889 --> 00:59:31,939
比我们关心的价值高1。
to go 1 past the value we care about.

1202
00:59:31,940 --> 00:59:35,170
然后第三个参数2是多少
And then the 2, the third argument, is how many

1203
00:59:35,170 --> 00:59:40,090
您想一次增加一个数字，从0到2到4到6到8，
numbers do you want to increment at a time, from 0 to 2 to 4 to 6 to 8,

1204
00:59:40,090 --> 00:59:41,920
直到100。
on up through 100.

1205
00:59:41,920 --> 00:59:44,290
所以我怎么能事先弄清楚
So how could I have figured this out in advance

1206
00:59:44,289 --> 00:59:45,879
而不是现在让自己尴尬？
rather than embarrassing myself now?

1207
00:59:45,880 --> 00:59:48,880
好吧，事实证明，这里有Python的官方文档。
Well, it turns out there is official documentation for Python.

1208
00:59:48,880 --> 00:59:50,710
我们将始终将其链接到您。
And we'll always link this to you.

1209
00:59:50,710 --> 00:59:53,060
这是最顶部的搜索框。
And here there is this search box at the very top.

1210
00:59:53,059 --> 00:59:54,879
您可以看到，在休息期间，我一直在搜索
And you can see that during the break I was searching

1211
00:59:54,880 --> 00:59:56,320
有关范围的文档。
for the documentation for range.

1212
00:59:56,320 --> 00:59:59,362
毫无疑问，如果我搜索范围文档，乍一看
And sure enough, if I search for the range documentation, at first glance

1213
00:59:59,362 --> 01:00:01,487
这似乎有点让人不知所措，因为
it might seem kind of overwhelming, because there's

1214
01:00:01,487 --> 01:00:04,450
在文档中对范围之类的东西有很多提及。
a lot of mentions of something like range in the documentation.

1215
01:00:04,449 --> 01:00:07,459
幸运的是，这里的第一个结果就是我们想要的结果。
Fortunately, the first result here is the one we want.

1216
01:00:07,460 --> 01:00:10,300
如果我单击该按钮，您会看到一些文档
And if I click on that, you'll see some documentation that's

1217
01:00:10,300 --> 01:00:12,520
乍一看有点神秘。
a little cryptic at first glance.

1218
01:00:12,519 --> 01:00:15,039
但是有趣的是这个范围
But what's interesting about this is that range

1219
01:00:15,039 --> 01:00:16,331
有两种不同的口味。
comes in two different flavors.

1220
01:00:16,331 --> 01:00:18,206
即使我一直称其为函数，
And even though I keep calling it a function,

1221
01:00:18,206 --> 01:00:19,879
从技术上讲，这就是所谓的课程。
technically it's what's called a class.

1222
01:00:19,880 --> 01:00:21,130
但是在另一时间。
But more on that another time.

1223
01:00:21,130 --> 01:00:23,330
就我们的目的而言，它表现为一种功能。
It behaves for our purposes as a function.

1224
01:00:23,329 --> 01:00:24,879
请注意，这里有两行。
Notice that there's two lines here.

1225
01:00:24,880 --> 01:00:26,780
它们相似但又不同。
And they're similar but different.

1226
01:00:26,780 --> 01:00:30,730
第一个指定此范围功能
The first one specifies that this range function

1227
01:00:30,730 --> 01:00:33,080
可以接受一个输入，即停止值。
can take one input, the stop value.

1228
01:00:33,079 --> 01:00:35,499
那么，您要停止计数的价值是多少？
So at what value do you want to stop counting?

1229
01:00:35,500 --> 01:00:40,299
因此，以前，当我们将范围设为3时，可以推断默认情况下，
So before, when we did range of 3, it stands to reason that by default,

1230
01:00:40,300 --> 01:00:43,360
如果您从0开始计数，然后从3停止，那将
if you start counting at 0 and you stop at 3, that will

1231
01:00:43,360 --> 01:00:47,260
让您使用i等于0、1和2。
get you to use i equals 0, 1, and 2.

1232
01:00:47,260 --> 01:00:50,500
但是范围函数还有另一种味道，
But there's another flavor of the range function, which

1233
01:00:50,500 --> 01:00:52,419
不是我提出的那个。
is not the one that I proposed exists.

1234
01:00:52,420 --> 01:00:56,050
还有另一个可能包含三个参数的地方，在这里
There's another that takes in potentially three arguments, here

1235
01:00:56,050 --> 01:00:57,400
或从技术上讲两个。
or technically two.

1236
01:00:57,400 --> 01:00:59,080
但是它以以下方式工作。
But it works in the following way.

1237
01:00:59,079 --> 01:01:02,319
当您在Python文档中看到类似这样的语法时，
When you see syntax like this in Python's documentation,

1238
01:01:02,320 --> 01:01:04,900
这意味着范围的替代形式
this means that the alternate form of range

1239
01:01:04,900 --> 01:01:09,490
接受一个叫做start的参数，然后跟一个叫做stop的参数，
takes an argument called start, followed by an argument called stop,

1240
01:01:09,489 --> 01:01:13,659
接下来是可选的第三个参数，称为step。
followed by, optionally, a third argument called step.

1241
01:01:13,659 --> 01:01:17,359
作为读者，我知道它是可选的，因为它在方括号中。
And I know as the reader it's optional, because it's in square brackets here.

1242
01:01:17,360 --> 01:01:20,050
因此，与列表或数组或类似内容无关。
So nothing to do with lists or arrays or anything like this.

1243
01:01:20,050 --> 01:01:21,590
这只是人工文档。
This is just human documentation.

1244
01:01:21,590 --> 01:01:23,530
每当您看到方括号中的内容时，
Anytime you see things in square brackets,

1245
01:01:23,530 --> 01:01:27,050
这倾向于向人类读者暗示这是可选的。
that tends to imply to the human reader that this is optional.

1246
01:01:27,050 --> 01:01:28,130
那是什么意思呢？
So what does that mean?

1247
01:01:28,130 --> 01:01:31,510
好吧，请注意，没有范围的味道
Well, notice that there is no flavor of range that

1248
01:01:31,510 --> 01:01:36,100
让我指定一个停止点和一个步骤，我认为这是片刻之前
lets me specify a stop and a step, which I thought there was a moment ago when

1249
01:01:36,099 --> 01:01:37,449
回答奥利维亚和诺亚。
answering Olivia and Noah.

1250
01:01:37,449 --> 01:01:40,169
而是有此三输入版本。
But rather, there is this three-input version.

1251
01:01:40,170 --> 01:01:43,210
因此，如果我指定我要从0开始，我想
So if I specify I want to start at 0, I want

1252
01:01:43,210 --> 01:01:47,230
停在101，刚好超过我所关心的100，
to stop at 101, which is just past the 100 I care about,

1253
01:01:47,230 --> 01:01:50,110
然后提供2的可选步骤
and then provide an optional step of 2, this

1254
01:01:50,110 --> 01:01:53,200
最终会给我一个程序，该程序将打印出来
will give me a program ultimately that will print out

1255
01:01:53,199 --> 01:01:54,729
所有这些偶数。
all of those even numbers.

1256
01:01:54,730 --> 01:01:55,780
因此，让我这样做。
So let me do this.

1257
01:01:55,780 --> 01:01:58,250
首先让我在这里进入一个程序。
First let me go into a program here.

1258
01:01:58,250 --> 01:01:59,649
我称它为count.py。
I'll call it count.py.

1259
01:01:59,650 --> 01:02:04,030
我将继续从0开始，直到但不超过101，
And I'm going to go ahead and start at 0, go up to but not through 101,

1260
01:02:04,030 --> 01:02:05,350
一次踩2。
stepping 2 at a time.

1261
01:02:05,349 --> 01:02:07,199
这次我要打印我。
And this time I'm going to print out i.

1262
01:02:07,199 --> 01:02:09,299
这也是Python的另一个便捷功能-
And here, too, another handy feature of Python--

1263
01:02:09,300 --> 01:02:11,730
没有更多的％s，也没有更多的％i。
no more %s, and also no more %i.

1264
01:02:11,730 --> 01:02:14,640
如果您要打印出名为i的变量的值，
If you want to print out the value of a variable called i,

1265
01:02:14,639 --> 01:02:18,119
只是说打印，打开括号，我，关闭括号。
just say print, open paren, i, close paren.

1266
01:02:18,119 --> 01:02:20,564
您不需要像C中一样的其他格式字符串。
You don't need another format string as in C.

1267
01:02:20,565 --> 01:02:24,570
现在让我继续并运行count.py的python，然后按Enter。
Let me go ahead now and run python of count.py, Enter.

1268
01:02:24,570 --> 01:02:26,070
它滚动得非常快。
And it scrolled by really fast.

1269
01:02:26,070 --> 01:02:28,350
但是请注意，它停止在100，并且如果我滚动
But notice that it stopped at 100, and if I scroll

1270
01:02:28,349 --> 01:02:30,809
到开始时，它从0开始。
to the beginning it started at 0.

1271
01:02:30,809 --> 01:02:31,614
因此，我深表歉意。
So my apologies.

1272
01:02:31,614 --> 01:02:33,419
Mea culpa较早将其弄乱了。
Mea culpa for messing that up earlier.

1273
01:02:33,420 --> 01:02:36,510
但是，这是介绍官方文档的绝佳机会
But what a wonderful opportunity to introduce the official documentation

1274
01:02:36,510 --> 01:02:39,930
对于Python，它将很快成为您的朋友，
for Python, which will soon become your friend,

1275
01:02:39,929 --> 01:02:42,599
乍一看似乎很神秘。
cryptic though it might feel at first glance.

1276
01:02:42,599 --> 01:02:43,359
好的。
All right.

1277
01:02:43,360 --> 01:02:45,840
让我们继续，然后重新访问另一个程序
Let's go ahead then and revisit one other program

1278
01:02:45,840 --> 01:02:47,400
是我们较早开始的。
that we started with earlier.

1279
01:02:47,400 --> 01:02:50,850
那个程序又是这个相对简单的Hello程序
And that program was again this relatively simple Hello program

1280
01:02:50,849 --> 01:02:52,709
在这种状态下我们放弃了。
that we left off in this state.

1281
01:02:52,710 --> 01:02:56,310
我们在Python中使用CS50库中的get_string函数。
We were using the get_string function from the CS50 library in Python.

1282
01:02:56,309 --> 01:02:59,159
我们有一个名为answer的变量正在获得回报
We had a variable called answer that was getting the return

1283
01:02:59,159 --> 01:03:01,019
该版本的get_string的值。
value of that version of get_string.

1284
01:03:01,019 --> 01:03:04,619
我们正在以某种方式打印“ hello”（逗号）。
And we were printing out "hello," comma, so-and-so.

1285
01:03:04,619 --> 01:03:07,619
而且我们正在使用该新的隐秘功能，但是很方便，
And we were using that new cryptic feature, but handy,

1286
01:03:07,619 --> 01:03:12,479
被称为格式字符串或f字符串，这仅表示替换所有内容
known as a format string or an f-string, which just means replace whatever's

1287
01:03:12,480 --> 01:03:14,717
用大括号括起来并带有实际值。
in curly braces with the actual value.

1288
01:03:14,717 --> 01:03:16,800
因此，让我们现在开始卸下训练轮
So let's start to now take off the training wheels

1289
01:03:16,800 --> 01:03:18,660
我们只是在一个小时前戴上了
that we just put on only an hour ago.

1290
01:03:18,659 --> 01:03:20,669
让我们摆脱CS50库。
Let's get rid of the CS50 library.

1291
01:03:20,670 --> 01:03:24,210
我们如何在不使用Python的情况下实际获得输入
How can we actually get input in Python without using

1292
01:03:24,210 --> 01:03:26,670
像CS50这样的人提供的图书馆？
a library from someone like CS50?

1293
01:03:26,670 --> 01:03:28,290
好吧，get_string不再存在。
Well, get_string no longer exists.

1294
01:03:28,289 --> 01:03:33,479
但值得庆幸的是，还有一个我们可以使用的函数，叫做输入。
But thankfully there is another function we can use called, quite simply, input.

1295
01:03:33,480 --> 01:03:38,730
输入是一个函数，与C和Python中的get_string非常相似，
Input is a function that, quite similar to get_string in both C and Python,

1296
01:03:38,730 --> 01:03:42,030
向用户提示一个短语，例如此处的“您叫什么名字？”；
prompts the user with a phrase, like this one here, "What's your name?";

1297
01:03:42,030 --> 01:03:45,120
等待他们键入一个值；当他们按下Enter键后，
waits for them to type in a value; and as soon as they hit Enter,

1298
01:03:45,119 --> 01:03:48,609
它会返回人类为您输入的内容。
it returns whatever the human has typed in for you.

1299
01:03:48,610 --> 01:03:52,800
因此，如果我现在继续执行并重新运行该程序，即hello.py的python，
So if I go ahead now and rerun this program, python of hello.py,

1300
01:03:52,800 --> 01:03:56,505
摆脱CS50库并使用输入代替get_string之后，
after getting rid of the CS50 library and using input instead of get_string,

1301
01:03:56,505 --> 01:03:57,810
我的名字是什么？
what's my name?

1302
01:03:57,809 --> 01:03:58,759
大卫。
David.

1303
01:03:58,760 --> 01:03:59,820
“你好，”逗号，“大卫”。
"Hello," comma, "David."

1304
01:03:59,820 --> 01:04:02,790
所以现在已经在那里，这是原始的原生Python
So already there now, this is raw, native Python

1305
01:04:02,789 --> 01:04:07,079
完全与CS50无关的代码。
code completely unrelated to anything CS50 specific.

1306
01:04:07,079 --> 01:04:10,259
但是，现在让我们继续前进，让我们最初继续使用CS50库，
But now let's go ahead, and let's keep using the CS50 library initially,

1307
01:04:10,260 --> 01:04:13,830
因为我们很快就会发现使用它的好处，
because we'll see that very quickly are there advantages of using it,

1308
01:04:13,829 --> 01:04:15,959
因为我们为您做了很多错误检查。
because we do a lot of error checking for you.

1309
01:04:15,960 --> 01:04:19,500
但是，我们最终也将完全取消这些训练轮。
But we'll eventually take those training wheels off entirely as well.

1310
01:04:19,500 --> 01:04:22,290
但是请注意，这样做确实相对简单。
But notice, indeed, how relatively simple it is to do so.

1311
01:04:22,289 --> 01:04:26,982
让我继续并打开我们预先编写的程序。
Let me go ahead and open up a program that we wrote in advance.

1312
01:04:26,983 --> 01:04:28,650
我将继续进行此操作。
And I'm going to go ahead and grab this.

1313
01:04:28,650 --> 01:04:31,510
与往常一样，可以在课程的网站上找到该文件。
This is available, as always, on the course's website.

1314
01:04:31,510 --> 01:04:35,850
我将继续打开一个名为additional0.c的文件，
And I'm going to go ahead and open a file called addition0.c,

1315
01:04:35,849 --> 01:04:37,829
这是我们之前真正见过的。
which we've actually seen before.

1316
01:04:37,829 --> 01:04:40,199
我要继续在这里做这个花哨的事情
And I'm going to go ahead and do this fancy thing here

1317
01:04:40,199 --> 01:04:43,349
稍后，我将在其中拆分窗口，以便
where, in just a moment, I'm going to split my window so

1318
01:04:43,349 --> 01:04:45,239
我一次可以看到两个文件。
that I can see two files at a time.

1319
01:04:45,239 --> 01:04:49,349
在这里，我将创建一个新文件，并将其命名为additioning.py。
And over here I'm going to create a new file, and I'll call this addition.py.

1320
01:04:49,349 --> 01:04:52,619
就是说，我只是暂时重新排列我的IDE
So that is to say, I'm just going to rearrange my IDE temporarily

1321
01:04:52,619 --> 01:04:56,399
今天，以便我们可以在左侧看到一种语言，C，然后
today so that we can see one language on the left, C, and then

1322
01:04:56,400 --> 01:04:58,872
Python中右侧的相应语言。
corresponding language on the right in Python.

1323
01:04:58,871 --> 01:05:01,079
同样，您可以在线下载所有这些示例
And again, you can download all these examples online

1324
01:05:01,079 --> 01:05:03,219
如果您想自己跟随。
if you'd like to follow along on your own.

1325
01:05:03,219 --> 01:05:06,819
因此，如果我要将左侧的程序翻译为右侧的程序，
So if I'm translating this program on the left to this program on the right,

1326
01:05:06,820 --> 01:05:09,810
让我们首先回顾一下左侧程序的实际操作。
let's first recall what the program on the left actually did.

1327
01:05:09,809 --> 01:05:13,499
这个程序提示用户输入x，提示用户输入y，
This was a program that prompts the user for x, prompts the user for y,

1328
01:05:13,500 --> 01:05:15,720
并且非常简单地对两者进行加法运算。
and quite simply performs addition on the two.

1329
01:05:15,719 --> 01:05:18,299
这是第1周的内容，可以追溯到现在。
So this is week 1 stuff, way back when now.

1330
01:05:18,300 --> 01:05:19,990
好吧，让我们继续翻译一下。
Well, let's go ahead and translate this.

1331
01:05:19,989 --> 01:05:22,621
我将使用CS50库中的get_int函数，
I will use the get_int function from the CS50 library,

1332
01:05:22,621 --> 01:05:25,079
因为这将使我的生活现在更轻松一些。
because it's going to make my life a little easier for now.

1333
01:05:25,079 --> 01:05:28,259
我要说的是从cs50 import get_int。
I'm going to say from cs50 import get_int.

1334
01:05:28,260 --> 01:05:30,990
我将继续使用，并从用户那里获取一个int
I'm going to then go ahead and get an int from the user using

1335
01:05:30,989 --> 01:05:32,819
get_int并提示他们输入x。
get_int and prompting them for x.

1336
01:05:32,820 --> 01:05:36,390
然后，我将从用户那里获取一个整数，提示他们输入y。
I'm going to then go ahead and get an int from the user prompting them for y.

1337
01:05:36,389 --> 01:05:41,699
然后，我将继续打印，例如，打印出x加y。
I'm going to then finally go ahead and, let's say, print out x plus y.

1338
01:05:41,699 --> 01:05:45,689
让我继续这里并运行additioning.py的python。
And let me go ahead down here and run python of addition.py.

1339
01:05:45,690 --> 01:05:50,310
现在提示我输入x，让我们输入1，y，让我们输入2，瞧，
I'm now being prompted for x, let's type in 1, y, let's type in 2, and voila,

1340
01:05:50,309 --> 01:05:52,139
3是我的程序在这里。
3 is my program here.

1341
01:05:52,139 --> 01:05:53,519
非常简单。
So pretty straightforward.

1342
01:05:53,519 --> 01:05:56,549
更少的代码行，因为其中之一，我没有这些不必要的代码
Fewer lines of code, because one, I don't have these unnecessary

1343
01:05:56,550 --> 01:05:58,600
包括stdio.h。
includes like stdio.h.

1344
01:05:58,599 --> 01:06:00,354
我没有花括号。
I don't have any of the curly braces.

1345
01:06:00,355 --> 01:06:02,230
公平地说，我没有任何评论。
To be fair, I don't have any of the comments.

1346
01:06:02,230 --> 01:06:03,272
因此，让我写评论。
So let me write comments.

1347
01:06:03,271 --> 01:06:05,969
在Python中，它将是一个不同的符号。
In Python, it's going to be a different symbol.

1348
01:06:05,969 --> 01:06:12,959
现在应在“提示用户输入x”前面加上一个井号，而不是//。
"Prompt user for x" should be prefixed with a hash symbol now instead of a //.

1349
01:06:12,960 --> 01:06:18,300
我将继续提示用户输入y，然后在这里执行加法操作。
I'll go ahead and prompt user for y, and then, how about here, perform addition.

1350
01:06:18,300 --> 01:06:19,890
但即使如此，它仍然很紧。
But even still, it's pretty tight.

1351
01:06:19,889 --> 01:06:23,964
仅有10行代码，其中有一些注释。
It's only 10 lines of code with some of those comments there.

1352
01:06:23,965 --> 01:06:26,590
好吧，那我可以做什么呢？
All right, well, what might I do that's a little bit different?

1353
01:06:26,590 --> 01:06:27,990
好吧，让我们卸下训练轮。
Well, let's take off the training wheels.

1354
01:06:27,989 --> 01:06:30,739
让我们卸下训练轮，摆脱CS50库
Let's take off the training wheels and get rid of the CS50 library

1355
01:06:30,739 --> 01:06:32,879
再次在这里获取输入。
again and get input here.

1356
01:06:32,880 --> 01:06:36,240
好吧，如果我继续在这里获得输入，在这里获得输入，
Well, if I go ahead and get input here, get input here,

1357
01:06:36,239 --> 01:06:40,229
将值分别分配给x和y，我现在要继续
assigning the values to x and y respectively, I'm going to go ahead now

1358
01:06:40,230 --> 01:06:44,340
并运行additioning.py的python。
and run python of addition.py.

1359
01:06:44,340 --> 01:06:48,540
x将再次为1，y将再次为2，答案当然是-
x will be 1 again, y will be 2 again, and the answer, of course, is--

1360
01:06:48,539 --> 01:06:49,789
12
12.

1361
01:06:49,789 --> 01:06:52,559
好吧，那是错误的。
Well, that's wrong.

1362
01:06:52,559 --> 01:06:55,019
这是怎么回事？
What's going on?

1363
01:06:55,019 --> 01:06:59,419
我怎么已经搞砸了这样一个简单的程序？
How did I screw up such a simple program already?

1364
01:06:59,420 --> 01:07:02,850
尽管对我来说是一种新的语言，Python。
Albeit in a new language for me, Python.

1365
01:07:02,849 --> 01:07:03,949
我在这里做什么？
What did I do here?

1366
01:07:03,949 --> 01:07:05,299
是的，本？
Yeah, Ben?

1367
01:07:05,300 --> 01:07:08,387
听众：因为实际上是把它当作两个字符串，
AUDIENCE: Because it's really taking it in as two strings,

1368
01:07:08,387 --> 01:07:10,220
所以只是将它们彼此相邻
so it's just putting them next to each other

1369
01:07:10,219 --> 01:07:12,019
而不是对它进行实际的数学计算。
as opposed to doing the actual math on it.

1370
01:07:12,019 --> 01:07:13,634
它没有像int那样读取它。
It's not reading it as in int.

1371
01:07:13,635 --> 01:07:14,510
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

1372
01:07:14,510 --> 01:07:17,270
因此，输入，Python附带的此功能，
So input, this function that comes with Python,

1373
01:07:17,269 --> 01:07:19,504
确实类似于Cs50的get_string。
really is analogous to Cs50's get_string.

1374
01:07:19,505 --> 01:07:21,380
无论人类是什么类型，
No matter what the human types, it's going

1375
01:07:21,380 --> 01:07:25,370
返回为键盘输入字符或ASCII字符，
to come back as keyboard input characters, or ASCII characters,

1376
01:07:25,369 --> 01:07:27,259
或过去几周的Unicode字符。
or Unicode characters from weeks past.

1377
01:07:27,260 --> 01:07:29,052
即使它们看起来像数字，也不是
Even if they look like numbers, they're not

1378
01:07:29,052 --> 01:07:32,990
除非我们强制如此，否则将被视为数字（也称为整数）。
going to be treated as numbers, a.k.a., integers, unless we coerce them so.

1379
01:07:32,989 --> 01:07:37,549
现在请记住，在C语言中，我们具有将值从一个值转换到另一个值的功能。
Now remember in C, we had this ability to cast values from one to another.

1380
01:07:37,550 --> 01:07:40,170
强制转换是指将一种数据类型转换为另一种数据类型。
Casting meant to convert one data type to another.

1381
01:07:40,170 --> 01:07:44,150
我们被允许这样做，以便将char转换为int或将ints转换为char，
And we were allowed to do that for chars to ints or ints to chars,

1382
01:07:44,150 --> 01:07:48,668
但对于字符串到整数或从整数到字符串，您无法执行此操作。
but you could not do it for strings to ints, or from ints to strings.

1383
01:07:48,668 --> 01:07:50,210
为此，我们需要特殊的功能。
For that we needed special functions.

1384
01:07:50,210 --> 01:07:53,520
你们中有些人可能曾经使用过atoi，ASCII到int，
And some of you might have used atoi, ASCII to int,

1385
01:07:53,519 --> 01:07:56,959
这实际上是一个功能，可以查看ASCII中的所有字符
which was a function that actually looks at all of the characters in an ASCII

1386
01:07:56,960 --> 01:07:59,690
字符串并将其转换为相应的整数。
string and converts it to the corresponding integer.

1387
01:07:59,690 --> 01:08:02,040
坦白说，在Python中，它要简单一些。
In Python, frankly, it's a little simpler.

1388
01:08:02,039 --> 01:08:04,319
我们可以将它从一件事投射到另一件事。
We can just cast it from one thing to another.

1389
01:08:04,320 --> 01:08:08,270
所以我要继续进行并转换输入的返回值
So I'm going to go ahead and cast the return value of input

1390
01:08:08,269 --> 01:08:11,389
作为使用此，诠释。
as using this, int.

1391
01:08:11,389 --> 01:08:16,009
我将对y进行同样的操作，在此处传递输入的返回值
And I'm going to do the same for y, passing the return value of input there

1392
01:08:16,010 --> 01:08:18,620
将看起来像字符串的东西转换为-
to convert what looks like a string to what's--

1393
01:08:18,619 --> 01:08:21,799
看起来像int的东西实际上是int的东西。
what looks like an int to what's actually an int.

1394
01:08:21,800 --> 01:08:25,399
现在，让我继续执行附加操作，addition.py的python。
And now let me go ahead and perform the additions again, python of addition.py.

1395
01:08:25,399 --> 01:08:27,830
并注意这次，希望能达到Ben的观点，
And notice this time, hopefully to Ben's point,

1396
01:08:27,829 --> 01:08:31,528
正如我们所见，它不会连接两个字符串
it's not going to concatenate two strings, as we saw

1397
01:08:31,529 --> 01:08:34,790
当左右有两个字符串时，是默认的加号行为。
is the default behavior of plus when you have two strings left and right.

1398
01:08:34,789 --> 01:08:39,289
希望现在它将在x等于1，y等于2上做一个do加法。
Hopefully now it will do a do addition on x equals 1, y equals 2.

1399
01:08:39,289 --> 01:08:42,309
瞧，现在我们重新营业了。
And voila, now we're back in business.

1400
01:08:42,310 --> 01:08:47,479
但是，如果我不是最合作或最敏锐的用户，该怎么办？
However, what if I'm not the most cooperative or sharp user,

1401
01:08:47,479 --> 01:08:50,090
并输入x的“ cat”？
and I type in "cat" for x?

1402
01:08:50,090 --> 01:08:52,950
现在一些疯狂的事情开始发生。
Now some crazy stuff starts to happen.

1403
01:08:52,949 --> 01:08:55,728
因此请注意，我们在以下情况下触发了第一个错误
So notice we've triggered our very first error when

1404
01:08:55,729 --> 01:08:58,520
涉及到运行一个程序，而我的程序甚至不会
it comes to running a program whereby my program won't even

1405
01:08:58,520 --> 01:08:59,660
首先运行。
run in the first place.

1406
01:08:59,659 --> 01:09:02,179
并请注意，我在这里得到一些含糊的语法-
And notice I'm getting some somewhat cryptic syntax here--

1407
01:09:02,180 --> 01:09:06,319
追溯，最近一次调用，文件addition.py第2行。
traceback, most recent call last, file addition.py line 2.

1408
01:09:06,319 --> 01:09:07,819
好吧，至少是熟悉的。
All right, that's at least familiar.

1409
01:09:07,819 --> 01:09:09,800
我在2号线的某个地方搞砸了。
I screwed up somewhere on line 2.

1410
01:09:09,800 --> 01:09:11,970
它在这里向我显示了代码行。
It's showing me the line of code here.

1411
01:09:11,970 --> 01:09:16,729
并说“ ValueError-以10为基数的int无效的文字，猫。”
And it's saying "ValueError-- invalid literal for int with base 10, cat."

1412
01:09:16,729 --> 01:09:19,430
这是一个非常神秘的说法，我只是
That's a very cryptic way of saying I just

1413
01:09:19,430 --> 01:09:23,750
尝试将非整数的内容转换为整数。
have tried to cast something that's not an integer to an integer.

1414
01:09:23,750 --> 01:09:26,600
因此，这就是为什么我们使用CS50库之类的原因。
And so this is why we use things like the CS50 library.

1415
01:09:26,600 --> 01:09:28,970
编写所有代码实际上有点烦人
It's actually kind of annoying to write all of the code

1416
01:09:28,970 --> 01:09:32,450
检查并确保用户是否键入了一个数字，并且只键入了一个数字，
that checks and makes sure did the user type in a number and only a number,

1417
01:09:32,449 --> 01:09:35,269
而不是“ cat”或“ dog”或其他一些神秘的字符串。
and not "cat" or "dog" or some other cryptic string.

1418
01:09:35,270 --> 01:09:38,450
我们自己现在必须实施这种错误检查
We ourselves now would have to implement that kind of error checking

1419
01:09:38,449 --> 01:09:40,249
如果我们不想使用CS50库。
if we don't want to use the CS50 library.

1420
01:09:40,250 --> 01:09:41,429
因此，需要进行权衡。
So there, trade-off.

1421
01:09:41,430 --> 01:09:43,760
也许您自己编写所有代码感到更自在。
Maybe you feel more comfortable writing all of the code yourself.

1422
01:09:43,760 --> 01:09:46,552
您不想在互联网的图书馆中使用一些随意的人，
You don't want to use some random person on the internet's library,

1423
01:09:46,551 --> 01:09:49,759
无论是CS50还是别人的CS50，即使它是免费开放源代码。
whether it's CS50's or someone else's, even if it's free and open source.

1424
01:09:49,760 --> 01:09:51,140
您想自己写。
You want to write it yourself.

1425
01:09:51,140 --> 01:09:51,880
好的。
OK, fine.

1426
01:09:51,880 --> 01:09:53,630
如果你想自己写，现在我已经
If you want to write it yourself, now I've

1427
01:09:53,630 --> 01:09:56,630
必须添加更多代码行进行检查，
got to add a bunch more lines of code to check,

1428
01:09:56,630 --> 01:10:00,260
人类是一个接一个的十进制数字输入，还是他们
did the human type in a decimal digit one after the other, or did they

1429
01:10:00,260 --> 01:10:02,490
输入其他ASCII字符？
type in other ASCII characters?

1430
01:10:02,489 --> 01:10:05,299
同样，使用库之间的折衷并非如此。
So again, trade-off between using libraries are not.

1431
01:10:05,300 --> 01:10:10,100
通常，答案将是使用公共库来做-
Generally, the answer is going to be use a common library to do--

1432
01:10:10,100 --> 01:10:12,110
解决这类问题。
to solve these kinds of problems.

1433
01:10:12,109 --> 01:10:14,519
好吧，让我们继续进行一些更改。
Well, let's go ahead and change the program a little bit.

1434
01:10:14,520 --> 01:10:20,810
让我继续打开一个名为divation.py的新文件，
Let me go ahead and open a new file called division.py just

1435
01:10:20,810 --> 01:10:22,490
在这里做一些划分。
to do a bit of division here.

1436
01:10:22,489 --> 01:10:25,039
让我在右侧继续进行复制
And let me go ahead on the right-hand side and copy

1437
01:10:25,039 --> 01:10:28,439
粘贴我们之前所做的操作，但只需在此处更改为除法即可。
paste what we did before, but just change to division here.

1438
01:10:28,439 --> 01:10:31,309
让我继续将x除以y。
Let me go ahead and divide x by y.

1439
01:10:31,310 --> 01:10:33,830
我继续输入1代表x，输入2代表y。
And I keep typing in 1 for x, 2 for y.

1440
01:10:33,829 --> 01:10:36,889
稍后，我将运行Division.py的python并输入
In a moment I'm going to run python of division.py and type

1441
01:10:36,890 --> 01:10:38,900
x为1，y为2。
in 1 for x and 2 for y.

1442
01:10:38,899 --> 01:10:44,779
但是在我按Enter键之前，如果这是C语言程序，答案是什么？
But before I hit Enter, if this were a program in C, what would the answer be?

1443
01:10:44,779 --> 01:10:47,239
如果需要，请随时在聊天中回复。
Feel free to just respond in the chat if you'd like.

1444
01:10:47,239 --> 01:10:51,049
如果这是C语言中的程序，而我将x除以y，
If this were a program in C, and I'm dividing x by y,

1445
01:10:51,050 --> 01:10:54,860
从第一周开始，我每周会得到什么？
what would I have gotten in week 1 and every week since, Brian?

1446
01:10:54,859 --> 01:10:56,571
布莱恩：共识看起来像0。
BRIAN: The consensus looks like 0.

1447
01:10:56,572 --> 01:10:58,280
戴维·马兰（David MALAN）：是的，因为被截断了。
DAVID MALAN: Yeah, because of truncation.

1448
01:10:58,279 --> 01:11:04,649
如果将1除以2，则当然是1/2或0.5，则0.5是浮点数。
If 1 divided by 2, of course, is 1/2, or 0.5, 0.5 is a float.

1449
01:11:04,649 --> 01:11:07,339
但是，如果我正在处理整数，即使它是隐式的
But if I'm dealing with integers, even though it's implicitly

1450
01:11:07,340 --> 01:11:11,180
到目前为止的整数，现在我已经将其强制转换为整数，
integers thus far, and now explicitly now that I've casted them,

1451
01:11:11,180 --> 01:11:14,360
我似乎会丢掉0.5，然后又回到0。
I would seem to throw away the 0.5 and just get back 0.

1452
01:11:14,359 --> 01:11:18,289
但是让我继续运行python的division.py并将x等于1，
But let me go ahead and run python of division.py and putting x equals 1,

1453
01:11:18,289 --> 01:11:19,189
y等于2。
y equals 2.

1454
01:11:19,189 --> 01:11:24,589
哇，哇，这是C语言中最令人讨厌的功能之一，或者说缺乏功能，
And voila, wow, one of the most annoying features, or lack of features in C,

1455
01:11:24,590 --> 01:11:25,820
似乎是-
seems to have been--

1456
01:11:25,819 --> 01:11:29,879
在Python中似乎可以通过除以所需的方式来解决。
seems to have been solved in Python by division doing what you want.

1457
01:11:29,880 --> 01:11:32,540
如果您在Python中将一个整数除以另一个，
And if you divide one integer by another in Python,

1458
01:11:32,539 --> 01:11:35,659
事实证明，今天的语言还有其他功能之一
it turns out one of the other features of today's language

1459
01:11:35,659 --> 01:11:37,909
是它可以满足程序员的要求
is that it does what you the programmer would

1460
01:11:37,909 --> 01:11:42,079
无需花草就可以期待花车的细微差别
expect, without having to get into the weeds, of the nuances of floats

1461
01:11:42,079 --> 01:11:42,589
和整数。
and ints.

1462
01:11:42,590 --> 01:11:46,220
只是引用而已，请取消引用“正确的事情”。
Just does the quote, unquote "right thing" instead.

1463
01:11:46,220 --> 01:11:50,720
好吧，我还是从第一周开始在这里打开另一个程序。
Well, let me go ahead and open up another program here, also from week 1.

1464
01:11:50,720 --> 01:11:54,425
这被称为conditions.c。
This one was called conditions.c.

1465
01:11:54,425 --> 01:11:58,340
这一个-给我一点时间在左侧打开它-
And this one-- give me one moment to open this up on the left--

1466
01:11:58,340 --> 01:12:01,520
这是一个程序，其目的是生活
this one here was a program whose purpose in life

1467
01:12:01,520 --> 01:12:04,910
是要从名为x的用户那里获取一个int，然后再获取一个名为y的用户。
was to get an int from the user called x, get another called y.

1468
01:12:04,909 --> 01:12:08,839
然后它就这样做了-如果x小于y，则打印出尽可能多的内容。
And then it just did this-- if x less than y, print out as much.

1469
01:12:08,840 --> 01:12:12,412
否则，如果x大于y，则打印尽可能多的内容，依此类推。
Else if x greater than y, print out as much, and so forth.

1470
01:12:12,412 --> 01:12:14,120
让我们继续翻译这个程序
Let's go ahead and translate this program

1471
01:12:14,119 --> 01:12:18,349
使用我们已经看到的一些语法转换为相应的Python代码。
into the corresponding Python code using some of the syntax we've seen already.

1472
01:12:18,350 --> 01:12:20,560
我将继续并将其保存为conditions.py。
I'm going to go ahead and save this as conditions.py.

1473
01:12:20,560 --> 01:12:22,310
我想我要继续
And I think I'm going to go ahead and keep

1474
01:12:22,310 --> 01:12:24,350
使用该库，CS50库，以便我
using the library, the CS50 library, so that I

1475
01:12:24,350 --> 01:12:26,900
不必担心这些错误
don't have to worry about those kinds of errors

1476
01:12:26,899 --> 01:12:29,139
当向另一个输入错误的输入时。
when casting bad input to another.

1477
01:12:29,140 --> 01:12:31,910
因此，从cs50导入get_int。
So from cs50 import get_int.

1478
01:12:31,909 --> 01:12:36,049
让我继续，现在从用户那里获取一个int，称为x。
And let me go ahead and now get an int from the user, calling it x.

1479
01:12:36,050 --> 01:12:39,560
让我们继续从用户那里获取一个int，将其称为y。
Let's go ahead and get an int from the user, calling it y.

1480
01:12:39,560 --> 01:12:42,470
我不会为了时间的缘故而这次打扰评论。
And I won't bother typing comments this time, just for time's sake.

1481
01:12:42,470 --> 01:12:43,820
现在让我问一个问题。
And now let me ask the question.

1482
01:12:43,819 --> 01:12:46,459
在C语言中，如果x小于y，我会做的。
In C, I would have done if x less than y.

1483
01:12:46,460 --> 01:12:48,050
Python更加简洁。
Python's a little more terse.

1484
01:12:48,050 --> 01:12:50,900
如果x小于y就足够了，但是带有冒号。
If x less than y suffices, but with a colon.

1485
01:12:50,899 --> 01:12:55,379
在此之下，我将继续说“ x小于y”。
Under that, I'm going to go ahead and say print "x is less than y."

1486
01:12:55,380 --> 01:12:57,860
Elif-这很奇怪-
Elif-- this is the weird one--

1487
01:12:57,859 --> 01:13:02,419
x大于y，请继续打印“ x大于y”。
x is greater than y, go ahead and print out "x is greater than y."

1488
01:13:02,420 --> 01:13:09,050
然后，还有一个冒号，打印出“ x等于y”。
And then else, also with a colon, print out "x is equal to y."

1489
01:13:09,050 --> 01:13:11,250
我想就是这样。
And I think that's just about it.

1490
01:13:11,250 --> 01:13:15,020
我将继续在这里运行python的conditions.py。
I'm going to go ahead down here and run python of conditions.py.

1491
01:13:15,020 --> 01:13:19,040
我将输入1，将输入2，实际上x小于y。
I'll type in 1, I'll type in 2, and indeed x is less than y.

1492
01:13:19,039 --> 01:13:22,039
我将再次运行它，这次是2和1。
I'll run it again, this time with 2 and 1.

1493
01:13:22,039 --> 01:13:23,689
X大于y。
X is greater than y.

1494
01:13:23,689 --> 01:13:25,879
我再用1和1再次运行它。
And let me run it again with 1 and 1.

1495
01:13:25,880 --> 01:13:27,230
X等于y。
X is equal to y.

1496
01:13:27,229 --> 01:13:28,459
所以这似乎奏效了。
So that seems to have worked.

1497
01:13:28,460 --> 01:13:30,002
让我指出另一件事。
And let me point out one other thing.

1498
01:13:30,002 --> 01:13:33,230
我之前提到过，您还有其他速记语法，其中
I mentioned earlier that you have this other shorthand syntax where

1499
01:13:33,229 --> 01:13:36,649
如果您不想打扰，可以说导入CS50库
you can just say import the CS50 library if you don't want to bother typing out

1500
01:13:36,649 --> 01:13:37,999
各个函数的名称。
individual function names.

1501
01:13:38,000 --> 01:13:39,510
没关系的
That's totally fine.

1502
01:13:39,510 --> 01:13:42,470
但是请注意，IDE在第3行和第4行对我大吼大叫
But notice that the IDE is yelling at me at lines 3 and 4

1503
01:13:42,470 --> 01:13:44,820
该get_int不再被识别。
that get_int is no longer recognized.

1504
01:13:44,819 --> 01:13:46,999
那是因为Python支持此功能，
That's because Python supports this feature,

1505
01:13:47,000 --> 01:13:52,009
使用其他人的库时，它可以为您命名。
when using other people's libraries, that it can namespace them for you.

1506
01:13:52,010 --> 01:13:55,910
也就是说，您不能再直接引用get_int。
That is to say, you can't refer to get_int anymore directly.

1507
01:13:55,909 --> 01:13:59,989
您必须更明确地说，调用
You have to more explicitly say, call the get_int function that's

1508
01:13:59,989 --> 01:14:02,629
在CS50库中。
inside of the CS50 library.

1509
01:14:02,630 --> 01:14:05,510
同样，使用我们熟悉的点运算符，
And so again, using our familiar dot operator,

1510
01:14:05,510 --> 01:14:08,810
意味着像C结构一样进入该CS50库，
means go inside of that CS50 library, just like a C struct,

1511
01:14:08,810 --> 01:14:11,870
并在其中调用名为get_int的函数。
and call the function called get_int therein.

1512
01:14:11,869 --> 01:14:15,829
因此，我现在可以继续并重新运行此代码，即conditions.py的python，
So I can now go ahead and rerun this, python of conditions.py,

1513
01:14:15,829 --> 01:14:19,559
输入1和1，瞧，代码现在又可以工作了。
typing in 1 and 1, and voila, the code is now working again.

1514
01:14:19,560 --> 01:14:20,390
那么哪个更好呢？
So which is better?

1515
01:14:20,390 --> 01:14:21,080
这取决于。
It depends.

1516
01:14:21,079 --> 01:14:23,749
我的意思是，如果只写get_int更具可读性
I mean, if it's sort of more readable to just write get_int

1517
01:14:23,750 --> 01:14:26,916
到处都可以为您节省很多按键操作-您不需要
all over the place, that's going to save you a lot of keystrokes-- you don't

1518
01:14:26,917 --> 01:14:28,866
必须继续输入cs50点，cs50点。
have to keep typing cs50 dot, cs50 dot.

1519
01:14:28,865 --> 01:14:31,249
但是，如果您正在编写一个非常大的程序，
If, though, you're writing a pretty big program,

1520
01:14:31,250 --> 01:14:35,299
也许您正在使用两个都实现的不同库
and maybe you're using two different libraries that both implement

1521
01:14:35,300 --> 01:14:37,460
一个名为get_int的函数，您想成为
a function called get_int, you want to be

1522
01:14:37,460 --> 01:14:39,870
能够将彼此区分开。
able to distinguish one from the other.

1523
01:14:39,869 --> 01:14:42,709
因此，您可能只想按库的名称导入它们，
So you might want to just import the libraries by their name,

1524
01:14:42,710 --> 01:14:46,290
然后在函数调用前面加上前缀，就像我在这里所做的那样，
and then prefix the function calls, as I've done here,

1525
01:14:46,289 --> 01:14:47,749
这称为命名空间。
which is known as namespacing.

1526
01:14:47,750 --> 01:14:51,020
Namespacing意味着您可以拥有两个名称相同的变量
Namespacing means that you can have two identically named variables

1527
01:14:51,020 --> 01:14:54,470
或存在于两个不同名称空间中的函数。
or functions existing in two different namespaces.

1528
01:14:54,470 --> 01:14:57,440
只要它们在里面，它们就不会碰撞
They don't collide, so long as they are inside

1529
01:14:57,439 --> 01:15:02,299
CS50库的名称或其他库的名称。
of the CS50 library or some other library's name instead.

1530
01:15:02,300 --> 01:15:04,530
让我在这里根据条件做另一件事。
Let me do one other thing with conditions here.

1531
01:15:04,529 --> 01:15:07,849
让我继续，打开第一周的另一个文件。
Let me go ahead and open up another file from week 1.

1532
01:15:07,850 --> 01:15:10,790
这个人是同意的。c。
This one was agree.c.

1533
01:15:10,789 --> 01:15:17,359
并且该程序提示用户输入他们是否同意。
And this program prompted the user to input whether or not they agree.

1534
01:15:17,359 --> 01:15:21,709
我们好奇地检查了第一周是否使用等于
And we checked a little curiously that first week using equals

1535
01:15:21,710 --> 01:15:26,930
等于引号，不引号“ Y”或小写字母“ y”，或引号，不引号大写字母“ N”
equals quote, unquote "Y" or lowercase "y," or quote, unquote capital "N"

1536
01:15:26,930 --> 01:15:28,385
或小写的“ n”。
or lowercase "n."

1537
01:15:28,385 --> 01:15:30,260
好吧，我们如何进行转换呢？
Well, how do we go about converting this one?

1538
01:15:30,260 --> 01:15:32,520
让我继续，给我自己一个新文件。
Let me go ahead and give myself a new file over here.

1539
01:15:32,520 --> 01:15:35,390
在这种情况下，我称其为同意。
I'll call it agree.py in this case.

1540
01:15:35,390 --> 01:15:38,510
事实证明，我们可以通过几种不同的方式解决这一问题。
And it turns out we can solve this one in a few different ways.

1541
01:15:38,510 --> 01:15:42,950
让我继续，从CS50 get_int导入开始，
Let me go ahead and start off by importing from CS50 get_int,

1542
01:15:42,949 --> 01:15:46,189
只是因为-哦，不，get_string，而是因为它很方便。
just because it's-- oh, no, get_string, rather, because it's convenient.

1543
01:15:46,189 --> 01:15:49,199
让我继续通过get_string获取用户的输入
Let me go ahead and get the user's input via get_string

1544
01:15:49,199 --> 01:15:53,509
并问他们相同的问题，“您是否同意”，问号带有空格。
and ask them the same question, "Do you agree," question mark with a space.

1545
01:15:53,510 --> 01:15:54,350
然后让我检查一下。
Then let me check.

1546
01:15:54,350 --> 01:16:01,760
如果s等于引号，请取消引号“ Y”，或者s等于小写字母“ y”，然后
If s equals equals quote, unquote "Y" or s equals equals lowercase "y," then

1547
01:16:01,760 --> 01:16:04,970
我将继续打印“同意”。
I'm going to go ahead and print out "Agreed."

1548
01:16:04,970 --> 01:16:11,680
否则-哦，不，省略号等于大写字母“ N”
Else-- oh, no, elif s equals equals capital "N"

1549
01:16:11,680 --> 01:16:17,860
或s等于小写字母“ n”，让我继续在此处打印报价，
or s equals equals lowercase "n," let me go ahead and print out here quote,

1550
01:16:17,859 --> 01:16:20,529
取消引号，“不同意”。
unquote, "Not agreed."

1551
01:16:20,529 --> 01:16:22,929
我认为应该这样做。
And I think that should do it.

1552
01:16:22,930 --> 01:16:25,120
但是这里有些奇怪。
But something's weird here.

1553
01:16:25,119 --> 01:16:27,249
有一些区别。
There's a few differences.

1554
01:16:27,250 --> 01:16:31,089
是什么让您与C格格不入？
What strikes you as different from C?

1555
01:16:31,090 --> 01:16:33,640
您现在必须打破什么肌肉记忆
What muscle memory might you have to break now

1556
01:16:33,640 --> 01:16:37,660
当使用带有多个布尔表达式的条件时
when using conditions with multiple Boolean expressions

1557
01:16:37,659 --> 01:16:39,511
以这种方式结合？
combined in this way?

1558
01:16:39,511 --> 01:16:40,719
还有另一个微妙之处。
And there's another subtlety.

1559
01:16:40,720 --> 01:16:43,660
C和Python之间至少有两个明显的区别
There's at least two salient differences between C and Python

1560
01:16:43,659 --> 01:16:45,159
仅以这个例子为例。
with just this example alone.

1561
01:16:48,100 --> 01:16:51,600
在聊天中有任何想法或[听不清]？
Any thoughts in chat or [INAUDIBLE]?

1562
01:16:51,600 --> 01:16:52,100
瑞安
Ryan?

1563
01:16:52,100 --> 01:16:53,892
听众：我要说的是这个
AUDIENCE: I was going to say, for this one,

1564
01:16:53,891 --> 01:16:56,299
而不是将符号用于逻辑运算符，
instead of using the symbols for the logical operators,

1565
01:16:56,300 --> 01:16:57,990
您可以直接输入文字。
you can just type the text directly.

1566
01:16:57,989 --> 01:16:58,739
戴维·马兰：是的。
DAVID MALAN: Yeah.

1567
01:16:58,739 --> 01:17:01,019
我们可以从字面上键入英文单词“或”
We can literally just type the English word "or"

1568
01:17:01,020 --> 01:17:03,150
如果我们要表达逻辑或。
if we want to express a logical or.

1569
01:17:03,149 --> 01:17:06,444
因此，在C中，回想一下左侧，我们将完成此垂直条
So in C, recall on the left, we would have done this vertical bar

1570
01:17:06,444 --> 01:17:07,319
东西，这很好。
thing, which is fine.

1571
01:17:07,319 --> 01:17:08,139
你会习惯的。
You get used to it.

1572
01:17:08,140 --> 01:17:10,770
但这不是很可读，至少在任何英语意义上都是如此。
But it's not very readable, at least in any English sense.

1573
01:17:10,770 --> 01:17:13,470
Python采用了更频繁使用的方法
Python took the approach of using more frequently

1574
01:17:13,470 --> 01:17:17,628
实际上是从左到右阅读的实际英语或类似英语的单词。
actual English or English-like words that actually do read left to right.

1575
01:17:17,627 --> 01:17:19,169
实际上，这里正在出现一个主题。
And indeed, a theme is emerging here.

1576
01:17:19,170 --> 01:17:22,740
当您阅读Python代码时，它更接近英语
When you read Python code, it is closer to English

1577
01:17:22,739 --> 01:17:26,039
比起C来说，是因为您不会碰到太多的标点符号。
than C is, because you don't trip over as much punctuation.

1578
01:17:26,039 --> 01:17:29,339
每行Python代码都倾向于阅读更多内容
Each line of Python code tends to read a little more

1579
01:17:29,340 --> 01:17:32,190
例如英语短语或英语句子。
like an English phrase or an English sentence.

1580
01:17:32,189 --> 01:17:33,929
这里还有另一个微妙之处。
And there's one other subtlety here.

1581
01:17:33,930 --> 01:17:37,470
在第1周的左后方，我小心使用单引号
On the left back in week 1, I took care to use single quotes

1582
01:17:37,470 --> 01:17:39,600
在Ys和Ns周围。
around the Ys and the Ns.

1583
01:17:39,600 --> 01:17:41,620
这周我用双引号。
This week I'm using double quotes.

1584
01:17:41,619 --> 01:17:43,839
但老实说，这实际上并不重要。
But to be honest, it actually doesn't matter.

1585
01:17:43,840 --> 01:17:48,360
只要我保持一致，我也可以在任何地方都使用单引号。
I can alternatively use single quotes everywhere, so long as I'm consistent.

1586
01:17:48,359 --> 01:17:50,609
但是在Python中没有根本的区别
But in Python there is no fundamental difference

1587
01:17:50,609 --> 01:17:54,629
只要您保持一致，就可以在双引号和单引号之间进行选择。
between double quotes and single quotes, so long as you are consistent.

1588
01:17:54,630 --> 01:17:58,050
原因是，当我们查看C之间存在的数据类型时
The reason being, when we looked at the data types that existed between C

1589
01:17:58,050 --> 01:18:03,030
而现在，Python，没有出现在Python数据类型列表中的是char。
and now Python, absent from the list of Python data types was char.

1590
01:18:03,029 --> 01:18:06,599
在Python中，没有像单个字符这样的东西。
In Python there is no such thing as an individual char.

1591
01:18:06,600 --> 01:18:09,810
所有基于字符的内容都是一个字符串。
Everything that's character-based is a string.

1592
01:18:09,810 --> 01:18:13,650
即使只有一个字符长，也都是字符串。
Even if it's just one character long, everything is a string.

1593
01:18:13,649 --> 01:18:16,289
缺点是我们没有非常精细的控制。
Downside is we don't have quite as fine grained control.

1594
01:18:16,289 --> 01:18:21,354
好处是，这些字符串结构为我们提供了更多功能，
Upside is we get a lot more features with those string structures,

1595
01:18:21,354 --> 01:18:23,729
正如我们已经看到的，例如，做某事
as we've already seen with, for instance, doing something

1596
01:18:23,729 --> 01:18:26,624
就像那些大写字母一样。
like uppercase with those as well.

1597
01:18:26,625 --> 01:18:27,750
好吧，让我继续-
Well, let me go ahead and--

1598
01:18:27,750 --> 01:18:29,310
我想我可以简化一下。
I think I can simplify this.

1599
01:18:29,310 --> 01:18:32,550
例如，假设我想容忍类似“ Y”之类的东西
For instance, suppose I wanted to tolerate something like not just "Y"

1600
01:18:32,550 --> 01:18:34,980
或“ y”（大写或小写）。
or "y," in uppercase or lowercase.

1601
01:18:34,979 --> 01:18:40,229
假设我也想容忍大写或小写的“是”。
Suppose I wanted to also tolerate "Yes" in uppercase or lowercase as well.

1602
01:18:40,229 --> 01:18:42,719
好吧，您可以想象刚刚开始添加到代码中
Well, you could imagine just starting to add to the code

1603
01:18:42,720 --> 01:18:48,128
或s等于“是”，或s等于“是”。
or s equals equals "Yes," or s equals equals "yes."

1604
01:18:48,127 --> 01:18:50,669
但是请稍等，如果用户有点草率呢？
But wait a minute, what if the user is being a little sloppy?

1605
01:18:50,670 --> 01:18:54,360
如果我想说的真的好吗，如果他们大喊大叫怎么办？
And what if I want to actually say like, well, what if they're yelling?

1606
01:18:54,359 --> 01:18:57,134
或s等于在所有大写字母中均等于“ YES”。
Or s equals equals "YES" in all caps.

1607
01:18:57,135 --> 01:18:59,010
还有其他一些排列。
And there's a few other permutations as well.

1608
01:18:59,010 --> 01:19:02,130
就像，这很快演变成一团糟。
Like, this is quickly devolving into quite the mess.

1609
01:19:02,130 --> 01:19:06,270
但是如果在一天结束时，您真的只想检测“ Y”或单词
But if at the end of the day you really just want to detect "Y" or the word

1610
01:19:06,270 --> 01:19:11,190
“是的。”无论大小写如何，我敢打赌我们在Python中会非常聪明
"Yes," irrespective of capitalization, I bet we can be pretty clever in Python

1611
01:19:11,189 --> 01:19:11,789
这里。
here.

1612
01:19:11,789 --> 01:19:19,229
如果我继续说，如果s是带引号的，请取消引号“ y”或“是”怎么办-
What if I go ahead and say, if s is in quote, unquote "y" or "yes"--

1613
01:19:19,229 --> 01:19:21,779
实际上，我可以借鉴较早的想法，
in fact, I can borrow an idea from earlier,

1614
01:19:21,779 --> 01:19:24,299
借此我可以使用方括号符号来给我
whereby I can use the square bracket notation to give me

1615
01:19:24,300 --> 01:19:27,300
一个列表，它又像一个数组，但是它会自动增长
a list, which again, is like an array, but it will automatically grow

1616
01:19:27,300 --> 01:19:28,440
或根据需要收缩。
or shrink as you need it.

1617
01:19:28,439 --> 01:19:30,689
您不必事先决定它的大小。
You don't have to decide in advance how big it is.

1618
01:19:30,689 --> 01:19:34,949
这个介词是Python中的新关键字
This preposition here, in, is a new keyword in Python

1619
01:19:34,949 --> 01:19:37,469
从字面上可以为我回答这个问题。
that will literally answer that question for me.

1620
01:19:37,470 --> 01:19:39,030
而且我们之前已经使用过它。
And we've used it before earlier.

1621
01:19:39,029 --> 01:19:44,609
实施拼写检查时，我说如果单词在我的单词集中，请返回
When I implemented speller, I said if the word is in my set of words, return

1622
01:19:44,609 --> 01:19:45,489
真的。
True.

1623
01:19:45,489 --> 01:19:50,207
因此，如果s在此列表中，我将返回True或False
So if s in this list, I'll get back True or False

1624
01:19:50,207 --> 01:19:51,749
根据该问题的答案。
based on the answer to that question.

1625
01:19:51,750 --> 01:19:53,310
但同样，这是不能容忍的情况。
But again, it's not tolerating case.

1626
01:19:53,310 --> 01:19:54,420
但是没什么大不了的
But no big deal--

1627
01:19:54,420 --> 01:19:58,170
我可以说点小点是s的小写版本，
dot lower, now I can say, is the lowercase version of s,

1628
01:19:58,170 --> 01:20:01,920
无论人类输入了什么，在此两个值列表中？
no matter what the human typed in, in this list of two values?

1629
01:20:01,920 --> 01:20:04,500
这意味着用户现在可以输入所有大写字母，
That means now the user can type in all caps,

1630
01:20:04,500 --> 01:20:10,769
交替使用大写字母，一个大写字母或任何其他排列形式
in alternating caps, and one capitalized letter, or any other permutation

1631
01:20:10,770 --> 01:20:12,300
任何。
whatsoever.

1632
01:20:12,300 --> 01:20:13,020
好的。
All right.

1633
01:20:13,020 --> 01:20:14,880
因此，这就是我们的条件。
So that, then, is our conditions.

1634
01:20:14,880 --> 01:20:19,440
让我在这里暂停一下，看看是否有任何问题。
Let me pause here to see if there's any questions.

1635
01:20:19,439 --> 01:20:21,869
有什么问题或困惑可以解决吗？
Any questions or confusion that we can clear up?

1636
01:20:21,869 --> 01:20:24,869
具有语法，条件，布尔变量-
With syntax, with conditions, Boolean variable--

1637
01:20:24,869 --> 01:20:26,031
布尔值？
Boolean values?

1638
01:20:26,032 --> 01:20:27,240
布莱恩：所以提出了一个问题。
BRIAN: So a question came up.

1639
01:20:27,239 --> 01:20:30,659
因此，在Python中，我们允许使用equals equals语法
So in Python we are allowed to use the equals equals syntax

1640
01:20:30,659 --> 01:20:32,031
比较两个字符串？
to compare two strings?

1641
01:20:32,032 --> 01:20:32,740
戴维·马兰：是的。
DAVID MALAN: Yes.

1642
01:20:32,739 --> 01:20:34,739
因此，另一个非常好的收获。
So another really good catch.

1643
01:20:34,739 --> 01:20:37,371
在Python中，没有指针。
In Python, there are no pointers.

1644
01:20:37,372 --> 01:20:39,330
引擎盖下仍然有地址。
Underneath the hood, there are still addresses.

1645
01:20:39,329 --> 01:20:40,954
就像，您的记忆没有任何地方。
Like, your memory hasn't gone anywhere.

1646
01:20:40,954 --> 01:20:44,339
但是在幕后，所有这些现在都由该语言为您管理
But underneath the hood, all, of that is now managed for you by the language

1647
01:20:44,340 --> 01:20:45,070
本身。
itself.

1648
01:20:45,069 --> 01:20:49,019
因此，如果您想在概念上将一个字符串与另一个字符串进行比较，
So if you want to conceptually compare one string against another,

1649
01:20:49,020 --> 01:20:53,370
就像我现在在第7行所做的一样，您确实可以使用equals equals，
just as I did here now on line 7, you can indeed use equals equals,

1650
01:20:53,369 --> 01:20:56,589
Python将为您提供引用，为您取消引用“正确的事情”。
and Python will do the quote, unquote "right thing" for you.

1651
01:20:56,590 --> 01:21:00,647
您无需回归使用strcmp。
You don't need to regress into using strcmp instead.

1652
01:21:00,646 --> 01:21:02,729
为了清楚起见，让我继续进行更新。
Just for clarity, let me go ahead and update this.

1653
01:21:02,729 --> 01:21:08,429
如果引号较低，请取消引号“ n”或逗号“ no”，
If s.lower in quote, unquote "n" or comma "no,"

1654
01:21:08,430 --> 01:21:12,540
我们可以通过执行相同的技术来达到相同的结果。
we can achieve the same result there by doing the same technique.

1655
01:21:12,539 --> 01:21:15,449
好吧，让我继续讲一个例子
Well, let me go ahead and open up another example

1656
01:21:15,449 --> 01:21:17,939
您可能还记得我们做了一系列的例子
that you might recall we did a progression of examples

1657
01:21:17,939 --> 01:21:22,379
使它变得更好，更好，然后再好，这涉及
to make it good, better, and then best, this one involving

1658
01:21:22,380 --> 01:21:24,100
只是某种形式的猫叫声。
just a cat meowing in some form.

1659
01:21:24,100 --> 01:21:26,760
所以让我继续，从第一周开始
So let me go ahead and open up from week 1

1660
01:21:26,760 --> 01:21:31,410
一个相对简单的名为meow0的示例
an example that was called meow0, relatively straightforward, that

1661
01:21:31,409 --> 01:21:32,729
简单地做到了。
simply did this.

1662
01:21:32,729 --> 01:21:34,349
它只叫了三声。
It simply meowed three times.

1663
01:21:34,350 --> 01:21:37,230
现在就可以这么说了，在Python中，这是微不足道的
So suffice it to say now, in Python, it's pretty trivial

1664
01:21:37,229 --> 01:21:38,819
做三遍这样的事情。
to do something three times like this.

1665
01:21:38,819 --> 01:21:41,729
我将继续进行操作，并将其称为meow.py。
I'm going to go ahead and call this meow.py.

1666
01:21:41,729 --> 01:21:45,239
当然，我可以做类似打印“喵”的事情。
And of course, I can just do something like print "meow."

1667
01:21:45,239 --> 01:21:46,749
我可以复制粘贴。
And I can just copy paste that.

1668
01:21:46,750 --> 01:21:49,740
但是，当然，这个例子的全部要追溯到第1周
But of course, the whole point of this example back in week 1

1669
01:21:49,739 --> 01:21:52,019
不应只复制粘贴。
was not to devolve into just copy paste.

1670
01:21:52,020 --> 01:21:53,377
当然，有更好的方法。
Surely there's a better way.

1671
01:21:53,377 --> 01:21:54,960
这次我们看到了一种更好的方法。
And we've seen a better way this time.

1672
01:21:54,960 --> 01:21:57,750
如果我们想将其更改为C语言中的for循环，
If we wanted to change this into a for loop in C,

1673
01:21:57,750 --> 01:22:04,650
我们可以做一些类似的事情，因为int我得到0，我少于3，我++。
we could have done something like for int i get 0, i less than 3, i++.

1674
01:22:04,649 --> 01:22:06,629
然后在一些花括号中，我们可以完成
Then in some curly braces we could have done

1675
01:22:06,630 --> 01:22:09,780
“喵”的行，换行符，分号。
printf of "meow," new line, semicolon.

1676
01:22:09,779 --> 01:22:12,749
因此，这是C语言中喵代码的下一个版本。
So that was the next version of our meow code in C.

1677
01:22:12,750 --> 01:22:15,270
但是，在Python中，当然要简洁得多。
But in Python, of course, it's a little more succinct.

1678
01:22:15,270 --> 01:22:22,320
我可以为我做范围3的打印报价，取消报价“喵”。
I can just do for i in range 3 print quote, unquote "meow."

1679
01:22:22,319 --> 01:22:24,791
在精神上与我们之前的世界非常相似。
So very similar in spirit to our hello, world of before.

1680
01:22:24,792 --> 01:22:27,250
但是同样，我们不必为此包含任何库。
But again, we don't have to include any libraries for this.

1681
01:22:27,250 --> 01:22:28,979
我们不需要主要功能。
We don't need to have a main function.

1682
01:22:28,979 --> 01:22:31,687
我们不需要任何花括号或分号之类的东西。
We don't need any of those curly braces or semicolon or the like.

1683
01:22:31,688 --> 01:22:35,040
我们可以深入研究代码本身。
We can just dive in and focus on the code itself.

1684
01:22:35,039 --> 01:22:39,839
但是回想一下，我们上次也改进了喵程序
But recall that we also, last time, evolved the meow program

1685
01:22:39,840 --> 01:22:42,780
拥有自己的助手功能，我们自己的功能
into having our own helper function, our own function that

1686
01:22:42,779 --> 01:22:48,479
实际上允许我们在喵声之上创建一个抽象。
actually allowed us to create an abstraction on top of meowing.

1687
01:22:48,479 --> 01:22:51,119
那是我们的第三个版本，又叫喵喵。
And that was in our third version, a.k.a., meow2.

1688
01:22:51,119 --> 01:22:53,399
让我继续并在标签中打开此版本。
Let me go ahead and open up this version in a tab.

1689
01:22:53,399 --> 01:22:56,969
并请注意，这个版本开始涉及到一点点，因为
And notice that this version starts to get a little involved, because one,

1690
01:22:56,970 --> 01:22:59,580
我们需要顶部的原型，因为我现在
we needed a prototype at the top, because I now

1691
01:22:59,579 --> 01:23:02,519
在生活的最终目的中具有喵喵功能
have meow function at the bottom whose purpose in life

1692
01:23:02,520 --> 01:23:04,860
只是打印“喵”，而将其抽象化
was just to print "meow," but to abstract that away

1693
01:23:04,859 --> 01:23:07,139
作为新的辅助功能。
as a new helper function.

1694
01:23:07,140 --> 01:23:10,230
然后，我在此代码中包含了一个for循环。
And then I had this code here with a for loop inside.

1695
01:23:10,229 --> 01:23:13,799
好吧，在Python中，它在这里也会变得更加简单。
Well, in Python it's going to work out to be a little simpler here, too.

1696
01:23:13,800 --> 01:23:17,040
如果我想做三遍，因为我的范围是3
If I want to do something three times, for i in range of 3

1697
01:23:17,039 --> 01:23:18,989
继续叫喵。
go ahead and call meow.

1698
01:23:18,989 --> 01:23:21,459
现在，当然，喵并不存在。
Now of course, meow doesn't yet exist.

1699
01:23:21,460 --> 01:23:22,770
所以我可以解决这个问题。
So I can solve that problem.

1700
01:23:22,770 --> 01:23:25,290
我们在拼写法中早就看到了（尽管很快）
We've seen earlier, albeit quickly, in speller that I

1701
01:23:25,289 --> 01:23:27,179
可以定义我自己的功能，例如喵。
can define my own functions like meow.

1702
01:23:27,180 --> 01:23:29,223
没有更多的空虚，因为如果你不这样做
There's no more void, because if you don't

1703
01:23:29,222 --> 01:23:31,889
想要在函数中包含参数，只是不要将其放在那里。
want to have arguments in a function, just don't put them there.

1704
01:23:31,890 --> 01:23:34,770
在Python中没有指定返回值。
There's no return value specified in Python.

1705
01:23:34,770 --> 01:23:36,000
相反，它们是隐式的。
They're implicit instead.

1706
01:23:36,000 --> 01:23:37,800
这样就足够了。
So it suffices to do this.

1707
01:23:37,800 --> 01:23:40,530
现在，我可以打印出“喵”了。
And now I can just print out "meow."

1708
01:23:40,529 --> 01:23:44,369
所以现在在这里，我有一个程序迭代了三遍，
So here now, I have a program that iterates three times,

1709
01:23:44,369 --> 01:23:47,769
每次都调用喵，并且喵在下面定义。
calling meow each time, and meow is defined down below.

1710
01:23:47,770 --> 01:23:51,876
让我继续运行此程序，meow.py的python。
Let me go ahead and run this, python of meow.py.

1711
01:23:51,876 --> 01:23:52,650
嗯
Huh.

1712
01:23:52,649 --> 01:23:54,689
追溯，最近一次通话持续。
Traceback, most recent call last.

1713
01:23:54,689 --> 01:23:59,009
meow.py的第2行出现了一个问题，原因是NameError-name
There's a problem on line 2 of meow.py because of NameError-- name

1714
01:23:59,010 --> 01:24:01,360
“喵”没有定义。
"meow" is not defined.

1715
01:24:01,359 --> 01:24:05,549
现在，Python在此使用的语言与C有所不同。
Now, the language being used there by Python is a little different from C's.

1716
01:24:05,550 --> 01:24:10,050
坦率地说，它更加人性化。
It's frankly a little more human friendly.

1717
01:24:10,050 --> 01:24:11,400
但是到底发生了什么？
But what just happened?

1718
01:24:11,399 --> 01:24:16,364
出现了什么问题，直到现在我还没有绊倒？
What problem has arisen that I yet haven't tripped over until now?

1719
01:24:19,210 --> 01:24:21,620
即使您以前从未使用Python进行编程，
Even if you've never programmed in Python before,

1720
01:24:21,619 --> 01:24:26,769
即使您还没有运行help50，那里可能是什么问题？
and even if you haven't run help50 yet, what might be the issue there?

1721
01:24:26,770 --> 01:24:28,750
金妮
Ginny?

1722
01:24:28,750 --> 01:24:32,410
听众：这是我们尝试调用该函数时找不到的，
AUDIENCE: It's that the function is not found when we are trying to call it,

1723
01:24:32,409 --> 01:24:35,369
因为下面将在我们调用它时对其进行描述。
because it's described below when we are calling it.

1724
01:24:35,369 --> 01:24:36,129
戴维·马兰：是的。
DAVID MALAN: Yeah.

1725
01:24:36,130 --> 01:24:37,703
听众：没有原型。
AUDIENCE: There is no prototype.

1726
01:24:37,703 --> 01:24:39,370
大卫·马兰（David MALAN）：是的，没有原型。
DAVID MALAN: Yeah, there's no prototype.

1727
01:24:39,369 --> 01:24:42,369
事实证明，在Python中，没有原型的概念。
And it turns out in Python, there isn't a notion of prototypes.

1728
01:24:42,369 --> 01:24:44,859
不幸的是，我们在第1周看到的解决方案
So unfortunately, the solution we saw in week 1

1729
01:24:44,859 --> 01:24:47,409
不只是复制并粘贴上面的第一行
is not to just copy and paste the first line up above

1730
01:24:47,409 --> 01:24:48,849
并以分号结束。
and end it with a semicolon.

1731
01:24:48,850 --> 01:24:50,170
那不是什么。
That's just not a thing.

1732
01:24:50,170 --> 01:24:51,520
我可以做到的。
I could do this.

1733
01:24:51,520 --> 01:24:54,760
我可以将喵功能移到文件顶部，
I could just move my meow function to the top of the file,

1734
01:24:54,760 --> 01:24:58,330
从而首先定义函数，然后再使用它。
thereby defining the function first, and then using it last.

1735
01:24:58,329 --> 01:25:01,479
这实际上可以解决问题，“喵喵喵喵”。
And that would actually solve the problem, "meow meow meow."

1736
01:25:01,479 --> 01:25:03,939
当然，那从长远来看并没有真正帮助我们，
That, of course, doesn't really help us long term,

1737
01:25:03,939 --> 01:25:06,939
因为您可能会想象这种功能想要的情况
because you could probably imagine a situation where this function wants

1738
01:25:06,939 --> 01:25:09,272
调用此函数，但此函数调用此函数，
to call this function, but this function calls this one,

1739
01:25:09,273 --> 01:25:12,592
而且您无法以某种安全的方式真正整洁地订购它们。
and you just can't really neatly order them in some safe way.

1740
01:25:12,591 --> 01:25:14,799
而且它只是不会保持可维护性，对吗？
And it's just not going to be as maintainable, right?

1741
01:25:14,800 --> 01:25:18,220
回想一下，将main放在我们的C程序顶部的价值之一。
Recall that one of the values of putting main at the top of our C programs

1742
01:25:18,220 --> 01:25:21,128
是任何想要了解您的代码的理性人
was that any reasonable person who wants to understand your code

1743
01:25:21,127 --> 01:25:23,169
可能会开始从头到尾阅读。
is probably going to start reading top to bottom.

1744
01:25:23,170 --> 01:25:26,003
他们不需要浏览所有代码
They're not going to want to have to scroll through all of your code

1745
01:25:26,002 --> 01:25:28,119
寻找实际的主要代码。
looking for the actual main code.

1746
01:25:28,119 --> 01:25:32,049
所以事实证明，即使您不需要主要功能，也可以在Python中使用，
So it turns out in Python, even though you don't need a main function,

1747
01:25:32,050 --> 01:25:35,410
尽管如此，定义一个实际上是很常见的。
it's actually common to define one nonetheless.

1748
01:25:35,409 --> 01:25:38,559
它将通过类似这样的方式实现。
It's going to be implemented with something like this.

1749
01:25:38,560 --> 01:25:41,780
我只是在此处缩进代码。
And I'm just going to indent my code below that there.

1750
01:25:41,779 --> 01:25:43,509
所以现在我定义了main。
So now I've defined main.

1751
01:25:43,510 --> 01:25:45,490
但是我还没有执行任何代码。
But I haven't executed any code yet.

1752
01:25:45,489 --> 01:25:49,689
在第6行，我现在已经定义了喵，但是我还没有执行任何代码。
On line 6, I've now defined meow, but I haven't executed any code yet.

1753
01:25:49,689 --> 01:25:50,889
我的意思是从字面上看。
And I mean that literally.

1754
01:25:50,890 --> 01:25:53,530
如果我现在运行喵喵的python并按Enter，
If I run python of meow now and hit Enter,

1755
01:25:53,529 --> 01:25:58,389
我希望看到“喵喵喵”，但我什么也没看见。
I would hope to see "meow meow meow," but I see nothing.

1756
01:25:58,390 --> 01:26:00,470
这有点奇怪。
And this is a little weird.

1757
01:26:00,470 --> 01:26:02,860
但是Python实际上是按照我的指示去做的。
But Python is doing literally what I told it to do.

1758
01:26:02,859 --> 01:26:04,839
我告诉它定义一个名为main的函数，
I told it to define a function called main,

1759
01:26:04,840 --> 01:26:08,290
我告诉它定义一个叫做喵的函数。
and I told it to define a function called meow.

1760
01:26:08,289 --> 01:26:12,839
我从未告诉过它要做的是调用这些函数中的任何一个。
What I never told it to do is to call either of those functions.

1761
01:26:12,840 --> 01:26:16,480
因此，这里最简单的解决方案-与C稍有不同，并且有些怪异-
So the simplest fix here-- it's a little different from C and a little weird--

1762
01:26:16,479 --> 01:26:19,699
只是调用main是文件中的最后一个想法。
is just call main is your very last thought in the file.

1763
01:26:19,699 --> 01:26:23,599
因此，将main定义在顶部，这正是大多数程序员期望的位置，
So define main up at the top, just where most programmers would expect it to be,

1764
01:26:23,600 --> 01:26:25,292
但请一路打到底部。
but call it all the way at the bottom.

1765
01:26:25,292 --> 01:26:27,250
现在让我继续运行我的程序。
And let me go ahead and now and run my program.

1766
01:26:27,250 --> 01:26:30,640
现在瞧，“喵喵喵”又回来了，因为我定义了main，
And now voila, "meow meow meow" is back, because I've defined main,

1767
01:26:30,640 --> 01:26:33,910
我定义了喵，现在我叫main。
I've defined meow, and now I am calling main.

1768
01:26:33,909 --> 01:26:37,509
现在，顺便说一句，您会经常在各种文档中看到
Now, as an aside, you will very often see in various documentation

1769
01:26:37,510 --> 01:26:42,250
和在线教程比这更加神秘，
and tutorials online a much more cryptic incantation than this,

1770
01:26:42,250 --> 01:26:44,439
这将让您输入此内容。
which will have you typing out this.

1771
01:26:44,439 --> 01:26:47,049
这可以达到相同的目标，但并非绝对必要
This achieves the same goal, but it's not strictly necessary

1772
01:26:47,050 --> 01:26:47,860
为了我们的目的。
for our purposes.

1773
01:26:47,859 --> 01:26:50,919
如果您在任何在线参考资料或示例中都看到了这一行代码，
This line of code, if you see it in any online references, or examples,

1774
01:26:50,920 --> 01:26:53,328
或书籍，版面等
or books, or sections or the like, it is necessary

1775
01:26:53,328 --> 01:26:55,120
仅当您实施时，
only when you're implementing, essentially,

1776
01:26:55,119 --> 01:26:58,029
您自己的库-例如您自己的CS50库，
your own libraries-- like your own CS50 library,

1777
01:26:58,029 --> 01:27:00,579
或您自己的图像模糊库等。
or your own image blurring library or the like.

1778
01:27:00,579 --> 01:27:03,874
当我们只是编写自己的单个程序时，这是没有必要的。
It's not necessary when we're just writing individual programs of our own.

1779
01:27:03,875 --> 01:27:07,000
因此，我将继续进行操作，保持简单，从字面上讲就是main。
So I'm going to go ahead and keep mine simple and literally just call main.

1780
01:27:07,000 --> 01:27:10,629
让我挥舞一下为什么您否则需要该语法
And let me just wave my hand at why you'd need that syntax otherwise

1781
01:27:10,630 --> 01:27:11,950
在这种情况下。
in this context.

1782
01:27:11,949 --> 01:27:14,769
但是，让我继续进行最后一次修改。
But let me go ahead and modify this one last time.

1783
01:27:14,770 --> 01:27:18,520
因为记得在C中，我程序的最新版本
Because recall that in C, the last version of my program

1784
01:27:18,520 --> 01:27:21,310
让我运行喵并传递输入。
had me running meow and passing it input.

1785
01:27:21,310 --> 01:27:24,670
因为我将喵定义为接受n之类的输入，
Because I defined meow as taking an input like n,

1786
01:27:24,670 --> 01:27:30,370
然后做类似int的事情，我得到0，我小于n，i ++，
and then doing something like for int i get 0, i less than n, i++,

1787
01:27:30,369 --> 01:27:34,029
然后我在花括号内打印了喵声，
and then inside of my curly braces did I print meow,

1788
01:27:34,029 --> 01:27:38,469
所以现在我有了一个助手功能，需要一个
so that now I have a helper function that I've invented that takes one

1789
01:27:38,470 --> 01:27:40,240
输入，一个称为n的int。
input, an int called n.

1790
01:27:40,239 --> 01:27:43,389
它循环了很多次，并打印出了多次喵声。
And it loops that many times and prints out meow that many times.

1791
01:27:43,390 --> 01:27:47,320
现在我有了一个非常不错的抽象，现在我的程序已经精炼了，
And now I have a real nice abstraction, and that now my program is distilled,

1792
01:27:47,319 --> 01:27:48,819
它只有三声喵叫。
it's just meow three times.

1793
01:27:48,819 --> 01:27:51,129
而且我如何实现喵叫也没关系。
And it doesn't matter how I implemented meow.

1794
01:27:51,130 --> 01:27:52,900
我可以在Python中做同样的事情。
I can do the same thing in Python.

1795
01:27:52,899 --> 01:27:56,529
我可以继续说喵叫一个叫做n的参数。
I can go ahead and say that meow takes an argument called n.

1796
01:27:56,529 --> 01:27:58,449
我不必费心指定它的类型。
I don't have to bother specifying its type.

1797
01:27:58,449 --> 01:28:03,519
我现在可以说我在n范围内，并且我可以多次打印“喵”声。
I can now say for i in range of n, and I can print "meow" that many times.

1798
01:28:03,520 --> 01:28:07,810
现在我可以摆脱主循环了，只说三遍“喵”。
And now I can get rid of my loop in main and just say "meow" three times.

1799
01:28:07,810 --> 01:28:09,310
等等相同的功能。
And so same functionality.

1800
01:28:09,310 --> 01:28:11,770
如果我最后一次运行，“喵喵喵”，
If I run this a final time, "meow meow meow,"

1801
01:28:11,770 --> 01:28:16,570
但现在我有点以更复杂的方式设计代码
but now I'm kind of designing my code in a more sophisticated way

1802
01:28:16,569 --> 01:28:23,319
通过现在给自己一些实际的助手功能。
by actually giving myself now some of my own actual helper functions.

1803
01:28:23,319 --> 01:28:26,349
好吧，那么，关于这个进展有什么问题吗？
All right, any questions, then, on this progression?

1804
01:28:26,350 --> 01:28:28,810
现在，我们并没有真正看到新的Python语法。
Now, we're not really seeing new Python syntax.

1805
01:28:28,810 --> 01:28:32,980
现在，我们看到的是过去一些实际的C程序的翻译
We're now just seeing a translation of some actual past C programs

1806
01:28:32,979 --> 01:28:37,019
到Python中，以显示出真正的等效性。
into Python to show really the equivalence.

1807
01:28:39,560 --> 01:28:40,080
好的。
All right.

1808
01:28:40,079 --> 01:28:42,246
好吧，让我们继续，然后打开另一个版本
Well, let's go ahead, then, and open another version

1809
01:28:42,247 --> 01:28:45,590
从名为positive.c的程序的第1周开始，
from week 1 of a program called positive.c,

1810
01:28:45,590 --> 01:28:49,850
那时，这是一个机会，不仅是定义我们自己的助手功能
which was an opportunity back then, not only to define our own helper function

1811
01:28:49,850 --> 01:28:52,760
名为get_positive_int，但它也向我们介绍了
called get_positive_int, but it also introduced us

1812
01:28:52,760 --> 01:28:54,440
熟悉的do while循环。
to the familiar do while loop.

1813
01:28:54,439 --> 01:28:57,379
不幸的是，我们现在将把它从您手中夺走。
And unfortunately, we're going to take that away from you now.

1814
01:28:57,380 --> 01:28:59,390
Python没有do while循环。
Python does not have a do while loop.

1815
01:28:59,390 --> 01:29:03,260
但这当然是一件非常有用的事情
But it's, of course, a very useful thing to be able to do something

1816
01:29:03,260 --> 01:29:04,730
当条件为真时。
while a condition is true.

1817
01:29:04,729 --> 01:29:07,699
毕竟，几乎在我们上课的任何时候，
After all, pretty much any time we've gotten user input in the class,

1818
01:29:07,699 --> 01:29:11,569
我们已经使用了do，所以我们至少一次提示他们，然后可选地
we've used do while, so that we prompt them at least once and then optionally

1819
01:29:11,569 --> 01:29:14,299
一遍又一遍，直到他们合作。
again and again and again, until they cooperate.

1820
01:29:14,300 --> 01:29:16,430
因此，让我继续并在Python中实现它
So let me go ahead and implement this in Python

1821
01:29:16,430 --> 01:29:24,490
现在放在一个名为positive.py的文件中，然后再转到positive.py，
now in a file called positive.py, and go ahead here in positive.py,

1822
01:29:24,489 --> 01:29:27,049
并将其翻译如下。
and translate this thing as follows.

1823
01:29:27,050 --> 01:29:31,060
让我继续，从cs50导入get_int。
Let me go ahead and from cs50 import get_int.

1824
01:29:31,060 --> 01:29:33,670
让我继续定义一个名为main的函数。
Let me go ahead and define a function called main.

1825
01:29:33,670 --> 01:29:35,920
所以现在我要开始养成这个习惯。
So now I'm just going to start to get into this habit.

1826
01:29:35,920 --> 01:29:38,575
我要继续给自己一个变量，叫做i
I'm going to go ahead and give myself a variable called i

1827
01:29:38,574 --> 01:29:40,952
并调用get_positive_int。
and call get_positive_int.

1828
01:29:40,953 --> 01:29:43,120
然后我要继续打印我
And then I'm just going to go ahead and print out i,

1829
01:29:43,119 --> 01:29:44,559
保持美观和简单。
keeping it nice and simple.

1830
01:29:44,560 --> 01:29:48,550
现在，我必须实现get_positive_int。
Now I have to implement get_positive_int.

1831
01:29:48,550 --> 01:29:53,440
它不需要任何输入，因此我不会给它提供任何参数。
It doesn't need to take any input, so I'm not going to give it any arguments.

1832
01:29:53,439 --> 01:29:55,509
现在我必须做一件事情。
And now I have to do to do while thing.

1833
01:29:55,510 --> 01:29:59,770
因此，在Python中执行此操作的Pythonic方式几乎总是
So the Pythonic way to do this in Python is almost always

1834
01:29:59,770 --> 01:30:02,320
故意引起无限循环。
to deliberately induce an infinite loop.

1835
01:30:02,319 --> 01:30:04,989
想法是，如果您想一次又一次地做某事，
And the idea being, if you want to do something again and again,

1836
01:30:04,989 --> 01:30:07,929
只是永远地开始做，然后跳出循环
just start doing it forever and then break out of the loop

1837
01:30:07,930 --> 01:30:09,458
当你准备好了。
when you are ready to.

1838
01:30:09,457 --> 01:30:11,499
那么，我想在此功能中永远做些什么？
So what do I want to do forever in this function?

1839
01:30:11,500 --> 01:30:14,229
好吧，我想继续并获得一个int和提示
Well, I want to go ahead and get an int and prompt

1840
01:30:14,229 --> 01:30:17,599
人类为一个正整数。
the human for a positive integer.

1841
01:30:17,600 --> 01:30:21,490
然后，我想继续下一行并提出一个问题。
And then I want to go ahead on the next line and ask a question.

1842
01:30:21,489 --> 01:30:27,279
好吧，如果n大于0，从而使其为正，则中断。
Well, if n is greater than 0, thereby making it positive, break.

1843
01:30:27,279 --> 01:30:31,489
最后的代码行将返回n。
And the last line of code here is going to be to return n.

1844
01:30:31,489 --> 01:30:35,169
因此，请注意左侧的C，我做了整个事情。
So notice in C on the left, I did this do whole thing.

1845
01:30:35,170 --> 01:30:37,870
我必须在do while循环之外声明n，
I had to declare n outside of the do while loop,

1846
01:30:37,869 --> 01:30:40,629
因为它必须在花括号之外才能使用。
because it had to be outside the curly braces to be in scope.

1847
01:30:40,630 --> 01:30:44,290
但是在这里的Python中，请注意我在这里做什么
But in Python here, notice what I'm doing here

1848
01:30:44,289 --> 01:30:47,859
实际上有点不同。
is actually a little bit different.

1849
01:30:47,859 --> 01:30:50,049
我搞砸了吗？
And did I screw up?

1850
01:30:53,789 --> 01:30:55,299
哦，是的，我确实搞砸了。
Oh, yes, I did screw up.

1851
01:30:55,300 --> 01:30:56,500
好的。
OK.

1852
01:30:56,500 --> 01:30:58,839
如果询问实际问题，则n大于0。
If ask the actual question, if n greater than 0.

1853
01:30:58,840 --> 01:31:01,690
那么，我实际上在右侧做了什么不同的事情？
So what did I do actually differently here on the right-hand side?

1854
01:31:01,689 --> 01:31:03,981
好吧，注意，我故意引起了这个无限循环
Well, notice, I deliberately induced this infinite loop

1855
01:31:03,981 --> 01:31:06,549
在第10行上，这意味着永远做下面的事情。
on line 10, which just means, do the following forever.

1856
01:31:06,550 --> 01:31:10,510
然后，我用get_int向用户询问变量n，然后检查，
I then ask the user for a variable n with get_int, and then I check,

1857
01:31:10,510 --> 01:31:12,460
n是否大于0？
is n greater than 0?

1858
01:31:12,460 --> 01:31:14,408
如果是这样，请跳出循环。
If so, break out of the loop.

1859
01:31:14,408 --> 01:31:15,700
我该如何跳出循环？
How do I break out of the loop?

1860
01:31:15,699 --> 01:31:19,159
好吧，请注意，此处的缩进非常一致。
Well, notice that the indentation here has been very consistent.

1861
01:31:19,159 --> 01:31:22,149
因此，当我跳出循环圈时，这会让我退缩
So when I break out of the loop, that puts me back

1862
01:31:22,149 --> 01:31:26,054
与第14行的原始缩进一致。
in line with the original indentation which is now on line 14.

1863
01:31:26,055 --> 01:31:28,930
请注意，返回与while循环对齐，这意味着
Notice that the return lines up with the while loop, which means it's

1864
01:31:28,930 --> 01:31:31,840
该循环之外的第一行代码。
the first line of code that's outside of that loop.

1865
01:31:31,840 --> 01:31:34,300
在过去，我们会使用非常明确的花括号。
In the past, we would have had very explicit curly braces.

1866
01:31:34,300 --> 01:31:37,752
现在，我们仅依靠缩进，然后让我返回n。
Now we rely only on indentation that then lets me return n.

1867
01:31:37,752 --> 01:31:39,460
那么这里有什么区别呢？
So what are some of the differences here?

1868
01:31:39,460 --> 01:31:41,530
第一，do while循环完全消失了。
One, the do while loop is completely gone.

1869
01:31:41,529 --> 01:31:45,249
但是两个，范围不再是问题。
But two, scope is no longer an issue.

1870
01:31:45,250 --> 01:31:48,939
在Python中，您声明变量的那一刻，
It turns out in Python that the moment you declare a variable,

1871
01:31:48,939 --> 01:31:51,979
它存在直到该功能结束。
it exists until the end of that function.

1872
01:31:51,979 --> 01:31:55,749
您不必担心像我们这样先声明变量的细微差别
You don't have to worry about the nuance of declaring a variable first like we

1873
01:31:55,750 --> 01:31:59,620
在C中在这里做了，然后在下面将其返回。
did in C up here and then returning it down below.

1874
01:31:59,619 --> 01:32:03,219
我们在这里执行此行代码11的那一刻，n
The moment we execute this line of code 11 here, n

1875
01:32:03,220 --> 01:32:07,220
在该功能的其余部分中突然存在。
suddenly exists for the entirety of the remainder of that function.

1876
01:32:07,220 --> 01:32:10,120
因此，即使我们在循环内声明了它，可以这么说，
So even though we declared it inside of the loop, so to speak,

1877
01:32:10,119 --> 01:32:14,799
根据缩进，return语句仍然可以访问它
as per the indentation, it is still accessible to the return statement

1878
01:32:14,800 --> 01:32:16,610
在程序末尾。
here at the end of the program.

1879
01:32:16,609 --> 01:32:17,109
好的。
All right.

1880
01:32:17,109 --> 01:32:21,249
让我在那里停下来看看是否有任何疑问或困惑
Let me pause there and see if there's any questions or confusion

1881
01:32:21,250 --> 01:32:26,530
在获得用户输入方面，从逻辑上讲，与之同时做，
on getting user input, doing the equivalent, logically, of do while,

1882
01:32:26,529 --> 01:32:28,869
但是现在以这种更加Python化的方式进行。
but doing it now in this more Pythonic way.

1883
01:32:28,869 --> 01:32:29,529
彼得？
Peter?

1884
01:32:29,529 --> 01:32:32,934
听众：在Python中，变量是否可以跨函数访问？
AUDIENCE: In Python, are variables accessible across functions or no?

1885
01:32:32,935 --> 01:32:34,060
戴维·马兰：好的问题。
DAVID MALAN: Good question.

1886
01:32:34,060 --> 01:32:34,660
不。
No.

1887
01:32:34,659 --> 01:32:37,359
因此，如果您在函数内部声明变量，
So if you declare a variable inside of a function,

1888
01:32:37,359 --> 01:32:40,099
可以说，它仅限于该功能。
it is scoped, so to speak, to that function.

1889
01:32:40,100 --> 01:32:41,500
它在其他地方不可用。
It is not available elsewhere.

1890
01:32:41,500 --> 01:32:44,709
您将必须返回它，并将其作为输出传递给输入。
You would have to return it and pass it as output to input.

1891
01:32:44,710 --> 01:32:50,740
或者，您必须将其定义为例如全局变量。
Or you would have to define it, for instance, as a global variable instead.

1892
01:32:50,739 --> 01:32:51,439
好的。
All right.

1893
01:32:51,439 --> 01:32:53,499
那么，我们还能翻译什么呢？
Well, what else, then, might we translate?

1894
01:32:53,500 --> 01:32:57,679
好吧，回想一下我们在第1周所做的早期工作
Well, recall from our earlier endeavors in week 1,

1895
01:32:57,680 --> 01:32:59,680
我们玩了Mario的这些例子。
we played around with these examples from Mario.

1896
01:32:59,680 --> 01:33:02,920
例如，我们想用Python打印出一些东西
And for instance, we wanted to print something out in Python--

1897
01:33:02,920 --> 01:33:07,690
在C中模仿这些金字塔或这些硬币的概念，
in C that mimics the notion of these pyramids, or these coins,

1898
01:33:07,689 --> 01:33:09,759
或屏幕上的这些小砖头。
or these little bricks on the screen.

1899
01:33:09,760 --> 01:33:13,858
好吧，让我继续打开一个名为mario.py的新文件。
Well, here let me go ahead and open up a new file called mario.py.

1900
01:33:13,858 --> 01:33:16,900
而且我要从始终显示之前和之后过渡
And I'm going to transition away from always showing the before and after

1901
01:33:16,899 --> 01:33:19,419
现在只是开始更多地关注Python代码。
and now just start to focus more on the Python code.

1902
01:33:19,420 --> 01:33:22,550
但是，如果您想要相应的C版本，则可以随时进行回顾。
But you can always look back if you wanted the corresponding C versions.

1903
01:33:22,550 --> 01:33:25,998
我该如何垂直打印出三块这样的积木？
How do I go about printing out three bricks like this vertically?

1904
01:33:25,997 --> 01:33:27,789
好吧，在Python中我可能会说类似的话，
Well, in Python I might say something like,

1905
01:33:27,789 --> 01:33:33,999
很简单，因为我们已经做过几次了，所以我在3的范围内，
for i in range of 3, quite simply, as we've done a few times already,

1906
01:33:34,000 --> 01:33:35,679
然后继续打印哈希值。
and just go ahead and print out a hash.

1907
01:33:35,680 --> 01:33:38,740
我不需要担心新的生产线，因为您可以免费获得它，
I don't need to worry about the new line, because you get it for free,

1908
01:33:38,739 --> 01:33:39,609
可以这么说。
so to speak.

1909
01:33:39,609 --> 01:33:42,699
但是我现在要继续并运行mario.py的python。
But I'm going to go ahead now and run python of mario.py.

1910
01:33:42,699 --> 01:33:47,619
瞧，这是我非常简单的ASCII版本的Mario结构。
And voila, there's my very simple ASCII version of this Mario structure.

1911
01:33:47,619 --> 01:33:49,869
但是，如果我想做硬币怎么办？
But what if I want to do the coins instead?

1912
01:33:49,869 --> 01:33:54,039
如果我要执行出现在这四个积木中的水平硬币怎么办
What if I want to do this horizontal coins that appear in these four bricks

1913
01:33:54,039 --> 01:33:56,319
并打印出一个版本？
and print out a version of that?

1914
01:33:56,319 --> 01:33:57,769
好吧，我该怎么做？
Well, how might I do that?

1915
01:33:57,770 --> 01:34:00,430
好吧，让我继续并将其更改为-
Well, let me go ahead and change this to be--

1916
01:34:00,430 --> 01:34:05,150
相反，在我的代码中，我的范围是4，因此我可以打印其中的四个。
instead in my code for i in range of 4, so I can print four of these things.

1917
01:34:05,149 --> 01:34:09,079
让我继续并打印一个问号，然后运行它。
Let me go ahead and print out a question mark and then run this.

1918
01:34:09,079 --> 01:34:11,439
因此，让我运行mario.py。
So let me run mario.py.

1919
01:34:11,439 --> 01:34:13,179
瞧，该死。
And voila-- damn.

1920
01:34:13,180 --> 01:34:15,110
喜欢，不是我想要的。
Like, not what I wanted.

1921
01:34:15,109 --> 01:34:16,749
权衡取舍就在这里。
And so here is that trade-off.

1922
01:34:16,750 --> 01:34:18,580
到目前为止，您可能会有些激动
You might have been kind of excited, so far

1923
01:34:18,579 --> 01:34:21,789
因为有可能对代码感到兴奋，哦，天哪，
as it's possible to be excited about code, that, oh, my God,

1924
01:34:21,789 --> 01:34:24,499
您无需再处理愚蠢的换行符。
you don't need to do the stupid new line characters anymore.

1925
01:34:24,500 --> 01:34:25,870
但是，如果您不想要该怎么办？
But what if you don't want it?

1926
01:34:25,869 --> 01:34:31,389
现在，我们发现自动获取这些新行的弊端。
Now we've kind of found a downside of getting those new lines automatically.

1927
01:34:31,390 --> 01:34:34,870
好吧，事实证明，如果我们阅读了有关打印功能的文档
Well, it turns out if we read the documentation for the print function

1928
01:34:34,869 --> 01:34:38,169
在Python中，它也可以采用多个参数。
in Python, it, too, can take multiple arguments.

1929
01:34:38,170 --> 01:34:41,462
而且，Python的强大功能还在于
And what's powerful about Python, too, is

1930
01:34:41,462 --> 01:34:43,420
它不仅支持位置参数，
that it supports not just positional arguments,

1931
01:34:43,420 --> 01:34:47,620
您只需在其中用逗号分隔一个函数的多个参数列表即可。
where you just do a comma separated list of multiple arguments to a function.

1932
01:34:47,619 --> 01:34:51,069
Python支持所谓的命名参数，从而
Python supports what are called named arguments, whereby

1933
01:34:51,069 --> 01:34:53,949
如果一项功能，特别是像打印这样的超级强大的功能，
if a function, especially one that's super powerful like print,

1934
01:34:53,949 --> 01:34:58,539
接受多个输入，例如此输入，另一输入和另一输入。
takes multiple inputs, like this one, this other one, and this other thing.

1935
01:34:58,539 --> 01:35:00,429
这些输入中的每一个都可以具有名称。
Each of those inputs can have names.

1936
01:35:00,430 --> 01:35:04,240
您，该函数的用户，可以指定名称。
And you, the user of that function, can specify the name.

1937
01:35:04,239 --> 01:35:10,329
事实证明，Python中的print支持一个称为“ end”的参数。
And it turns out that print in Python supports an argument called "end."

1938
01:35:10,329 --> 01:35:14,919
您可以明确地说出您想为该参数赋予什么值
And you can explicitly say what value you want to give to that parameter

1939
01:35:14,920 --> 01:35:16,300
提起它的名字。
by mentioning its name.

1940
01:35:16,300 --> 01:35:18,550
在这里，我将按照字面意思进行操作。
And here I'm going to literally do this.

1941
01:35:18,550 --> 01:35:20,740
我要告诉打印功能
I'm going to tell the print function that I

1942
01:35:20,739 --> 01:35:25,899
希望将“结束”的值，参数，参数作为引号取消引用。
want the value of "end," a parameter, an argument to it, to be quote, unquote.

1943
01:35:25,899 --> 01:35:28,629
这样做的原因是，如果我阅读了文档，
The reason for that is that if I read the documentation,

1944
01:35:28,630 --> 01:35:30,160
默认实际上是这个。
the default is actually this.

1945
01:35:30,159 --> 01:35:34,599
如果您阅读了文档，它将告诉您打印的默认值
If you read the documentation, it will tell you print's default value

1946
01:35:34,600 --> 01:35:37,510
因为它的结束参数是反斜杠n。
for its end argument is backslash n.

1947
01:35:37,510 --> 01:35:39,580
这也是C所没有的功能。
This, too, is a feature that C did not have.

1948
01:35:39,579 --> 01:35:41,349
C没有可选参数。
C did not have optional arguments.

1949
01:35:41,350 --> 01:35:43,510
他们在那儿或者不在。
They're either there or they're not.

1950
01:35:43,510 --> 01:35:46,870
相反，它们要么必须存在，要么不能在那里。
Rather, they either have to be there, or they cannot be there.

1951
01:35:46,869 --> 01:35:51,309
Python支持甚至具有默认值的可选参数。
Python supports optional arguments that even have default values.

1952
01:35:51,310 --> 01:35:54,910
因此，在这种情况下，根据文档的默认值，
And so in this case, the default value of this, per the documentation,

1953
01:35:54,909 --> 01:35:58,239
那个末端是引号，反引号反引号n，这是
is that end is quote, unquote backslash n, which

1954
01:35:58,239 --> 01:36:00,879
这就是为什么每一行都以该值结尾的原因。
is why every line ends with that value.

1955
01:36:00,880 --> 01:36:02,950
如果您想将其更改为空，
If you want to change that to be nothing,

1956
01:36:02,949 --> 01:36:06,069
所谓的空字符串，您将其更改为引用，取消引用。
the so-called empty string, you change it to quote, unquote.

1957
01:36:06,069 --> 01:36:09,759
因此，让我继续并立即运行此命令，瞧，更近一点。
So let me go ahead and run this now, and voila, closer.

1958
01:36:09,760 --> 01:36:12,490
看起来有点愚蠢，因为现在我的光标结束了-
It's a little stupid looking, because now my cursor ended up--

1959
01:36:12,489 --> 01:36:14,689
我的提示在同一行结束。
my prompt ended up on the same line.

1960
01:36:14,689 --> 01:36:18,129
因此，也许在这一行之后，让我继续进行，不打印任何内容，也就是说，
So maybe after this line, let me just go ahead and print nothing, that is,

1961
01:36:18,130 --> 01:36:19,190
新线。
a new line.

1962
01:36:19,189 --> 01:36:23,774
现在，如果我运行mario.py，瞧，现在就可以得到想要的效果。
And now if I run mario.py, voila, now I get the effect I want.

1963
01:36:23,774 --> 01:36:25,899
如果您想看看这里到底发生了什么，
And if you want to see what's really going on here,

1964
01:36:25,899 --> 01:36:28,149
我可以做一些愚蠢的事情，例如“ HELLO”。
I can do something stupid like "HELLO."

1965
01:36:28,149 --> 01:36:34,179
现在，我可以用“ HELLO”，“ HELLO”，“ HELLO”，“ HELLO”结束所有打印。
And now I can end every print with "HELLO," "HELLO," "HELLO," "HELLO."

1966
01:36:34,180 --> 01:36:36,430
并非您会那样做，仅此而已。
Not that you would do that, but that's all it means.

1967
01:36:36,430 --> 01:36:40,060
它结束了每次使用该表达式进行打印的调用。
It's ending every call to print with that expression.

1968
01:36:40,060 --> 01:36:44,560
但是，正确的版本当然只是以这种方式将其清除。
But the correct version, of course, is just to blank it out in this way.

1969
01:36:44,560 --> 01:36:47,260
但是这里有些很棒。
But here's something that's kind of cool.

1970
01:36:47,260 --> 01:36:49,660
如果您是个极客，这就是这里
And this is where if you're kind of a geek,

1971
01:36:49,659 --> 01:36:51,879
生活开始变得非常有趣。
life starts to get really interesting fast.

1972
01:36:51,880 --> 01:36:55,510
我实际上可以更改我的Python代码以打印出这四个问题
I can actually change my Python code to print out these four question

1973
01:36:55,510 --> 01:37:00,760
天空中的标记可以很简单地打印报价单，取消报价单问题
marks in the sky to be quite simply print quote, unquote question

1974
01:37:00,760 --> 01:37:03,100
标记时间4。
mark times 4.

1975
01:37:03,100 --> 01:37:06,280
现在，如果我重新运行该程序，繁荣就完成了。
And now if I rerun this program, boom, done.

1976
01:37:06,279 --> 01:37:10,349
再次在这里，您将获得该语言的许多功能
And here's where, again, you're getting a lot of features in the language

1977
01:37:10,350 --> 01:37:12,100
您无需考虑循环的地方，
where you don't have to think about loops,

1978
01:37:12,100 --> 01:37:14,680
您不必考虑很多语法。
you don't have to think about a lot of syntax.

1979
01:37:14,680 --> 01:37:17,590
如果您想打一个问号并重复四次，
If you want to take a question mark and do it four times,

1980
01:37:17,590 --> 01:37:20,080
您可以从字面上使用star运算符，
you can literally use the star operator, which

1981
01:37:20,079 --> 01:37:24,489
已被重载，不仅支持与数字相乘
has been overloaded to support not only multiplication with numbers

1982
01:37:24,489 --> 01:37:31,339
而且还可以通过这种方式自动连接字符串（如果愿意的话）。
but also automatic concatenation, if you will, with strings in this way.

1983
01:37:31,340 --> 01:37:33,643
因此，让我继续为马里奥做一个最终版本。
So let me go ahead and do one final version for mario.

1984
01:37:33,643 --> 01:37:35,560
回想一下，我们用马里奥打造的最后一件事
Recall that the last thing we built with mario

1985
01:37:35,560 --> 01:37:37,060
看起来有点像这样。
looked a little something like this.

1986
01:37:37,060 --> 01:37:40,840
让我继续，现在更改我的马里奥代码，使之适合我，范围为3，
Let me go ahead and change my mario code now to be for i in range of 3,

1987
01:37:40,840 --> 01:37:44,260
因为这是一个3 x 3的砖块，所以可以说。
because this is a 3 by 3 grid of bricks, let's say.

1988
01:37:44,260 --> 01:37:46,960
让我们继续，现在，在这个循环中，
And let's go ahead and now, inside of this loop,

1989
01:37:46,960 --> 01:37:53,830
进行另一个嵌套循环，在该循环中我也做三列。
do another nested loop where I do three columns as well.

1990
01:37:53,829 --> 01:37:56,949
在这里，我想一次打印出一个哈希值。
And in here, I want to print out a single hash at a time.

1991
01:37:56,949 --> 01:37:58,979
但是我不想打印新行。
But I don't want to print out a new line.

1992
01:37:58,979 --> 01:38:02,022
我只想在这里打印换行。
I only want to print out a new line here.

1993
01:38:02,023 --> 01:38:04,440
事实证明，这是因为Python为您提供了
So it turns out that essentially, because Python gives you

1994
01:38:04,439 --> 01:38:07,709
反斜杠n是自动的，基本上是任何逻辑
the backslash n's automatically, essentially any logic

1995
01:38:07,710 --> 01:38:09,870
您过去写的内容现在需要颠倒。
you wrote in the past now needs to be reversed.

1996
01:38:09,869 --> 01:38:13,199
如果您曾经打印过新行，现在就不想再打印新行了。
If you ever printed a new line, now you don't want to print a new line.

1997
01:38:13,199 --> 01:38:17,399
而且，如果您从未打印过新行，则从某种意义上说现在可以了。
And if you ever didn't print a new line, now you do, in some sense.

1998
01:38:17,399 --> 01:38:19,499
所以让我继续-
So let me go ahead and--

1999
01:38:19,500 --> 01:38:22,439
不正确，语言错误-mario.py的python。
not make, wrong language-- python of mario.py.

2000
01:38:22,439 --> 01:38:24,819
瞧，我的3乘3格。
And voila, my 3 by 3 grid.

2001
01:38:24,819 --> 01:38:28,319
这就是说在Python中，我们可以嵌套循环
So this is to say that in Python, we can nest loops, just

2002
01:38:28,319 --> 01:38:31,379
就像我们在C中所做的那样。我可以使用多个变量名，例如
like we did in C. I can use multiple variable names, like i

2003
01:38:31,380 --> 01:38:32,640
和j是常规的。
and j being conventional.

2004
01:38:32,640 --> 01:38:35,010
没有花括号，没有分号。
There's no curly braces, there's no semicolons.

2005
01:38:35,010 --> 01:38:37,920
但是，逻辑又是相同的。
But again, the logic, the ideas are still the same.

2006
01:38:37,920 --> 01:38:42,070
例如，它只需要一点时间就可以习惯
It just takes a little bit of time to get used to, for instance,

2007
01:38:42,069 --> 01:38:43,649
一些新语法。
some of the new syntax.

2008
01:38:43,649 --> 01:38:48,599
您会记得在C语言中，我们很早就遇到了整数问题。
You'll recall that in C, we ran into a problem pretty early on with integers.

2009
01:38:48,600 --> 01:38:50,880
让我在这里创建一个名为int.py的程序。
And let me create a program here called int.py.

2010
01:38:50,880 --> 01:38:53,970
然后让我将名为i的变量初始化为1。
And let me initialize a variable called i to 1.

2011
01:38:53,970 --> 01:38:55,830
让我继续做下去，直到永远。
And let me go ahead and do this forever.

2012
01:38:55,829 --> 01:38:56,889
让我永远做到这一点。
Let me do this forever.

2013
01:38:56,890 --> 01:38:58,140
而不是一会儿True块。
Instead of a while True block.

2014
01:38:58,140 --> 01:38:59,760
让我打印出我是什么。
Let me print out whatever i is.

2015
01:38:59,760 --> 01:39:04,380
然后让我继续，在每次迭代中给i加1。
And then let me go ahead and just add 1 to i on each iteration.

2016
01:39:04,380 --> 01:39:06,370
让我继续运行该程序。
Let me go ahead and run this program.

2017
01:39:06,369 --> 01:39:09,639
现在，让我增加窗口的大小，然后运行该程序即可。
And let me increase the size of my window for now and just run this thing.

2018
01:39:09,640 --> 01:39:10,740
哎呀，那是马里奥。
Whoops, that was mario.

2019
01:39:10,739 --> 01:39:16,009
让我运行这个东西，即int.py的python。
Let me run this thing, python of int.py.

2020
01:39:16,010 --> 01:39:18,510
您会看到它的数量一直到无限。
And you'll see that it's counting up to infinity.

2021
01:39:18,510 --> 01:39:21,020
老实说，这将需要一段时间。
And honestly, this is going to take a while.

2022
01:39:21,020 --> 01:39:25,340
您知道什么比计数为1 /乘以2更快。
You know what's faster than counting by 1/ maybe multiplying by 2.

2023
01:39:25,340 --> 01:39:28,040
因此，让我继续乘以2。
So let me go ahead and multiply by 2 instead.

2024
01:39:28,039 --> 01:39:30,439
要杀死程序，就像在CI中使用Control-C一样。
To kill the program, just like in C I used Control-C.

2025
01:39:30,439 --> 01:39:32,389
这就是为什么我看到键盘中断的原因。
And that's why I see keyboard interrupt.

2026
01:39:32,390 --> 01:39:34,860
它尊重我要取消该程序的意愿。
It respected my wanting to cancel the program.

2027
01:39:34,859 --> 01:39:37,609
现在让我重新运行一下，只算非常大。
Let me rerun this now and just count really big.

2028
01:39:37,609 --> 01:39:39,829
即使互联网有点慢，
And even though the internet's being a little slow,

2029
01:39:39,829 --> 01:39:44,119
这就是为什么有点不稳定的原因，这已经是一个很大的数字
which is why it's a little shaky, that's a really big number already

2030
01:39:44,119 --> 01:39:46,099
如果我继续加倍我。
if I keep doubling i.

2031
01:39:46,100 --> 01:39:48,500
此时已经发生了什么
What would have happened already at this point

2032
01:39:48,500 --> 01:39:51,620
如果我使用C来实现此程序？
if I were using C to implement this program?

2033
01:39:51,619 --> 01:39:55,699
如果在CI中声明了一个名为i的变量，并且它是一个int，
If in C I declared a variable called i, and it was an int,

2034
01:39:55,699 --> 01:39:57,769
我不断地将它翻倍
and I kept doubling it, again and again and again

2035
01:39:57,770 --> 01:39:59,465
一次又一次，从字面上永远吗？
and again and again, literally forever?

2036
01:40:02,149 --> 01:40:02,839
有什么想法吗？
Any thoughts?

2037
01:40:02,840 --> 01:40:03,740
是的。
Yeah.

2038
01:40:03,739 --> 01:40:05,479
C. Joy会发生什么？
What would have happened in C. Joy?

2039
01:40:08,210 --> 01:40:11,102
听众：是的，我想它会崩溃的。
AUDIENCE: Yeah, I think it would have crashed.

2040
01:40:11,101 --> 01:40:12,559
大卫·马兰（David MALAN）：它将崩溃吗？
DAVID MALAN: It would have crashed?

2041
01:40:12,560 --> 01:40:14,870
为什么？
Why?

2042
01:40:14,869 --> 01:40:17,536
听众：因为这会占用很多内存。
AUDIENCE: Because it would be taking much memory.

2043
01:40:17,537 --> 01:40:18,620
DAVID MALAN：好主意。
DAVID MALAN: Good thought.

2044
01:40:18,619 --> 01:40:20,097
因此它本身不会崩溃。
So it wouldn't crash per se.

2045
01:40:20,097 --> 01:40:21,139
会出问题。
Something would go wrong.

2046
01:40:21,140 --> 01:40:21,890
它不会崩溃。
It wouldn't crash.

2047
01:40:21,890 --> 01:40:24,170
因为它仍然是一个int，至少在C语言中，
Because it's still an int, and in C at least,

2048
01:40:24,170 --> 01:40:27,590
在典型的计算机上，它仍将占用32位或4字节。
it would still be taking up on a typical computer 32 bits or 4 bytes.

2049
01:40:27,590 --> 01:40:31,520
但说实话，该程序可能会开始打印0
But honestly, the program probably would have started printing 0

2050
01:40:31,520 --> 01:40:33,320
现在，甚至是负数。
by now, or even negative numbers.

2051
01:40:33,319 --> 01:40:35,839
因为回忆，C的局限性之一
Because recall, one of the limitations of C

2052
01:40:35,840 --> 01:40:38,570
是整数是有限大小的吗？
is that integers are a finite size--

2053
01:40:38,569 --> 01:40:40,649
只有32位或4个字节。
only 32 bits or 4 bytes.

2054
01:40:40,649 --> 01:40:43,909
这意味着如果您继续从1、2、4、8、16开始
Which means if you keep going from 1, 2, 4 8, 16,

2055
01:40:43,909 --> 01:40:46,999
一百万，两百万，四百万，八百万，
a million, 2 million, 4 million, 8 million,

2056
01:40:47,000 --> 01:40:49,640
依此类推，最终您将涉足数十亿美元。
and so forth, eventually you're going to get into the billions.

2057
01:40:49,640 --> 01:40:52,820
而一旦您越过20亿甚至40亿的门槛
And as soon as you cross the 2 billion threshold or maybe the 4 billion

2058
01:40:52,819 --> 01:40:56,999
阈值，如果使用带符号或无符号数字，它将变得太大。
threshold, if using signed or unsigned numbers, it's going to get too big.

2059
01:40:57,000 --> 01:40:58,669
您将有整数溢出。
You're going to have integer overflow.

2060
01:40:58,670 --> 01:41:03,710
但是在Python的世界中，整数溢出已经不复存在了。
But in the world of Python, integer overflow, not a thing anymore.

2061
01:41:03,710 --> 01:41:05,600
在Python的世界中，您的数字将
In the world of Python, your numbers will

2062
01:41:05,600 --> 01:41:08,090
扩大到您需要的大小。
get as big as you need them to get.

2063
01:41:08,090 --> 01:41:10,770
他们将自动为您解决此问题。
They will automatically address this problem for you.

2064
01:41:10,770 --> 01:41:15,200
不幸的是，浮点数不精确，仍然是一回事。
Unfortunately, floating point imprecision, still a thing.

2065
01:41:15,199 --> 01:41:18,057
因此，我之前只将1除以2。
So I only divided 1 by 2 earlier.

2066
01:41:18,057 --> 01:41:21,349
但是，如果我继续除以其他值，并查看了足够的小数点，
But if I continue to divide other values and I looked at enough decimal points,

2067
01:41:21,350 --> 01:41:24,290
不幸的是，我们仍然会遭受浮点不精确的困扰。
we would still suffer, unfortunately, from floating point imprecision.

2068
01:41:24,289 --> 01:41:27,949
但是，在Python的世界中，例如Java和其他语言，
However, in the world of Python, like in Java and other languages,

2069
01:41:27,949 --> 01:41:30,379
有图书馆，科学图书馆
there are libraries, scientific libraries

2070
01:41:30,380 --> 01:41:33,500
使您可以根据需要使用尽可能多的精度，
that allow you to use as much precision as you need,

2071
01:41:33,500 --> 01:41:35,720
或至少与您的计算机一样多的内存。
or at least as much memory as your computer has.

2072
01:41:35,720 --> 01:41:39,560
因此，这些问题也已经用更现代的语言更好地解决了
So those problems, too, have been better solved in more modern languages

2073
01:41:39,560 --> 01:41:42,260
而不是像C代码这样的开箱即用的东西。
than in something out of the box like C code.

2074
01:41:42,260 --> 01:41:45,800
但是，只要一次又一次地乘以那个数字，我就可以了，
But just by multiplying that number again and again was I able, then,

2075
01:41:45,800 --> 01:41:50,720
展示出比过去几周更大的数字。
to demonstrate much larger numbers than we ever saw in weeks past.

2076
01:41:50,720 --> 01:41:53,690
好吧，让我继续在这里做另一个程序，
Well, let me go ahead and do another program here,

2077
01:41:53,689 --> 01:41:56,689
这个叫做scores.py。
this one called scores.py.

2078
01:41:56,689 --> 01:41:58,849
这将是保持真实状态的一个例子
That's going to be an example of really keeping

2079
01:41:58,850 --> 01:42:03,140
跟踪分数，这是我们在课程的第2周初期所做的一个示例。
track of scores, which was an example we did early on in week 2 of the class.

2080
01:42:03,140 --> 01:42:05,390
在Python中，我将继续前进
And in Python, I'm going to go ahead and give myself

2081
01:42:05,390 --> 01:42:06,890
像这样的分数列表
a list of scores like this--

2082
01:42:06,890 --> 01:42:08,900
72、73和33--
72, 73, and 33--

2083
01:42:08,899 --> 01:42:11,284
再次，有趣地引用了我们的ASCII数字。
again, sort of a playful reference to our ASCII numbers.

2084
01:42:11,284 --> 01:42:13,159
但是在这种情况下，它们是测验分数-所以
But in this context, they're quiz scores-- so

2085
01:42:13,159 --> 01:42:16,009
两个OK测验分数和一种低测验分数，
two OK quiz scores, and one kind of low quiz score,

2086
01:42:16,010 --> 01:42:18,110
假设这些东西不超过100。
assuming these things are out of like 100.

2087
01:42:18,109 --> 01:42:19,849
但是请注意我使用的语法。
But notice the syntax I'm using.

2088
01:42:19,850 --> 01:42:22,680
Python中的方括号为我提供了一个列表。
Square brackets in Python give me a list.

2089
01:42:22,680 --> 01:42:25,070
我不必事先决定它的大小。
I don't have to decide in advance how big it is.

2090
01:42:25,069 --> 01:42:27,599
它本身不是数组，但是在精神上是相似的。
It's not an array per se, but it's similar in spirit.

2091
01:42:27,600 --> 01:42:29,480
但是它会自动增长或收缩。
But it will automatically grow or shrink.

2092
01:42:29,479 --> 01:42:31,369
而且语法甚至更简单。
And the syntax is even simpler.

2093
01:42:31,369 --> 01:42:33,617
假设我想在Python中平均这些分数。
Suppose I want to average these scores in Python.

2094
01:42:33,618 --> 01:42:34,910
我可以做这样的事情。
I could do something like this.

2095
01:42:34,909 --> 01:42:39,139
我可以打印出这些分数的平均值，例如-
I could print out that the average of these scores is, for instance--

2096
01:42:39,140 --> 01:42:40,880
然后我可以做这样的事情。
and then I could do something like this.

2097
01:42:40,880 --> 01:42:46,130
我可以将分数之和除以分数的长度。
I could do the sum of scores divided by the length of scores.

2098
01:42:46,130 --> 01:42:49,190
其中一些实际上已经是新的。
And some of this is actually kind of new already.

2099
01:42:49,189 --> 01:42:54,709
事实证明，在Python中，有sum函数将一个列表作为输入
It turns out in Python that there is sum function that will take a list as input

2100
01:42:54,710 --> 01:42:58,520
并将这些项目的总和返还给您。
and return to you the sum of those items.

2101
01:42:58,520 --> 01:43:01,790
而且我们已经看到了len函数LEN
And we've seen already there's a len function, L-E-N

2102
01:43:01,789 --> 01:43:03,569
告诉您列表的长度。
that tells you the length of a list.

2103
01:43:03,569 --> 01:43:07,459
因此，如果我将所有分数相加然后除以分数总数，
So if I add up all my scores and then divide by the total number of scores,

2104
01:43:07,460 --> 01:43:09,660
从定义上讲，这应该给我我的平均值。
that should give me by definition my average.

2105
01:43:09,659 --> 01:43:13,389
因此，scores.py的蟒蛇，瞧-
So python of scores.py, voila--

2106
01:43:13,390 --> 01:43:15,620
哎呀，我在这里做什么？
whoops, what did I do here?

2107
01:43:15,619 --> 01:43:18,389
啊，我搞砸了。
Ah, I screwed up.

2108
01:43:18,390 --> 01:43:21,560
坦率地说，这是意料之外的，但让我在这里尝试保存自己。
So unintended, admittedly, but let me try to save myself here.

2109
01:43:21,560 --> 01:43:22,980
那到底发生了什么？
So what just happened?

2110
01:43:22,979 --> 01:43:24,854
好吧，此错误消息有点含糊不清。
Well, this error message is a little cryptic.

2111
01:43:24,854 --> 01:43:29,469
它说：“ TypeError-只能将str串联，而不能将float串联到str。”
It says, "TypeError-- can only concatenate str, not float, to str."

2112
01:43:29,470 --> 01:43:29,970
长。
long.

2113
01:43:29,970 --> 01:43:32,460
简而言之，Python在这种情况下不
Story short, Python in this case does not

2114
01:43:32,460 --> 01:43:36,540
就像我尝试在左侧取平均弦的事实
like the fact that I'm trying to take a string, average, on the left

2115
01:43:36,539 --> 01:43:40,214
并在右边连接一个浮点数。
and concatenate to it a float on the right.

2116
01:43:40,215 --> 01:43:42,090
因此，有两种方法可以解决此问题。
So there's a couple of ways I can solve this.

2117
01:43:42,090 --> 01:43:44,860
而且，我们早些时候已经看到了基本的解决方案。
And we saw the fundamental solution earlier.

2118
01:43:44,859 --> 01:43:47,699
如果我在这里强调了这个表达
If this expression here that I've highlighted

2119
01:43:47,699 --> 01:43:52,319
从定义上讲，它是一个浮点数，但我希望它成为一个字符串，
is by definition mathematically a float, but I want it to become a string,

2120
01:43:52,319 --> 01:43:56,399
我可以告诉Python，将浮点数转换为字符串。
I can just tell Python, convert that float to a string.

2121
01:43:56,399 --> 01:44:00,127
就像有些人发现了itoa函数一样，
So much like there's the itoa function that some of you discovered,

2122
01:44:00,127 --> 01:44:01,919
与atoi函数相反
which is the opposite of the atoi function,

2123
01:44:01,920 --> 01:44:05,430
我可以使用Python（在这种情况下为float），
I can take in Python, in this case a float,

2124
01:44:05,430 --> 01:44:07,330
并将其转换为等效的字符串。
and convert it to a string equivalent.

2125
01:44:07,329 --> 01:44:13,319
因此，如果我现在运行scores.py，voila的python，我的平均值为59.333333。
So now if I run python of scores.py, voila, my average is 59.333333.

2126
01:44:13,319 --> 01:44:15,299
而且您已经看到了一些不精确的地方。
And you already see a bit of imprecision.

2127
01:44:15,300 --> 01:44:19,573
最后有一些舍入误差，这不是完美的三分之一。
There's some rounding error at the end there that is not a perfect one third.

2128
01:44:19,573 --> 01:44:21,240
但是我还有另一种方式可以做到这一点。
But there's another way I could do this.

2129
01:44:21,239 --> 01:44:22,469
而且有点难看。
And it's a little uglier.

2130
01:44:22,470 --> 01:44:25,050
但是我可以使用其中的F弦之一。
But I could use one of those f-strings.

2131
01:44:25,050 --> 01:44:27,540
我可以说，插入一个值
I could, say, go ahead and plug in a value

2132
01:44:27,539 --> 01:44:30,609
在这里，只需打印出用户的平均值即可。
here and just print out the user's average.

2133
01:44:30,609 --> 01:44:32,969
事实证明，在这些花括号内，
So it turns out that inside of these curly braces,

2134
01:44:32,970 --> 01:44:35,880
您不必只打印变量。
you don't have to print just variables.

2135
01:44:35,880 --> 01:44:39,040
您实际上可以放置整个编码表达式。
You can actually put entire coding expressions.

2136
01:44:39,039 --> 01:44:42,136
而且我鼓励您不要粘贴疯狂的冗长的代码行，
And I would encourage you not to paste crazy long lines of code,

2137
01:44:42,136 --> 01:44:44,219
因为它很快就会变得不可读。
because it's going to very quickly get unreadable.

2138
01:44:44,220 --> 01:44:46,290
在那时，您可能应该使用一个变量。
At that point you probably should use a variable.

2139
01:44:46,289 --> 01:44:49,919
但是在这里我可以继续并运行scores.py的python。
But here I can go ahead and run python of scores.py.

2140
01:44:49,920 --> 01:44:52,170
瞧-我又搞砸了。
And voila-- I screwed up again.

2141
01:44:52,170 --> 01:44:54,750
同样不是故意的，但是我可以解决这个问题。
Also not intentional, but I can fix this.

2142
01:44:54,750 --> 01:44:59,309
是的，我在开始时就缺少f来使它成为格式化的字符串。
Yeah, I'm missing the f at the beginning to make this a formatted string.

2143
01:44:59,310 --> 01:45:02,928
现在，如果我重新运行它，瞧，同样的答案。
And now if I rerun it, voila, same exact answer.

2144
01:45:02,927 --> 01:45:04,469
同样，我有多种方法。
So again, I have multiple approaches.

2145
01:45:04,470 --> 01:45:05,640
这里有第三个。
There's a third one here.

2146
01:45:05,640 --> 01:45:09,480
我可以做点什么-实际上，在这种情况下，我不需要str，
I could do something-- and actually, I don't need the str in that context,

2147
01:45:09,479 --> 01:45:11,939
因为现在如果它在格式字符串中，
because now if it's inside of a format string,

2148
01:45:11,939 --> 01:45:15,209
Python会假定我要自动将其转换为字符串。
Python will presume that I want to automatically convert it to a string.

2149
01:45:15,210 --> 01:45:16,170
很好。
So that's nice.

2150
01:45:16,170 --> 01:45:18,780
或者我可以将其排除在外，然后我可以说些什么
Or I can just factor this out, and I can say something

2151
01:45:18,779 --> 01:45:22,229
这样-给我一个称为平均值的变量，将其分配为等于该数学值，
like this-- give me a variable called average, assign it equal to that math,

2152
01:45:22,229 --> 01:45:23,919
然后打印出平均值。
and then print out the average.

2153
01:45:23,920 --> 01:45:26,970
同样，就像在C语言中一样，有很多不同的方法可以解决问题。
So again, just like in C, so many different ways to solve the problem.

2154
01:45:26,970 --> 01:45:29,550
而哪一个最好则取决于什么
And which one is best depends really on what

2155
01:45:29,550 --> 01:45:33,953
可能是最易读，最易维护或最容易做到的。
might be most readable, most maintainable, or easiest to do.

2156
01:45:33,953 --> 01:45:36,120
让我继续，现在动态添加一些分数。
Let me go ahead and add some scores dynamically now.

2157
01:45:36,119 --> 01:45:38,009
不用硬编码我的三个分数，而是
Instead of hardcoding my three scores, let

2158
01:45:38,010 --> 01:45:41,010
我问自己在整个学期的成绩。
me ask myself for my scores over the course of the semester.

2159
01:45:41,010 --> 01:45:44,850
从cs50开始，让我get_int，这样我就可以轻松获得一些数字。
From cs50 let me get_int, just so I can get some numbers easily.

2160
01:45:44,850 --> 01:45:48,270
让我给自己一个空的分数列表，其语法
Let me give myself an empty list of scores, the syntax for which

2161
01:45:48,270 --> 01:45:52,380
只是开括号，右括号，所以最初没有任何内容。
is just open bracket, close bracket, so nothing inside of it initially.

2162
01:45:52,380 --> 01:45:53,880
现在让我继续执行此操作。
And now let me go ahead and do this.

2163
01:45:53,880 --> 01:45:55,380
我给自己打三分
Let me get myself three scores--

2164
01:45:55,380 --> 01:45:56,880
也许现在该学期结束了。
maybe it's the end of the term now.

2165
01:45:56,880 --> 01:46:03,120
对于3范围内的我，让我继续并附加到分数数组中
For i in range of 3, let me go ahead and append to the scores array

2166
01:46:03,119 --> 01:46:07,452
不管get_int的返回值是什么样的。
whatever the return value of get_int is like this.

2167
01:46:07,453 --> 01:46:09,370
现在，我也可以通过多种方式做到这一点。
Now, this, too, I could do in a bunch of ways.

2168
01:46:09,369 --> 01:46:12,041
让我在这里摆脱它。
Let me get rid of this here.

2169
01:46:12,042 --> 01:46:12,930
哎呀
Whoops.

2170
01:46:12,930 --> 01:46:14,160
不，我们将其留在那儿。
Nope, we'll leave that there.

2171
01:46:14,159 --> 01:46:15,539
我可以通过多种方式做到这一点。
This I could do in a bunch of ways.

2172
01:46:15,539 --> 01:46:16,622
但是请注意我在做什么。
But notice what I'm doing.

2173
01:46:16,622 --> 01:46:20,369
我正在获取int，并且正在传递int的返回值
I'm getting int, and I'm passing the return value of int

2174
01:46:20,369 --> 01:46:21,869
到一个名为append的新函数中。
to a new function called append.

2175
01:46:21,869 --> 01:46:24,839
事实证明，列表，方括号，
It turns out that lists, the square brackets,

2176
01:46:24,840 --> 01:46:27,600
在将它们定义为诸如scores之类的变量后，
once you've defined them in a variable like scores,

2177
01:46:27,600 --> 01:46:29,350
它们也具有内置的功能。
they, too, have functions built into them.

2178
01:46:29,350 --> 01:46:34,090
因此，我可以执行scores.append以便将数字添加到列表中。
So I can do scores.append in order to add a number to the list.

2179
01:46:34,090 --> 01:46:36,840
因此，现在让我继续运行此程序，运行scores.py的python。
So now let me go ahead and run this, python of scores.py.

2180
01:46:36,840 --> 01:46:40,260
让我手动输入72、73和33。
Let me manually type in my 72, my 73, and my 33.

2181
01:46:40,260 --> 01:46:42,675
瞧，同样的答案。
And voila, same exact answer.

2182
01:46:42,675 --> 01:46:44,550
但是想想这会带来多大的痛苦
But think about how much of a pain this would

2183
01:46:44,550 --> 01:46:46,950
如果您必须决定使用C
have been in C, if you had to either decide

2184
01:46:46,949 --> 01:46:49,799
预先确定数组的大小，还是不预先确定
in advance the size of the array, or not decide in advance

2185
01:46:49,800 --> 01:46:53,460
并使用malloc和realloc使其不断增长和缩小。
and use malloc and realloc to keep growing and shrinking it.

2186
01:46:53,460 --> 01:46:56,340
Python，使用此附加函数，其中
Python, using this append function, which

2187
01:46:56,340 --> 01:46:59,880
进入该列表变量的内部，处理
comes inside of that list variable, handles

2188
01:46:59,880 --> 01:47:03,070
所有这些对我们来说都是自动的。
all of this automatically for us.

2189
01:47:03,069 --> 01:47:03,569
好的。
All right.

2190
01:47:03,569 --> 01:47:06,779
因此，这也是一堆功能。
So that, too, is a whole bunch of features.

2191
01:47:06,779 --> 01:47:10,199
但是，我有什么要回答的问题吗？
Any questions, though, that I can answer here?

2192
01:47:13,149 --> 01:47:16,419
任何问题？
Any questions?

2193
01:47:16,420 --> 01:47:16,920
不？
No?

2194
01:47:16,920 --> 01:47:19,290
是的，去圣地亚哥。
Yeah, over to Santiago.

2195
01:47:19,289 --> 01:47:20,459
听众：是的。
AUDIENCE: Yeah.

2196
01:47:20,460 --> 01:47:22,800
我有一个问题-
I had a question about--

2197
01:47:22,800 --> 01:47:28,410
因此，即使append减少了您必须编写的代码量，
so even if append reduces the amount of code you have to write,

2198
01:47:28,409 --> 01:47:31,559
它在引擎盖下是否恰好做了我们所要做的
does it underneath the hood just do exactly what we

2199
01:47:31,560 --> 01:47:35,900
用C做的，就像malloc和realloc之类的？
were doing in C, which is like, malloc and realloc, or something like that?

2200
01:47:35,899 --> 01:47:38,099
这就是全部-这是在Python内部发生的吗？
Is that all-- is that happening inside Python?

2201
01:47:38,100 --> 01:47:38,970
戴维·马兰：是的。
DAVID MALAN: It is.

2202
01:47:38,970 --> 01:47:41,068
是的，这就是您免费获得的东西，
Yeah, that's exactly what you're getting for free,

2203
01:47:41,068 --> 01:47:42,360
可以说，用语言。
so to speak, with the language.

2204
01:47:42,359 --> 01:47:45,029
所有这些malloc的东西，realloc的东西，也许是
All of that malloc stuff, realloc stuff, maybe it's

2205
01:47:45,029 --> 01:47:47,447
用引擎盖下面的阵列实现，
implemented with an array underneath the hood,

2206
01:47:47,448 --> 01:47:48,990
就像在实际计算机的内存中一样。
like in the actual computer's memory.

2207
01:47:48,989 --> 01:47:51,137
也许是像我们上周看到的那样的链表。
Maybe it's a linked list like we saw last week.

2208
01:47:51,137 --> 01:47:52,679
但是所有这些都在为您发生。
But all of that is happening for you.

2209
01:47:52,680 --> 01:47:55,470
但这又是代码最终的原因之一
But that, again, is one of the reasons why the code ultimately

2210
01:47:55,470 --> 01:47:59,370
运行速度稍慢，因为您之间有其他人的代码
runs a little slower, because you have someone else's code in between you

2211
01:47:59,369 --> 01:48:03,209
而计算机中的CPU会为您完成一些工作。
and the CPU in your computer doing a bit of that work for you.

2212
01:48:03,210 --> 01:48:06,180
索菲亚？
Sophia?

2213
01:48:06,180 --> 01:48:08,360
听众：有效率差异吗
AUDIENCE: Are there efficiency differences

2214
01:48:08,359 --> 01:48:13,639
在我们打印的方式之间，利用f格式
in between the ways that we print, of utilizing the f formatting

2215
01:48:13,640 --> 01:48:16,550
还是我们使用的其他形式？
or the other forms that we've used?

2216
01:48:16,550 --> 01:48:19,700
戴维·马兰（DAVID MALAN）：如果我的理解正确，则不必如此
DAVID MALAN: You don't have to be-- if I'm understanding correctly,

2217
01:48:19,699 --> 01:48:21,291
它有一些花哨的功能。
there are some fancy features of it.

2218
01:48:21,292 --> 01:48:23,000
例如，您可以使用一些语法
For instance, there is syntax you can use

2219
01:48:23,000 --> 01:48:25,189
指定您想要多少个小数点
to specify how many decimal points you want

2220
01:48:25,189 --> 01:48:27,469
在浮点值之后打印。
to print after a floating point value.

2221
01:48:27,470 --> 01:48:32,030
但这不再是％i，％s，％f等的全部。
But it's no longer all of the %i, %s, %f, and so forth.

2222
01:48:32,029 --> 01:48:34,969
它们的语法略有不同，但幸运的是，
They're slightly different syntax, but fortunately less of it,

2223
01:48:34,970 --> 01:48:39,620
因为您不必担心这些约定。
since you don't have to worry as much about those conventions.

2224
01:48:39,619 --> 01:48:43,369
还有其他疑问或困惑吗？
Other questions or confusion?

2225
01:48:43,369 --> 01:48:43,869
不？
No?

2226
01:48:43,869 --> 01:48:44,239
好的。
All right.

2227
01:48:44,239 --> 01:48:46,364
好吧，让我继续做一个例子
Well, let me go ahead and do one other example that

2228
01:48:46,364 --> 01:48:48,279
在过去的几周内可能会很熟悉。
might be familiar from some weeks past.

2229
01:48:48,279 --> 01:48:51,189
让我继续讲一个简单的例子，只是
Let me go ahead and whip up a quick example of uppercasing, just

2230
01:48:51,189 --> 01:48:53,229
结合我们前面的例子之一
to tie together one of our earlier examples

2231
01:48:53,229 --> 01:48:55,659
我们更自然地看到了或降低了外壳。
that we saw more organically, or lowercasing.

2232
01:48:55,659 --> 01:48:58,391
在这种情况下，一个名为uppercase.py的文件。
In this case, a file called uppercase.py.

2233
01:48:58,391 --> 01:49:00,849
让我继续前进，从CS50库中，让我继续前进
Let me go ahead, and from the CS50 library, let me go ahead

2234
01:49:00,850 --> 01:49:02,338
并导入get_string。
and import get_string.

2235
01:49:02,337 --> 01:49:05,379
然后，有了这个，让我继续从用户那里获取字符串
And then once I have this, let me go ahead and get a string from the user

2236
01:49:05,380 --> 01:49:09,070
并要求他们输入“之前”。
and ask them for, "Before," for instance.

2237
01:49:09,069 --> 01:49:11,509
然后让我继续执行以下操作。
And then let me go ahead and do the following.

2238
01:49:11,510 --> 01:49:13,810
让我继续打印“之后”，目标是我
Let me go ahead and print out "After," the goal being I

2239
01:49:13,810 --> 01:49:16,950
想要为用户将整个字符串大写。
want to uppercase this whole string for the user.

2240
01:49:16,949 --> 01:49:18,949
我将把所有这些保持在同一行。
And I'm going to keep this all on the same line.

2241
01:49:18,949 --> 01:49:21,366
再说一遍，我想要一个可以打印“之前”的程序，
So again, I want a program that's going to print "Before,"

2242
01:49:21,367 --> 01:49:23,320
要求人类进行一些输入，然后，
ask the human for some input, and then after,

2243
01:49:23,319 --> 01:49:26,149
显示整个字符串的大写版本。
show the capitalized version of the whole string.

2244
01:49:26,149 --> 01:49:27,319
那我该怎么做呢？
So how can I do this?

2245
01:49:27,319 --> 01:49:28,719
好吧，我们已经看到了一种方法。
Well, we've seen one way already.

2246
01:49:28,720 --> 01:49:33,160
我可以按字面意思做，例如s.upper。
I can do literally, for instance, s.upper.

2247
01:49:33,159 --> 01:49:34,789
让我继续保存。
And let me go ahead and save this.

2248
01:49:34,789 --> 01:49:37,069
现在运行uppercase.py的python。
And now run python of uppercase.py.

2249
01:49:37,069 --> 01:49:39,549
现在让我以小写形式输入“ hi”，然后开始繁荣
Let me type in "hi" in lowercase, and boom, now

2250
01:49:39,550 --> 01:49:41,350
我得到了大写版本。
I get back the uppercase version.

2251
01:49:41,350 --> 01:49:44,200
但是如果您愿意，您实际上可以操纵单个字符
But if you want, you can actually manipulate individual characters

2252
01:49:44,199 --> 01:49:44,847
也一样
as well.

2253
01:49:44,847 --> 01:49:47,139
让我继续前进，然后进行一些更有趣的操作。
Let me go ahead and a little more pedantically do this.

2254
01:49:47,140 --> 01:49:50,290
对于c in s，打印c。
For c in s, print c.

2255
01:49:50,289 --> 01:49:53,179
现在，这还不是我想要的，但这是一个垫脚石。
Now, this isn't quite what I want yet, but it's a stepping stone.

2256
01:49:53,180 --> 01:49:55,930
现在注意，如果我以小写形式输入“ hi”，
Notice now if I type in "hi" in lowercase,

2257
01:49:55,930 --> 01:49:59,930
我看到“ h”，“ i”，感叹号都全是小写。
I see "h," "i," exclamation point, all still lowercase.

2258
01:49:59,930 --> 01:50:01,557
所以我没有做任何有趣的事情。
So I haven't done anything interesting.

2259
01:50:01,556 --> 01:50:03,639
但是你知道吗，让我摆脱新的界限，
But you know what, let me get rid of the new line,

2260
01:50:03,640 --> 01:50:06,650
只是一切都保持在同一行，因为那有点丑陋。
just so it all stays on the same line, because that was kind of ugly.

2261
01:50:06,649 --> 01:50:07,709
让我再做一次。
Let me do it again.

2262
01:50:07,710 --> 01:50:08,590
好，好一点
OK, a little better.

2263
01:50:08,590 --> 01:50:11,230
让我实际上在程序的最后添加新行
Let me actually add a new line at the very end of the program

2264
01:50:11,229 --> 01:50:13,039
将光标移动到新行。
to move my cursor to the new line.

2265
01:50:13,039 --> 01:50:14,859
让我们再做一次，“嗨”。
Let's do it once more, "hi."

2266
01:50:14,859 --> 01:50:17,419
好吧，我什么都没写。
OK, I'm not uppercasing anything.

2267
01:50:17,420 --> 01:50:23,560
但是，如果我将c更改为c.upper，我可以按预期进行。
But if I change c to c.upper, I can do that as expected.

2268
01:50:23,560 --> 01:50:25,630
让我再次运行它，“嗨”，繁荣发展。
And let me run it again, "hi," and boom.

2269
01:50:25,630 --> 01:50:27,490
现在，我有另一个工作程序。
Now I have another working program.

2270
01:50:27,489 --> 01:50:32,229
但是现在的新功能是，请注意第5行的这种酷炫性。
But the new feature now is, notice this coolness on line 5.

2271
01:50:32,229 --> 01:50:35,079
如果您要遍历字符串的字符，
If you want to iterate over a string's characters,

2272
01:50:35,079 --> 01:50:39,129
您不需要将i初始化为0，然后使用方括号表示法
you don't need to initialize i to 0 and then use square bracket notation

2273
01:50:39,130 --> 01:50:45,460
就像您在C中所做的一样。您只是说，对于c中的s，对于x和y，无论是什么。
like you did in C. You just say, for c in s, or for x and y, whatever it is.

2274
01:50:45,460 --> 01:50:50,257
也可以用于迭代字符串中的各个字符，
For can also be used to iterate over the individual characters in a string,

2275
01:50:50,256 --> 01:50:52,089
正如您在做某事时可能想做的
as you might want to do when doing something

2276
01:50:52,090 --> 01:50:54,133
像密码学之类的。
like cryptography or the like.

2277
01:50:54,132 --> 01:50:56,799
因此，我们不必一次全部将整个字符串都大写。
So we don't have to just uppercase the whole string all at once.

2278
01:50:56,800 --> 01:51:00,340
我们仍然可以使用我们的个人价值观。
We can still gain access to our individual values.

2279
01:51:00,340 --> 01:51:03,550
您还可以在Python中完成其他一些事情，就像在C语言中可以完成的一样。
And there's other things you can do in Python as well that we could do in C.

2280
01:51:03,550 --> 01:51:07,480
让我继续在这里创建一个名为argv.py的程序，
Let me go ahead and create a program here called argv.py,

2281
01:51:07,479 --> 01:51:12,307
参数向量，回想一下，它是main输入的名称
for argument vector, which, recall, was the name of the input to main

2282
01:51:12,307 --> 01:51:14,349
允许您访问命令行参数。
that allows you to access command line arguments.

2283
01:51:14,350 --> 01:51:17,090
今天，我们已经看到您可以拥有一个主要功能
Now today, we have seen that you can have a main function

2284
01:51:17,090 --> 01:51:19,240
但是您不需要，但是这很传统。
but you don't need to, but it's conventional.

2285
01:51:19,239 --> 01:51:20,809
不再需要了。
It's not required anymore.

2286
01:51:20,810 --> 01:51:24,370
因此，我们还没有看到argc或argv，但这是
And so we haven't seen argc or argv yet, but that's

2287
01:51:24,369 --> 01:51:26,499
因为它们在Python中的其他位置。
because they're elsewhere in Python.

2288
01:51:26,500 --> 01:51:29,649
如果您想在Python中访问命令行参数，
If you want to access command line arguments in Python,

2289
01:51:29,649 --> 01:51:33,639
事实证明，您可以导入一个名为argv的模块。
it turns out that you can import a module called argv.

2290
01:51:33,640 --> 01:51:37,300
这有点新，但是它遵循与CS50库相同的模式。
And this is a little new, but it follows the same pattern as the CS50's library.

2291
01:51:37,300 --> 01:51:42,640
我将从系统库中导入一个名为argv的功能。
I'm going to import from the System library a feature called argv.

2292
01:51:42,640 --> 01:51:45,700
所以这只是意味着它是Python附带的，但是要使用它
So this just means that it comes with Python, but to use it

2293
01:51:45,699 --> 01:51:47,979
您必须显式导入它。
you have to import it explicitly.

2294
01:51:47,979 --> 01:51:49,359
现在，我要执行此操作。
And now I'm going to do this.

2295
01:51:49,359 --> 01:51:54,489
如果argv的长度等于2，那么我要
If the length of argv equals 2, then I'm going

2296
01:51:54,489 --> 01:51:57,339
继续进行打印，就像我们几周前所做的一样，
to go ahead and print out, just like we did a few weeks ago,

2297
01:51:57,340 --> 01:52:01,660
“ hello”，然后是argv括号1。
"hello," and then argv bracket 1.

2298
01:52:01,659 --> 01:52:04,479
有点晦涩难懂，但是我稍后会再讲到这一点。
Somewhat cryptic, but I'll come back to this in a moment.

2299
01:52:04,479 --> 01:52:07,579
否则，我将继续打印默认的“你好，世界”。
Else, I'm going to go ahead and print out a default of "hello, world."

2300
01:52:07,579 --> 01:52:09,969
因此，我们在几周前（第二周）进行了此操作
So we did this some weeks ago, in week 2,

2301
01:52:09,970 --> 01:52:14,260
因此，我们运行了一个程序，如果用户在提示符下键入了他们的姓名，
whereby we ran a program that if the user typed their name at the prompt,

2302
01:52:14,260 --> 01:52:16,250
它会说“你好，大卫”或“你好，布莱恩”。
it would say "hello, David" or "hello, Brian."

2303
01:52:16,250 --> 01:52:18,410
如果他们没有，它只会说“你好，世界”。
If they didn't, it would just say "hello, world."

2304
01:52:18,409 --> 01:52:22,149
因此要明确，如果我运行此程序并在没有任何命令行的情况下运行它
So to be clear, if I run this thing and run it without any command line

2305
01:52:22,149 --> 01:52:24,249
论据，我只看到“你好，世界”。
arguments, I just see "hello, world."

2306
01:52:24,250 --> 01:52:27,790
不过，如果我再次运行它，然后输入我的名字，然后按Enter键，
If I run it again, though, and type my name in and hit Enter,

2307
01:52:27,789 --> 01:52:29,019
现在我看到“你好，大卫。”
now I see "hello, David."

2308
01:52:29,020 --> 01:52:30,340
那怎么运作的呢？
So how is that working?

2309
01:52:30,340 --> 01:52:33,340
好的，这第一行代码使我可以访问argv，
Well, this first line of code gives me access to argv,

2310
01:52:33,340 --> 01:52:37,100
现在将其藏在sys库中，如果您愿意的话，
which is now tucked away in the sys library, if you will,

2311
01:52:37,100 --> 01:52:38,800
sys包，可以这么说。
the sys package, so to speak.

2312
01:52:38,800 --> 01:52:40,300
但它的工作方式相同。
But it works the same way.

2313
01:52:40,300 --> 01:52:42,580
没有argc，但没有问题。
There's no argc, but no problem.

2314
01:52:42,579 --> 01:52:46,209
如果argv是一个命令行参数列表，则为
If argv is a list of command line arguments, which it is,

2315
01:52:46,210 --> 01:52:50,620
len（LEN）会告诉我该列表的长度，它等于argc。
len, L-E-N, will tell me the length of that list, which is equivalent to argc.

2316
01:52:50,619 --> 01:52:55,929
因此，我可以从C版本中重建相同的想法。
So I can reconstruct the same idea from my version in C.

2317
01:52:55,930 --> 01:52:59,680
然后，在这里，我有一个格式字符串，它打印出“ hello”（逗号），
And here, then, I have a format string that prints out "hello," comma,

2318
01:52:59,680 --> 01:53:01,270
然后大括号中的所有内容
and then whatever's in curly braces.

2319
01:53:01,270 --> 01:53:02,650
argv是一个列表。
And argv is a list.

2320
01:53:02,649 --> 01:53:05,829
就像在C中有数组一样，一个列表
And just like in C, which had arrays, a list

2321
01:53:05,829 --> 01:53:09,264
只是可以为您动态增长和收缩的数组。
is just an array that can dynamically grow and shrink for you.

2322
01:53:09,265 --> 01:53:13,610
在这种情况下，您仍然可以使用方括号表示法
You can still use square bracket notation to get at, in this case,

2323
01:53:13,609 --> 01:53:15,789
人类打字的第二件事。
the second thing the human typed.

2324
01:53:15,789 --> 01:53:18,309
因此，为了清楚起见，让我将其更改为0。
So let me change this just for clarity to be 0.

2325
01:53:18,310 --> 01:53:20,680
如果我现在重新运行并输入David，
And if I rerun this now and type in David,

2326
01:53:20,680 --> 01:53:23,590
它奇怪地说：“您好，argv.py。”
it says weirdly, "hello, argv.py."

2327
01:53:23,590 --> 01:53:25,540
因此，您看不到的是“ Python”一词。
So what you don't see is the word "Python."

2328
01:53:25,539 --> 01:53:29,049
Python是解释器，但这不是程序执行的一部分
Python is the interpreter, but that's not part of your program's execution

2329
01:53:29,050 --> 01:53:29,890
本身。
per se.

2330
01:53:29,890 --> 01:53:36,100
argv 0将成为您正在运行的Python程序的名称，
argv 0 is going to be the name of the Python program you're running,

2331
01:53:36,100 --> 01:53:39,920
argv 1将成为其后的第一个单词，依此类推。
and argv 1 is going to be the first word thereafter, and so forth.

2332
01:53:39,920 --> 01:53:42,310
因此，我们仍然可以使用该功能，但是现在
So we still have access to that feature, but now

2333
01:53:42,310 --> 01:53:44,008
我们现在可以将其转换为Python。
we can convert it now to Python.

2334
01:53:44,007 --> 01:53:46,799
实际上，如果我想打印出所有命令行参数，
And in fact, if I want to print out all the command line arguments,

2335
01:53:46,800 --> 01:53:48,330
我可以更简单地做到这一点-
I can just more simply do this--

2336
01:53:48,329 --> 01:53:52,199
对于argv中的arg，请继续并打印arg。
for arg in argv, go ahead and print arg.

2337
01:53:52,199 --> 01:53:55,171
如此简洁，即使乍一看也不是很明显。
So very succinct, if not obvious at first glance.

2338
01:53:55,171 --> 01:53:56,879
现在让我继续输入
Now let me go ahead and type in something

2339
01:53:56,880 --> 01:53:58,710
像“大卫·马兰”两个词。
like "David Malan," two words.

2340
01:53:58,710 --> 01:54:04,710
输入，现在您将看到在程序名称之后打印或键入的所有内容，
Enter, you now see everything printed or typed after the program's name,

2341
01:54:04,710 --> 01:54:05,650
等等。
and so forth.

2342
01:54:05,649 --> 01:54:10,799
因此，在这里也请注意，我们可以多么巧妙地遍历Python中的列表。
So here, too, notice how neatly we can iterate over a list in Python.

2343
01:54:10,800 --> 01:54:13,470
没有i，不一定有方括号。
There's no i, there's no square brackets necessarily.

2344
01:54:13,470 --> 01:54:18,240
您可以说，对于argv中的arg，就像刚才我对c in s所说的那样。
You can just say, for arg in argv, just like a moment ago I said for c in s.

2345
01:54:18,239 --> 01:54:21,479
Python for循环几乎足够聪明
Pretty much the Python for loop is smart enough

2346
01:54:21,479 --> 01:54:25,049
弄清楚你想要它迭代什么，
to figure out what it is you want it to iterate over,

2347
01:54:25,050 --> 01:54:26,650
无论是字符串还是列表。
whether it's a string or a list.

2348
01:54:26,649 --> 01:54:29,552
我的天哪，编程真是太有趣了，还是太愉快了
And my God, it's just so much more fun or pleasant to program

2349
01:54:29,552 --> 01:54:32,219
现在，当您不必担心所有愚蠢的机制时
now, when you don't have to worry about all the stupid mechanics

2350
01:54:32,220 --> 01:54:35,040
，加号，加号，分号以及所有
of incrementing, and plus plus, and semicolons, and all

2351
01:54:35,039 --> 01:54:37,619
语法混乱。
of that syntactical mess.

2352
01:54:37,619 --> 01:54:40,161
好吧，让我在这里暂停看看是否有任何问题。
All right, let me pause here to see if there's any questions.

2353
01:54:40,162 --> 01:54:42,578
我知道我们正在快速研究其中的一些例子，
I know we're going through some of these examples quickly,

2354
01:54:42,578 --> 01:54:44,430
但实际上它们只是翻译而已。
but they're really just translations again.

2355
01:54:44,430 --> 01:54:46,860
对于即将出现的问题和问题集
And for upcoming problems and problems sets

2356
01:54:46,859 --> 01:54:52,989
您还能更系统地比较之前和之后的情况吗？
will you be able to more methodically compare before and after as well.

2357
01:54:52,989 --> 01:54:55,179
Brian，您到底要做什么？
Anything at all on your end, Brian?

2358
01:54:55,180 --> 01:54:56,080
布莱恩：什么都没有。
BRIAN: Nothing here.

2359
01:54:56,079 --> 01:54:57,037
戴维·马兰：好的。
DAVID MALAN: All right.

2360
01:54:57,037 --> 01:54:59,079
因此，让我们看一下过去的一些最终示例。
So let's look at some of our final past examples.

2361
01:54:59,079 --> 01:55:01,245
然后，我们将在今天结束时保留一些时间
And then we'll reserve some time at the end of today

2362
01:55:01,246 --> 01:55:02,980
看一些更强大的东西
to look at some even more powerful things

2363
01:55:02,979 --> 01:55:06,229
之所以能够做到，是因为现在有了Python之类的语言。
that we can do because now of languages like Python.

2364
01:55:06,229 --> 01:55:10,614
让我继续创建一个程序，这次称为exit.py，exit.py。
Let me go ahead and create a program, this time called exit.py, exit.py.

2365
01:55:10,614 --> 01:55:12,489
这个程序的目的是
And this program's purpose in life, it's just

2366
01:55:12,489 --> 01:55:14,079
将展示退出状态。
going to demonstrate exit statuses.

2367
01:55:14,079 --> 01:55:16,269
回想一下，最终在C语言中，我们引入了
Recall that eventually in C, we introduced

2368
01:55:16,270 --> 01:55:20,320
返回0或返回1或来自main的任何其他值的概念。
the notion of returning 0, or returning 1, or any other value from main.

2369
01:55:20,319 --> 01:55:22,719
我们现在在Python中也确实具有这种能力，
We do have that ability now in Python, too,

2370
01:55:22,720 --> 01:55:25,278
您将在更大的程序中开始看到它。
that you'll start to see in more larger programs.

2371
01:55:25,278 --> 01:55:27,070
在这里，我也要继续导入
Here, too, I'm going to go ahead and import

2372
01:55:27,069 --> 01:55:30,739
sys，这整个过程，只是为了展示执行此操作的另一种方式。
sys, the whole thing this time, just to show a different way of doing this.

2373
01:55:30,739 --> 01:55:34,419
我要说的是，如果sys.argv的长度
I'm going to say, if the length of sys.argv

2374
01:55:34,420 --> 01:55:37,960
不等于2，让我继续对用户大喊，
does not equal 2, let me go ahead and yell at the user,

2375
01:55:37,960 --> 01:55:40,570
“缺少命令行参数。”
"Missing command-line arguments."

2376
01:55:40,569 --> 01:55:44,679
然后，在此之后，我将继续执行sys.exit 1。
And then after this, I'm going to go ahead and do sys.exit 1.

2377
01:55:44,680 --> 01:55:48,940
否则，我将继续打印出格式化的字符串，
Otherwise, I'm going to go ahead and print out a formatted string that

2378
01:55:48,939 --> 01:55:54,639
说“你好”，逗号arg v括号1，前面是sys
says "hello," comma arg v bracket 1, with sys now in front of it

2379
01:55:54,640 --> 01:55:56,420
由于种种原因，我会在稍后解释。
for reasons I'll explain in a moment.

2380
01:55:56,420 --> 01:56:01,490
然后最后，我将继续进行操作，默认情况下，打印sys.exit 0。
And then at the end, I'm going to go ahead and by default print sys.exit 0.

2381
01:56:01,489 --> 01:56:01,989
好的。
All right.

2382
01:56:01,989 --> 01:56:03,269
那么这是怎么回事？
So what is going on here?

2383
01:56:03,270 --> 01:56:06,730
第一，因为我现在将sys用于两种不同的情况，
One, because I'm now using sys for two different things,

2384
01:56:06,729 --> 01:56:09,189
我决定不专门导入argv，
I decided not to import argv specifically,

2385
01:56:09,189 --> 01:56:11,169
但只是导入整个库。
but just to import the whole library.

2386
01:56:11,170 --> 01:56:14,770
但是因为这样做了，所以我不能只在任何地方写“ argv”一词。
But because I did that, I can't just write the word "argv" anywhere.

2387
01:56:14,770 --> 01:56:18,700
现在，我必须在其中加上包或库的名称作为前缀。
I now have to prefix it with the name of the package or library that it's in.

2388
01:56:18,699 --> 01:56:22,869
所以这就是为什么我开始做sys.argv，sys.argv的原因。
So that's why I started doing sys.argv, sys.argv.

2389
01:56:22,869 --> 01:56:27,579
但是我还使用了sys库的另一个功能，该功能使我可以访问
But I'm also using another feature of the sys library, which gives me access

2390
01:56:27,579 --> 01:56:33,219
到退出函数，相当于从main返回。
to an exit function, which is the equivalent to returning from main.

2391
01:56:33,220 --> 01:56:34,630
所以这有点二分法。
So this is a bit of a dichotomy.

2392
01:56:34,630 --> 01:56:39,430
在C语言中，您必须从main返回0或1，或其他整数。
In C, you had to return 0 or 1, or some other integer from main.

2393
01:56:39,430 --> 01:56:44,750
在Python中，您可以使用相同的数字来调用sys.exit。
In Python, you instead call sys.exit with the same kinds of numbers.

2394
01:56:44,750 --> 01:56:48,339
语法上有些许不同，但这是相同的基本思想。
So a little bit different syntactically, but it's the same fundamental idea.

2395
01:56:48,340 --> 01:56:49,890
该程序的目的是什么？
What's the purpose of this program?

2396
01:56:49,890 --> 01:56:52,150
好吧，如果我运行这个东西，它的目的仅仅是
Well, if I run this thing, its purpose is just

2397
01:56:52,149 --> 01:56:56,589
让我输入一个单词，然后在程序名称后面输入一个单词。
to make me type in one word and only one word after my program's name.

2398
01:56:56,590 --> 01:56:59,080
所以请注意，如果我只是运行exit.py的python，
So notice, if I just run python of exit.py,

2399
01:56:59,079 --> 01:57:01,749
对我大喊：“缺少命令行参数。”
it's yelling at me, "Missing command-line argument."

2400
01:57:01,750 --> 01:57:05,889
如果我改用我的名字来运行它，现在它说“你好，大卫”。
If I run it instead with my name after that, now it says "hello, David."

2401
01:57:05,890 --> 01:57:07,300
如此愚蠢的程序。
So stupid program.

2402
01:57:07,300 --> 01:57:11,200
这只是为了演示如何现在可以返回不同的值
It's only meant to demonstrate how you can now return different values

2403
01:57:11,199 --> 01:57:14,294
或真的从程序中过早地返回，
or really return prematurely from a program,

2404
01:57:14,295 --> 01:57:15,670
因为你不再是主要的。
because you're no longer in main.

2405
01:57:15,670 --> 01:57:21,770
您本身无法返回，但是现在可以根据需要在Python中退出。
You can't return per se, but you can now in Python exit as needed.

2406
01:57:21,770 --> 01:57:24,350
这就是那里的可比线。
So that's the comparable line there.

2407
01:57:24,350 --> 01:57:26,435
好吧，关于出口状态有什么问题吗？
All right, any questions, then, on exit statuses?

2408
01:57:26,435 --> 01:57:29,060
再说一遍，我们只是在浏览功能列表
Again, we're just kind of churning through the list of features

2409
01:57:29,060 --> 01:57:33,350
我们在C语言中看到了，即使他们不是很自然地来找您-
we saw in C, even if they don't come to you super naturally--

2410
01:57:33,350 --> 01:57:40,540
双关语不是故意的，而是Python世界中的类似物。
pun not intended-- but rather, there are analogs here in the Python world.

2411
01:57:40,539 --> 01:57:41,039
不？
No?

2412
01:57:41,039 --> 01:57:41,499
好的。
All right.

2413
01:57:41,500 --> 01:57:43,439
好吧，回想一下之后，我们开始真正地专注于
Well, recall that after that we started focusing really

2414
01:57:43,439 --> 01:57:44,759
在算法课上。
in the class on algorithms.

2415
01:57:44,760 --> 01:57:46,560
那就是我们数据集的大小
And that's when the size of our data sets

2416
01:57:46,560 --> 01:57:49,620
我们的代码效率开始变得至关重要。
and our-- the efficiency of our code started to really matter.

2417
01:57:49,619 --> 01:57:52,229
让我继续编写一个名为numbers.py的程序
Let me go ahead and write a program called numbers.py

2418
01:57:52,229 --> 01:57:55,439
例如，在sys的顶部包含一个导入，
that, for instance, contains an import at the top for sys,

2419
01:57:55,439 --> 01:57:56,979
因为我稍后会需要它。
because I'll need that in a moment.

2420
01:57:56,979 --> 01:57:58,049
然后它给了我-
And then it gives me--

2421
01:57:58,050 --> 01:58:02,850
让我给自己一个数字数组，例如4、6、8、2、7、5、0。
and let me give myself an array of numbers, like 4, 6, 8, 2, 7, 5, 0.

2422
01:58:02,850 --> 01:58:07,030
您可能还记得，这些都是第3周的数字。
And you might recall that those were the numbers behind the doors in week 3.

2423
01:58:07,029 --> 01:58:09,449
并假设我要搜索数字0。
And suppose that I want to search for the number 0.

2424
01:58:09,449 --> 01:58:13,829
好吧，在C语言中，要实现线性搜索，您可以使用for循环
Well, in C, to implement linear search you would use a for loop

2425
01:58:13,829 --> 01:58:17,129
和像i这样的变量，然后检查所有位置。
and a variable like i, and check all of the locations.

2426
01:58:17,130 --> 01:58:18,690
Python更简单。
Python is way simpler.

2427
01:58:18,689 --> 01:58:25,179
如果数字为0，则继续打印“找到”。
If 0 in numbers, go ahead and print out "Found."

2428
01:58:25,180 --> 01:58:31,850
然后，我继续进行操作，否则打印出“未找到”。
And then I'll go ahead and else print out "Not found."

2429
01:58:31,850 --> 01:58:32,750
就是这样。
And that's it.

2430
01:58:32,750 --> 01:58:35,500
因此，现在让我继续进行python number.py的编写。
So let me go ahead now and do python of numbers.py.

2431
01:58:35,500 --> 01:58:38,359
希望我能找到[音频不清晰]，因为它确实存在。
Hopefully I will see [INAUDIBLE] found, because it's in fact there.

2432
01:58:38,359 --> 01:58:38,919
就是这样了。
So that's it.

2433
01:58:38,920 --> 01:58:44,620
线性搜索只是介词短语，如果数字为0，
Linear search is just a prepositional phrase, if 0 in numbers,

2434
01:58:44,619 --> 01:58:47,619
为您提供所需的答案是非。
gives you the answer True or False that you want.

2435
01:58:47,619 --> 01:58:49,359
因此，存在我们的线性搜索。
So there is our linear search.

2436
01:58:49,359 --> 01:58:50,829
如果我想用名字怎么办？
What if I want to do it for names?

2437
01:58:50,829 --> 01:58:54,069
好吧，让我继续，给我自己第二份文件，本着相似的精神，
Well, let me go ahead and give myself a second file, similar in spirit,

2438
01:58:54,069 --> 01:58:55,599
叫做names.py。
called names.py.

2439
01:58:55,600 --> 01:58:56,800
让我再次导入-
Let me again import--

2440
01:58:56,800 --> 01:59:00,400
实际上，如果我真的想与我们的C版本相同，
and actually, if I really want to be identical to our C version,

2441
01:59:00,399 --> 01:59:05,736
让我继续并在这里以0退出，然后让我在这里1退出。
let me go ahead and exit with 0 here, and let me exit with 1 here.

2442
01:59:05,737 --> 01:59:07,570
但是严格来说，这不是必需的。
But strictly speaking, that's not necessary.

2443
01:59:07,569 --> 01:59:11,264
那恰好是我在C中执行此操作时所执行的操作。
That just happens to be what I did when we did this in C instead.

2444
01:59:11,265 --> 01:59:13,390
名义上，让我继续做类似的事情。
In names, let me go ahead and do something similar.

2445
01:59:13,390 --> 01:59:17,020
让我给自己列出一堆名字-
Let me give myself a names list with a whole bunch of names--

2446
01:59:17,020 --> 01:59:25,750
“比尔”，“查理”，“弗雷德”，“乔治”，“金妮”和“珀西”
"Bill," and "Charlie," and "Fred," and "George," and "Ginny," and "Percy,"

2447
01:59:25,750 --> 01:59:28,700
最后是“罗恩”，一直到最后。
and lastly "Ron," all the way at the end.

2448
01:59:28,699 --> 01:59:31,719
然后，让我使用线性搜索检查“ Ron”是否在该列表中。
And then let me just check if "Ron" is in that list using linear search.

2449
01:59:31,720 --> 01:59:36,820
如果名称中有“ Ron”，请继续打印“ Found”。
If "Ron" in names, go ahead and print out "Found."

2450
01:59:36,819 --> 01:59:39,219
否则，继续打印“找不到”。
Else, go ahead and print out "Not found."

2451
01:59:39,220 --> 01:59:43,120
这次我不会打扰打印或退出0或1。
And I won't bother printing out or exiting with 0 or 1 this time.

2452
01:59:43,119 --> 01:59:45,759
但是让我继续并运行python的名称-
But let me go ahead and run python of names--

2453
01:59:45,760 --> 01:59:48,010
哎呀，名字的巨蟒。
whoops, python of names.

2454
01:59:48,010 --> 01:59:49,840
瞧，我们找到了“罗恩”。
And voila, we found "Ron."

2455
01:59:49,840 --> 01:59:51,160
注意，我不是在作弊。
And notice, I'm not cheating.

2456
01:59:51,159 --> 01:59:52,719
我不认为我搞砸了。
I don't think I've screwed up.

2457
01:59:52,720 --> 01:59:55,960
如果我继续说“罗纳德”，如果那实际上是他的正式名字，
If I go ahead and say "Ronald," if that was in fact his formal name,

2458
01:59:55,960 --> 01:59:58,120
现在，我搜索“ Ron”，但找不到。
now I search for "Ron," not found.

2459
01:59:58,119 --> 01:59:59,972
确实是在寻找完全匹配的东西。
It's looking, indeed, for an exact match.

2460
01:59:59,972 --> 02:00:02,139
所以这很酷，我们可以蒸馏出一些东西
So that's pretty cool, that we can distill something

2461
02:00:02,140 --> 02:00:03,430
像那样很容易。
like that pretty readily.

2462
02:00:03,430 --> 02:00:06,670
好吧，回想一下，我曾提议Python具有其他数据
Well, recall that a little bit ago, I proposed that Python has other data

2463
02:00:06,670 --> 02:00:11,080
类型，其中有一些叫做字典或字典的东西，
types as well, among which are these things called dictionaries or dicts,

2464
02:00:11,079 --> 02:00:17,379
DICT，代表了精神上相似的键值对的集合
D-I-C-T, which represent a collection of key-value pairs similar in spirit

2465
02:00:17,380 --> 02:00:18,250
到字典。
to a dictionary.

2466
02:00:18,250 --> 02:00:23,110
像，西班牙语字典有西班牙语键和英语值转换一个
Like, the Spanish dictionary has Spanish keys and English values converting one

2467
02:00:23,109 --> 02:00:25,329
另一方面，这本英语词典有
to the other, this English dictionary has

2468
02:00:25,329 --> 02:00:27,699
英文单词和英文定义。
English words and English definitions.

2469
02:00:27,699 --> 02:00:30,699
但是同样的想法-键和值的集合。
But the same idea-- a collection of keys and values.

2470
02:00:30,699 --> 02:00:32,862
使用一个，您可以找到另一个。
Using one, you can find the other.

2471
02:00:32,863 --> 02:00:35,530
好吧，让我们继续将其在程序中转换为Python
Well, let's go ahead and translate this into Python in a program

2472
02:00:35,529 --> 02:00:38,739
称为phonebook.py，并实现了一些功能
called phonebook.py, and implements something

2473
02:00:38,739 --> 02:00:41,169
就像我们的C电话簿一样，回想一下，
like our C phone book a while back, which, recall,

2474
02:00:41,170 --> 02:00:45,580
在C语言中，我们最初使用了两个数组，然后我们进行了刮擦，
in C, we used a couple of arrays initially, then we scratched that,

2475
02:00:45,579 --> 02:00:48,159
而我们使用了一个结构数组。
and we used an array of structs instead.

2476
02:00:48,159 --> 02:00:51,969
现在让我们使用字典，这是一个更通用的数据
Now let's use a dictionary, which is a more general-purpose data

2477
02:00:51,970 --> 02:00:54,320
结构如下。
structure, as follows.

2478
02:00:54,319 --> 02:00:59,289
让我继续前进，然后从cs50导入get_string。
Let me go ahead here and from cs50 import get_string.

2479
02:00:59,289 --> 02:01:02,409
然后，让我继续前进，给自己写一本人文字典。
Then let me go ahead and give myself a dictionary of people.

2480
02:01:02,409 --> 02:01:04,599
而且这里的语法有些不同，
And the syntax here is a little different,

2481
02:01:04,600 --> 02:01:07,690
但我将继续使用花括号。
but I'm going to go ahead and preemptively use curly braces.

2482
02:01:07,689 --> 02:01:10,329
为了字典的目的，它们又回来了。
They are back for the purposes of dictionaries.

2483
02:01:10,329 --> 02:01:12,819
然后是定义键值对的方式。
And then here's how you define key-value pairs.

2484
02:01:12,819 --> 02:01:14,559
一个关键就是“布莱恩”。
One key is going to be "Brian."

2485
02:01:14,560 --> 02:01:18,910
他的价值将是“ + 1-617-495-1000”。
And his value is going to be "+1-617-495-1000."

2486
02:01:18,909 --> 02:01:19,841
那是他的电话。
That's his number.

2487
02:01:19,841 --> 02:01:21,799
然后从现在起我将成为其他关键人物之一
And then I'll be one of the other keys from now

2488
02:01:21,800 --> 02:01:24,430
我们将其保留为非常小的电话簿或字典。
We'll keep it a very small phone book or dictionary.

2489
02:01:24,430 --> 02:01:29,380
我的电话是“ + 1-949-468-2750”。
Mine will be "+1-949-468-2750."

2490
02:01:29,380 --> 02:01:31,360
就是这样。
And that's it.

2491
02:01:31,359 --> 02:01:34,274
因此，花括号在技术上可以位于不同的行上。
So the curly braces can technically be on different lines.

2492
02:01:34,274 --> 02:01:36,399
我可以把它移到这里，我可以摆脱它。
I could move this up here, I could get rid of this.

2493
02:01:36,399 --> 02:01:39,099
但是Python中有某些样式约定。
But there are certain style conventions in Python.

2494
02:01:39,100 --> 02:01:43,240
不过，重点是字典用花括号定义
The point, though, here is that a dictionary is defined with curly braces

2495
02:01:43,239 --> 02:01:47,769
在开始和结束时；键和值之间用冒号隔开；
at the beginning and end; the keys and values are separated by colons;

2496
02:01:47,770 --> 02:01:50,993
键值对之间用逗号分隔。
and the key-value pairs are separated by commas.

2497
02:01:50,993 --> 02:01:53,410
这就是为什么按照我的习惯编写它的原因。
So that's why it's conventional to write it the way I did.

2498
02:01:53,409 --> 02:01:55,117
更明显的是
It's just a little more obvious that this

2499
02:01:55,118 --> 02:01:58,750
是具有两个键的字典，每个键都有一个值。
is a dictionary with two keys, each of which has a value.

2500
02:01:58,750 --> 02:02:01,640
可以这么说，它只是将左右关联起来。
It's just associating left with right, so to speak.

2501
02:02:01,640 --> 02:02:02,770
现在，这是什么意思？
Now, what does this mean?

2502
02:02:02,770 --> 02:02:04,840
假设我要搜索某人的名字。
Suppose I want to search for someone's name.

2503
02:02:04,840 --> 02:02:08,440
好吧，让我继续，给我自己一个名为get_string的名称变量，询问
Well, let me go ahead and give myself a name variable called get_string, asking

2504
02:02:08,439 --> 02:02:09,519
以人为名。
the human for a name.

2505
02:02:09,520 --> 02:02:13,210
让我实现自己的虚拟电话簿，就像“联系人”应用程序一样
And let me implement my own virtual phone book, much like the Contacts app

2506
02:02:13,210 --> 02:02:13,935
在您的手机上。
on your phone.

2507
02:02:13,935 --> 02:02:16,060
让我继续，然后说，一旦我有了名字，
Let me go ahead and then say, once I have the name,

2508
02:02:16,060 --> 02:02:18,640
如果有人称呼，那就太好了。
if name in people, that's great.

2509
02:02:18,640 --> 02:02:20,890
如果我在别人身上找到名字，让我继续
If I found the name in people, let me go ahead

2510
02:02:20,890 --> 02:02:27,100
并打印出该人的号码是人括号名称。
and print out that the number for that person is people bracket name.

2511
02:02:27,100 --> 02:02:30,100
这就是字典将变得真正强大的地方。
And this is where dictionaries are going to get really powerful.

2512
02:02:30,100 --> 02:02:32,020
让我先运行它，然后再解释。
Let me run it first and then explain.

2513
02:02:32,020 --> 02:02:34,870
phonebook.py的Python，请输入-
Python of phonebook.py, Enter--

2514
02:02:34,869 --> 02:02:38,349
糟糕，phonebook.py的python。
whoops, python of phonebook.py.

2515
02:02:38,350 --> 02:02:40,300
让我搜索Brian的电话号码。
Let me search for Brian's number.

2516
02:02:40,300 --> 02:02:42,685
oom，有布莱恩的电话。
Boom, there's Brian's number.

2517
02:02:42,685 --> 02:02:44,560
让我继续并使用大卫的名字来运行它。
Let me go ahead and run it with David's name.

2518
02:02:44,560 --> 02:02:46,270
景气，有那个数字。
Boom, there's that number.

2519
02:02:46,270 --> 02:02:50,380
让我继续使用Montague的名字来运行它。
Let me go ahead and run it with, say, Montague's name.

2520
02:02:50,380 --> 02:02:52,630
暂时没有他的电话号码。
Don't have his phone number just yet.

2521
02:02:52,630 --> 02:02:55,810
他没有被列出，我输入的其他人也都没有列出。
He's unlisted, as would be anyone else that I type in.

2522
02:02:55,810 --> 02:02:57,850
那么，这里发生了什么？
So what has gone on here?

2523
02:02:57,850 --> 02:03:00,730
好吧，在顶部，我要声明这个称为人的新变量。
Well, at the top I'm declaring this new variable called people.

2524
02:03:00,729 --> 02:03:03,819
这是一本字典，左右一组键值对。
And it's a dictionary, a set of key-value pairs left and right.

2525
02:03:03,819 --> 02:03:07,899
然后，我像以前一样使用get_string从用户那里得到一个字符串。
Then I'm just getting a string from the user using get_string as before.

2526
02:03:07,899 --> 02:03:09,759
然后它也很强大。
And then this is powerful, too.

2527
02:03:09,760 --> 02:03:14,830
从本质上讲，这是在第9行上，搜索整个词典
This is essentially, on line 9, searching the whole dictionary

2528
02:03:14,829 --> 02:03:16,029
给定名称。
for the given name.

2529
02:03:16,029 --> 02:03:22,289
现在，它又回到了与之相关的名称，或者，对不起，
And it's returning to me down here the name associated with that-- or, sorry,

2530
02:03:22,289 --> 02:03:24,759
与该人的姓名相关联的号码。
the number associated with that person's name.

2531
02:03:24,760 --> 02:03:27,200
让我通过将其排除在外来使这一点更加清楚。
And let me make this more clear by factoring this out.

2532
02:03:27,199 --> 02:03:30,089
让我给自己一个变量，称为数字，然后更多
Let me give myself a variable called number and then more

2533
02:03:30,090 --> 02:03:32,460
显式打印出该变量的名称。
explicitly print out that variable's name.

2534
02:03:32,460 --> 02:03:34,260
这就是今天的不同之处。
Here's what's different today.

2535
02:03:34,260 --> 02:03:39,780
这里的“如果以人命名”，这就是Python
"If name in people" in here, what this does is Python

2536
02:03:39,779 --> 02:03:42,539
在所有键中搜索该名称。
searches all of the keys for that name.

2537
02:03:42,539 --> 02:03:43,649
它不搜索值。
It doesn't search values.

2538
02:03:43,649 --> 02:03:47,279
当您说给定词典中的名字是否像人一样时，
When you say if name in a given dictionary, like people is,

2539
02:03:47,279 --> 02:03:49,049
它仅搜索键。
it searches only the keys.

2540
02:03:49,050 --> 02:03:52,290
如果您随后找到了钥匙，我一定会知道
If you've then found the key, I know definitively

2541
02:03:52,289 --> 02:03:54,779
字典中有“ David”或“ Brian”。
that "David" or "Brian" are in the dictionary.

2542
02:03:54,779 --> 02:03:55,829
并注意这一点。
And notice this.

2543
02:03:55,829 --> 02:03:58,559
就像在C的数组语法中一样。
It's just like in C's arrays syntax.

2544
02:03:58,560 --> 02:04:01,800
您现在可以使用方括号表示法编制索引
You can now use square bracket notation to index

2545
02:04:01,800 --> 02:04:06,510
使用“ David”或“ Brian”之类的词进入字典，
into a dictionary using a word like "David" or "Brian,"

2546
02:04:06,510 --> 02:04:09,150
然后找回我们的电话号码之类的值。
and get back a value like our phone number.

2547
02:04:09,149 --> 02:04:12,059
在C语言中，甚至在Python中，每当
In C, and thus far even in Python, whenever

2548
02:04:12,060 --> 02:04:16,770
我们已经看到了方括号符号，通常只用于数字，
we've seen square bracket notation, it would only be typically for numbers,

2549
02:04:16,770 --> 02:04:19,590
因为数组或列表具有索引，数字
because arrays or lists have indices, numbers

2550
02:04:19,590 --> 02:04:22,050
指出第一个位置，中间位置和最后一个位置，
that addresses the first location, middle, and last,

2551
02:04:22,050 --> 02:04:24,033
等等，介于两者之间的所有内容。
and so forth, everything in between.

2552
02:04:24,033 --> 02:04:26,700
但是字典的强大之处在于它们在其他方面
But what's powerful about dictionaries is that they're otherwise

2553
02:04:26,699 --> 02:04:28,709
称为关联数组。
known as associative arrays.

2554
02:04:28,710 --> 02:04:31,150
字典是键值对的集合。
A dictionary is a collection of key-value pairs.

2555
02:04:31,149 --> 02:04:33,569
如果您想查找一个钥匙，您只需
And if you want to look up a key, you simply

2556
02:04:33,569 --> 02:04:35,729
使用方括号表示法，就像我们以前使用的
use square bracket notation, just like we used

2557
02:04:35,729 --> 02:04:37,499
在数字上使用方括号。
to use square brackets for numbers.

2558
02:04:37,500 --> 02:04:42,030
而且由于Python是一种非常漂亮的语言，
And because Python is a pretty fancy language,

2559
02:04:42,029 --> 02:04:44,129
它会处理您的搜索。
it handles the searching for you.

2560
02:04:44,130 --> 02:04:46,920
甚至更好的是，它不使用线性搜索。
And even better, it does not use linear search.

2561
02:04:46,920 --> 02:04:50,460
搜索字典时，它渴望为您提供
When searching a dictionary, it aspires to give you

2562
02:04:50,460 --> 02:04:54,600
通过使用我们上周称为哈希表的固定时间。
constant time by using what we called last week a hash table.

2563
02:04:54,600 --> 02:04:58,020
字典通常是在幕后使用某些东西实现的
Dictionaries are typically implemented underneath the hood using something

2564
02:04:58,020 --> 02:04:59,190
像哈希表
like a hash table.

2565
02:04:59,189 --> 02:05:01,379
回想一下，即使它确实是
And recall that, even though it was really

2566
02:05:01,380 --> 02:05:05,730
如果您选择非常好的哈希值，则可以实现恒定时间的目标
a goal of achieving constant time, if you choose a really good hash

2567
02:05:05,729 --> 02:05:07,289
功能和真正-
function and a really--

2568
02:05:07,289 --> 02:05:11,669
适当大小的数组进行哈希运算，您可以接近恒定时间。
the right size array to hash into, you can come close to constant time.

2569
02:05:11,670 --> 02:05:15,660
同样，在Python字典的功能中
So again, among the features of a dictionary in Python

2570
02:05:15,659 --> 02:05:18,269
是它为您提供了非常高的性能。
are that it gives you very high performance.

2571
02:05:18,270 --> 02:05:19,350
这不是线性搜索。
It's not linear search.

2572
02:05:19,350 --> 02:05:22,470
实际上，回想一下，当我们早些时候开始使用Python时，
And in fact, set-- recall that when we began playing with Python earlier,

2573
02:05:22,470 --> 02:05:24,795
然后我使用什么重新实现了拼写器
and I re-implemented speller using, what,

2574
02:05:24,795 --> 02:05:27,420
最多10或20行代码，而不是很多行
10 or 20 lines of code max instead of the many

2575
02:05:27,420 --> 02:05:31,440
您可能为pset 5编写的更多内容，speller使用了一组。
more that you might have written for pset 5, speller used a set.

2576
02:05:31,439 --> 02:05:33,459
集合只是价值的集合。
And a set is just a collection of values.

2577
02:05:33,460 --> 02:05:36,960
长话短说，它的精神类似于字典
Long story short, it's similar in spirit to a dictionary

2578
02:05:36,960 --> 02:05:40,140
因为它在引擎盖下也使用了哈希表
in that it, too, underneath the hood uses a hash table

2579
02:05:40,140 --> 02:05:42,010
让您快速得到答案。
to get you answers quickly.

2580
02:05:42,010 --> 02:05:46,110
因此，如果您回想一下之前的那个拼写器示例
So if you think back to what that speller example was from earlier

2581
02:05:46,109 --> 02:05:51,419
今天，当我有一行代码说单词等于集合时，
on today, when I had a line of code that just said words equals set,

2582
02:05:51,420 --> 02:05:55,680
一行代码几乎实现了全部
that one line of code was implementing pretty much the entirety

2583
02:05:55,680 --> 02:05:57,180
您的拼写检查器。
of your spell checker.

2584
02:05:57,180 --> 02:06:01,080
所有这些指针，所有哈希表和链以及链接列表
All of those pointers, all of those hash tables and chains and linked lists

2585
02:06:01,079 --> 02:06:04,019
被提炼成仅一行代码。
are distilled into just one line of code.

2586
02:06:04,020 --> 02:06:07,210
您可以通过语言本身来获得。
You get that with the language itself.

2587
02:06:07,210 --> 02:06:07,710
好的。
All right.

2588
02:06:07,710 --> 02:06:10,500
对字典有任何疑问吗？
Any questions, then, on dictionaries?

2589
02:06:10,500 --> 02:06:14,669
它们会重复出现，并且它们往往是最有用的数据结构之一，
They will recur, and they tend to be one of the most useful data structures,

2590
02:06:14,670 --> 02:06:17,910
因为这种将某事物与其他事物联系起来的能力
because this ability to just associate something with something else

2591
02:06:17,909 --> 02:06:24,139
事实证明，这只是组织数据的一种好方法。
is just a wonderful way, it turns out, to organize your data.

2592
02:06:24,140 --> 02:06:27,260
有什么问题吗？
Any questions here?

2593
02:06:27,260 --> 02:06:29,225
是的，索菲娅？
Yeah, Sophia?

2594
02:06:29,225 --> 02:06:31,390
听众：是否只有设定的散列函数
AUDIENCE: Is there only a set hash function

2595
02:06:31,390 --> 02:06:33,445
Python为这些字典定义的
that Python has defined for these dictionaries,

2596
02:06:33,444 --> 02:06:36,399
还是我们可以通过任何方式更改哈希函数？
or can we change the hash function in any way?

2597
02:06:36,399 --> 02:06:38,139
戴维·马兰：好的问题。
DAVID MALAN: Good question.

2598
02:06:38,140 --> 02:06:40,540
它为您提供了哈希函数和Python
It comes with a hash function for you, and Python

2599
02:06:40,539 --> 02:06:42,429
为您找到所有这些。
figures all of that out for you.

2600
02:06:42,430 --> 02:06:46,210
这就是您应该留给图书馆的细节，
So that's the kind of detail that you should leave to the library,

2601
02:06:46,210 --> 02:06:48,502
因为别人一直都在思考
because someone else has spent all of the time thinking

2602
02:06:48,502 --> 02:06:51,502
关于如何动态适应数据结构，
about how to dynamically adapt the data structure, move things around as

2603
02:06:51,502 --> 02:06:54,040
需要，这样您就不再需要强调
needed, so that you no longer need to stress to the degree

2604
02:06:54,039 --> 02:06:57,114
您自己实施拼写检查时可能会遇到的问题。
you might have when implementing speller yourself.

2605
02:06:57,114 --> 02:06:58,989
事实证明，其他事情也变得容易。
And it turns out, other things get easy, too.

2606
02:06:58,989 --> 02:07:01,709
这不一定是通常需要的功能，
This is not a commonly needed feature, necessarily,

2607
02:07:01,710 --> 02:07:02,960
但这是我们可以做的。
but it is something we can do.

2608
02:07:02,960 --> 02:07:05,650
让我继续编写一个名为swap.py的快速程序。
And let me go ahead and write a quick program called swap.py.

2609
02:07:05,649 --> 02:07:10,809
回想几周前在swap.ca中，我们给xa值为1，
Recall that in swap.c a couple of weeks ago, we gave x a value of 1,

2610
02:07:10,810 --> 02:07:14,320
ya变量-值为2，然后我打印出一些内容
y a variable-- a value of 2, and then I printed out something

2611
02:07:14,319 --> 02:07:17,739
就像“ x是x，y是y”。
like "x is x, y is y."

2612
02:07:17,739 --> 02:07:20,679
但是这周我使用格式字符串只是为了打印出来。
But this week I'm using format strings just to print that out.

2613
02:07:20,680 --> 02:07:24,670
然后我做了一些交换x，y之类的事情，但我只是希望能做到最好，
Then I did something like swap x, y, and I just kind of hoped for the best,

2614
02:07:24,670 --> 02:07:26,860
然后我再次打印出这些值。
and then I printed out those values again.

2615
02:07:26,859 --> 02:07:30,099
好吧，事实证明是在Python中，因为您没有指针
Well it turns out in Python, because you don't have pointers

2616
02:07:30,100 --> 02:07:34,720
而且您本身没有可访问的地址，
and you don't have addresses per se that you have access to,

2617
02:07:34,720 --> 02:07:37,330
你不能像上周那样求助于解决方案
you can't resort to the solution like last week

2618
02:07:37,329 --> 02:07:39,769
并通过引用传递这些变量，
and pass these variables around by reference,

2619
02:07:39,770 --> 02:07:41,140
可以这么说，按他们的地址。
so to speak, by their address.

2620
02:07:41,140 --> 02:07:42,620
那是不可能的。
That's just not possible.

2621
02:07:42,619 --> 02:07:43,629
为什么会这样？
Why is that a thing?

2622
02:07:43,630 --> 02:07:46,005
好吧，这似乎使您失去了功能，
Well, it would seem to be taking a feature away from you,

2623
02:07:46,005 --> 02:07:49,240
但说实话，如果过去一周有任何迹象（包括前一周），
but honestly, if this past week was any indication, including the week prior,

2624
02:07:49,239 --> 02:07:50,259
指针很难。
pointers are hard.

2625
02:07:50,260 --> 02:07:52,330
并且分割错误频繁发生。
And segmentation faults are frequent.

2626
02:07:52,329 --> 02:07:55,599
正确地处理所有这些问题是困难的。最糟糕的是
And getting all of that stuff right is difficult. And at worst,

2627
02:07:55,600 --> 02:07:58,600
您的程序可能会受到威胁，因为有人可以访问
your programs can be compromised, because someone can access memory that

2628
02:07:58,600 --> 02:07:59,470
他们不应该。
they shouldn't.

2629
02:07:59,470 --> 02:08:01,390
因此，Python取消了该功能。
So Python takes that feature away.

2630
02:08:01,390 --> 02:08:04,510
Java还使程序员无法使用该功能
Java also takes that feature away from programmers

2631
02:08:04,510 --> 02:08:08,320
保护您免于被搞砸，就像您可能
to protect you against yourself from screwing up, like you may have

2632
02:08:08,319 --> 02:08:11,189
并且应该在过去一周内有几次。
and should have in some number of times this past week.

2633
02:08:11,189 --> 02:08:13,939
但是事实证明，在Python中有解决这些问题的方法。
But it turns out, in Python there are solutions to these problems.

2634
02:08:13,939 --> 02:08:16,419
而且，如果您想交换x和y，那就很好。
And if you want to swap x and y, that's fine.

2635
02:08:16,420 --> 02:08:17,860
交换x和y。
Swap x and y.

2636
02:08:17,859 --> 02:08:23,499
所以现在如果我在这个程序上运行交换python，瞧，繁荣，
And so now if I run python of swap on this program, voila, boom,

2637
02:08:23,500 --> 02:08:25,159
它被蒸馏成另一条线。
it's distilled into one other line.

2638
02:08:25,159 --> 02:08:28,119
因此，即使他们从我们身边夺走了某些东西，您也可能造成很大的损失
So even though they take something away from us that you can do a lot of damage

2639
02:08:28,119 --> 02:08:30,519
还是犯了很多错误，我们仍然可以
with or make a lot of mistakes with, we can nonetheless

2640
02:08:30,520 --> 02:08:35,620
只需一根衬板即可更换，让您拥有更强大的功能。
hand you back a more powerful feature with this one liner for swap.

2641
02:08:35,619 --> 02:08:39,497
并注意，左边是x逗号，右边是y逗号。
And notice that it's x comma y on the left, but y comma x on the right.

2642
02:08:39,497 --> 02:08:41,289
这具有做Brian的作用
And that has the effect of doing what Brian

2643
02:08:41,289 --> 02:08:43,989
戴着一瓶做switcheroo的液体，
did with the glasses of liquid of doing the switcheroo,

2644
02:08:43,989 --> 02:08:47,829
即使那里没有明确的临时变量，
even without a temporary variable explicitly there,

2645
02:08:47,829 --> 02:08:51,289
尽管引擎盖下面发生了一些魔术。
though some magic is happening underneath the hood.

2646
02:08:51,289 --> 02:08:54,969
好吧，让我们继续执行第4周的几个最终程序
Well, let's go ahead and implement a couple of final programs from week 4

2647
02:08:54,970 --> 02:08:58,240
然后在第6周在这里介绍一些我们自己的内容。
and then introduce a few of our own here in week 6.

2648
02:08:58,239 --> 02:09:00,579
让我继续实施另一本电话簿
Let me go ahead and implement another phone book

2649
02:09:00,579 --> 02:09:02,679
这是一个更持久的。
that this one's a little more persistent.

2650
02:09:02,680 --> 02:09:09,940
让我继续此处并打开-在此处创建一个名为phonebook.csv的文件。
Let me go ahead here and open-- create a file here called phonebook.csv.

2651
02:09:09,939 --> 02:09:12,639
让我继续命名该逗号。
And let me go ahead and name this name comma number.

2652
02:09:12,640 --> 02:09:15,520
因此，回想起来，CSV文件就像一个非常简单的电子表格。
So CSV file, recall, is like a very simple spreadsheet.

2653
02:09:15,520 --> 02:09:18,430
我们将继续进行创建，以便在附近使用。
And we're going to go ahead and just create that so I have it nearby.

2654
02:09:18,430 --> 02:09:22,180
然后我要创建一个名为phonebook.py的新文件
And then I'm going to create a new file called phonebook.py that's

2655
02:09:22,180 --> 02:09:23,500
最初是空的。
initially empty.

2656
02:09:23,500 --> 02:09:25,149
这次我要这样做。
And this time I'm going to do this.

2657
02:09:25,149 --> 02:09:30,039
我将像以前一样从cs50导入get_string函数。
I'm going to import from cs50 the get_string function as before.

2658
02:09:30,039 --> 02:09:33,669
但是我还将导入一个名为CSV库的库。
But I'm also going to import a library called the CSV library.

2659
02:09:33,670 --> 02:09:37,690
事实证明，Python附带了与CSV相关的大量功能
It turns out, Python comes with a whole lot of functionality related to CSV

2660
02:09:37,689 --> 02:09:41,979
文件，使您的生活更轻松，并且使使用CSV进行操作变得更加容易。
files to make your life easier and make it easier to do things with CSVs.

2661
02:09:41,979 --> 02:09:43,969
我可能想做的事情就是这样。
Among the things I might want to do is this.

2662
02:09:43,970 --> 02:09:48,820
我继续以追加模式打开该文件phonebook.csv，
Let me go ahead and open up that file, phonebook.csv, in append mode,

2663
02:09:48,819 --> 02:09:51,519
类似于两周前的fopen。
similar to fopen two weeks ago.

2664
02:09:51,520 --> 02:09:56,050
让我继续并将其分配给一个名为file的变量。
And let me go ahead and assign that to a variable called file.

2665
02:09:56,050 --> 02:09:58,640
然后，让我继续，然后从用户那里获得一个名字。
Then let me go ahead and just get a name from the user.

2666
02:09:58,640 --> 02:10:02,710
因此，让我使用get_string在此处获取某人的名称“名称”。
So let me use get_string to get someone's name, "Name" here.

2667
02:10:02,710 --> 02:10:04,900
然后让我继续获取-再次使用get_string
Then let me go ahead and get-- use get_string again

2668
02:10:04,899 --> 02:10:07,809
在这里获取某人的电话号码，因此请使用“电话号码”。
to get someone's number here, so using "Number."

2669
02:10:07,810 --> 02:10:10,240
最后-这是新代码-
And then lastly-- and this is the new code--

2670
02:10:10,239 --> 02:10:13,299
让我将该名称和编号保存到文件中。
let me save that name and number to a file.

2671
02:10:13,300 --> 02:10:17,278
再回想一下pset 4中的内容，即保存文件并将字节写出到文件中
And recall from pset 4 that saving files and writing bytes out to files

2672
02:10:17,278 --> 02:10:18,070
非常参与。
is pretty involved.

2673
02:10:18,069 --> 02:10:21,249
就像，您可能花了一段时间才能实现恢复或模糊处理，
Like, it probably took you a while to implement recover, or blur,

2674
02:10:21,250 --> 02:10:24,160
任何涉及创建新文件的过滤器。
any of those filters that involved creating new files.

2675
02:10:24,159 --> 02:10:26,379
事实证明，CSV库使此操作非常容易。
Turns out the CSV library makes this pretty easy.

2676
02:10:26,380 --> 02:10:29,230
让我继续前进，给自己一个所谓的作家。
Let me go ahead and give myself what's called a writer.

2677
02:10:29,229 --> 02:10:34,789
我要给自己打电话给文件csv.writer的返回值。
And I'm going to give myself the return value of calling csv.writer of file.

2678
02:10:34,789 --> 02:10:35,829
那这是在做什么呢？
So what is this doing?

2679
02:10:35,829 --> 02:10:38,889
同样，文件代表我要打开的文件。
File, again, represents the file I'm trying to open.

2680
02:10:38,890 --> 02:10:42,490
csv.writer是CSV库随附的一些功能。
csv.writer is some function that comes with the CSV library.

2681
02:10:42,489 --> 02:10:45,939
并且它希望您已经打开的文件作为输入。
And it expects as input a file that you've already opened.

2682
02:10:45,939 --> 02:10:49,209
并使用一些更高级的功能包装该文件
And it kind of wraps that file with some fancier functionality

2683
02:10:49,210 --> 02:10:52,000
这将使我的程序员更轻松
that's going to make it way easier for me the programmer

2684
02:10:52,000 --> 02:10:53,649
写入该文件。
to write to that file.

2685
02:10:53,649 --> 02:10:54,829
我该怎么办？
What am I going to do?

2686
02:10:54,829 --> 02:10:59,229
我将使用那个writer变量来专门写一行
I'm going to use that writer variable to write a row that specifically

2687
02:10:59,229 --> 02:11:00,689
包含一个名称和一个数字。
contains a name and a number.

2688
02:11:00,689 --> 02:11:02,439
我正在使用一个列表，因为如果您认为
And I'm using a list, because if you think

2689
02:11:02,439 --> 02:11:06,009
对于具有列和行的电子表格，列表是一种正确的想法。
of a spreadsheet with columns and rows, a list is kind of the right idea.

2690
02:11:06,010 --> 02:11:08,710
从左到右的每个单元格都像一个列表。
Each of the cells from left to right is kind of like a list.

2691
02:11:08,710 --> 02:11:10,100
行就像一个列表。
A row is like a list.

2692
02:11:10,100 --> 02:11:11,990
因此，我将在此处故意使用一个列表。
So I'm going to deliberately use a list here.

2693
02:11:11,989 --> 02:11:15,799
最后，就像过去一样，我将关闭文件。
And then lastly, I'm going to close the file, just as I've done in the past.

2694
02:11:15,800 --> 02:11:17,140
所以这里有点神秘。
So it's a little cryptic here.

2695
02:11:17,140 --> 02:11:21,910
但是，get_string-get_string现在已经很旧了。
But again, get_string-- get_string is old now.

2696
02:11:21,909 --> 02:11:22,899
现在已经老了。
This is old now.

2697
02:11:22,899 --> 02:11:26,049
因此，仅有的新内容是导入CSV。
So the only things that are new are importing the CSV.

2698
02:11:26,050 --> 02:11:30,170
我正在以追加模式打开此文件，类似于在C中所做的操作。
I'm opening this file in append mode, similar to what I did in C.

2699
02:11:30,170 --> 02:11:33,950
然后这些行涉及到用CSV包装文件
And then these lines here involve wrapping the file with the CSV

2700
02:11:33,949 --> 02:11:37,999
功能，使用writerow将行写入此文件，
functionality, writing a row to this file with writerow,

2701
02:11:38,000 --> 02:11:39,260
然后关闭它。
and then closing it.

2702
02:11:39,260 --> 02:11:40,760
因此，让我继续尝试一下。
So let me go ahead and try this now.

2703
02:11:40,760 --> 02:11:43,880
让我打开一个phonebook.csv，目前仅
Let me open up a phonebook.csv, which for now only

2704
02:11:43,880 --> 02:11:47,030
包含这些标题，这些标题是我刚才创建的。
contains these headers which I created manually a moment ago.

2705
02:11:47,029 --> 02:11:50,479
然后，让我继续运行该文件，即phonebook.py的python。
And let me go ahead and run this, python of phonebook.py.

2706
02:11:50,479 --> 02:11:52,039
让我继续并添加Brian。
Let me go ahead and add Brian.

2707
02:11:52,039 --> 02:11:56,809
而Brian将会是+ 1-617-495-1000，Enter。
And Brian will be +1-617-495-1000, Enter.

2708
02:11:56,810 --> 02:12:00,420
现在让我在这里转到我的CSV文件。
And now let me go to my CSV file over here.

2709
02:12:00,420 --> 02:12:02,195
该死，我搞砸了。
Dammit, I screwed up.

2710
02:12:02,194 --> 02:12:03,569
假装我没有在那打Enter。
Pretend I didn't hit Enter there.

2711
02:12:03,569 --> 02:12:04,629
现在可以了。
Now it works.

2712
02:12:04,630 --> 02:12:06,715
现在让我继续，然后通过输入再次执行此操作-
Let me go ahead now and do this again by input--

2713
02:12:06,715 --> 02:12:09,090
手动创建文件时，我应该按Enter键，
I should have hit Enter when I created the file manually,

2714
02:12:09,090 --> 02:12:10,210
但我搞砸了创建它。
but I screwed up on creating it.

2715
02:12:10,210 --> 02:12:13,252
因此，让我对此挥手致意，并说服您我做得正确
So let me wave my hand at that and convince you that I did this correctly

2716
02:12:13,252 --> 02:12:21,270
在代码中添加自己，David，+ 1-949-468-2750，Enter。
in code by adding myself, David, +1-949-468-2750, Enter.

2717
02:12:21,270 --> 02:12:23,250
让我回到我的CSV文件。
Let me go back to my CSV file.

2718
02:12:23,250 --> 02:12:26,370
瞧，现在它的格式正确了，因为我做到了-
And voila, now it's formatted correctly, because I did--

2719
02:12:26,369 --> 02:12:28,929
writerow为我提供了一行。
writerow includes a line for me.

2720
02:12:28,930 --> 02:12:32,700
另外请注意，如果我下载此文件，请让我下载phonebook.csv
And notice, too, if I download this file-- let me download phonebook.csv

2721
02:12:32,699 --> 02:12:34,409
就像我过去一周所做的一样。
like I did in a past week.

2722
02:12:34,409 --> 02:12:36,389
让我将其下载到我自己的Mac上。
Let me download this to my own Mac.

2723
02:12:36,390 --> 02:12:38,130
让我打开此CSV文件。
Let me open this CSV file.

2724
02:12:38,130 --> 02:12:40,808
不管您安装的是Apple Numbers还是Microsoft Excel，
And whether you have Apple Numbers installed or Microsoft Excel,

2725
02:12:40,807 --> 02:12:42,599
您将打开如下所示的内容。
you'll open something that looks like this.

2726
02:12:42,600 --> 02:12:46,260
瞧，我现在是使用Python代码动态创建的，
And voila, I've dynamically created, using Python code now,

2727
02:12:46,260 --> 02:12:49,067
我自己的CSV文件类型。
my own sort of CSV file.

2728
02:12:49,067 --> 02:12:51,900
事实证明，有一种方法可以将其收紧一点。
And it turns out there's a way to tighten this up just a little bit.

2729
02:12:51,899 --> 02:12:54,689
按照我的方式做，这没什么大不了的，但是事实证明
Not a big deal to do it the way I did, but it turns out

2730
02:12:54,689 --> 02:12:59,309
您还可以以不同的方式打开和关闭文件。
that you can also open and close files a little differently.

2731
02:12:59,310 --> 02:13:00,510
你可以这样做。
You can do this.

2732
02:13:00,510 --> 02:13:06,000
带文件-带，而是带文件打开。
With file-- with, rather, with open as file.

2733
02:13:06,000 --> 02:13:09,810
然后，我可以在此处缩进所有这些内容，并摆脱掉自己的底线。
Then I can indent all of this here, and I can get rid of my close line.

2734
02:13:09,810 --> 02:13:12,780
因此，按照我打开和关闭的方式进行操作没什么大不了的，
So not a big deal to do it the way I did with open and close,

2735
02:13:12,779 --> 02:13:15,779
但是我在这里完成此操作的方式有点像Pythonic。
but the way I've done this here is a little more Pythonic.

2736
02:13:15,779 --> 02:13:19,259
这个“ with”关键字，与任何东西都不相似
This "with" keyword, which is not something analogous to anything

2737
02:13:19,260 --> 02:13:22,230
我们在C中看到with关键字，当您打开文件时，
we've seen in C, the with keyword, when you open a file,

2738
02:13:22,229 --> 02:13:24,419
它将最终自动为您关闭。
it will automatically close it for you eventually.

2739
02:13:24,420 --> 02:13:27,550
因此，您可能会在一些在线参考资料或其他材料中看到这一点。
So you might see that in some online references or other materials.

2740
02:13:27,550 --> 02:13:31,535
但是，它只是自动为您完成此操作。
But again, it just does that for you automatically.

2741
02:13:31,534 --> 02:13:32,909
好吧，让我们继续执行此操作。
Well, let's go ahead and do this.

2742
02:13:32,909 --> 02:13:35,639
我喜欢我们现在可以操作CSV的事实。
I like the fact that we can now manipulate CSV.

2743
02:13:35,640 --> 02:13:38,010
事实证明，如果您曾经使用过Google表单-
And it turns out that if you've ever used Google Forms--

2744
02:13:38,010 --> 02:13:41,230
这是从用户收集数据的一种非常流行的方式。
that's a very popular way of collecting data from users.

2745
02:13:41,229 --> 02:13:44,669
实际上，让我继续并转到要访问的URL
In fact, let me go ahead and go to a URL which is going

2746
02:13:44,670 --> 02:13:47,160
在这里向您展示这样的表格。
to show you a form like this here.

2747
02:13:47,159 --> 02:13:50,999
布赖恩，如果您不介意在聊天中输入网址，请转到您的网址，
Brian, if you wouldn't mind typing that into the chat, go to that you URL,

2748
02:13:51,000 --> 02:13:53,458
cs50.ly.hogwarts。
cs50.ly.hogwarts.

2749
02:13:53,457 --> 02:13:55,499
如果每个人都不介意一起玩，
And if everyone wouldn't mind just playing along,

2750
02:13:55,500 --> 02:13:59,160
只需告诉我们您希望分房后将您分配给哪栋房子
just tell us what house you wish you were assigned to by the Sorting

2751
02:13:59,159 --> 02:14:02,549
霍格沃茨世界的帽子。
Hat in the world of Hogwarts.

2752
02:14:02,550 --> 02:14:04,290
你会在哪间房子里？
What house would you be in?

2753
02:14:04,289 --> 02:14:06,299
现在，如果您以前使用过Google Forms，
Now, if you've used Google Forms before, you'll

2754
02:14:06,300 --> 02:14:09,730
回想一下，您肯定可以在Google表单本身中看到这些结果-
recall that you can see these results, certainly in the Google Form itself--

2755
02:14:09,729 --> 02:14:12,184
你们当中已有122位蜂拥而至。
and already 122 of you have buzzed in.

2756
02:14:12,185 --> 02:14:14,560
我们可以看到分布和图形等等。
And we could see a distribution and a graph and so forth.

2757
02:14:14,560 --> 02:14:17,390
但是我想要的不是那里的图片分布。
But what I want is not the distribution pictorially there.

2758
02:14:17,390 --> 02:14:19,390
我将继续打开电子表格。
I'm going to go ahead and open up a spreadsheet.

2759
02:14:19,390 --> 02:14:22,230
因此，如果您以前从未使用过Google Forms，则可以单击一个按钮，
And so if you've never used Google Forms before, you can click a button,

2760
02:14:22,229 --> 02:14:24,449
然后您可以获得所有回复的列表
and then you can get a list of all of the responses

2761
02:14:24,449 --> 02:14:26,159
现在即将上线。
that are coming in live right now.

2762
02:14:26,159 --> 02:14:28,559
默认情况下，Google会跟踪时间戳，
And by default, Google keeps track of the timestamp,

2763
02:14:28,560 --> 02:14:32,500
提交表单的时间以及实际使用的房屋。
when the form was submitted, and what house was actually used.

2764
02:14:32,500 --> 02:14:34,439
因此，我现在要继续进行此操作。
So I'm going to go ahead now and do this.

2765
02:14:34,439 --> 02:14:37,979
让我继续并将其下载到另一个选项卡中。
Let me go ahead and download that in another tab.

2766
02:14:37,979 --> 02:14:42,089
请给我一点时间在此屏幕上进行操作。
Give me just a moment to do it on this screen here.

2767
02:14:42,090 --> 02:14:48,270
我将继续将该CSV文件下载到我的Mac上
I'm going to go ahead and download that CSV file onto my Mac

2768
02:14:48,270 --> 02:14:53,700
在本地，通过转到文件，下载，CSV。
locally, by going to File, Download, CSV.

2769
02:14:53,699 --> 02:14:55,829
它将放入我的“下载”文件夹中。
That's going to put it into my Downloads folder.

2770
02:14:55,829 --> 02:14:59,969
然后我要继续并将其上传到我的IDE中
And then I'm going to go ahead and upload this into my IDE

2771
02:14:59,970 --> 02:15:01,530
只需拖放即可。
by just dragging and dropping.

2772
02:15:01,529 --> 02:15:03,479
糟糕，我必须打开文件浏览器。
Whoops, I have to open the file browser.

2773
02:15:03,479 --> 02:15:07,699
我将通过拖放文件来做到这一点。
I'm going to do this by dragging and dropping the file.

2774
02:15:07,699 --> 02:15:08,259
好的。
All right.

2775
02:15:08,260 --> 02:15:09,980
现在我在那里有那个文件。
Now I have that file there.

2776
02:15:09,979 --> 02:15:13,269
现在让我继续进行操作，确保文件在那里。
And let me go ahead now and make sure the file's there.

2777
02:15:13,270 --> 02:15:15,280
我有一个名为“排序帽子响应-
I have this file called "Sorting Hat Responses--

2778
02:15:15,279 --> 02:15:17,509
表格回应1，”，依此类推。
Form Responses 1," and so forth.

2779
02:15:17,510 --> 02:15:20,602
好吧，让我继续写一个程序来处理这些数据，
Well, let me go ahead and write a program now that manipulates this data,

2780
02:15:20,601 --> 02:15:22,809
如果您经营一个学生团体，
much like you might if running a student group that's

2781
02:15:22,810 --> 02:15:25,900
收集Google表单中的数据，或者您只是在收集信息
collecting data in a Google Form, or you're just collecting information

2782
02:15:25,899 --> 02:15:27,999
一般而言，并以CSV格式显示。
in general and have it in CSV format.

2783
02:15:28,000 --> 02:15:30,680
您现在如何计算所有结果，
How might you now tally up all of the results,

2784
02:15:30,680 --> 02:15:32,560
特别是如果Google不只是在讲
especially if Google weren't just telling

2785
02:15:32,560 --> 02:15:34,480
您以图形方式显示了什么结果？
you graphically what the results were?

2786
02:15:34,479 --> 02:15:36,939
好吧，让我继续编写一个名为hogwarts的程序，
Well, let me go ahead and write a program called hogwarts,

2787
02:15:36,939 --> 02:15:40,629
这不是我们以前在C语言中见过的东西。让我继续
which was not something that we've seen ever before in C. Let me go ahead

2788
02:15:40,630 --> 02:15:42,580
并导入此CSV库。
and import this CSV library.

2789
02:15:42,579 --> 02:15:44,619
首先让我给自己一本字典
Let me give myself initially a dictionary

2790
02:15:44,619 --> 02:15:48,069
所谓的房屋，包含一堆钥匙，
called houses that contains a whole bunch of keys,

2791
02:15:48,069 --> 02:15:52,539
像“格兰芬多”（Gryffindor），初始计数为0；
like "Gryffindor" with initial count of 0;

2792
02:15:52,539 --> 02:15:59,499
初始计数为0的“赫奇帕奇”； “ Ravenclaw”，初始计数为0；
"Hufflepuff" with an initial count of 0; "Ravenclaw" with an initial count of 0;

2793
02:15:59,500 --> 02:16:02,859
以及初始计数为0的“ Slytherin”。
and also, "Slytherin" with an initial count of 0.

2794
02:16:02,859 --> 02:16:05,589
因此请注意，在字典或Python中的字典中，
So notice, in a dictionary, or dict in Python,

2795
02:16:05,590 --> 02:16:09,100
键和值不必是字符串和字符串。
the keys and values don't need to be strings and strings.

2796
02:16:09,100 --> 02:16:11,712
当然可以是字符串和数字。
It can certainly be strings and numbers.

2797
02:16:11,712 --> 02:16:14,170
因为我最终将使用这本词典来保存
Because I'm going to use this dictionary ultimately to keep

2798
02:16:14,170 --> 02:16:17,918
计算一所房子或另一所房子的所有票数。
count of all of the votes for one house or another.

2799
02:16:17,917 --> 02:16:19,209
因此，让我继续执行此操作。
So let me go ahead and do this.

2800
02:16:19,210 --> 02:16:24,400
让我继续并打开Sorting Hat文件打开-
Let me go ahead and open up with open the Sorting Hat File--

2801
02:16:24,399 --> 02:16:30,279
表单响应1.csv”-长文件名，但这是Google的默认文件-
Form Responses 1.csv"-- long filename, but that's the default from Google--

2802
02:16:30,279 --> 02:16:31,129
作为文件。
as file.

2803
02:16:31,130 --> 02:16:34,299
因此，我将使用我的一根衬纸，而不必打开和关闭。
So I'm going to use my one liner instead of having to open and close.

2804
02:16:34,299 --> 02:16:38,209
这次我要给自己一个读者，这是我们之前从未见过的。
I'm going to give myself this time a reader, which we did not see before.

2805
02:16:38,209 --> 02:16:41,680
CSV库具有阅读器功能，该功能允许
CSV library has a reader function that allows

2806
02:16:41,680 --> 02:16:44,570
我可以自动读取CSV文件。
me to read a CSV file automatically.

2807
02:16:44,569 --> 02:16:46,458
我将继续并跳过第一行。
I'm going to go ahead and skip the first row.

2808
02:16:46,459 --> 02:16:48,760
接下来是一个仅跳过第一行的函数，
Next is a function that just skips the first row,

2809
02:16:48,760 --> 02:16:53,290
因为回想起那只是时间戳和房子，
because recall that that one is just timestamp and house, which

2810
02:16:53,290 --> 02:16:54,200
我想忽略。
I do want to ignore.

2811
02:16:54,200 --> 02:16:55,690
我想要你们的真实数据。
I want the real data from you all.

2812
02:16:55,690 --> 02:16:58,450
这是Python中CSV的最酷之处。
And here's what's cool about CSVs in Python.

2813
02:16:58,450 --> 02:17:02,740
我可以-如果要遍历该电子表格中的所有行，
I can-- if I want to iterate over all of the rows that are in that spreadsheet,

2814
02:17:02,739 --> 02:17:05,079
我可以做阅读器中的行。
I can do for row in reader.

2815
02:17:05,079 --> 02:17:12,979
现在，让我继续前进，例如到达有关房屋。
And now, let me go ahead and get at, for instance, the house in question.

2816
02:17:12,979 --> 02:17:20,079
因此，给定行中的房子将成为该行的第一个条目，索引为0。
So the house in a given row is going to be the row's first entry, 0 indexed.

2817
02:17:20,079 --> 02:17:21,589
那么这是怎么回事？
So what is going on here?

2818
02:17:21,590 --> 02:17:25,000
好吧，让我先回到Google电子表格。
Well, let me go back to the Google spreadsheet a moment ago.

2819
02:17:25,000 --> 02:17:27,910
在Google电子表格中，有两列。
And in the Google spreadsheet, there's two columns.

2820
02:17:27,909 --> 02:17:32,569
CSV阅读器的工作方式是一次返回给您-
And the way the CSV reader works is it returns to you one row at a time--

2821
02:17:32,569 --> 02:17:34,638
从概念上讲，这非常简单。
and that's conceptually pretty straightforward.

2822
02:17:34,638 --> 02:17:37,179
它完全符合电子表格的想法。
It maps perfectly to the idea of a spreadsheet.

2823
02:17:37,180 --> 02:17:42,280
但是每一行都以列表的形式返回给您，在这种情况下，列表的大小为2。
But each row is returned to you as a list, a list in this case of size 2.

2824
02:17:42,280 --> 02:17:46,299
所以行括号0会给我一个给定的时间戳，行括号
So row bracket 0 would give me a given timestamp, row bracket

2825
02:17:46,299 --> 02:17:48,639
1会给我一个给定的房子名称。
1 would give me a given house name.

2826
02:17:48,638 --> 02:17:52,869
这就是为什么在IDE中，我要声明一个名为
So that's why here in the IDE, I'm going ahead and declaring a variable called

2827
02:17:52,870 --> 02:17:55,597
房子，我将其分配为等于行括号1，因为我
house, and I'm assigning it equal to row bracket 1, because I

2828
02:17:55,596 --> 02:17:56,888
不在乎时间戳。
don't care about the timestamp.

2829
02:17:56,888 --> 02:17:59,119
我们几乎都在同一时间做到了这一点。
We all just did this roughly at the same time.

2830
02:17:59,120 --> 02:18:04,150
但是现在有了房子，我现在可以索引字典了，
But now that I have the house, I can now index into the dictionary, just

2831
02:18:04,149 --> 02:18:08,718
像在C中一样，您可以使用数字索引到数组中。
like in C you could index into an array using a number.

2832
02:18:08,718 --> 02:18:10,989
但是在字典中，我可以使用字符串。
But in a dictionary, I can use strings.

2833
02:18:10,989 --> 02:18:14,649
所以我要继续说，进入房屋字典，
So I'm going to go ahead and say, go into the houses dictionary, which

2834
02:18:14,649 --> 02:18:19,388
我在上方定义，然后转到房门钥匙，然后继续
I defined up above, and go to the house key, and go ahead

2835
02:18:19,388 --> 02:18:22,239
并增加1。
and increment it by 1.

2836
02:18:22,239 --> 02:18:23,229
就是这样。
And that's it.

2837
02:18:23,229 --> 02:18:28,029
至此，我已经打开了CSV文件，并使用该库进行了读取。
At this point, I have opened the CSV file and read it using the library.

2838
02:18:28,030 --> 02:18:30,940
在此循环中，我要遍历电子表格中的每一行
In this loop, I'm iterating over every row in the spreadsheet

2839
02:18:30,940 --> 02:18:34,000
你们都是通过一次又一次地填写表格来创建的。
that you all created by filling out that form again and again.

2840
02:18:34,000 --> 02:18:36,309
我只是用一个变量来得到什么
I'm just using a variable to get at whatever's

2841
02:18:36,308 --> 02:18:40,149
在第二列（也称为行括号1）中，
in the second column, otherwise known as row bracket 1,

2842
02:18:40,149 --> 02:18:42,249
因为行括号0将是时间戳。
because row bracket 0 would be the timestamp.

2843
02:18:42,250 --> 02:18:44,229
然后我要进入字典
And then I'm going into the dictionary called

2844
02:18:44,229 --> 02:18:46,569
房子，我们在这里定义。
houses, which we defined up here.

2845
02:18:46,569 --> 02:18:50,589
我像数组一样索引其中，但在这种情况下是列表，
I'm indexing into it just like an array, but it's a list in this case,

2846
02:18:50,590 --> 02:18:54,219
使用其房屋名称查找相应的密钥。
using its house name, which looks up the appropriate key.

2847
02:18:54,218 --> 02:18:59,269
然后正等于1会增加其值。
And then plus equals 1 has the effect of incrementing its value.

2848
02:18:59,270 --> 02:19:02,170
因此，这是进入字典并递增的一种好方法。
So it's a nice way of going into the dictionary and incrementing.

2849
02:19:02,170 --> 02:19:03,478
进入并递增。
Go in and increment.

2850
02:19:03,477 --> 02:19:06,519
因此，现在让我们从这里开始，继续打印结果。
So now let's go ahead at the very end here and just print out the result.

2851
02:19:06,520 --> 02:19:10,330
“在房屋中换屋子”是一种反复尝试的奇特方法
"For house in houses" is the fancy way to iterate over

2852
02:19:10,329 --> 02:19:14,229
字典中的所有键，继续并打印出格式化的字符串
all of the keys in a dictionary, go ahead and print out a formatted string

2853
02:19:14,229 --> 02:19:15,499
如下。
as follows.

2854
02:19:15,500 --> 02:19:21,160
让我先打印出房子的名称，然后是冒号，然后是房子
Let me print out the house name followed by a colon followed by the houses

2855
02:19:21,159 --> 02:19:24,308
字典，用房子索引到它。
dictionary, indexing into it with house.

2856
02:19:24,308 --> 02:19:25,089
再说一次，神秘的。
So again, cryptic.

2857
02:19:25,090 --> 02:19:26,590
我们一会儿再讲。
We'll come back to this in a second.

2858
02:19:26,590 --> 02:19:27,820
霍格沃茨巨蟒。
Python of hogwarts.

2859
02:19:27,819 --> 02:19:31,869
让我用手指交叉，以防我没拧紧。
Let me cross my fingers that I didn't screw this up.

2860
02:19:31,870 --> 02:19:33,670
而我做到了。
And I did.

2861
02:19:33,670 --> 02:19:35,209
IDE早于我就知道了。
The IDE knew before I did.

2862
02:19:35,209 --> 02:19:35,709
好的。
All right.

2863
02:19:35,709 --> 02:19:38,270
现在让我希望我不要搞砸了，该死。
Now let me hope that I didn't screw this up-- and dammit.

2864
02:19:38,270 --> 02:19:38,770
好的。
All right.

2865
02:19:38,770 --> 02:19:41,830
该文件的名称略有不同。
The file is called something slightly different.

2866
02:19:41,829 --> 02:19:46,839
抱歉，与我练习时相比，Google的名称必须更改了。
Google's name must have changed, sorry, versus when I practiced.

2867
02:19:46,840 --> 02:19:49,310
让我复制一下。
Let me copy this.

2868
02:19:49,309 --> 02:19:50,589
很近。
So close.

2869
02:19:50,590 --> 02:19:52,180
对帽子响应进行排序。
Sorting hat responses.

2870
02:19:52,180 --> 02:19:54,440
啊，有我忘了的括号。
Ah, it has parentheses which I forgot.

2871
02:19:54,440 --> 02:19:54,940
好的。
All right.

2872
02:19:54,940 --> 02:19:58,600
现在让我动动手指，重新运行该程序，该死。
Now let me cross my fingers, rerun the program, dammit.

2873
02:19:58,600 --> 02:20:00,070
好，没有这样的文件，或者-
OK, no such file or--

2874
02:20:00,069 --> 02:20:02,889
哦，我忘了csv，点csv。
oh, I forgot the csv, dot csv.

2875
02:20:02,889 --> 02:20:03,459
好的。
OK.

2876
02:20:03,459 --> 02:20:05,259
现在，交叉手指，然后-
Now cross fingers and--

2877
02:20:05,260 --> 02:20:06,040
哦，感谢上帝。
oh, thank God.

2878
02:20:06,040 --> 02:20:11,440
好的，格兰芬多（Gryffindor）最受欢迎的房子就不足为奇了。
OK so Gryffindor, not surprisingly, the most popular house.

2879
02:20:11,440 --> 02:20:15,910
赫奇帕奇（Hufflepuff）40岁，拉文克劳（Ravenclaw）71岁，斯莱特林（Slytherin）–击败赫奇帕奇（Hufflepuff）。
Hufflepuff at 40, Ravenclaw at 71, Slytherin-- oh, beat out Hufflepuff.

2880
02:20:15,909 --> 02:20:18,879
无论出于什么社会学原因，都很有趣。
Very interesting for whatever sociological reason.

2881
02:20:18,879 --> 02:20:21,739
但是，现在我们有了一个分析CSV的程序。
But here we have a program now that analyzed the CSV.

2882
02:20:21,739 --> 02:20:24,379
现在，我们碰巧用愚蠢的哈利·波特数据来做到这一点。
Now, we happened to do it with silly Harry Potter data.

2883
02:20:24,379 --> 02:20:26,889
但是，再次想像一下，从用户那里收集您想要的任何数据，
But again, imagine collecting any data you want from users,

2884
02:20:26,889 --> 02:20:30,699
以CSV格式下载到您的Mac或PC或IDE，
downloading it as a CSV to your Mac or PC or your IDE,

2885
02:20:30,700 --> 02:20:34,220
然后编写用于分析所需数据的代码。
then writing code that analyzes that data however you want.

2886
02:20:34,219 --> 02:20:36,789
我做了一个非常简单的总结，但是您当然可以
I did a very simple summation, but you could certainly

2887
02:20:36,790 --> 02:20:39,295
想象做些比这更奇妙的事情，
imagine doing something fancier than that,

2888
02:20:39,295 --> 02:20:42,640
像是求和或平均值，标准差。
like doing summations or averages, standard deviations.

2889
02:20:42,639 --> 02:20:46,569
所有这些功能我们也可以得到。
All of that functionality could we get as well.

2890
02:20:46,569 --> 02:20:50,229
好吧，关于字典的任何疑问，现在就开始吧
All right, any questions on dictionaries before we now

2891
02:20:50,229 --> 02:20:53,709
提供我们迄今最强大的功能
offer up some of the most powerful features we've yet

2892
02:20:53,709 --> 02:20:55,629
用编程语言看过吗？
seen in a programming language?

2893
02:20:58,379 --> 02:21:01,599
Brian，您到底要做什么？
Anything at all on your end, Brian?

2894
02:21:01,600 --> 02:21:02,820
布莱恩：这里没有举手。
BRIAN: No hands raised here.

2895
02:21:02,819 --> 02:21:03,777
戴维·马兰：好的。
DAVID MALAN: All right.

2896
02:21:03,778 --> 02:21:06,690
好吧，现在让我继续前进，我实际上将过渡
Well, let me go ahead now, and I'm going to transition actually

2897
02:21:06,690 --> 02:21:10,080
到我预先安装了Python的Mac上，
to my Mac where I have in advance pre-installed Python,

2898
02:21:10,079 --> 02:21:11,869
只是为了我可以在本地做事。
just so that I can do things locally.

2899
02:21:11,870 --> 02:21:13,370
它将使事情变得更快。
It will make things a little faster.

2900
02:21:13,370 --> 02:21:15,030
我不必担心互联网速度之类的问题。
I don't have to worry about internet speeds and the like.

2901
02:21:15,030 --> 02:21:18,090
的确如此，在您自己的Mac，您的PC上，
And this is indeed the case, that on your own Mac, your own PC,

2902
02:21:18,090 --> 02:21:21,210
您可以下载并安装Python解释器，
you can download and install the Python interpreter,

2903
02:21:21,209 --> 02:21:23,069
在您自己的Mac和PC上运行它。
run it on your own Mac and PC.

2904
02:21:23,069 --> 02:21:25,739
但是，我建议您继续使用此IDE，
However, I would recommend you continue using this IDE,

2905
02:21:25,739 --> 02:21:28,589
当然，为了解决问题，直到学期末，
certainly for problem sets' sake until the end of the semester,

2906
02:21:28,590 --> 02:21:31,350
也许过渡到Mac或PC进行最终项目
maybe transitioning to your Mac or PC for final projects

2907
02:21:31,350 --> 02:21:34,440
只是因为我这个周末做的事花了-
only, only because what I did this weekend was spent--

2908
02:21:34,440 --> 02:21:37,500
浪费大量时间只是让愚蠢的库工作
waste a huge amount of time just getting stupid libraries to work

2909
02:21:37,500 --> 02:21:40,253
在我自己的Mac上，说起来容易做起来难，
on my own Mac, which is often easier said than done,

2910
02:21:40,253 --> 02:21:43,170
只是因为程序员在编写应该可以工作的代码时
just because when programmers are writing code that's supposed to work

2911
02:21:43,170 --> 02:21:46,980
在世界上所有可能的Mac和PC上，您和我以及其他所有人
on every possible Mac and PC in the world, you and I and everyone else

2912
02:21:46,979 --> 02:21:49,829
版本号略有不同，软件安装也不同，
have slightly different version numbers, different software install,

2913
02:21:49,829 --> 02:21:51,269
不同的不兼容性。
different incompatibilities.

2914
02:21:51,270 --> 02:21:55,140
因此，当您在本地做事时，这些头痛很快就会出现。
So those kinds of headaches very quickly arise when you're doing things locally.

2915
02:21:55,139 --> 02:21:58,209
因此，让我鼓励您等到最终项目结束时，
So let me encourage you to wait until terms end with final projects,

2916
02:21:58,209 --> 02:22:00,959
也许，要离开IDE并做些什么
perhaps, to move off of the IDE and do what

2917
02:22:00,959 --> 02:22:05,639
我现在要这样做，只是因为您将能够看到更多这些演示
I'm about to now do, just because you'll be able to see these demos more

2918
02:22:05,639 --> 02:22:06,809
显然在这里。
clearly here.

2919
02:22:06,809 --> 02:22:08,969
我要继续，在我自己的Mac上，
I'm going to go ahead, and on my own Mac,

2920
02:22:08,969 --> 02:22:12,539
我将继续创建一个名为Speech.py的程序。
I'm going to go ahead and create a program called speech.py.

2921
02:22:12,540 --> 02:22:16,770
预先，我已经安装了一个支持语音合成的库。
In advance, I've installed a library that supports speech synthesis.

2922
02:22:16,770 --> 02:22:18,810
如果我想使用该功能，
And if I want access to that functionality,

2923
02:22:18,809 --> 02:22:24,719
只需导入pyttsx3，即该人的开源名称
it suffices to import pyttsx3, which is the name of that person's open source

2924
02:22:24,719 --> 02:22:28,259
我预先下载并安装在Mac上的免费库。
free library that I downloaded and installed on my Mac in advance.

2925
02:22:28,260 --> 02:22:29,400
我阅读了文档。
I read the documentation.

2926
02:22:29,399 --> 02:22:31,979
在过去的一周中，我几乎从未使用过此功能。
I literally never used this before this past week.

2927
02:22:31,979 --> 02:22:36,269
我发现例如可以声明一个名为engine的变量。
And I found that I can declare a variable called engine, for instance.

2928
02:22:36,270 --> 02:22:41,830
然后，我可以调用pyttsx3.init初始化该库。
I can then call pyttsx3.init to initialize the library.

2929
02:22:41,829 --> 02:22:42,329
为什么？
Why?

2930
02:22:42,329 --> 02:22:44,369
那只是因为程序员是如何设计的。
That's just because of how the programmer designed it.

2931
02:22:44,370 --> 02:22:45,720
您必须先对其进行初始化。
You have to initialize it first.

2932
02:22:45,719 --> 02:22:50,609
然后，我可以使用该引擎说诸如“ hello”，逗号“ world”之类的内容。
I then can use that engine to say things like, say, "hello," comma "world."

2933
02:22:50,610 --> 02:22:54,180
然后在那之后，我应该运行引擎并等待它
Then after that, I should run the engine and wait for it

2934
02:22:54,180 --> 02:22:56,800
在我自己的程序退出之前完成。
to finish before my own program quits.

2935
02:22:56,799 --> 02:22:57,299
好的。
All right.

2936
02:22:57,299 --> 02:23:03,419
现在让我继续并关闭它，然后在我自己的Mac上运行Speech.py的python
Let me go ahead now and close that, and run python of speech.py on my own Mac

2937
02:23:03,420 --> 02:23:04,950
这里。
here.

2938
02:23:04,950 --> 02:23:06,678
计算机声音：您好，世界。
COMPUTER VOICE: Hello, world.

2939
02:23:06,677 --> 02:23:07,719
大卫·马兰：有趣。
DAVID MALAN: Interesting.

2940
02:23:07,719 --> 02:23:09,479
所以它说了我输入的内容。
So it said what I typed in.

2941
02:23:09,479 --> 02:23:13,049
确实，我可能可以使这一点变得更加有趣。
And indeed, I can probably make this even more interesting.

2942
02:23:13,049 --> 02:23:15,369
让我继续说这样的话。
Let me go ahead and say something like this.

2943
02:23:15,370 --> 02:23:19,170
让我再次打开speech.py并添加一些功能。
Let me open up speech.py again and add some functionality.

2944
02:23:19,170 --> 02:23:23,910
我不会使用CS50库，但也许会使用输入功能。
I won't use the CS50 library, but I will use maybe the input function.

2945
02:23:23,909 --> 02:23:30,269
让我继续说，输入姓名，“您叫什么名字，”问号。
Let me go ahead and say name gets input, "What's your name," question mark.

2946
02:23:30,270 --> 02:23:33,090
然后让我继续说，而不是说“你好，世界”
And then let me go ahead and say, not "hello, world,"

2947
02:23:33,090 --> 02:23:34,680
但让我用f弦
but let me use an f-string--

2948
02:23:34,680 --> 02:23:36,570
不必在印刷中使用
which doesn't have to be used in print, you

2949
02:23:36,569 --> 02:23:39,219
可以在需要字符串的任何函数中使用它。
can use it in any function that takes a string.

2950
02:23:39,219 --> 02:23:42,159
让我继续说那个名字“你好”。
Let me go ahead and say "hello" to that name.

2951
02:23:42,159 --> 02:23:42,659
好的。
All right.

2952
02:23:42,659 --> 02:23:45,549
让我继续并再次运行python speech.py。
Let me go ahead and run python speech.py again.

2953
02:23:45,549 --> 02:23:46,319
哎呀。
Oops.

2954
02:23:46,319 --> 02:23:50,929
让我继续并再次运行Speech.py的python。
Let me go ahead and run python of speech.py again.

2955
02:23:50,930 --> 02:23:51,620
我的名字是什么？
What's my name?

2956
02:23:51,620 --> 02:23:52,350
大卫。
David.

2957
02:23:52,350 --> 02:23:54,590
计算机声音：您好，戴维。
COMPUTER VOICE: Hello, David.

2958
02:23:54,590 --> 02:23:57,860
戴维·马兰（DAVID MALAN）：曲折的选择很奇怪，但实际上是综合的。
DAVID MALAN: Weird choice of inflection, but indeed it synthesized it.

2959
02:23:57,860 --> 02:23:58,790
让我们尝试Brian。
Let's try Brian.

2960
02:23:58,790 --> 02:24:00,253
电脑声音：您好，布莱恩。
COMPUTER VOICE: Hello, Brian.

2961
02:24:00,253 --> 02:24:00,920
戴维·马兰：好的。
DAVID MALAN: OK.

2962
02:24:00,920 --> 02:24:02,795
所以我们可能可以修改设置
So we could probably tinker with the settings

2963
02:24:02,795 --> 02:24:04,800
使声音听起来更自然。
to make the voice sound a little more natural.

2964
02:24:04,799 --> 02:24:05,959
但这很酷。
But that's pretty cool.

2965
02:24:05,959 --> 02:24:08,749
好吧，让我看一下我这次使用预先编写的一些代码
Well, let me go into some code I wrote in advance this time using

2966
02:24:08,750 --> 02:24:13,429
一个不同的库，这个库与面部和面部检测有关。
a different library, this one related to faces and facial detection.

2967
02:24:13,430 --> 02:24:16,130
当然，在社交媒体方面非常流行
Certainly very much in vogue when it comes to social media

2968
02:24:16,129 --> 02:24:19,639
如今，随着Facebook和其他网站自动为您添加标签，
these days, with Facebook and other websites automatically tagging you,

2969
02:24:19,639 --> 02:24:23,149
与州政府和联邦政府的关系越来越密切
very concerning increasingly with state governments and federal governments

2970
02:24:23,149 --> 02:24:26,539
和执法部门使用面部检测功能来找到人群。
and law enforcement using facial detection to find people in a crowd.

2971
02:24:26,540 --> 02:24:29,180
让我继续在这里打开一个文件，例如，
And let me go ahead and open up a file here, for instance,

2972
02:24:29,180 --> 02:24:32,550
更加温和一点，就像一群人在办公室里一样。
a little more benignly, like a whole bunch of people in an office.

2973
02:24:32,549 --> 02:24:34,744
这是办公室里一些人的照片。
So here is a photograph of some people in an office.

2974
02:24:34,745 --> 02:24:36,120
而且那里有很多面孔。
And there's a lot of faces there.

2975
02:24:36,120 --> 02:24:42,020
但是，除了那些面孔之外，还有很多纸箱和其他分散注意力的东西。
But there's a lot of boxes of paper and other distractions besides those faces.

2976
02:24:42,020 --> 02:24:46,400
但是，让我继续快速看一下一个名为detect.py的程序。
But let me go ahead and look at, quickly, a program called detect.py.

2977
02:24:46,399 --> 02:24:49,099
这个文件的大部分是注释，只是如果您要在家中
Most of this file is comments, just so that if you want at home

2978
02:24:49,100 --> 02:24:50,930
您可以继续进行下去，看看它能做什么。
you can follow along and see what it does.

2979
02:24:50,930 --> 02:24:53,500
但是，让我仅强调一些明显的界线。
But let me just highlight a few salient lines.

2980
02:24:53,500 --> 02:24:55,759
再次是那个枕头库，我在这里
Here is that Pillow library again, where I'm

2981
02:24:55,760 --> 02:24:59,660
从预安装的Python函数访问与图像相关的功能。
accessing image related functionality from a pre-installed Python function.

2982
02:24:59,659 --> 02:25:01,159
这真是太神奇了。
And this one's just kind of amazing.

2983
02:25:01,159 --> 02:25:03,469
如果您想使用面部识别技术，
If you want to use facial recognition technology,

2984
02:25:03,469 --> 02:25:05,359
只需导入face_recognition。
just import face_recognition.

2985
02:25:05,360 --> 02:25:08,330
那是一个您可以导入的库，它将使您能够访问
That is a library you can import that will give you access

2986
02:25:08,329 --> 02:25:09,919
那种力量。
to that kind of power.

2987
02:25:09,920 --> 02:25:13,790
现在到这里，我只知道如何通过阅读一些文档来解决这个问题，
Down here now, I only knew how to figure this out by reading some documentation,

2988
02:25:13,790 --> 02:25:17,897
但是您访问了名为face_recognition.load_image_file的库，
but you access the library called face_recognition.load_image_file,

2989
02:25:17,897 --> 02:25:19,730
这是功能的意思。
which is a function that does what it means.

2990
02:25:19,729 --> 02:25:21,589
我正在打开office.jpg。
I'm opening up office.jpg.

2991
02:25:21,590 --> 02:25:25,340
然后在此处向下滚动到白色代码，这是实际的代码-
And then scrolling down here to the white code, which is the actual code--

2992
02:25:25,340 --> 02:25:28,280
所有的蓝色都是评论，回想一下-
all of the blue is comments, recall--

2993
02:25:28,280 --> 02:25:32,690
这行代码是Python所需的全部
this line of code here is all that's required in Python

2994
02:25:32,690 --> 02:25:36,050
使用面部识别库，找到所有面部位置
to use the face recognition library, find all of the face locations

2995
02:25:36,049 --> 02:25:40,819
在给定的图像中，并将它们存储在一个名为face_locations的列表中。
in a given image, and store them in a list called face_locations.

2996
02:25:40,819 --> 02:25:43,309
这行代码只是一个Python循环
This line of code here is just a Python loop

2997
02:25:43,309 --> 02:25:47,179
遍历检测到的面部中的每个面部。
that iterates over every face in the faces that were detected.

2998
02:25:47,180 --> 02:25:50,180
然后是这几行代码，长话短说，
And then these several lines of code here, long story short,

2999
02:25:50,180 --> 02:25:54,050
只是裁剪出个人面孔并使用找到的图像创建新图像
just crop out individual faces and create a new image with the found

3000
02:25:54,049 --> 02:25:55,106
面孔。
faces.

3001
02:25:55,106 --> 02:25:58,189
因此，无需过多了解库的详细信息，
So without getting too much into the details of the library, which are not

3002
02:25:58,190 --> 02:26:01,550
从理论上讲，这些功能对我们而言现在很有趣，
that intellectually interesting, the features are interesting to us for now,

3003
02:26:01,549 --> 02:26:04,099
让我运行detect.py的python。
let me run python of detect.py.

3004
02:26:04,100 --> 02:26:06,890
让我在这里给我的Mac几秒钟做它的事情。
Let me give my Mac a few seconds here to do its thing.

3005
02:26:06,889 --> 02:26:11,809
瞧，如果我放大此处，我们会看到菲利斯和吉姆，
And voila, if I zoom in here we see Phyllis, and Jim,

3006
02:26:11,809 --> 02:26:15,469
和罗伊，几乎所有其他面孔
and Roy, and pretty much every other face that

3007
02:26:15,469 --> 02:26:19,981
在那张照片中被检测到，并被裁剪成一张单独的脸。
was detected in that photograph, cropped out as, indeed, an individual face.

3008
02:26:19,981 --> 02:26:22,189
因此，如果您曾经发现自己身上有一个小方块
So if you've ever noticed a little square on yourself

3009
02:26:22,190 --> 02:26:25,880
在Facebook中上传照片时，这正是这种代码
in Facebook when uploading a photo, this is exactly the kind of code

3010
02:26:25,879 --> 02:26:30,379
Facebook和其他人正在其服务器上使用该文件来执行该操作。
that Facebook and others are using on their servers in order to execute that.

3011
02:26:30,379 --> 02:26:31,969
好吧，你知道吗，这呢？
Well, you know what, how about this?

3012
02:26:31,969 --> 02:26:35,299
在同一张办公室的照片中，
In the same office photo, you know, there's

3013
02:26:35,299 --> 02:26:37,119
一个似乎总是脱颖而出的人。
one person that always seems to stand out.

3014
02:26:37,120 --> 02:26:38,120
没有人真的喜欢他。
No one really likes him.

3015
02:26:38,120 --> 02:26:39,050
那就是托比。
And that's Toby.

3016
02:26:39,049 --> 02:26:43,369
如果我们在这样一个单独的文件中拍摄了托比的大头照怎么办？
What if we had a mug shot of Toby in a separate file like this?

3017
02:26:43,370 --> 02:26:47,390
我们可以在办公室里的这些人中间找到托比吗？
Can we find Toby in a crowd among these people in the office?

3018
02:26:47,389 --> 02:26:48,139
好吧，我们可以。
Well, we can.

3019
02:26:48,139 --> 02:26:50,984
现在，让我继续运行一个程序，该程序名为Recognition.py，
Let me go ahead now and run a program called recognize.py,

3020
02:26:50,985 --> 02:26:52,610
欢迎您在线观看。
which you're welcome to look at online.

3021
02:26:52,610 --> 02:26:54,830
这是相似的代码行，不是很多，
It's similar lines of code, It's not terribly many,

3022
02:26:54,829 --> 02:26:58,039
那会引起一些思考。
that is going to do some thinking.

3023
02:26:58,040 --> 02:27:00,540
它同时开放了办公室JPEG和这一文件。
It's opening up both the office JPEG and this one.

3024
02:27:00,540 --> 02:27:02,780
并注意发生了什么，如果我放大，
And notice what just happened, if I zoom in,

3025
02:27:02,780 --> 02:27:09,200
奇妙的是，托比是唯一一个脸上有一个大绿框的人，
wonderfully, Toby is the only one with a big green box around his face,

3026
02:27:09,200 --> 02:27:10,965
确实得到认可。
having indeed been recognized.

3027
02:27:10,965 --> 02:27:12,590
再说一遍，我只看一下代码。
So again, I'll just glance at the code.

3028
02:27:12,590 --> 02:27:16,700
这次，如果我打开identify.py，则需要多几行代码。
This time, if I open up recognize.py, it's a few more lines of code.

3029
02:27:16,700 --> 02:27:19,610
但同样，我正在导入面部识别和其他一些东西。
But again, I'm importing face recognition and some other things.

3030
02:27:19,610 --> 02:27:21,260
我正在加载toby.jpg。
I'm loading toby.jpg.

3031
02:27:21,260 --> 02:27:23,278
我正在加载office.jpg。
And I'm loading office.jpg.

3032
02:27:23,278 --> 02:27:25,820
然后，这里还有更多代码正在寻找Toby，
And then there's some more code here that's looking for Toby,

3033
02:27:25,819 --> 02:27:29,989
寻找托比，然后在脸上画一个大绿框
looking for Toby, and then drawing a big green box around the face that

3034
02:27:29,989 --> 02:27:31,259
最终被发现。
is ultimately found.

3035
02:27:31,260 --> 02:27:33,380
再说一遍，在一天结束时，它只是循环而已。
So again, at the end of the day, it's just loops.

3036
02:27:33,379 --> 02:27:34,499
只是功能而已。
It's just functions.

3037
02:27:34,500 --> 02:27:35,629
这只是变量。
It's just variables.

3038
02:27:35,629 --> 02:27:39,439
但是现在这些功能非常漂亮而且功能强大，
But now the functions are pretty darn fancy and powerful,

3039
02:27:39,440 --> 02:27:43,070
因为他们再次利用了所有其他功能
because again, they're taking advantage of all of these other features

3040
02:27:43,069 --> 02:27:46,429
我们自己已经用C之类的语言实现了，
that we ourselves have implemented in a language like C,

3041
02:27:46,430 --> 02:27:50,435
或现在已经看到了Python世界的一瞥。
or have now seen glimpses of within the world of Python.

3042
02:27:50,434 --> 02:27:51,559
好吧，让我们再做一个。
Well, let's do another one.

3043
02:27:51,559 --> 02:27:57,829
让我继续并快速打开一个真正的程序
Let me go ahead and open up real quickly a program

3044
02:27:57,829 --> 02:28:02,629
这样我就可以创建这些2D条形码之一，即所谓的QR码。
that will allow me to create one of these 2D barcodes, a so-called QR code.

3045
02:28:02,629 --> 02:28:07,219
让我继续创建一个名为qr.py的文件。在此文件中，让我继续
Let me go ahead and create a file called qr.py And in this file, let me go ahead

3046
02:28:07,219 --> 02:28:08,359
并做到这一点。
and do this.

3047
02:28:08,360 --> 02:28:10,970
出于某种原因导入操作系统库
Import the operating system library, for reasons

3048
02:28:10,969 --> 02:28:14,749
我们很快就会看到，让我导入QR码库
we'll soon see, and let me import the QR code library, which

3049
02:28:14,750 --> 02:28:17,000
会为我做所有的辛苦工作。
will do all of the hard work for me.

3050
02:28:17,000 --> 02:28:19,520
让我继续创建一个名为qr的图像-
Let me go ahead and create an image called qr--

3051
02:28:19,520 --> 02:28:22,280
分配了qrcode make的值。
that's assigned the value of qrcode making.

3052
02:28:22,280 --> 02:28:25,680
然后让我粘贴该课程的一个讲座视频的URL，
And let me paste in this URL of one of the course's lecture videos,

3053
02:28:25,680 --> 02:28:26,510
例如。
for instance.

3054
02:28:26,510 --> 02:28:31,700
然后让我继续将此图像另存为qr.png，便携式网络
And then let me go ahead and save this image as qr.png, Portable Network

3055
02:28:31,700 --> 02:28:34,910
图形（确实是PNG）是一种非常流行的文件格式
Graphic, as indeed a PNG, a very popular file format

3056
02:28:34,909 --> 02:28:36,479
用于照片和其他东西。
for photos and other things.

3057
02:28:36,479 --> 02:28:38,329
然后让我实际打开这个东西。
And then let me actually open this thing up.

3058
02:28:38,329 --> 02:28:41,719
开放系统-实际上，不，这很好。
Open up system-- actually, nope, that's fine.

3059
02:28:41,719 --> 02:28:42,839
让我保持简单。
Let me keep it simple.

3060
02:28:42,840 --> 02:28:44,210
我们不需要os库。
We don't need the os library.

3061
02:28:44,209 --> 02:28:45,079
不，我们愿意。
Nope, we do.

3062
02:28:45,079 --> 02:28:49,249
让我们继续并使用“ open qr.png”打开它。
Let's go ahead and open it up with "open qr.png."

3063
02:28:49,250 --> 02:28:50,969
所以三行代码
So three lines of code--

3064
02:28:50,969 --> 02:28:56,219
用该URL制作一个QR码，将其另存为qr.png，然后打开文件。
make a QR code with that URL, save it as qr.png, and open the file.

3065
02:28:56,219 --> 02:28:57,729
三行代码。
Three lines of code.

3066
02:28:57,729 --> 02:29:00,749
让我继续运行qr.py的python。
Let me go ahead and run python of qr.py.

3067
02:29:00,750 --> 02:29:02,280
瞧，速度非常快。
Voila, it was pretty fast.

3068
02:29:02,280 --> 02:29:05,670
如果您想拿出自己的iPhone或Android手机，
If you would like to take out your own iPhone or Android phone,

3069
02:29:05,670 --> 02:29:08,190
如果您的手机支持，请打开相机，
turn on the camera if your phone supports this,

3070
02:29:08,190 --> 02:29:13,800
笨拙地将手机对准演讲课，然后扫描3D条码
and scan this 3D barcode by awkwardly just pointing your phone at the lecture

3071
02:29:13,799 --> 02:29:23,039
正如我们所说的那样，它应该可以为您打开YouTube，并且具有以下特点：
as we speak, it should open up YouTube for you, hopefully, and with such is--

3072
02:29:23,040 --> 02:29:26,730
抱歉，是的，谢谢您向我展示您没有看到的内容。
I apologize to those-- yes, thank you for showing me what you're not seeing.

3073
02:29:26,729 --> 02:29:28,739
对于再次这样做，我深表歉意。
I apologize for doing that yet again.

3074
02:29:28,739 --> 02:29:29,669
永不变老。
Never gets old.

3075
02:29:29,670 --> 02:29:33,330
但是我们所做的只是嵌入二维格式，详细信息
But all we've done is embed in a two-dimensional format, details

3076
02:29:33,329 --> 02:29:35,939
其中我们不会在课堂上介绍URL，
of which we won't go into in class, a URL,

3077
02:29:35,940 --> 02:29:39,373
这表明您可以在这些二维条形码中存储任何内容，
which suggests that you can store anything inside of these 2D barcodes,

3078
02:29:39,372 --> 02:29:41,789
如果用像摄像机这样的东西解码它们
and if you decode them with something like your camera can

3079
02:29:41,790 --> 02:29:45,870
这些天在您的手机上运行的软件会为您解码这些内容。
the software running on your phones these days decode these things for you.

3080
02:29:45,870 --> 02:29:49,590
好吧，让我做点别的，这次涉及另一种意义，这个
Well, let me do something else, this time involving another sense, this one

3081
02:29:49,590 --> 02:29:50,340
听。
listening.

3082
02:29:50,340 --> 02:29:53,428
让我进入一个名为listen.py的文件。
Let me go into a file called listen.py.

3083
02:29:53,427 --> 02:29:55,469
让我继续做一些非常简单的事情。
And let me go ahead and do something very simple.

3084
02:29:55,469 --> 02:29:59,309
让我继续，在名为word的变量中获取用户输入
Let me go ahead and get a user's input in a variable called word

3085
02:29:59,309 --> 02:30:01,289
通过使用输入功能。
by using the input function.

3086
02:30:01,290 --> 02:30:02,670
说些什么。
Say something.

3087
02:30:02,670 --> 02:30:06,690
然后，让我将所有内容都转换为小写，只是为了使事情保持简单。
And then let me just send it all to lowercase, just to keep things simple.

3088
02:30:06,690 --> 02:30:07,980
现在让我来做。
And now let me do this.

3089
02:30:07,979 --> 02:30:10,289
听到用户的话后，让我继续说：
Once I get the user's words, let me go ahead and say,

3090
02:30:10,290 --> 02:30:17,730
如果他们用的是“你好”一词，请继续打印“向你好”
if the word "hello" is in their words, go ahead and print out "Hello to you

3091
02:30:17,729 --> 02:30:18,369
也！”
too!"

3092
02:30:18,370 --> 02:30:20,640
因此，如果他们打招呼，我想打个招呼。
So if they say hello, I want to say hello back.

3093
02:30:20,639 --> 02:30:27,839
Elif，说“你好吗”，然后让我继续并打印出一些内容
Elif, "how are you" in words, then let me go ahead and print out something

3094
02:30:27,840 --> 02:30:31,290
比如说“我很好，谢谢”。
like, "I am well, thanks," as the computer.

3095
02:30:31,290 --> 02:30:37,590
Elif用话语“再见”，然后让我继续说些合理的话
Elif "goodbye" in words, then let me go ahead and say something reasonable

3096
02:30:37,590 --> 02:30:42,350
就像“再见，你也一样。”
like "Goodbye to you too."

3097
02:30:42,350 --> 02:30:45,530
最后，否则，让我继续进行打印
And then lastly, else let me go ahead and print out

3098
02:30:45,530 --> 02:30:46,820
只是像“嗯？”之类的东西。
just something like "Huh?"

3099
02:30:46,819 --> 02:30:48,019
无法识别。
Unrecognized.

3100
02:30:48,020 --> 02:30:52,580
因此，如果您愿意的话，这就是人工智能的开始，即AI
So if you will, here is the beginnings of an artificial intelligence, an AI--

3101
02:30:52,579 --> 02:30:55,939
一个将以某种方式与我互动的程序
a program that's going to somehow interact with me the human typing

3102
02:30:55,940 --> 02:30:57,390
用这句话来形容。
in phrases to this thing.

3103
02:30:57,389 --> 02:31:00,829
因此，如果我正确地做到了，那么让我继续运行listen.py的python。
So if I did it correctly, let me go ahead and run python of listen.py.

3104
02:31:00,829 --> 02:31:04,129
我没有正确地做某事。
I did not do something correctly.

3105
02:31:04,129 --> 02:31:06,389
哦，不是“是”，“在”。
Oh, not "is," "in."

3106
02:31:06,389 --> 02:31:08,089
好的，对不起。
OK, sorry.

3107
02:31:08,090 --> 02:31:10,160
让我继续并运行listen.py的python。
Let me go ahead and run python of listen.py.

3108
02:31:10,159 --> 02:31:10,909
说些什么。
Say something.

3109
02:31:10,909 --> 02:31:12,019
我会说“你好”。
I'll say "hello."

3110
02:31:12,020 --> 02:31:13,100
哦，你好。
Oh, Hello to you too.

3111
02:31:13,100 --> 02:31:14,900
多么好的友好程序。
What a nice friendly program.

3112
02:31:14,899 --> 02:31:18,229
让我问问它是什么，“你好吗”，问号。
Let me ask it how it is, "how are you," question mark.

3113
02:31:18,229 --> 02:31:20,099
似乎发现了这一点。
It seems to detect that.

3114
02:31:20,100 --> 02:31:23,840
让我继续说：“暂时再见。”
Let me go ahead and say, "ok goodbye for now."

3115
02:31:23,840 --> 02:31:27,860
而且它也检测到，因为“再见”在短语中
And it detects that, too, because "goodbye" is in the phrase

3116
02:31:27,860 --> 02:31:29,130
用户键入的内容。
that the user typed in.

3117
02:31:29,129 --> 02:31:32,879
但是，如果我说“嘿”，那是无法识别的。
But if I say something like, "hey there," it's not recognized.

3118
02:31:32,879 --> 02:31:33,749
太酷了。
So pretty cool.

3119
02:31:33,750 --> 02:31:37,399
我们可以使用in介词使用非常简单的字符串比较
We can use very simple string comparisons using the in preposition

3120
02:31:37,399 --> 02:31:38,389
检测事物。
to detect things.

3121
02:31:38,389 --> 02:31:40,879
但是我敢打赌-你知道，我敢打赌，如果我们使用正确的库，
But I bet-- you know, I bet if we use the right library,

3122
02:31:40,879 --> 02:31:43,579
我们真的可以使它变得更强大。
we can really make this more powerful, too.

3123
02:31:43,579 --> 02:31:46,939
让我继续前进，就像我导入面部识别一样，
Let me go ahead, and just like I imported facial recognition,

3124
02:31:46,940 --> 02:31:51,710
让我用Python导入语音识别，这是另一个库
let me import speech recognition in Python, which is yet another library

3125
02:31:51,709 --> 02:31:53,239
我预先安装的
that I pre-installed.

3126
02:31:53,239 --> 02:31:56,329
让我继续，现在要做，识别器等于
Let me go ahead and now do this, recognizer equals

3127
02:31:56,329 --> 02:31:58,319
speech_recognition。识别器。
speech_recognition.Recognizer.

3128
02:32:01,700 --> 02:32:04,610
这只是创建一个称为识别器的变量
And this is just creating a variable called recognizer

3129
02:32:04,610 --> 02:32:08,420
我从字面上遵循了使用该库的文档。
by my having followed literally the documentation for using this library.

3130
02:32:08,420 --> 02:32:11,030
然后，让我继续进行操作，也可以从文档中进行操作，
Then let me go ahead and do this, also from the documentation,

3131
02:32:11,030 --> 02:32:19,640
以Speech_recognition.Microphone为来源。
with speech_recognition.Microphone as source.

3132
02:32:19,639 --> 02:32:22,499
所以这在某种意义上打开了我的麦克风，
So this is opening up my microphone in some sense,

3133
02:32:22,500 --> 02:32:24,290
再次按照文档进行操作。
again just following the documentation.

3134
02:32:24,290 --> 02:32:28,300
让我继续向用户说“说点什么”。
Let me go ahead and say "Say something" to the user.

3135
02:32:28,299 --> 02:32:30,759
然后，让我继续声明
And then after that, let me go ahead and declare

3136
02:32:30,760 --> 02:32:36,700
将一个称为音频的变量设置为等于识别器的监听功能，
a variable called audio, set it equal to the recognizer's listen function,

3137
02:32:36,700 --> 02:32:39,310
传入我的麦克风作为信号源。
passing in my microphone as the source.

3138
02:32:39,309 --> 02:32:44,499
现在，在这里，让我继续说，打印出“您说过”，
And now down here, let me go ahead and say print out "You said,"

3139
02:32:44,500 --> 02:32:51,532
在下面，我将打印出identifier.recognize，
and below that I will print out recognizer.recognize,

3140
02:32:51,531 --> 02:32:55,669
出于某种原因，它是今天迄今为止最困难的部分，Google音频。
is the hardest part today so far for some reason, google audio.

3141
02:32:55,670 --> 02:32:56,170
好的。
All right.

3142
02:32:56,170 --> 02:32:57,610
发生什么了？
So what's going on?

3143
02:32:57,610 --> 02:33:00,040
这行代码-这里的这些行
This line of code-- these lines of code here

3144
02:33:00,040 --> 02:33:03,010
正在与Mac上的麦克风建立连接。
are opening up a connection to my microphone on my Mac.

3145
02:33:03,010 --> 02:33:07,030
然后，它使用语音识别库来收听我的麦克风，
It's then using the speech recognition library to listen to my microphone,

3146
02:33:07,030 --> 02:33:11,680
并将来自我麦克风的音频存储在一个名为audio的变量中。
and storing the audio from my microphone in a variable called audio.

3147
02:33:11,680 --> 02:33:14,230
这些代码行实际上是在打印，
These lines of code down here are literally printing,

3148
02:33:14,229 --> 02:33:20,349
“您说了”，然后将其传递给google.com，音频文件
"You said," and then it's passing to the, the google.com, the file of audio

3149
02:33:20,350 --> 02:33:23,560
我刚刚记录在麦克风上，并且正在打印
that I just recorded on my microphone, and it's printing out

3150
02:33:23,559 --> 02:33:25,146
从Google回来的一切。
whatever comes back from Google.

3151
02:33:25,147 --> 02:33:26,980
让我们再来看一次
So let's see what comes out, again, crossing

3152
02:33:26,979 --> 02:33:28,809
我没有弄乱的手指。
my fingers that I didn't mess up.

3153
02:33:28,809 --> 02:33:32,019
Python的监听。
Python of listen.

3154
02:33:32,020 --> 02:33:32,725
你好，世界。
Hello, world.

3155
02:33:35,680 --> 02:33:37,940
胡胡。
Hoo.

3156
02:33:37,940 --> 02:33:41,320
你好吗？
How are you?

3157
02:33:41,319 --> 02:33:42,932
这是一个很好的语音识别。
It's a pretty good speech recognition.

3158
02:33:42,933 --> 02:33:44,350
可以这么说，它正在使用云。
It's using the cloud, so to speak.

3159
02:33:44,350 --> 02:33:45,558
它正在将其传递给Google。
It's passing it up to Google.

3160
02:33:45,558 --> 02:33:47,350
但是现在让我们做些更奇特的事情
But now let's make things a little fancier

3161
02:33:47,350 --> 02:33:49,060
并真正回应人类。
and actually respond to the human.

3162
02:33:49,059 --> 02:33:52,359
因此，让我回到这里并添加一些先前的逻辑
So let me go back into here and add back some of the previous logic

3163
02:33:52,360 --> 02:33:53,620
并说这样的话。
and say something like this.

3164
02:33:53,620 --> 02:33:58,330
如果是“ hello”，请像以前一样继续打印并打印出来，
If "hello" in words, then go ahead and print out, like before,

3165
02:33:58,329 --> 02:34:00,219
“你也好。”
"Hello to you too."

3166
02:34:00,219 --> 02:34:05,649
用Google的话说的Elif“你好吗”，
Elif "how are you" in the words that have come back from Google,

3167
02:34:05,649 --> 02:34:08,799
继续并打印出“我很好，谢谢！”
go ahead and print out "I am well, thanks!"

3168
02:34:08,799 --> 02:34:13,479
在这里，如果我说“再见”，
And down here if I said "goodbye" in words,

3169
02:34:13,479 --> 02:34:20,049
然后继续打印并“再见！”
then go ahead and print out "Goodbye to you too!"

3170
02:34:20,049 --> 02:34:25,209
否则，如果我认不出任何东西，让我们打印出“嗯？”
Else if nothing comes back that I recognize, let's just print out "Huh?"

3171
02:34:25,209 --> 02:34:30,159
因此，如果我做对了，让我们继续，让我们做listen.py的python。
So if I did this right, let's now go ahead and let's do python of listen.py.

3172
02:34:30,159 --> 02:34:32,559
你好。
Hello, there.

3173
02:34:32,559 --> 02:34:33,489
哦，该死。
Oh, dammit.

3174
02:34:33,489 --> 02:34:35,379
好，待命
OK, standby.

3175
02:34:35,379 --> 02:34:36,369
哒哒哒哒
Da-da-da.

3176
02:34:36,370 --> 02:34:36,985
哦对不起。
Oh, sorry.

3177
02:34:39,801 --> 02:34:41,009
让我查找并替换。
Let me do a find and replace.

3178
02:34:41,010 --> 02:34:43,170
我将变量称为“单词”，而不是“音频”。
I called the variable "words" instead of "audio."

3179
02:34:43,170 --> 02:34:45,790
我刚刚执行了一个漂亮的命令来替换它。
And I just executed a fancy command to replace it everywhere.

3180
02:34:45,790 --> 02:34:47,890
所以我这次要说的是“音频”。
So "audio" is what I meant to say this time.

3181
02:34:47,889 --> 02:34:52,004
现在，让我们继续运行此文件，即listen.py的python。
Now, let's go ahead and run this, python of listen.py.

3182
02:34:52,004 --> 02:34:54,589
你好，世界。
Hello, world.

3183
02:34:54,590 --> 02:34:55,500
该死
Dammit.

3184
02:34:55,500 --> 02:34:57,779
AudioData是不可迭代的。
AudioData is not iterable.

3185
02:34:57,780 --> 02:34:59,820
这是一个错误。
This is a bug.

3186
02:34:59,819 --> 02:35:03,899
给我一点时间仔细检查我的笔记。
Give me one second to double check my notes.

3187
02:35:03,899 --> 02:35:06,719
非常抱歉，令人失望。
Very sorry to disappoint.

3188
02:35:06,719 --> 02:35:09,449
音频输入-哦，我做到了-
The audio in-- oh, I did--

3189
02:35:09,450 --> 02:35:10,200
对不起。
sorry.

3190
02:35:10,200 --> 02:35:12,960
我第一次做的是对的，但是方法却是错误的。
I did it right the first time but the wrong way.

3191
02:35:12,959 --> 02:35:16,619
让我将我的变量改回单词。
Let me change my variable back to words.

3192
02:35:16,620 --> 02:35:17,310
好的。
OK.

3193
02:35:17,309 --> 02:35:20,009
我忘了要做的是在这里调用一行代码
What I forgot to do was call one line of code here

3194
02:35:20,010 --> 02:35:21,700
那实际上就是坐在我的面前。
that's literally sitting in front of me.

3195
02:35:21,700 --> 02:35:28,080
我需要转换识别器的返回值，identify_google音频。
I need to convert the recognizer's return value, recognize_google audio.

3196
02:35:28,079 --> 02:35:32,039
我需要存储将音频传递给Google的返回值
I need to store the return value of passing the audio to Google

3197
02:35:32,040 --> 02:35:33,900
并将结果文本存储在此处。
and storing the resulting text here.

3198
02:35:33,899 --> 02:35:37,529
因此，我在这里使用了变量word来进行重新存储。
And so I have re-stored, using the words variable here.

3199
02:35:37,530 --> 02:35:42,810
现在，让我继续并运行listen.py的python。
All right now let me go ahead and run python of listen.py.

3200
02:35:42,809 --> 02:35:45,769
你好。
Hello, there.

3201
02:35:45,770 --> 02:35:47,270
很不错。
Very nice.

3202
02:35:47,270 --> 02:35:48,185
你今天怎么样？
How are you today?

3203
02:35:51,200 --> 02:35:52,880
凉爽的。
Cool.

3204
02:35:52,879 --> 02:35:53,689
好，再见。
OK, goodbye.

3205
02:35:56,430 --> 02:35:56,970
好的。
All right.

3206
02:35:56,969 --> 02:35:59,677
因此，我们拥有了更加引人注目的人工智能。
So there we have an even more compelling artificial intelligence.

3207
02:35:59,677 --> 02:36:03,029
当然，它不是那么聪明，它只是在寻找预先设定的字符串。
Granted, it's not that intelligent, it's just looking for preordained strings.

3208
02:36:03,030 --> 02:36:05,250
但是我敢打赌，我们可以做更多的事情。
But I bet we can do something even more.

3209
02:36:05,250 --> 02:36:08,729
实际上，让我继续前进，看看我的同事是否
And in fact, let me go ahead and step inside, and see if a colleague of mine

3210
02:36:08,729 --> 02:36:10,439
忍不住实时地做某事。
can't help do something in real time.

3211
02:36:10,440 --> 02:36:13,080
在剧院里的一台大型花式PC上，我们
On a big fancy PC here in the theater, we

3212
02:36:13,079 --> 02:36:16,147
在CPU上运行其他Python程序
are running some other Python program on a CPU

3213
02:36:16,147 --> 02:36:17,939
这样的速度足以实时执行此操作。
that's fast enough to do this in real time.

3214
02:36:17,940 --> 02:36:20,730
而且我们已经将其中一台相机连接到该PC，
And we've connected one of our cameras to that PC,

3215
02:36:20,729 --> 02:36:24,209
因此，您即将看到的是我们其中一台摄像机的结果
so that what you're about to see is the result of one of our cameras being

3216
02:36:24,209 --> 02:36:28,859
连接到这台PC，将相机的输入运行到Python软件中
wired into this PC, running that camera's input into Python software

3217
02:36:28,860 --> 02:36:30,330
在该PC上运行。
running on that PC.

3218
02:36:30,329 --> 02:36:34,079
我们已经使用此Python软件对PC进行了培训，
And we have trained the PC, using this Python software,

3219
02:36:34,079 --> 02:36:37,019
识别过去的某些图像。
to recognize certain images in the past.

3220
02:36:37,020 --> 02:36:40,710
让我们看看是否也不能做到这一点。
And let's see if we can't do this as well.

3221
02:36:40,709 --> 02:36:43,919
布莱恩，您介意将我显示在屏幕1上吗？
Brian, would you mind putting me on screen 1?

3222
02:36:43,920 --> 02:36:48,120
还有荣欣，您要继续加载我们的第一位客人吗？
And Rongxin, do you want to go ahead and load up our first guest?

3223
02:36:48,120 --> 02:36:49,930
我认为我们还活着。
I think we are live.

3224
02:36:49,930 --> 02:36:55,950
再说一次，您在这里看到我的嘴与爱因斯坦步调一致。
So again, you see my mouth moving in lock step with Einstein here.

3225
02:36:55,950 --> 02:36:57,570
他的嘴唇与我的嘴唇相配。
His lips are matching mine.

3226
02:36:57,569 --> 02:36:59,129
他的头部动作在移动-
His head movements are moving--

3227
02:36:59,129 --> 02:36:59,759
匹配我的。
matching mine.

3228
02:36:59,760 --> 02:37:01,380
我们甚至可以变得好奇。
We can even be inquisitive.

3229
02:37:01,379 --> 02:37:05,769
如果我的眉毛抬起，请这样移动我的嘴。
If my eyebrows go up, move my mouth this way, this way.

3230
02:37:05,770 --> 02:37:08,610
您可以看到Python程序是实时的
And you can see that the Python program in real time

3231
02:37:08,610 --> 02:37:13,050
是将我的面部动作映射到其他人的脸上
is mapping my facial movements onto someone else's face, of course

3232
02:37:13,049 --> 02:37:15,819
否则称为深造假。
otherwise known as a deep fake.

3233
02:37:15,819 --> 02:37:17,864
容欣我们可以试试布莱恩的照片吗？
Rongxin, could we try out Brian's photo instead?

3234
02:37:24,149 --> 02:37:31,109
现在，我们这里有布赖恩（Brian），他也同样大笑。
Here now we have Brian who similarly is matching big smile.

3235
02:37:31,110 --> 02:37:32,940
在某个时候有点假。
Gets a little fake at some point.

3236
02:37:32,940 --> 02:37:36,000
但同样，如果我们将所有这些内容预先渲染而不是实时发布，
But again, if we pre-rendered all of this instead of doing it live,

3237
02:37:36,000 --> 02:37:38,549
PC可能会做得更好。
the PC could probably do an even better job.

3238
02:37:38,549 --> 02:37:42,129
怎么样，我们邀请哈佛总统拉里·巴科（Larry Bacow）加入我们，
How about could, we invite Harvard president Larry Bacow to join us,

3239
02:37:42,129 --> 02:37:42,629
容馨吗
Rongxin?

3240
02:37:47,469 --> 02:37:51,249
这是哈佛大学的CS50简介
This is CS50, Harvard University's introduction

3241
02:37:51,250 --> 02:37:53,950
致计算机科学知识型企业
to the intellectual enterprises of computer science

3242
02:37:53,950 --> 02:37:56,790
和编程艺术。
and the art of programming.

3243
02:37:56,790 --> 02:38:00,140
来自耶鲁大学荣信的彼得·萨洛维（Peter Salovey）总统怎么样？
How about President Peter Salovey from Yale, Rongxin?

3244
02:38:04,659 --> 02:38:08,439
这是耶鲁大学的CS50简介
This is CS50, Yale University's introduction

3245
02:38:08,440 --> 02:38:10,960
致计算机科学知识型企业
to the intellectual enterprises of computer science

3246
02:38:10,959 --> 02:38:12,939
和编程艺术。
and the art of programming.

3247
02:38:12,940 --> 02:38:15,850
现在，这一点的现实意义
Now at this point, the real-world implications of this

3248
02:38:15,850 --> 02:38:17,420
应该越来越清楚了。
should be getting increasingly clear.

3249
02:38:17,420 --> 02:38:20,650
虽然在Instagram，TikTok等平台上实现此功能很有趣，但还是有游戏，
While it's all fun and games to do this on Instagram, in TikTok and the like,

3250
02:38:20,649 --> 02:38:22,906
如今使用各种移动应用程序，
using various mobile applications these days,

3251
02:38:22,906 --> 02:38:24,739
本质上是在做同样的事情-
which are essentially doing the same thing--

3252
02:38:24,739 --> 02:38:26,289
而且您可以看到图像并不太跟上
and you can see the image doesn't quite keep up

3253
02:38:26,290 --> 02:38:28,810
如果我现在开始移动得太快，请与我同在-
with me if I start moving a little too quickly right now--

3254
02:38:28,809 --> 02:38:32,986
这在政治，政府，
this is very real-world implications in the world of politics, government,

3255
02:38:32,986 --> 02:38:35,319
商业，实际上更一般地说只是现实世界，
business, and really just the real world more generally,

3256
02:38:35,319 --> 02:38:39,279
因为我本质上是在用别人的口说我自己的话。
because I'm essentially putting in someone else's mouth my own words.

3257
02:38:39,280 --> 02:38:42,790
虽然很明显，到目前为止，这些例子还不是真的
And while it's clear that these examples thus far aren't really that

3258
02:38:42,790 --> 02:38:44,560
令人信服-如果我开始移动太多，
compelling-- if I start to move too much,

3259
02:38:44,559 --> 02:38:46,509
您会发现事情开始不同步了-
you see that things start to get out of sync--

3260
02:38:46,510 --> 02:38:48,842
试想一下，如果我们等待一年，我们的计算机
just imagine that if we wait one year, our computers

3261
02:38:48,842 --> 02:38:51,550
如果有更多的内存等，速度将是以前的两倍。
are going to be twice as fast with even more memory and the like.

3262
02:38:51,549 --> 02:38:53,589
软件只会变得越来越好，功能越来越强大，
Software is only getting better and more powerful,

3263
02:38:53,590 --> 02:38:56,170
图书馆和人工智能正在接受更多培训。
the libraries and the artificial intelligence is getting more trained.

3264
02:38:56,170 --> 02:38:58,545
在接下来的几周的主题中，
And so among the themes for the coming weeks of the class

3265
02:38:58,545 --> 02:39:01,270
不只是如何用技术做一些事情
is not just how to do some things with technology

3266
02:39:01,270 --> 02:39:04,300
以及如何编写代码，但坦率地说，要求更大，更多
and how to write code, but frankly asking the much bigger, more

3267
02:39:04,299 --> 02:39:07,989
您是否应该使用技术做某些事情的重要图片问题，
important picture question of should you do certain things with technology,

3268
02:39:07,989 --> 02:39:10,689
并且您是否应该实际编写这样的代码。
and should you actually write such code.

3269
02:39:10,690 --> 02:39:14,320
我们确实征求了萨洛维总统和巴科总统的允许
We did ask President Salovey and President Bacow for their permission

3270
02:39:14,319 --> 02:39:16,439
事先以这种方式欺骗他们。
in advance to spoof them in this way.

3271
02:39:16,440 --> 02:39:18,190
但是我们认为我们会更有趣地结束
But we thought we would more playfully end

3272
02:39:18,190 --> 02:39:20,950
也许还有其他一些例子
with just a couple of other examples that you perhaps

3273
02:39:20,950 --> 02:39:23,980
在Instagram，TikTok等网站上查看。
see on Instagram, TikTok, and the like.

3274
02:39:23,979 --> 02:39:26,289
容欣我们可以邀请帕姆先加入我们吗？
Rongxin, could we invite Pam to join us first?

3275
02:39:30,440 --> 02:39:32,450
那某个吉姆呢？
And how about a certain Jim?

3276
02:39:40,069 --> 02:39:40,669
好的。
All right.

3277
02:39:40,670 --> 02:39:43,190
就是今天的CS50和Python。
That's it for CS50 and Python today.

3278
02:39:43,190 --> 02:39:44,960
下次见。
We'll see you next time.

3279
02:39:44,959 --> 02:39:49,809
[音乐播放]
[MUSIC PLAYING]

