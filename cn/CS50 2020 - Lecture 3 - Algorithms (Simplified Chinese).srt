1
00:00:00,000 --> 00:00:04,959
[音乐响起--字幕精校中--By Persisan]
[MUSIC PLAYING]

2
00:00:49,182 --> 00:00:50,140
戴维·马兰：好的。
DAVID MALAN: All right.

3
00:00:50,140 --> 00:00:53,260
这是CS50，这是第3周。
This is CS50, and this is week 3.

4
00:00:53,259 --> 00:00:56,559
您会记得上周，我们为您提供了更多工具
And you'll recall that last week, we equipped you with a lot more tools

5
00:00:56,560 --> 00:00:59,830
解决问题的方法-不仅是我们提出的问题，
by which to solve problems-- not only problems that we had proposed,

6
00:00:59,829 --> 00:01:02,109
但是您自己的代码中存在问题，那就是错误。
but problems in your own code, that is to say bugs.

7
00:01:02,109 --> 00:01:05,979
回想一下，这些工具涉及诸如help50之类的命令行工具。
And recall that those tools involve command line tools like help50

8
00:01:05,980 --> 00:01:09,580
获得有关编译器可能发出的隐式错误消息的帮助；
for help with cryptic error messages that the compiler might spit out;

9
00:01:09,579 --> 00:01:11,499
style50，可以给您一些反馈
style50 which, gives you a bit of feedback

10
00:01:11,500 --> 00:01:14,229
关于代码的风格，其美观性；
on the stylization of your code, the aesthetics thereof;

11
00:01:14,230 --> 00:01:18,550
check50，它根据规范检查代码的正确性
check50, which checks the correctness of your code against the specifications

12
00:01:18,549 --> 00:01:21,399
在给定的问题或实验室中； printf，其中
in a given problem set or lab; printf, which

13
00:01:21,400 --> 00:01:24,640
是几乎在任何编程中都以某种形式存在的函数
is a function that it exists in some form in almost any programming

14
00:01:24,640 --> 00:01:27,185
您可能最终会学习的语言
language that you might ultimately learn, and this

15
00:01:27,185 --> 00:01:30,310
只是从计算机的计算机上打印出您想要的任何内容的一种方式
is simply a way of printing out anything you might want from the computer's

16
00:01:30,310 --> 00:01:31,345
内存到屏幕上。
memory onto the screen.

17
00:01:31,344 --> 00:01:33,219
那么也许是这些工具中最强大的
Then perhaps the most powerful of these tools

18
00:01:33,219 --> 00:01:36,189
是debug50，这是此交互式调试器。
was debug50, which was this interactive debugger.

19
00:01:36,189 --> 00:01:40,059
即使此命令debug50特定于CS50，
And even though this command debug50 is a little specific to CS50,

20
00:01:40,060 --> 00:01:42,970
它触发了什么，那个小小的侧窗
what it triggers to happen, that little side window

21
00:01:42,969 --> 00:01:46,149
在这里您可以看到您所使用的功能栈
where you can see the stack of functions that you

22
00:01:46,150 --> 00:01:48,550
可能在某个断点时打电话了，
might have called during some break point,

23
00:01:48,549 --> 00:01:51,941
并且您可以看到您可能在某个时候定义的局部变量
and you can see the local variables that you might have defined at some point

24
00:01:51,941 --> 00:01:53,649
在执行代码的过程中
during the execution of your code, that's

25
00:01:53,650 --> 00:01:58,900
这是使用大多数语言编写的任何调试器的非常常见的常规功能。
a very common conventional feature of any debugger with most any language.

26
00:01:58,900 --> 00:02:02,500
最后，回想一下，有一个ddb，duck调试器，
And then lastly, recall there was this ddb, duck debugger, which

27
00:02:02,500 --> 00:02:06,490
当然，如果您碰巧躺着橡皮鸭，那就采取这种物理形式
of course, takes this physical form, if you happen to have a rubber duck lying

28
00:02:06,489 --> 00:02:07,869
你可以和谁聊天。
around with whom you can talk.

29
00:02:07,870 --> 00:02:10,270
但我很高兴地说，如果你缺乏
But I'm so pleased to say that if you lack

30
00:02:10,270 --> 00:02:16,420
目前在家中，CS50自己的Kareem，Brenda和Sophie
that currently while at home, CS50's own Kareem and Brenda and Sophie

31
00:02:16,419 --> 00:02:19,149
添加了精彩的内容，如果您还没有注意到的话，
have wonderfully added, if you haven't noticed already,

32
00:02:19,150 --> 00:02:22,090
与CS50 IDE相同的虚拟鸭子。
that same virtual duck to CS50 IDE.

33
00:02:22,090 --> 00:02:24,400
因此，如果您单击右上角的
So if you click in the top corner, you can actually

34
00:02:24,400 --> 00:02:27,328
开始和橡皮鸭聊天。
begin to have a chat of sorts with the rubber duck.

35
00:02:27,328 --> 00:02:30,370
虽然这肯定是同一想法的更好玩的化身，
And while this is a certainly more playful incarnation of that same idea,

36
00:02:30,370 --> 00:02:32,560
我们真的不能强调足够的价值
we really can't emphasize enough the value

37
00:02:32,560 --> 00:02:36,700
与某人一起在代码中遇到问题时谈论问题的技巧
of talking through problems when you're experiencing them in code with someone

38
00:02:36,699 --> 00:02:38,529
否则或其他。
else or with something else.

39
00:02:38,530 --> 00:02:42,250
这只鸭子，不是那么大的词汇量，
This particular duck, not all that large of a vocabulary,

40
00:02:42,250 --> 00:02:45,100
但这不是别人所说的，而是你所说的
but it's not so much what the other person says but what you say

41
00:02:45,099 --> 00:02:47,951
和你听到的自己的话无疑是
and what you hear yourself saying that is undoubtedly

42
00:02:47,951 --> 00:02:49,534
这个过程中最有价值的部分。
the most valuable part of the process.

43
00:02:49,534 --> 00:02:53,559
因此，我们感谢Kareem，Brenda和Sophie。
So our thanks to Kareem and Brenda and Sophie on that.

44
00:02:53,560 --> 00:02:58,000
回想上个星期2，我们在引擎盖下看了一眼，
Recall last week, 2, that we took a look underneath the hood,

45
00:02:58,000 --> 00:03:02,019
从某种意义上说，实际上是笔记本电脑中的计算机内存
literally in some sense, at the computer's memory in your laptop

46
00:03:02,020 --> 00:03:03,040
或台式机或手机。
or desktop or phone.

47
00:03:03,039 --> 00:03:06,159
然后我们决定再考虑一下
And then we decided to think about this more

48
00:03:06,159 --> 00:03:09,099
在艺术上只是一个字节的网格。
artistically as just a grid of bytes.

49
00:03:09,099 --> 00:03:11,469
因此，在该芯片中，有一堆比特。
So within that chip, there's a whole bunch of bits.

50
00:03:11,469 --> 00:03:14,619
而且，如果一次查看八个，那么会有一大堆字节。
And if you look at eight of them at a time, there's a whole bunch of bytes.

51
00:03:14,620 --> 00:03:16,150
我们可以认为这是有理由的
And it stands to reason that we could think

52
00:03:16,150 --> 00:03:18,790
作为第一个字节，第二个字节，第三个字节，
of this as the first byte, the second byte, the third byte,

53
00:03:18,789 --> 00:03:21,359
依此类推，然后以图形方式将其切碎
and so forth, and sort of chop this up pictorially

54
00:03:21,360 --> 00:03:25,790
放入计算机内存中的整个字节序列。
into just a whole sequence of bytes in the computer's memory.

55
00:03:25,789 --> 00:03:30,159
回想一下，如果我们放大并仅关注一个连续的块
And recall that if we zoom in on that and focus on just one continuous block

56
00:03:30,159 --> 00:03:33,499
内存，也称为“数组”
of memory, otherwise known as an "array,"

57
00:03:33,500 --> 00:03:37,639
我们可以在此数组中执行操作，例如存储一堆不同的值。
we can do things within this array like storing a bunch of different values.

58
00:03:37,639 --> 00:03:41,109
所以回想一下上周，我们首先定义了一些
So recall last week, we started by defining a little--

59
00:03:41,110 --> 00:03:44,710
愚蠢地，多个几乎完全相同名称的变量，
goofily, multiple variables that were almost identically names,

60
00:03:44,710 --> 00:03:47,470
像scores1，score2，score3。
like scores1, scores2, scores3.

61
00:03:47,469 --> 00:03:51,189
然后，我们开始通过引入数组来清理代码设计，
And then we began to clean up the design of our code by introducing an array,

62
00:03:51,189 --> 00:03:55,539
所以我们只能有一个称为scores的变量，其大小为3
so we can have just one variable called scores, that is of size 3

63
00:03:55,539 --> 00:03:57,859
并且有多个值的余地。
and has room for multiple values.

64
00:03:57,860 --> 00:04:02,320
因此，今天，我们将继续利用许多编程的功能
So today, we'll continue to leverage this feature of many programming

65
00:04:02,319 --> 00:04:04,569
语言-能够连续存储事物，
languages-- being able to store things continuously,

66
00:04:04,569 --> 00:04:06,999
背对背背对背，在计算机的内存中，
back to back to back to back, in a computer's memory,

67
00:04:07,000 --> 00:04:11,049
因为这种非常简单的布局，这种语言的非常简单的功能，
because this very simple layout, this very simple feature of the language,

68
00:04:11,050 --> 00:04:13,270
将开放各种强大的功能。
is going to open up all sorts of powerful features.

69
00:04:13,270 --> 00:04:17,410
实际上，我们甚至可以回顾一些问题
And in fact, we can even revisit some of the problems

70
00:04:17,410 --> 00:04:19,990
我们试图在第0周解决问题。
we tried to solve way back in week 0.

71
00:04:19,990 --> 00:04:21,700
但是数组有一个陷阱。
But there is a catch with arrays.

72
00:04:21,699 --> 00:04:25,404
上周我们并没有真正强调这一点。
And we didn't really emphasize this much last week.

73
00:04:25,404 --> 00:04:27,279
那是因为，即使你我能
And that's because, even though you and I can

74
00:04:27,279 --> 00:04:30,362
瞥了一眼屏幕上的这张图片，马上看到，哦，
glance at this picture on the screen and see immediately that, oh, there's

75
00:04:30,362 --> 00:04:33,639
屏幕上有七个框，您可以在其中七个位置
seven boxes on the screen, there are seven locations in which you

76
00:04:33,639 --> 00:04:37,869
可以存储值，您和我可以对所有事物都具有这种鸟瞰图
can store values, you and I can sort of have this bird's eye view of everything

77
00:04:37,870 --> 00:04:41,380
并立即查看整个阵列中的内容。
and just see what's inside that entire array all at once.

78
00:04:41,379 --> 00:04:45,369
但是，回忆起来，计算机更具方法性，算法性，
But computers, recall, are much more methodical, more algorithmic,

79
00:04:45,370 --> 00:04:46,250
如果可以的话。
if you will.

80
00:04:46,250 --> 00:04:48,790
因此，一台功能强大的计算机，
And so a computer, as powerful as they are,

81
00:04:48,790 --> 00:04:51,945
从技术上讲，一次只能查看一个阵列中的一个位置。
can technically only look at one location in an array at a time.

82
00:04:51,944 --> 00:04:54,069
因此，尽管您和我可以一目了然
So whereas you and I can glance at this and sort of

83
00:04:54,069 --> 00:04:57,369
一口气把它全部收起来一台电脑根本无法看一眼它的内存
take it all in at once a computer just can't glance at its memory

84
00:04:57,370 --> 00:05:00,040
并一次吸收其中的所有值，
and take in all at once all of the values therein,

85
00:05:00,040 --> 00:05:04,270
它必须更加有条理地这样做，例如，从左到右，也许
it has to do so more methodically, for instance, from left to right, maybe

86
00:05:04,269 --> 00:05:06,949
从右到左，也许在中间向前。
right to left, maybe middle onward.

87
00:05:06,949 --> 00:05:08,989
但这必须是一种算法。
But it has to be an algorithm.

88
00:05:08,990 --> 00:05:12,850
因此，今天我们将这一概念形式化，并确实掩盖了以下事实：
And so today we'll formalize that notion and really kind of hide the fact that

89
00:05:12,850 --> 00:05:16,840
无法一次看到所有数组，只能查看一个位置
this array cannot be seen all at once, you can only look at one location

90
00:05:16,839 --> 00:05:19,089
在给定时间的数组中。
in an array at a given time.

91
00:05:19,089 --> 00:05:21,159
这将具有非常实际的意义。
And this is going to have very real implications.

92
00:05:21,160 --> 00:05:23,820
例如，如果我们考虑第一个问题
For instance, if we consider that very first problem

93
00:05:23,819 --> 00:05:27,429
在我们尝试在电话簿中查找我的电话号码的第一周，
in the very first week where we tried to find my phone number in a phone book,

94
00:05:27,430 --> 00:05:30,640
最幼稚的方法是从头开始，从左开始搜索
the very naive approach was to start at the beginning and search from left

95
00:05:30,639 --> 00:05:31,179
在右边。
to right.

96
00:05:31,180 --> 00:05:33,055
此后，我们尝试了几种变体。
And we tried a couple of variants thereafter.

97
00:05:33,055 --> 00:05:35,590
但是，问题很简单，就是搜索问题。
But the problem, quite simply, is that of searching.

98
00:05:35,589 --> 00:05:37,689
这是计算机科学中的艺术术语，
And this is a term of art in computer science,

99
00:05:37,689 --> 00:05:40,539
超级普通，当然对您和我（作为Google用户）
super common, certainly for you and I as users on Google

100
00:05:40,540 --> 00:05:42,830
并喜欢整天搜索事物。
and the like to search for things all day long.

101
00:05:42,829 --> 00:05:46,689
因此，当然可以很好地进行搜索，并精心设计搜索算法，
And so certainly searching well, designing a search algorithm well,

102
00:05:46,689 --> 00:05:49,709
无疑是当今许多工具的引人注目的功能
is certainly a compelling feature of so many of today's tools

103
00:05:49,709 --> 00:05:50,722
你和我用的
that you and I use.

104
00:05:50,723 --> 00:05:52,890
因此，如果我们真的认为这是要解决的问题，
So if we think of this really as a problem to solve,

105
00:05:52,889 --> 00:05:56,429
我们得到了一些输入，例如，可能是数字数组，
we've got some input, which, for instance, might be an array of numbers,

106
00:05:56,430 --> 00:05:59,640
或是Google的一系列网页。
or maybe an array of web pages in the case of Google.

107
00:05:59,639 --> 00:06:01,269
目标是获得一些输出。
And the goal is to get some output.

108
00:06:01,269 --> 00:06:05,339
因此，如果问题的输入是一个值数组，则输出，
So if the input to the problem is an array of values, the output,

109
00:06:05,339 --> 00:06:09,629
希望它会像布尔值一样简单，真的-
hopefully, is going to be something as simple, really, as a bool--

110
00:06:09,629 --> 00:06:10,649
是还是不是。
yes or no.

111
00:06:10,649 --> 00:06:15,179
您寻找的价值是否可以发现？
Is the value you're looking for discoverable?

112
00:06:15,180 --> 00:06:20,130
您是否可以搜索并找到该值，是或否，是或否？
Can you search for and find that value, yes or no, true or false?

113
00:06:20,129 --> 00:06:23,189
现在，回想一下，在这个黑匣子中，将成为某种算法。
Now, within this black box, recall, is going to be some algorithm.

114
00:06:23,189 --> 00:06:25,529
这就是今天我们将花费大部分时间的地方。
And that's where today we'll spend most of our time.

115
00:06:25,529 --> 00:06:28,679
确实，我们不会真正介绍C的更多功能。
Indeed, we won't really introduce that many more features of C.

116
00:06:28,680 --> 00:06:30,480
我们不会介绍更多代码。
We won't introduce that much more code.

117
00:06:30,480 --> 00:06:33,930
我们将再次专注于想法，现在您已经认为是理所当然的了
We'll focus again on ideas, just taking for granted now that you

118
00:06:33,930 --> 00:06:35,670
您的工具箱中还有其他工具。
have some more tools in your toolkit.

119
00:06:35,670 --> 00:06:38,100
除了循环和条件以及布尔表达式之外，
Beyond loops and conditions and Boolean expressions,

120
00:06:38,100 --> 00:06:40,830
现在，我们有了另一种称为数组的工具。
we now have this other tool known as arrays.

121
00:06:40,829 --> 00:06:45,059
但是，让我们先介绍一些其他艺术术语，如果可以的话，用一些术语，
But let's first introduce some other terms of art, some jargon if you will,

122
00:06:45,060 --> 00:06:46,990
与我们称为运行时间有关。
related to what we'll call running time.

123
00:06:46,990 --> 00:06:48,780
因此，我们已经提到了几次。
So we've alluded to this a few times.

124
00:06:48,779 --> 00:06:51,509
当我们在考虑算法的优劣时，
When we're thinking about just how good or bad an algorithm is,

125
00:06:51,509 --> 00:06:53,489
我们描述了运行需要多长时间。
we describe how long it takes to run.

126
00:06:53,490 --> 00:06:54,540
那就是它的运行时间。
That is its running time.

127
00:06:54,540 --> 00:06:57,330
算法的运行时间是需要多长时间-
The running time of an algorithm is how long it takes--

128
00:06:57,329 --> 00:07:00,819
需要多少步骤，需要多少秒，需要多少次迭代
how many steps it takes, how many seconds it takes, how many iterations

129
00:07:00,819 --> 00:07:01,319
它需要。
it takes.

130
00:07:01,319 --> 00:07:04,139
您的度量单位是什么并不重要。
It doesn't really matter what your unit of measure is.

131
00:07:04,139 --> 00:07:07,349
也许是时候了，也许是迭代或其他。
Maybe it's time, maybe it's iterations or something else.

132
00:07:07,350 --> 00:07:10,422
但是运行时间只是指算法要花费多长时间。
But running time just refers to how long does an algorithm take.

133
00:07:10,422 --> 00:07:13,380
我们可以通过一些方式来对此进行更正式的思考。
And there are ways that we can think about this a little more formally.

134
00:07:13,379 --> 00:07:16,019
我们在第一周就已经做到了这一点，
And we kind of did this already in the first week,

135
00:07:16,019 --> 00:07:19,319
但是我们没有给它起这个名字，这个斜体字O，
but we didn't give it this name, this italicized O,

136
00:07:19,319 --> 00:07:23,219
屏幕上的大写O，也称为Big O表示法。
this capital O on the screen, is otherwise known as Big O notation.

137
00:07:23,220 --> 00:07:25,470
还有计算机科学家和一些数学家
And computer scientists and some mathematicians

138
00:07:25,470 --> 00:07:28,410
从字面上看，它将经常使用该符号
will very frequently use, literally, this symbol

139
00:07:28,410 --> 00:07:31,410
描述算法的运行时间，
to describe the running times of algorithms,

140
00:07:31,410 --> 00:07:33,310
或在数学上像一个函数。
or mathematically like a function.

141
00:07:33,310 --> 00:07:34,720
因此，事实上，请记住这张照片。
So recall this picture, in fact.

142
00:07:34,720 --> 00:07:38,190
当我们搜索电话簿时，我们做到了很好，更好，最好。
When we were searching that phone book, we did it sort of good, better, best.

143
00:07:38,189 --> 00:07:41,799
我们是线性进行的-即一次搜索一页，
We did it linearly-- that is, searching one page at a time,

144
00:07:41,800 --> 00:07:44,940
我们一次完成两页的速度是它的两倍-
we did it twice as fast by doing two pages at a time--

145
00:07:44,939 --> 00:07:48,689
然后我们通过对数划分和征服来对数地做到这一点，
and then we did it logarithmically by dividing and conquering,

146
00:07:48,689 --> 00:07:50,059
在一半和一半。
in half and half and half.

147
00:07:50,060 --> 00:07:52,560
当时，我提议如果我们想到电话簿
And at the time, I proposed that if we think of a phone book

148
00:07:52,560 --> 00:07:57,630
如n页，其中n只是计算机科学中的一个数字，
as having n pages, where n is just a number in computer science vernacular,

149
00:07:57,629 --> 00:08:00,299
我们可能会描述运行时间或步骤数
we might describe the running time, or the number of steps

150
00:08:00,300 --> 00:08:04,350
涉及到第一个算法，因为在最坏的情况下可能需要n步。
involved for that first algorithm, as being maybe in the worst case n steps.

151
00:08:04,350 --> 00:08:06,780
如果您正在电话簿中寻找的人
If the person you're looking for in a phone book maybe

152
00:08:06,779 --> 00:08:10,296
英文字母的姓氏以Z开头，
alphabetically has the last name starting with Z in English,

153
00:08:10,297 --> 00:08:12,880
好吧，Z可能一直在电话簿的末尾。
well, the Z might be all the way at the end of the phone book.

154
00:08:12,879 --> 00:08:15,449
因此，在最坏的情况下，您可能会采取n步
So at the worst case, you might be taking n steps

155
00:08:15,449 --> 00:08:18,089
在电话簿中找到像我这样的人。
to find someone like myself in that phone book.

156
00:08:18,089 --> 00:08:20,399
不过，第二种算法的速度是后者的两倍，
The second algorithm, though, was twice as fast,

157
00:08:20,399 --> 00:08:22,509
因为我们一次走了两页。
because we went two pages at a time.

158
00:08:22,509 --> 00:08:24,984
因此，我们可以将其运行时间描述为n除以2。
So we might describe its running time as n divided by 2.

159
00:08:24,985 --> 00:08:28,110
然后是第三种算法，我们将问题分成两半
And then the third algorithm, where we divided the problem in half and half

160
00:08:28,110 --> 00:08:31,680
一半，一次又一次地抛弃了一半的问题，
and half, literally throwing half of the problem away again and again,

161
00:08:31,680 --> 00:08:35,760
是对数的-从技术上讲，以n为底的对数2
was logarithmic-- technically log base 2 of n, which, again, is just

162
00:08:35,759 --> 00:08:39,389
一个数学公式，指的是再减半
a mathematical formula that refers to halving something again

163
00:08:39,389 --> 00:08:40,288
一遍又一遍。
and again and again.

164
00:08:40,288 --> 00:08:43,689
在这种情况下，当然要从n页开始。
And you start with, of course, n pages in that scenario.

165
00:08:43,690 --> 00:08:46,560
好吧，事实证明，计算机科学家实际上会
Well, it turns out that a computer scientist would actually

166
00:08:46,559 --> 00:08:49,026
在其中一些数学细节上挥手致意。
wave their hands at some of these mathematical details.

167
00:08:49,027 --> 00:08:51,360
确实，我们不会养成写作的习惯
Indeed, we're not going to get into the habit of writing

168
00:08:51,360 --> 00:08:53,517
非常精确的数学公式。
very precise mathematical formulas.

169
00:08:53,517 --> 00:08:55,350
相反，我们要做的就是尝试获得
What we're instead going to do is try to get

170
00:08:55,350 --> 00:08:59,850
一种算法运行时间的顺序感
a sense of the order on which the running time of an algorithm

171
00:08:59,850 --> 00:09:03,870
大概是快或慢，但仍然
is, just roughly how fast or how slow it is, but still

172
00:09:03,870 --> 00:09:06,210
使用像n这样的符号作为占位符。
using some symbology like n as a placeholder.

173
00:09:06,210 --> 00:09:09,480
因此，计算机科学家会描述这三个系统的运行时间
And so a computer scientist would describe the running time of all three

174
00:09:09,480 --> 00:09:14,820
从第0周起的那些算法是n的大O或n / 2的大O，
of those algorithms from week 0 as being big O of n, or big O of n/2,

175
00:09:14,820 --> 00:09:17,040
或n的以2为底的对数O。
or big O of log base 2 of n.

176
00:09:17,039 --> 00:09:18,899
因此，“大O”仅表示“按顺序”。
So "big O" just means "on the order of."

177
00:09:18,899 --> 00:09:20,519
有点像挥手。
It's sort of a wave of the hand.

178
00:09:20,519 --> 00:09:24,899
也许是n减1，也许是n加1，也许甚至是2n。
Maybe it's n minus 1, maybe it's n plus 1, maybe it's even 2n.

179
00:09:24,899 --> 00:09:28,239
但这是n或其他值的数量级。
But it's on the order of n or these other values.

180
00:09:28,240 --> 00:09:30,468
但实际上，也要注意此图表
But in fact, too, notice that this chart,

181
00:09:30,467 --> 00:09:33,509
有点好奇，就像前两种算法一样
there's something kind of curious. , Like these first two algorithms from

182
00:09:33,509 --> 00:09:36,869
第0周的图片看起来几乎一样。
week 0 kind of pictorially look pretty much the same.

183
00:09:36,870 --> 00:09:39,137
毫无疑问，黄线稍低
Like undoubtedly, the yellow line is a little lower

184
00:09:39,136 --> 00:09:41,969
因此比红线好一点，快一点。
and therefore a little better and a little faster than the red line.

185
00:09:41,970 --> 00:09:43,200
但是它们具有相同的形状。
But they have the same shape.

186
00:09:43,200 --> 00:09:47,370
实际上，我敢打赌，如果我们将这两条直线缩小，
And in fact, I bet if we zoomed way out, these two straight lines

187
00:09:47,370 --> 00:09:49,380
看起来几乎一样。
would pretty much look identical.

188
00:09:49,379 --> 00:09:53,411
如果您将轴更改为既足够大又足够高，
If you change your axis to be big enough and tall enough,

189
00:09:53,412 --> 00:09:54,870
这些将开始一起模糊。
these would start to blur together.

190
00:09:54,870 --> 00:09:57,880
但显然，绿线是根本不同的。
But clearly, the green line is fundamentally different.

191
00:09:57,879 --> 00:10:01,019
因此，这说明了计算机科学家的趋势
And so this speaks to a computer scientist's tendency

192
00:10:01,019 --> 00:10:03,869
不会真正质疑这些细节。
to not really quibble over these details.

193
00:10:03,870 --> 00:10:06,977
就像是的，第0周的第二种算法更好。
Like, yes, the second algorithm in week 0 was better.

194
00:10:06,976 --> 00:10:08,309
是的，这条黄线更好。
Yes, this yellow line is better.

195
00:10:08,309 --> 00:10:12,539
但是，让我们仅将这两种算法的运行时间称为
But, eh, let's just call both of those algorithms running times

196
00:10:12,539 --> 00:10:13,799
在n的数量级上
on the order of n.

197
00:10:13,799 --> 00:10:18,389
就是说，计算机科学家倾向于抛弃不变的因素，
That is to say, a computer scientist tends to throw away constant factors,

198
00:10:18,389 --> 00:10:20,839
例如1/2或2分频。
like the 1/2 or the divided by 2.

199
00:10:20,840 --> 00:10:23,250
他们倾向于只关注主导因素，
And they tend to focus only on the dominant factor,

200
00:10:23,250 --> 00:10:27,809
就像那个数学表达式中哪个值增长最快，
like which value in that mathematical expression is going to grow the most,

201
00:10:27,809 --> 00:10:28,889
增长最快。
grow the fastest.

202
00:10:28,889 --> 00:10:32,279
n除以2n会逐渐占主导地位。
And n divided by 2n it's going to dominate over time.

203
00:10:32,279 --> 00:10:34,829
电话簿越大，您拥有的页面就越多。
The bigger the phone book gets, the more pages you have.

204
00:10:34,830 --> 00:10:38,238
实际上，n的重要性要小于2的总和。
It's really n that's going to matter less so than that divided by 2.

205
00:10:38,238 --> 00:10:39,280
还有同样的事情。
And same thing over here.

206
00:10:39,279 --> 00:10:41,699
如果您熟悉并记住对数，
If you're familiar with and remember your logarithms,

207
00:10:41,700 --> 00:10:45,120
我们甚至根本不必关心该对数的底数。
we don't really have to even care about the base of that logarithm.

208
00:10:45,120 --> 00:10:48,940
是的，以2为底，但是，我们可以乘以该对数
Yes, it's base 2, but eh, we can just multiply that logarithm

209
00:10:48,940 --> 00:10:51,490
用其他一些数字将其转换为我们想要的任何基数-
by some other number to convert it to any base we want--

210
00:10:51,490 --> 00:10:54,040
以10为底，以3为底，以7为底的任何东西。
base 10, base 3, base 7, anything.

211
00:10:54,039 --> 00:10:55,959
因此，我们只说它在log n的顺序上。
So let's just say it's on the order of log n.

212
00:10:55,960 --> 00:10:57,760
所以这很好，因为这意味着我们不是真的
So this is good, because it means we're not really

213
00:10:57,759 --> 00:10:59,814
会浪费时间真正进入杂草
going to waste time getting really into the weeds

214
00:10:59,815 --> 00:11:02,440
数学上，当我们谈论算法的效率时。
mathematically when we talk about the efficiency of algorithms.

215
00:11:02,440 --> 00:11:07,580
只需用变量n来描述事物就足够了，在这种情况下，
It suffices to describe things really in terms of the variable, n in this case,

216
00:11:07,580 --> 00:11:09,370
如果愿意的话，随着时间的流逝，它会占主导地位。
if you will, that dominates over time.

217
00:11:09,370 --> 00:11:10,510
确实，让我们缩小。
And indeed, let's zoom out.

218
00:11:10,509 --> 00:11:12,909
如果我放大这张照片，请开始
If I zoom out on this picture, boom, you begin

219
00:11:12,909 --> 00:11:16,404
是的，这些真的开始看起来几乎完全相同。
to see that, yeah, these are really starting to look almost identical.

220
00:11:16,404 --> 00:11:20,139
如果我们继续缩小，您会发现它们本质上是
And if we kept zooming out, you would see that they're essentially

221
00:11:20,139 --> 00:11:21,039
一个在同一。
one in the same.

222
00:11:21,039 --> 00:11:25,419
但是绿色的一个引人注目，所以确实在n的对数的顺序上
But the green one stands out, so that's indeed on the order of log of n

223
00:11:25,419 --> 00:11:26,767
与n本身相反。
as opposed to n itself.

224
00:11:26,768 --> 00:11:28,060
所以这是一个小备忘单。
So here's a little cheat sheet.

225
00:11:28,059 --> 00:11:30,279
事实证明，在计算机科学中，
It turns out that within computer science,

226
00:11:30,279 --> 00:11:33,249
在分析算法的过程中，我们
and within the analysis of algorithms, we're

227
00:11:33,250 --> 00:11:36,410
会倾向于看到一些像这样的通用公式。
going to tend to see some common formulas like this.

228
00:11:36,409 --> 00:11:38,289
因此，我们刚刚看到了n的数量级。
So we've just seen on the order of n.

229
00:11:38,289 --> 00:11:39,879
我们已经看到了log n的顺序。
We've seen on the order of log n.

230
00:11:39,879 --> 00:11:42,849
原来，最常见的两次将是n次
It turns out that the very common two is going to be n times

231
00:11:42,850 --> 00:11:46,677
对数n，甚至n平方，然后甚至为1的大O。
log n, maybe even n squared, and then even big O of 1.

232
00:11:46,677 --> 00:11:48,760
最后的那些只是意味着一个算法
And the last of those just means that an algorithm

233
00:11:48,759 --> 00:11:50,799
迈出了精彩的一步-
takes, wonderfully, one step--

234
00:11:50,799 --> 00:11:55,419
或也许两步，甚至十步，但步数不变。
or maybe two steps, maybe even 10 steps, but a constant number of steps.

235
00:11:55,419 --> 00:11:58,779
因此，至少在这些选项中，这是最好的情况。
So that's sort of the best case scenario, at least among these options.

236
00:11:58,779 --> 00:12:01,819
而n平方将开始花费很长时间。
Whereas, n squared is going to start to take a long time.

237
00:12:01,820 --> 00:12:03,820
它会开始变得缓慢，因为如果您
It's going to start to feel slow, because if you

238
00:12:03,820 --> 00:12:06,070
取n的任何值并将其平方，即
take any value of n and square it, that's

239
00:12:06,070 --> 00:12:08,510
将意味着越来越多的步骤。
going to imply more and more steps.

240
00:12:08,509 --> 00:12:10,997
所以，从今天开始，只是一点行话，
So just a bit of jargon, then, to start off today,

241
00:12:10,998 --> 00:12:12,790
现在我们有了这种词汇
whereby we now have this sort of vocabulary

242
00:12:12,789 --> 00:12:16,749
用这个大O来描述算法的运行时间
with which to describe the running times of an algorithm in terms of this Big O

243
00:12:16,750 --> 00:12:17,560
符号。
notation.

244
00:12:17,559 --> 00:12:19,239
但是还有另一种表示法。
But there's one other notation.

245
00:12:19,240 --> 00:12:22,960
就像大O代表上限一样
And just as big O refers to an upper bound

246
00:12:22,960 --> 00:12:25,930
在运行时间方面，例如最大步数
on running times, like how many steps maximally,

247
00:12:25,929 --> 00:12:27,969
一个算法最多可能花费多少时间，
how much time maximally might an algorithm take,

248
00:12:27,970 --> 00:12:31,730
这种欧米茄表示法则相反。
this omega notation refers to the opposite.

249
00:12:31,730 --> 00:12:34,293
算法运行时间的下限是多少？
What's a lower bound on the running time of an algorithm?

250
00:12:34,293 --> 00:12:36,460
而且我们不需要其他图片或其他公式。
And we don't need another picture or other formulas.

251
00:12:36,460 --> 00:12:37,740
我们可以重用相同的一个。
We can reuse the same one.

252
00:12:37,740 --> 00:12:40,150
所以这里的备忘单只是建议
So this cheat sheet here just proposes that,

253
00:12:40,149 --> 00:12:43,849
描述算法的效率或低效率时
when describing the efficiency or inefficiency of an algorithm

254
00:12:43,850 --> 00:12:45,850
而您想提出一个下限-
and you want to come up with a lower bound--

255
00:12:45,850 --> 00:12:48,630
就像最低限度一样，我的算法需要执行多少步骤-
like minimally, how many steps does my algorithm take--

256
00:12:48,629 --> 00:12:50,379
我们可以使用相同的数学公式
we can use the same mathematical formulas,

257
00:12:50,379 --> 00:12:54,339
但我们可以注意到，使用omega而不是bigO。
but we can note that with omega instead of big O.

258
00:12:54,340 --> 00:12:56,620
再说一次，看起来很花哨，但这实际上只是指
So again, looks fancy, but it really just refers

259
00:12:56,620 --> 00:13:01,090
挥动一下手，试图精确地计算出运行时间
to a wave of the hand trying to sort of ballpark exactly what the running time

260
00:13:01,090 --> 00:13:02,600
是一种算法。
is of an algorithm.

261
00:13:02,600 --> 00:13:05,080
幸运的是，我们已经看到了一些算法，
And thankfully, we've seen a few algorithms already,

262
00:13:05,080 --> 00:13:08,650
包括那一周的0，现在我们给它起一个更正式的名字。
including in that week 0, and now we're going to give it a more formal name.

263
00:13:08,649 --> 00:13:11,749
线性搜索就是我们对电话簿的处理
Linear search is what we did with that phone book

264
00:13:11,750 --> 00:13:15,009
首先，逐页搜索，
first off by searching it page by page by page,

265
00:13:15,009 --> 00:13:18,709
在该特定示例中查找我的电话号码。
looking for my phone number in that particular example.

266
00:13:18,710 --> 00:13:23,412
因此，今天的不同之处在于，与我们人类不同，
And so the difference today is that, unlike us humans, who

267
00:13:23,412 --> 00:13:26,620
可以往下看电话簿页面，看到一大堆名字和电话号码
can look down at a phone book page and see a whole bunch of names and numbers

268
00:13:26,620 --> 00:13:30,490
一次不像一个人，他刚才可以看板上的一个阵列
at once, unlike a human who can look at an array on the board a moment ago

269
00:13:30,490 --> 00:13:32,530
并立即看到一切，我们需要
and sort of see everything at once, we need

270
00:13:32,529 --> 00:13:34,629
今天要更加有条理，更深思熟虑
to be more methodical, more deliberate today so

271
00:13:34,629 --> 00:13:39,159
我们现在可以将第0周的想法转化为伪代码，
that we can translate week 0's ideas now, not into even pseudocode,

272
00:13:39,159 --> 00:13:40,509
但是实际的C代码。
but actual C code.

273
00:13:40,509 --> 00:13:43,809
奇妙的是，这里是美国话剧团
And so wonderfully, here at the American Repertory Theater

274
00:13:43,809 --> 00:13:46,279
就像本学期我们在哈佛大学校园里一样，
as we are on Harvard's campus this semester,

275
00:13:46,279 --> 00:13:48,609
我们一直在与整个团队合作
we've been collaborating with the whole team

276
00:13:48,610 --> 00:13:51,670
在这里，我比我更倾向于艺术
here who are much more artistically inclined than certainly I

277
00:13:51,669 --> 00:13:52,899
可能是我一个人在这里。
could be on my own here.

278
00:13:52,899 --> 00:13:55,149
我们有这七个美妙的门
And we have these seven wonderful doors that

279
00:13:55,149 --> 00:13:58,689
以前曾在这里举行的各种戏剧表演中使用
were previously used in various theatrical shows that took place here

280
00:13:58,690 --> 00:13:59,680
在这家剧院。
in this theater.

281
00:13:59,679 --> 00:14:03,129
我们甚至与剧院的道具店进行了合作，
And we've even collaborated with the theater's prop shop,

282
00:14:03,129 --> 00:14:07,029
后面的人美妙地制造了一些令人愉快的数字
who in back have wonderfully manufactured some delightful numbers

283
00:14:07,029 --> 00:14:08,299
并使它们栩栩如生。
and brought them to life.

284
00:14:08,299 --> 00:14:12,436
也就是说，在这七个门的每一个后面都有一个数字。
Which is to say that, behind each of these seven doors is a number.

285
00:14:12,437 --> 00:14:15,520
现在这将是一个机会，可以真正阐明这一点
And this is going to be an opportunity now to really hammer home the point

286
00:14:15,519 --> 00:14:18,429
当我们想在数组中搜索某个数字时，
that when we want to search for some number in an array,

287
00:14:18,429 --> 00:14:22,899
这相当于必须搜索一个号码，在这种情况下，
it's pretty equivalent to having to search for a number, in this case,

288
00:14:22,899 --> 00:14:25,209
在原本关着的门后面。
behind an otherwise closed door.

289
00:14:25,210 --> 00:14:27,190
你和我不能只看所有这些门
You and I can't just look at all of these doors

290
00:14:27,190 --> 00:14:29,020
现在找出数字在哪里。
now and figure out where a number is.

291
00:14:29,019 --> 00:14:30,429
我们必须更有条理。
We have to be more methodical.

292
00:14:30,429 --> 00:14:32,439
我们必须开始搜索这些门，也许
We have to start searching these doors, maybe

293
00:14:32,440 --> 00:14:35,688
从左到右，也许从右到左，也许从中间到外面。
from left to right, maybe from right to left, maybe from the middle on out.

294
00:14:35,687 --> 00:14:38,979
但是，我们需要提出一种算法，并最终将其转换为代码。
But we need to come up with an algorithm and ultimately translate that to code.

295
00:14:38,980 --> 00:14:43,630
例如，假设我要搜索数字0。
So for instance, suppose I were to search for the number 0.

296
00:14:43,629 --> 00:14:48,699
我们如何才能有条不紊地搜索这七个木门
How could we go about searching, methodically, these seven wooden doors

297
00:14:48,700 --> 00:14:50,200
为数字0？
for the number 0?

298
00:14:50,200 --> 00:14:54,310
让我听取观众的建议。
Let me take a suggestion from the audience.

299
00:14:54,309 --> 00:14:56,619
您会采取什么方法？
What approach might you take?

300
00:14:56,620 --> 00:15:02,540
您建议我带着这些门独自在这里采取什么第一步？
What first step would you propose I take here on my own with these doors?

301
00:15:02,539 --> 00:15:04,539
有什么建议吗？
Any recommendations?

302
00:15:04,539 --> 00:15:07,029
我如何开始发现自己的数字为0？
How do I begin to find myself the number 0?

303
00:15:07,029 --> 00:15:09,279
佛罗伦萨，你有什么建议？
Florence, what do you propose?

304
00:15:09,279 --> 00:15:13,522
听众：我建议从左边开始，因为0是一个较小的数字。
AUDIENCE: I would propose starting form the left, since 0 is a smaller number.

305
00:15:13,523 --> 00:15:14,440
大卫·马兰：好的，很好。
DAVID MALAN: OK, good.

306
00:15:14,440 --> 00:15:15,880
和我在那里呆一会儿。
And hang in there for with me for just a moment.

307
00:15:15,879 --> 00:15:18,629
让我继续前进，按照佛罗伦萨的建议从最左边开始。
Let me go ahead and started on the left edge as Florence proposes.

308
00:15:18,629 --> 00:15:21,039
继续并打开门，希望-
Go ahead and open the door, and hopefully, voila--

309
00:15:21,039 --> 00:15:21,849
不。
no.

310
00:15:21,850 --> 00:15:23,020
这是数字4。
It's a number 4.

311
00:15:23,019 --> 00:15:23,919
所以它不是0。
So it's not a 0.

312
00:15:23,919 --> 00:15:27,149
那么佛罗伦萨，你会建议我下一步做什么？
So Florence, what would you propose I do next?

313
00:15:27,149 --> 00:15:31,789
听众：我可能会从中间某处开始，
AUDIENCE: I'd probably start in the middle somewhere,

314
00:15:31,789 --> 00:15:35,532
如果，例如，如果我不知道，它正在下降1。
if, like, in case, I don't know, it's going down by 1.

315
00:15:35,533 --> 00:15:36,200
戴维·马兰：好的。
DAVID MALAN: OK.

316
00:15:36,200 --> 00:15:37,367
所以也许它正在下降。
So maybe it's going down.

317
00:15:37,366 --> 00:15:38,699
因此，让我继续尝试。
So let me go ahead and try that.

318
00:15:38,700 --> 00:15:41,690
所以您建议中点，我可以在这里过去，瞧……
So you propose middle, I could go over here, and voila--

319
00:15:41,690 --> 00:15:42,620
没有。
nope.

320
00:15:42,620 --> 00:15:44,360
那是数字2。
That's the number 2.

321
00:15:44,360 --> 00:15:47,820
我想知道，我还应该去哪里。
And I wonder, where else should I look.

322
00:15:47,820 --> 00:15:49,070
让我-我有点好奇。
Let me-- I'm a little curious.

323
00:15:49,070 --> 00:15:50,570
我有点不敢理会这些门。
I'm a little nervous that I ignored these doors.

324
00:15:50,570 --> 00:15:53,320
因此，佛罗伦萨，如果您不介意，让我们继续看看这里，并且-
So Florence, if you don't mind, let's go ahead and look here and--

325
00:15:53,320 --> 00:15:56,240
不，这就是数字6。
no, that's the number 6, it seems.

326
00:15:56,240 --> 00:15:59,690
让我们继续前进，在这里检查数字8。
Let's go ahead and check in here, the number 8.

327
00:15:59,690 --> 00:16:02,670
因此，它们有点起伏。
So they're kind of going up and down.

328
00:16:02,669 --> 00:16:05,149
那么佛罗伦萨，我怎么能完成这个号码的搜索呢？
So Florence, how might I finish searching for this number?

329
00:16:05,149 --> 00:16:08,419
您会说还有什么要做？
What remains to be done, would you say?

330
00:16:08,419 --> 00:16:10,489
听众：可能是从现在开始。
AUDIENCE: Probably start from the right now.

331
00:16:10,490 --> 00:16:11,157
戴维·马兰：好的。
DAVID MALAN: OK.

332
00:16:11,157 --> 00:16:14,420
所以我可以从现在开始，也许只是在这里。
So I could start from the right now, and maybe just go over here.

333
00:16:14,419 --> 00:16:16,549
瞧-就在那里。
And voila-- and there it is.

334
00:16:16,549 --> 00:16:17,689
因此我们找到了数字0。
So we found the number 0.

335
00:16:17,690 --> 00:16:19,820
因此，让我问佛罗伦萨，您的算法是什么？
So let me ask Florence, what was your algorithm?

336
00:16:19,820 --> 00:16:23,060
您如何成功为我们找到数字0？
How did you go about so successfully finding the number 0 for us?

337
00:16:26,129 --> 00:16:30,989
听众：我想我最初是想开始时降低1。
AUDIENCE: I guess I initially tried starting, like, by going down by 1.

338
00:16:30,990 --> 00:16:36,840
就像，如果数字不在左边，
So like, if the number was not at the left,

339
00:16:36,840 --> 00:16:40,490
然后去中间，就像中间
then going to the center, which is, like, halfway in between

340
00:16:40,490 --> 00:16:41,780
然后转到[音频不清晰]。
and then going to [INAUDIBLE].

341
00:16:41,779 --> 00:16:42,409
我不知道。
I don't know.

342
00:16:42,409 --> 00:16:45,779
戴维·马兰（DAVID MALAN）：有趣的是，这如何为您解决问题，发展到中间？
DAVID MALAN: And playfully, how did that work out for you, going to the middle?

343
00:16:45,779 --> 00:16:48,419
好还是坏，没什么不同？
Better or worse, no different?

344
00:16:48,419 --> 00:16:52,289
听众：我的意思是，我想这可能会有所帮助
AUDIENCE: I mean, I guess maybe it helped a little bit

345
00:16:52,289 --> 00:16:54,082
然后一直向右走。
to then go all the way to the right.

346
00:16:54,082 --> 00:16:54,749
戴维·马兰：好的。
DAVID MALAN: OK.

347
00:16:54,750 --> 00:16:56,370
是的，我们可能已经收集了一些信息。
Yeah, we might have gleaned some information.

348
00:16:56,370 --> 00:16:59,203
但是，让我们继续看一下所有的门。
But let's go ahead and take a look at all of the doors for a moment.

349
00:16:59,202 --> 00:17:00,719
再有4和6。
There's that 4 and the 6 again.

350
00:17:00,720 --> 00:17:02,400
这又是8点。
Here is that 8 again.

351
00:17:02,399 --> 00:17:04,919
在中间，我们又有2个。
Over in the middle we have the 2 again.

352
00:17:04,920 --> 00:17:08,490
在这里，我们第一次有7。
Over here we have a 7 for the first time.

353
00:17:08,490 --> 00:17:10,109
在这里，我们有一个5。
Over here we have a 5.

354
00:17:10,108 --> 00:17:11,995
然后，当然，我们有一个0。
And then of course, we have a 0.

355
00:17:11,996 --> 00:17:14,579
老实说，如果您把所有这些都带进了佛罗伦萨，您和我，
And if you took all of that in, honestly, Florence, you and I,

356
00:17:14,578 --> 00:17:16,078
我们真的无法做得更好。
we couldn't really have done any better.

357
00:17:16,078 --> 00:17:18,129
因为这些门-这些数字证明，
Because these door-- these numbers, it turns out,

358
00:17:18,130 --> 00:17:20,310
只是随机地排列在这些门的后面。
are just randomly arranged behind these doors.

359
00:17:20,309 --> 00:17:23,459
因此，您跳来跳去也算不错。
So it wasn't bad at all that you kind of hopped around.

360
00:17:23,460 --> 00:17:26,060
虽然缺点是如果您跳来跳去，
Although, the downside is if you hop around,

361
00:17:26,059 --> 00:17:29,641
您和我作为人类可以很容易地记住我们去过的地方。
you and I as humans can pretty easily remember where we've been before.

362
00:17:29,642 --> 00:17:32,100
但是，如果您考虑我们如何将其转换为代码，
But if you think about how we would translate that to code,

363
00:17:32,099 --> 00:17:34,499
我觉得我们开始积累一堆变量
I feel like we're starting to accumulate a bunch of variables

364
00:17:34,500 --> 00:17:36,417
也许是因为您必须对此进行跟踪。
maybe, because you have to keep track of that.

365
00:17:36,416 --> 00:17:40,139
坦率地说，也许最简单的解决方案-哎呀-
So frankly, maybe the simplest solution-- whoops--

366
00:17:40,140 --> 00:17:44,460
也许最简单的解决方案应该是我们在第0周开始的地方，
maybe the simplest solution would have been where we started in week 0,

367
00:17:44,460 --> 00:17:48,540
在这里，我们只是采取一种非常简单但简单的方法来开始
where we just take a very simple if naive approach of starting

368
00:17:48,539 --> 00:17:52,919
与我们的数组，这次的大小为7，后面是一些数字。
with our array, this time of size 7, behind which are some numbers.

369
00:17:52,920 --> 00:17:55,530
如果您对这些数字一无所知，
And if you don't know anything about those numbers,

370
00:17:55,529 --> 00:18:01,259
老实说，您可以做的最好的事情就是从第0周开始进行相同的线性搜索，
honestly the best you can do is just that same linear search from week 0,

371
00:18:01,259 --> 00:18:05,189
然后一次检查每个门后面的值
and just check, one at a time, the values behind each of these doors

372
00:18:05,190 --> 00:18:08,940
并希望最终您能找到它。
and just hope that eventually you will find it.

373
00:18:08,940 --> 00:18:12,360
因此，这已经花费了很多时间，对吗？
So this is already sort of taking a lot of time, right?

374
00:18:12,359 --> 00:18:16,089
如果像第0周一样进行这种线性搜索，
If I do this linear search approach like I did in week 0,

375
00:18:16,089 --> 00:18:18,839
我可能将不得不在所有这些门后面进行搜索。
I'm potentially going to have to search behind all of those doors.

376
00:18:18,839 --> 00:18:21,089
我将不得不在所有这些门后面进行搜索。
I'm going to have to search behind all of those doors.

377
00:18:21,089 --> 00:18:24,484
因此，让我们更正式地考虑一下我至少应该如何实现
So let's consider a little more formally exactly how I could at least implement

378
00:18:24,484 --> 00:18:25,109
该算法。
that algorithm.

379
00:18:25,109 --> 00:18:26,729
因为我可以采取佛罗伦萨
Because I could take the approach that Florence

380
00:18:26,730 --> 00:18:29,105
建议的，只是有点跳来跳去，也许使用
proposed, and just kind of jumping around and maybe using

381
00:18:29,105 --> 00:18:30,030
有点直觉。
a bit of intuition.

382
00:18:30,029 --> 00:18:31,529
但这又不是一个真正的算法。
But again, that's not really an algorithm.

383
00:18:31,529 --> 00:18:33,571
我们确实需要逐步做更多的事情。
We really need to do something more step by step.

384
00:18:33,571 --> 00:18:36,446
同时，让我们继续前进，乔，让我们闭上帷幕
And in the meantime, let's go ahead, Joe, and let's close the curtain

385
00:18:36,446 --> 00:18:39,299
看看我们是否无法马上解决另一个问题，
and see if we can't clean those up with another problem in a moment,

386
00:18:39,299 --> 00:18:43,179
现在我们考虑线性搜索及其分析。
while we consider now linear search and the analysis thereof.

387
00:18:43,180 --> 00:18:46,650
因此，对于线性搜索，我建议
So with linear search, I would propose that we

388
00:18:46,650 --> 00:18:50,160
如果可以的话，可以先用伪代码实现它。
could implement it in pseudocode first, if you will, like this.

389
00:18:50,160 --> 00:18:53,280
对于从0到n减去1的i--
For i from 0 to n minus 1--

390
00:18:53,279 --> 00:18:57,089
我们将看到我们要去的地方-如果数字在第i门的后面，
we'll see where we're going with this-- if the number is behind the i-th door,

391
00:18:57,089 --> 00:19:02,109
返回true，否则最后返回false。
return true, otherwise at the very end return false.

392
00:19:02,109 --> 00:19:05,279
所以这是一个相对简单的伪代码翻译，
So it's a relatively simple translation into pseudocode,

393
00:19:05,279 --> 00:19:08,129
就像我们前一段时间使用电话簿一样。
much like we did with the phone book some time ago.

394
00:19:08,130 --> 00:19:10,260
但是，为什么要使用这些值呢？
And why, though, these values?

395
00:19:10,259 --> 00:19:13,199
因为我现在开始更像C来表达自己，
Because I'm now starting to express myself a little more like C,

396
00:19:13,200 --> 00:19:14,770
即使它仍然是伪代码。
even though it's still pseudocode.

397
00:19:14,769 --> 00:19:16,799
因此，对于我，从0到n减去1。
So for i from 0 to n minus 1.

398
00:19:16,799 --> 00:19:19,319
因此，计算机科学家倾向于从0开始计数。
So computer scientists tend to start counting from 0.

399
00:19:19,319 --> 00:19:25,229
如果有n个门，或在这种情况下为7个门，则您要从0一直上升到6，
If there's n doors, or 7 doors in this case, you want to go from 0 on up to 6,

400
00:19:25,230 --> 00:19:27,930
或从0到n减1。
or from 0 on up to n minus 1.

401
00:19:27,930 --> 00:19:31,980
因此，这只是使用for循环进行设置的一种非常常见的方式，
So this is just a very common way of setting yourself up with a for loop,

402
00:19:31,980 --> 00:19:34,320
也许在C中，在这种情况下可能在伪代码中，
maybe in C, maybe in pseudocode in this case, that

403
00:19:34,319 --> 00:19:38,139
会逐步从算法上使您从左到右。
just gets you from left to right, algorithmically step by step.

404
00:19:38,140 --> 00:19:41,530
如果有条件，数字在第i门后面-
If a condition, number is behind the i-th door--

405
00:19:41,529 --> 00:19:43,709
我只是口语化的说法，
i-th just being a colloquial way of saying,

406
00:19:43,710 --> 00:19:45,960
第i个位置的门后面是什么-
what is behind the door at location i--

407
00:19:45,960 --> 00:19:47,160
继续并返回true。
go ahead and return true.

408
00:19:47,160 --> 00:19:50,640
我发现自己想要的号码，例如，号码0。
I have found myself the number I want, for instance, the number 0.

409
00:19:50,640 --> 00:19:54,640
然后请注意，此return false不属于else的一部分，
And then notice that this return false is not part of an else,

410
00:19:54,640 --> 00:19:58,710
因为我不想过早地中止该算法而只是中止
because I don't want to abort this algorithm prematurely and abort simply

411
00:19:58,710 --> 00:20:01,950
因为数字不在当前门后面。
because a number is not behind the current door.

412
00:20:01,950 --> 00:20:05,820
我本质上想一直等到算法结束，
I essentially want to wait all the way to the end of the algorithm,

413
00:20:05,819 --> 00:20:10,079
在我检查了所有n扇门之后，如果仍然没有找到
after I've checked all n doors, and if I have still not found

414
00:20:10,079 --> 00:20:14,149
我关心的数字，然后只有这样，我才返回false。
the number I care about, then and only then am I going to return false.

415
00:20:14,150 --> 00:20:15,900
所以很常见的编程错误
So a very common programming mistake might

416
00:20:15,900 --> 00:20:19,920
将其内部嵌套，并根据if和else来思考事物。
be to nest this internally and think about things in terms of ifs and elses.

417
00:20:19,920 --> 00:20:21,600
但是您不需要其他。
But you don't need to have an else.

418
00:20:21,599 --> 00:20:24,899
在最后，这是一个包罗万象的地方。
This is kind of a catchall here at the very end.

419
00:20:24,900 --> 00:20:29,460
但是现在让我们考虑一下，如果这是线性搜索的伪代码，那么
But now let's consider, if this is the pseudocode for linear search, just what

420
00:20:29,460 --> 00:20:32,730
搜索的效率是多少？
is the efficiency of linear search?

421
00:20:32,730 --> 00:20:35,650
线性搜索的效率是多少，也就是说，
What is the efficiency of linear search, which is to say,

422
00:20:35,650 --> 00:20:37,680
该算法的设计水平如何？
how well-designed is this algorithm?

423
00:20:37,680 --> 00:20:40,260
我们刚才放了一个框架，或者给了我们一个框架，
We put or gave ourselves a framework a moment ago,

424
00:20:40,259 --> 00:20:43,499
大O表示法，这是一个上限，我们现在可以想到
Big O notation, which is an upper bound, which we can think of for now

425
00:20:43,500 --> 00:20:45,060
就像最坏的情况一样。
as meaning like a worst case.

426
00:20:45,059 --> 00:20:49,379
在最坏的情况下，找到数字0可能需要花费几步-
In the worst case, how many steps might it take me to find the number 0--

427
00:20:49,380 --> 00:20:51,030
或任何与此有关的数字-
or any number for that matter--

428
00:20:51,029 --> 00:20:52,799
在n门之间？
among n doors?

429
00:20:52,799 --> 00:20:57,059
是n的大O平方，n的大O是log n，n的大O，
Is it big O of n squared, big O of n times log n, big O of n,

430
00:20:57,059 --> 00:21:00,359
log n的大O或1的大O，这再次意味着
big O of log n, or big O of one, which, again, just means

431
00:21:00,359 --> 00:21:03,289
固定数量的步骤？
a constant fixed number of steps?

432
00:21:03,289 --> 00:21:06,669
布莱恩，我们可以继续提出这个问题吗？
Brian, could we go ahead and pull up this question?

433
00:21:06,670 --> 00:21:09,180
让我继续并将其拉到屏幕上。
Let me go ahead and pull it up on my screen as well.

434
00:21:09,180 --> 00:21:14,250
如果您访问我们常用的网址来提出您认为的上限
If you go to our usual URL to propose what you think an upper bound

435
00:21:14,250 --> 00:21:18,209
是线性搜索的运行时间。
is on the running time of linear search.

436
00:21:18,210 --> 00:21:18,710
好的。
OK.

437
00:21:18,710 --> 00:21:20,940
确实，如果我们现在考虑线性搜索的运行时间，
Indeed, if we consider now the running time of linear search,

438
00:21:20,940 --> 00:21:22,107
这将是n的大O。
it's going to be big O of n.

439
00:21:22,106 --> 00:21:22,677
这是为什么？
Why is that?

440
00:21:22,678 --> 00:21:24,720
所以在最坏的情况下，我要寻找的号码
So in the worst case, the number I'm looking for,

441
00:21:24,720 --> 00:21:27,480
0，很可能位于该列表的末尾，即
0, might very well be at the end of that list, which

442
00:21:27,480 --> 00:21:31,087
将以n步为单位，或者在这种情况下恰好是n步。
is going to be on the order of n steps, or in this case precisely n steps.

443
00:21:31,086 --> 00:21:32,669
因此，这是考虑此问题的一种方法。
So that's one way to think about this.

444
00:21:32,670 --> 00:21:34,590
好吧，现在让我问一个后续问题。
Well, now let me ask a follow-up question.

445
00:21:34,589 --> 00:21:39,089
相反，建议我们考虑欧米茄符号，这是一个下限
Proposing instead that we consider omega notation, which is a lower bound

446
00:21:39,089 --> 00:21:40,799
在算法的运行时间上
on the running time of an algorithm--

447
00:21:40,799 --> 00:21:43,319
布莱恩，我们可以继续问下这个问题吗？
Brian, could we go ahead and ask this question next?

448
00:21:43,319 --> 00:21:47,469
在相同的网址，我们现在会看到一个问题
At that same URL, we'll see a question asking now

449
00:21:47,470 --> 00:21:55,210
对于运行时间的可能答案-
for the possible answers for the running time--

450
00:21:55,210 --> 00:21:58,280
线性搜索运行时间的下限。
for a lower bound on the running time of linear search.

451
00:21:58,279 --> 00:22:00,799
因此，让我们继续来看这里。
So let's go ahead and take a look at this one here.

452
00:22:00,799 --> 00:22:03,219
片刻之内，我们将看到响应的出现，
And in just a moment, we'll see as the responses come in,

453
00:22:03,220 --> 00:22:05,830
大约有百分之七十五以上的人在提议
about 75-plus percent of you are proposing

454
00:22:05,829 --> 00:22:07,629
实际上是1的欧米茄
that it's actually omega of 1.

455
00:22:07,630 --> 00:22:09,220
因此，欧米茄是一个下限。
So omega is a lower bound.

456
00:22:09,220 --> 00:22:10,923
1表示恒定时间。
1 refers to constant time.

457
00:22:10,923 --> 00:22:11,590
那为什么呢？
And why is that?

458
00:22:11,589 --> 00:22:13,506
让我就这一点做一个简短的回答。
Let me just take a quick answer on this point.

459
00:22:13,507 --> 00:22:17,890
在您说一个步骤或固定步骤数的75％的人中，
Among the 75% of you who said one step, or a constant number of steps,

460
00:22:17,890 --> 00:22:19,060
这是为什么？
why is that?

461
00:22:19,059 --> 00:22:23,259
您如何看待运行时间的下限？
How do you think about this lower bound on running time?

462
00:22:23,259 --> 00:22:25,209
从基思那里怎么样？
How about from Keith?

463
00:22:25,210 --> 00:22:27,600
为什么是1的欧米茄？
Why omega of 1?

464
00:22:27,599 --> 00:22:31,119
听众：是的，您可以打开它，很幸运，可以在第一扇门找到它。
AUDIENCE: Yeah, you can just open it and be lucky and find it in the first door.

465
00:22:31,119 --> 00:22:31,409
戴维·马兰：是的。
DAVID MALAN: Yeah.

466
00:22:31,410 --> 00:22:32,830
所以这确实说明了这一点。
So it really speaks to just that.

467
00:22:32,829 --> 00:22:34,899
您可能会很幸运，而且正在寻找所需的电话号码
You might just get lucky, and the number you're looking for

468
00:22:34,900 --> 00:22:36,290
可能在第一扇门。
might be at the very first door.

469
00:22:36,289 --> 00:22:39,759
因此，在最佳情况下，如果可能的话，此算法的下限是
So the lower bound, in the best case, if you will, of this algorithm,

470
00:22:39,759 --> 00:22:44,529
正是由于这个原因，线性搜索很可能是1的Ω
linear search might very well be omega of 1 for exactly that reason--

471
00:22:44,529 --> 00:22:46,539
拥有的-幸运的是，元素
that you have-- get lucky and the element

472
00:22:46,539 --> 00:22:48,019
可能一开始就在那里。
might be there at the beginning.

473
00:22:48,019 --> 00:22:48,669
很好。
So that's pretty good.

474
00:22:48,670 --> 00:22:50,378
您确实不能做得更好。
You really can't do any better than that.

475
00:22:50,377 --> 00:22:54,879
所以我们现在的这个范围的下限从1的欧米茄到n的大O
So we this range now of a lower bound from omega of 1 on up to big O of n

476
00:22:54,880 --> 00:22:57,940
是线性搜索运行时间的上限。
being an upper bound on the running time of linear search.

477
00:22:57,940 --> 00:23:00,760
但是，当然，我们的工具包中还有其他算法。
But of course, we have this other algorithm in our toolkit.

478
00:23:00,759 --> 00:23:04,239
回想第0周的内容，我们研究了二进制搜索-尽管，
And recall from week 0 that we looked at binary search-- although,

479
00:23:04,240 --> 00:23:05,530
不一定是名字。
not necessarily by name.

480
00:23:05,529 --> 00:23:09,249
那是第三个分治法，我们拿了电话簿
It was that divide-and-conquer third algorithm, where we took the phone book

481
00:23:09,250 --> 00:23:11,950
然后再将它一分为二
and split it in half and half and half again.

482
00:23:11,950 --> 00:23:17,140
现在，当我在那儿摸索的时候，乔好心地给了我们一套新的门。
Now, while I fumbled there, Joe kindly has given us a new set of doors.

483
00:23:17,140 --> 00:23:19,990
如果是乔，您可以继续说出我们的七扇门，
If Joe, you could go ahead and reveal our seven doors again,

484
00:23:19,990 --> 00:23:22,510
后面我们还有一些数字。
behind which we still have some numbers.

485
00:23:22,509 --> 00:23:26,439
但是我认为这一次，我会变得更好。
But I think this time, I'm going to be a little better off.

486
00:23:26,440 --> 00:23:30,010
提示乔和后面的门。
Cue Joe and the doors behind.

487
00:23:30,009 --> 00:23:30,619
好了
There we go.

488
00:23:30,619 --> 00:23:32,139
因此，我们有七个相同的门。
So we have our same seven doors.

489
00:23:32,140 --> 00:23:34,930
但是，在这些门后面现在是一个不同的数字排列方式。
But behind those doors now is a different arrangement of numbers.

490
00:23:34,930 --> 00:23:39,532
假设这次，我想找到自己的数字6。
And suppose this time, I want to find myself the number 6.

491
00:23:39,531 --> 00:23:41,739
因此，数字6 –我们将稍作更改，
So the number 6-- we'll change the problem slightly--

492
00:23:41,740 --> 00:23:44,630
但是这次我要再给你一种成分
but I'm going to give you one other ingredient this time,

493
00:23:44,630 --> 00:23:46,990
这将是这项工作的关键。
which is going to be key to this working.

494
00:23:46,990 --> 00:23:51,580
为什么佛罗伦萨和我之前做不到线性搜索？
Why were Florence and I able to do no better than linear search before?

495
00:23:51,579 --> 00:23:53,529
为什么佛罗伦萨和我不能做得更好
Why were Florence and I able to do no better

496
00:23:53,529 --> 00:23:57,609
比上次随机搜索还多？
than randomly searching even last time?

497
00:23:57,609 --> 00:24:00,759
关于数字数组或数组是什么
What was it about the array of numbers, or the array

498
00:24:00,759 --> 00:24:06,389
门，那以前不允许我使用二进制搜索？
of doors, that did not allow me previously to use binary search?

499
00:24:06,390 --> 00:24:08,755
虹膜，您怎么看？
Iris, what do you think?

500
00:24:08,755 --> 00:24:11,380
听众：因为我们不知道数字是否排序。
AUDIENCE: Because we didn't know the numbers are sorted or not.

501
00:24:11,380 --> 00:24:11,860
戴维·马兰：是的。
DAVID MALAN: Yeah.

502
00:24:11,859 --> 00:24:14,059
我们不知道数字是否已排序。
We didn't know if the numbers were sorted or not.

503
00:24:14,059 --> 00:24:16,509
的确，除非如此，佛罗伦萨和我
And indeed, barring that detail, Florence and I

504
00:24:16,509 --> 00:24:19,549
确实比线性搜索做得更好。
really couldn't have done any better than, say, linear search.

505
00:24:19,549 --> 00:24:22,899
所以这次，乔帮了一些忙
So this time, though, Joe has kindly sorted some numbers

506
00:24:22,900 --> 00:24:24,440
这些门后面对我们来说。
behind these doors for us.

507
00:24:24,440 --> 00:24:26,590
因此，如果我想搜索数字6，
And so if I want to search for the number 6,

508
00:24:26,589 --> 00:24:29,289
现在我可以开始使用这些信息了。
now I can begin to use a bit of that information.

509
00:24:29,289 --> 00:24:31,479
所以，您知道吗，我将像对待电话簿一样开始
So you know what, I'm going to start just like we did with the phone book

510
00:24:31,480 --> 00:24:32,813
然后从中间开始
and start roughly in the middle.

511
00:24:32,813 --> 00:24:34,310
瞧，第5位。
And voila, number 5.

512
00:24:34,309 --> 00:24:34,809
好的。
All right.

513
00:24:34,809 --> 00:24:36,849
所以我们非常接近，我们也非常接近。
So we're pretty close, we're pretty close.

514
00:24:36,849 --> 00:24:38,739
但是关于二分查找，回想，
But the thing about binary search, recall,

515
00:24:38,740 --> 00:24:41,080
就是现在这是有用的信息。
is that this is now useful information.

516
00:24:41,079 --> 00:24:44,919
如果这些数字都排在这些门的后面，则所有门都在左侧
If the numbers are sorted behind these doors all, of the doors to the left

517
00:24:44,920 --> 00:24:48,790
应该小于5，并且所有门都在右边
should presumably be lower than 5, and all of the doors to the right

518
00:24:48,789 --> 00:24:51,339
应该大于5。
should presumably be larger than 5.

519
00:24:51,339 --> 00:24:54,429
现在，我可能会在这里偷工减料，好吧，如果是5岁，
Now, I might kind of cut a corner here and be like, well, if this is 5,

520
00:24:54,430 --> 00:24:57,220
从字面上看，6可能就在隔壁。
6 is probably right next door, literally.

521
00:24:57,220 --> 00:24:59,530
但是再次，从算法上讲，我们应该怎么做呢？
But again, algorithmically, how might we do this?

522
00:24:59,529 --> 00:25:02,419
我们不想考虑这些特殊情况。
We don't want to necessarily consider these special cases.

523
00:25:02,420 --> 00:25:06,580
因此，更一般地说，我现在有一个大小为3的数组。
So more generally, it looks like I now have an array of size 3.

524
00:25:06,579 --> 00:25:10,399
因此，让我继续并将相同的算法voila应用于中间。
So let me go ahead and apply that same algorithm, voila, to the middle.

525
00:25:10,400 --> 00:25:11,560
现在我有数字7。
Now I have the number 7.

526
00:25:11,559 --> 00:25:14,887
现在非常清楚的是，如果存在数字6，
And now it's becoming pretty clear that if the number 6 is present,

527
00:25:14,887 --> 00:25:16,179
它可能在这扇门后面。
it's probably behind this door.

528
00:25:16,180 --> 00:25:21,400
确实，如果我现在看一下剩下的1号阵列，瞧，
And indeed, if I now look at my remaining array of size 1, and voila,

529
00:25:21,400 --> 00:25:23,470
中间有那个数字6。
in the middle there is that number 6.

530
00:25:23,470 --> 00:25:27,700
所以这一次，我只需要打开三扇门，而不是全部打开七扇门，
So this time, I only had to open up three doors instead of all seven,

531
00:25:27,700 --> 00:25:31,390
可能，或者可能是所有六个门找到通往该数字的方式，
potentially, or maybe all six doors to find my way to that number,

532
00:25:31,390 --> 00:25:34,060
因为我得到了所有这些额外的成分
because I was given this additional ingredient of all

533
00:25:34,059 --> 00:25:35,859
这些数字中进行排序。
of those numbers being sorted.

534
00:25:35,859 --> 00:25:38,229
这样看来，您可以申请
So it would seem, then, that you can apply

535
00:25:38,230 --> 00:25:40,960
更好，更高效，设计更完善的算法，现已广为人知
the better, more efficient, better designed algorithm, now known

536
00:25:40,960 --> 00:25:46,060
作为二进制搜索，如果只有像Joe这样的人会为您对数字进行排序
as binary search, if only someone like Joe would sort the numbers for you

537
00:25:46,059 --> 00:25:46,819
提前。
in advance.

538
00:25:46,819 --> 00:25:50,109
现在让我们考虑一下算法
So let's consider now a little more algorithmically

539
00:25:50,109 --> 00:25:51,439
我们如何实现这一目标。
how we might implement this.

540
00:25:51,440 --> 00:25:54,130
因此，对于二进制搜索，让我提出这个伪代码。
So with binary search, let me propose this pseudocode.

541
00:25:54,130 --> 00:25:57,980
如果数字在中间门后面，请返回true-我们找到了。
If the number is behind the middle door, return true-- we found it.

542
00:25:57,980 --> 00:26:00,562
因此，如果我们很幸运，那么我们可能会很好
So if we got lucky, then we might very well

543
00:26:00,561 --> 00:26:02,519
在中间门后面找到了6号，
have found the number 6 behind the middle door,

544
00:26:02,519 --> 00:26:03,686
而且我们会做的很好。
and we would have been done.

545
00:26:03,686 --> 00:26:04,659
但是那没有发生。
But that didn't happen.

546
00:26:04,660 --> 00:26:06,785
在一般情况下，这可能不会发生。
And in the general case that probably won't happen.

547
00:26:06,785 --> 00:26:10,452
因此，如果数量少于中间门后面的数量，则
So if the number is less than that behind the middle door, then

548
00:26:10,451 --> 00:26:12,909
就像电话簿一样，我要走到左边，
just like with the phone book, I'm going to go to the left,

549
00:26:12,910 --> 00:26:17,020
我将搜索阵列中其余门的左半部分。
and I'm going to search the left half of the remaining doors in the array.

550
00:26:17,019 --> 00:26:20,044
否则，如果这个数字大于中间门后面的数字，
Else if the number is greater than that behind the middle door,

551
00:26:20,045 --> 00:26:22,420
然后像电话簿一样，我将继续搜索
then like the phone book I'm going to go ahead and search

552
00:26:22,420 --> 00:26:24,370
电话簿的右半部分。
the right half of the phone book.

553
00:26:24,369 --> 00:26:27,999
但是可能仍然有最后一种情况，
But there might still be one final case potentially,

554
00:26:28,000 --> 00:26:32,169
因此，如果根本没有门，或者一开始就没有门，
whereby if there's no doors left at all, or no doors in the first place,

555
00:26:32,170 --> 00:26:36,430
我至少应该有一种特殊情况，我确实说return false。
I should at least have this one special case where I do say return false.

556
00:26:36,430 --> 00:26:40,272
例如，如果6，无论出于何种原因，都不在这些门之列
For instance, if 6, for whatever reason, weren't be among those doors

557
00:26:40,271 --> 00:26:41,979
我一直在寻找它，我仍然需要
and I were searching for it, I still need

558
00:26:41,980 --> 00:26:44,860
能够处理我可以明确地说的那种情况
to be able to handle that situation where I can say definitively

559
00:26:44,859 --> 00:26:48,279
如果我没有其他可搜索的门，则返回false。
return false if I'm left with no further doors to search.

560
00:26:48,279 --> 00:26:51,749
因此，这里可能更正式地是该算法的伪代码。
So here, then, might be the pseudocode for this algorithm a bit more formally.

561
00:26:51,750 --> 00:26:53,819
现在让我们考虑对其进行分析。
Now let's consider the analysis thereof.

562
00:26:53,819 --> 00:26:58,619
在此之前，线性搜索是n的大O。
Before, where we left off, linear search was big O of n.

563
00:26:58,619 --> 00:27:00,629
线性搜索为n的大O。
Linear search was big O of n.

564
00:27:00,630 --> 00:27:05,310
这次让我们考虑一下二进制搜索的实际位置
This time let's consider where binary search actually falls into place

565
00:27:05,309 --> 00:27:06,907
通过问一个不同的问题。
by asking a different question.

566
00:27:06,907 --> 00:27:09,449
我要继续前进，现在回问这个问题-
I'm going to go ahead and go back and ask this question now--

567
00:27:09,450 --> 00:27:13,920
二进制搜索的运行时间上限是多少？
what's an upper bound on the running time of binary search?

568
00:27:13,920 --> 00:27:16,920
二进制搜索运行时间的上限-
An upper bound on the running time of binary search--

569
00:27:16,920 --> 00:27:21,210
并继续嗡嗡作响，如果您愿意的话，也可以像以前一样。
and go ahead and buzz in, if you'd like, similarly to before.

570
00:27:21,210 --> 00:27:25,510
二进制搜索的运行时间上限是多少？
What's an upper bound on the running time of binary search?

571
00:27:25,509 --> 00:27:30,959
并且您可以看到在这里，答案在log n周围变得相当占主导地位。
And you can see here answers are getting pretty dominant around log n.

572
00:27:30,960 --> 00:27:33,780
确实，这与我们在第0周所做的事情息息相关。
And indeed, that jives with exactly what we did in week 0.

573
00:27:33,779 --> 00:27:36,239
正确答案的确是n的对数，因为那是
The correct answer is indeed log of n, because that's

574
00:27:36,240 --> 00:27:38,240
将是您的最大次数
going to be the maximum number of times that you

575
00:27:38,240 --> 00:27:40,438
可以获取给定大小的列表或数组
can take a list or an array of a given size

576
00:27:40,438 --> 00:27:42,480
并分成一半一半，直到你
and split it in half and half and half, until you

577
00:27:42,480 --> 00:27:45,360
找到您要寻找的号码，或者最终找到您
find the number you're looking for, or ultimately you

578
00:27:45,359 --> 00:27:47,319
根本找不到那个数字。
don't find that number at all.

579
00:27:47,319 --> 00:27:54,459
同时，如果我们现在不仅仅考虑该算法的上限，
Meanwhile, if we consider now not just the upper bound on this algorithm--

580
00:27:54,460 --> 00:27:57,930
因此，在最坏的情况下，二进制搜索会占用log n的大O--
so in the worst case, binary search takes big O of log n--

581
00:27:57,930 --> 00:28:00,210
现在让我们考虑一个相关的问题
now let's consider a related question which

582
00:28:00,210 --> 00:28:03,420
是，相同算法的运行时间的下限是多少？
is, what's a lower bound on the running time of this same algorithm?

583
00:28:03,420 --> 00:28:05,530
运行时间的下限是多少？
What's a lower bound on the running time?

584
00:28:05,529 --> 00:28:07,469
我会继续把这个摘下来
I'll go ahead and pluck this one off myself

585
00:28:07,470 --> 00:28:10,680
然后回到到目前为止的一些建议。
and go back to some of the suggestions thus far.

586
00:28:10,680 --> 00:28:13,573
在最好的情况下，也许您也很幸运，
In the best case, maybe, too, you do get lucky,

587
00:28:13,573 --> 00:28:15,990
以及您要查找的号码6或其他号码，
and the number you're looking for, 6 or some other number,

588
00:28:15,990 --> 00:28:18,250
在阵列中间打点DAB。
is smack dab in the middle of the array.

589
00:28:18,250 --> 00:28:20,939
因此，也许您确实可以只迈出一步。
And so maybe indeed you can get away with just one step.

590
00:28:20,940 --> 00:28:25,110
确实，现在二进制搜索的下限可能会很好
And indeed, a lower bound on binary search now might very well just

591
00:28:25,109 --> 00:28:29,249
等于1的欧米茄，因为在最佳情况下，您会很幸运，
be an omega of 1, because in that best case you just get lucky,

592
00:28:29,250 --> 00:28:33,250
在这里碰巧是正确的起点，就在中间。
and it's right where you happen to start, in this case in the middle.

593
00:28:33,250 --> 00:28:34,689
因此，我们似乎有一个范围。
So we seem to have a range there.

594
00:28:34,690 --> 00:28:37,950
但是严格来说，二进制搜索似乎更好。
But strictly speaking, it would seem that binary search is better.

595
00:28:37,950 --> 00:28:40,710
二进制搜索优于线性搜索，
Binary search is better than linear search,

596
00:28:40,710 --> 00:28:44,880
因为随着n变大，变大，变大，您真的可以感觉到这种差异。
because as n gets big, big, big, you can really feel that difference.

597
00:28:44,880 --> 00:28:47,970
实际上，从第0周起，我们就使用了这些灯泡。
In fact, recall from week 0 we played a little bit with these light bulbs.

598
00:28:47,970 --> 00:28:50,698
现在，所有这些灯泡中的全部64个都已打开。
And right now, all 64 of these light bulbs are on.

599
00:28:50,698 --> 00:28:53,490
让我们考虑一下，只是为了了解这一点，
And let's consider for a moment, just to put this into perspective,

600
00:28:53,490 --> 00:28:56,400
使用线性搜索查找需要多长时间
how long it would take to use linear search to find

601
00:28:56,400 --> 00:28:58,410
在这64个灯泡中，只有一个灯泡。
one light bulb among these 64.

602
00:28:58,410 --> 00:29:01,920
并记得在最坏的情况下，可能是灯泡或数字
And recall that in the worst case, maybe the light bulb, or the number

603
00:29:01,920 --> 00:29:04,480
我们正在寻找的是在最后
that we're looking for, is way down there at the end,

604
00:29:04,480 --> 00:29:06,100
但我们事先不知道。
but we don't know in advance.

605
00:29:06,099 --> 00:29:09,899
因此，萨姆纳（Sumner），如果您不介意执行线性搜索
And so Sumner, if you wouldn't mind executing linear search

606
00:29:09,900 --> 00:29:13,410
在这些灯泡上，让我们来感受一下效率
on these light bulbs, let's just get a feel for the efficiency

607
00:29:13,410 --> 00:29:15,870
或此算法效率低下。
or inefficiency of this algorithm.

608
00:29:15,869 --> 00:29:18,359
灯泡形式的线性搜索。
Linear search in light bulb form.

609
00:29:18,359 --> 00:29:21,059
因此，您会一次注意到一个灯泡
So you'll notice that one light bulb at a time

610
00:29:21,059 --> 00:29:24,569
出门了，暗示我已经搜索了那扇门，搜索了那扇门，
is going out, implying that I've searched that door, searched that door,

611
00:29:24,569 --> 00:29:25,889
搜索那扇门。
searched that door.

612
00:29:25,890 --> 00:29:27,990
但是我们只经历了10个左右的灯泡，
But we've only gone through 10 or so bulbs,

613
00:29:27,990 --> 00:29:30,400
我们还有50多个。
and we've got another 50-plus to go.

614
00:29:30,400 --> 00:29:34,920
您会看到，如果我们每秒看一眼这些门，
And you can see that if we look inside of these doors one per second,

615
00:29:34,920 --> 00:29:39,010
或每秒关掉这些灯泡，这将需要很长时间。
or turn off these light bulbs one per second, it's going to take a long time.

616
00:29:39,009 --> 00:29:42,309
实际上，似乎没有必要等到最后。
In fact, it doesn't seem worthwhile to even wait until the very end.

617
00:29:42,309 --> 00:29:45,142
所以萨姆纳，如果您不介意，让我们把所有的灯光都放回原处，
So Sumner, if you wouldn't mind, let's bring all the lights back up,

618
00:29:45,143 --> 00:29:48,300
然后再尝试另一种算法，这个二进制搜索，
and let's try once more another algorithm, this one binary search, just

619
00:29:48,299 --> 00:29:52,499
再次感觉到算法的运行时间是多少，
to get, again, a feel of what the running time is of an algorithm,

620
00:29:52,500 --> 00:29:54,750
例如以对数时间运行的二进制搜索。
like binary search that runs in logarithmic time.

621
00:29:54,750 --> 00:29:58,259
因此，稍后，我们将继续执行二进制搜索
So in just a moment, we'll go ahead and execute binary search

622
00:29:58,259 --> 00:30:01,509
在这些灯泡上，想法是我们关心一个灯泡。
on these light bulbs, the idea being that there's one bulb we care about.

623
00:30:01,509 --> 00:30:04,619
让我们看看我们能以多快的速度降到64个灯泡中的一个。
Let's see how fast we can get down to just one bulb out of 64.

624
00:30:04,619 --> 00:30:07,439
因此，萨姆纳（Sumner），以您的意愿，开始前进。
So Sumner, on your marks, get set, go.

625
00:30:10,849 --> 00:30:14,101
几步后，我们就完成了。
And we're done just a few steps later.

626
00:30:14,102 --> 00:30:15,560
然后有这个唯一的灯泡。
And then have this sole light bulb.

627
00:30:15,559 --> 00:30:16,879
那快得多了。
That was so much faster.

628
00:30:16,880 --> 00:30:20,330
实际上，我们一次故意进行了一次迭代。
And in fact, we did this deliberately one iteration at a time.

629
00:30:20,329 --> 00:30:24,919
我们刚刚在萨姆纳和马特的帮助下执行的算法，
The algorithm that we just executed with Sumner's and Matt's help,

630
00:30:24,920 --> 00:30:28,400
在算法上以1赫兹，1赫兹的频率运行
algorithmically was operating at what's called 1 hertz, 1 hertz.

631
00:30:28,400 --> 00:30:31,400
而且，如果您不熟悉赫兹，那么每秒仅是一件事。
And if you're unfamiliar with hertz, it's just one something per second.

632
00:30:31,400 --> 00:30:34,855
它非常常用于物理学中或仅用于电的讨论中
It's very often used in physics or just in discussions of electricity

633
00:30:34,855 --> 00:30:35,480
更普遍。
more generally.

634
00:30:35,480 --> 00:30:38,090
实际上，在这种情况下，如果您每秒要做一件事，
And indeed, in this case if you're doing one thing per second,

635
00:30:38,089 --> 00:30:41,929
第一个算法，线性搜索，可能要花我们64秒
that first algorithm, linear search, might have taken us like 64 seconds

636
00:30:41,930 --> 00:30:44,480
一直到最后一个灯泡。
to get all the way to that final light bulb.

637
00:30:44,480 --> 00:30:47,390
但是第二种算法是对数的。
But that second algorithm was logarithmic.

638
00:30:47,390 --> 00:30:54,350
因此，从64到32到16到8到4到2到1，
And so by going from 64 to 32 to 16 to 8 to 4 to 2 to 1,

639
00:30:54,349 --> 00:30:58,849
即使以相同的速度前进，我们也能更快地获得最终结果。
we get to the final result much faster, even going at the same pace.

640
00:30:58,849 --> 00:31:01,499
因此，实际上，如果您想到计算机的CPU，
So in fact, if you think of your computer's CPU,

641
00:31:01,500 --> 00:31:03,560
CPU的单位也是赫兹
CPUs are also measured in hertz--

642
00:31:03,559 --> 00:31:06,749
赫兹。大概以千兆赫为单位
H-E-R-T-Z. Probably measured in gigahertz,

643
00:31:06,750 --> 00:31:08,959
每秒数十亿赫兹。
which is billions of hertz per second.

644
00:31:08,960 --> 00:31:11,960
因此，您的CPU，计算机的大脑如果是1 GHz，
So your CPU, the brain of your computer, If it's 1 gigahertz,

645
00:31:11,960 --> 00:31:15,840
这意味着它一次可以完成10亿件事情。
that means it can literally do 1 billion things at a time.

646
00:31:15,839 --> 00:31:18,769
在这里，我们使用灯泡进行这种更简单的设置
And here we have this sort of simpler setup of just light bulbs doing

647
00:31:18,769 --> 00:31:20,509
每秒一件事。
one thing per second.

648
00:31:20,509 --> 00:31:24,289
您的计算机可以一次执行10亿种此类操作。
Your computer can do 1 billion of these kinds of operations at once.

649
00:31:24,289 --> 00:31:27,259
因此，请想象一下，这些节省的趋势有多大
So just imagine, therefore, how much these savings tend

650
00:31:27,259 --> 00:31:30,742
如果您可以一次从这些问题中解脱出来，那么随着时间的推移就会加起来，
to add up over time if you can take big bites out of these problems at once,

651
00:31:30,742 --> 00:31:32,659
而不是像我们一周所做的那样
as opposed to doing things like we did in week

652
00:31:32,660 --> 00:31:36,620
0，一次仅一步。
0, just one single step at a time.

653
00:31:36,619 --> 00:31:37,379
好的。
All right.

654
00:31:37,380 --> 00:31:39,922
好吧，现在让我们开始将其转换为代码。
Well, let's now go ahead and start to translate this to code.

655
00:31:39,922 --> 00:31:42,677
我认为C语言的工具包中有足够的工具，
We have enough tools in our toolkit in C that I think,

656
00:31:42,676 --> 00:31:44,509
根据我们上周对数组的讨论，
based on our discussion of arrays last week,

657
00:31:44,509 --> 00:31:48,329
现在，我们实际上可以开始自己构建代码了。
we can now actually start to build something in code on our own.

658
00:31:48,329 --> 00:31:51,599
所以我将继续在这里创建一个文件，
So I'm going to go ahead and create a file here in just a moment,

659
00:31:51,599 --> 00:31:55,429
在CS50 IDE中，例如，称为number.c。
in CS50 IDE, called, for instance, numbers.c.

660
00:31:55,430 --> 00:32:00,320
让我继续将其转换为C数字文件，称为numbers.c。
Let me go ahead and translate this to a file in C code called numbers.c.

661
00:32:00,319 --> 00:32:03,649
目前的目标只是在代码中实现线性搜索，
The goal at hand is just to implement linear search in code,

662
00:32:03,650 --> 00:32:06,380
只是为了让我们不再对伪代码挥手
just so that we're no longer waving our hands at the pseudocode

663
00:32:06,380 --> 00:32:08,520
但做些更具体的事情。
but doing things a little more concretely.

664
00:32:08,519 --> 00:32:10,879
因此，我将继续包含cs50.h。
So I'm going to go ahead and include cs50.h.

665
00:32:10,880 --> 00:32:13,160
我将继续添加stdio.h。
I'm going to go ahead and include stdio.h.

666
00:32:13,160 --> 00:32:15,530
我将从没有命令行参数开始，
And I'm going to start with no command line arguments,

667
00:32:15,529 --> 00:32:18,646
就像我们上周离开时一样，但主要是无效的。
like we left off last week, but just with main void.

668
00:32:18,646 --> 00:32:21,229
我要继续给自己一些数字，
And I'm going to go ahead and give myself an array of numbers,

669
00:32:21,230 --> 00:32:22,820
七个数字，就像门一样。
seven numbers, just like the doors.

670
00:32:22,819 --> 00:32:25,669
我将继续讲int数。
And I'm going to go ahead and say int numbers.

671
00:32:25,670 --> 00:32:28,250
然后这是我们上周没有看到的小技巧，
And then this is a little trick that we didn't see last week,

672
00:32:28,250 --> 00:32:30,740
但是在以下情况下创建数组很方便
but it's handy for creating an array when

673
00:32:30,740 --> 00:32:33,110
你事先知道你想要什么号码，我要做什么，
you know in advance what numbers you want, which I do,

674
00:32:33,109 --> 00:32:36,439
因为我要模仿乔在这里为我们设置的门，我是
because I'm going to mimic the doors that Joe kindly set up for us here, I'm

675
00:32:36,440 --> 00:32:44,120
继续说给我一个等于4、6、8、2、7的数组
going to go ahead and say give me an array that is equal to 4, 6, 8, 2, 7,

676
00:32:44,119 --> 00:32:45,479
5、0。
5, 0.

677
00:32:45,480 --> 00:32:47,480
这是我们上周没有看到的功能。
And this is the feature we didn't see last week.

678
00:32:47,480 --> 00:32:50,690
如果您事先知道要分配给数组的数字，
If you know in advance the numbers that you want to assign to an array,

679
00:32:50,690 --> 00:32:54,560
您实际上不必费心指定数组的大小
you actually don't have to bother specifying the size of the array

680
00:32:54,559 --> 00:32:55,789
明确地。
explicitly.

681
00:32:55,789 --> 00:32:58,639
编译器可以为您明智地解决这一问题。
The compiler can figure that out intelligently for you.

682
00:32:58,640 --> 00:33:01,960
但是您可以将这些花括号与逗号一起使用
But you can use these curly braces with commas

683
00:33:01,960 --> 00:33:05,420
内部从左到右枚举值
inside to enumerate from left to right the values

684
00:33:05,420 --> 00:33:07,400
您想要放入该数组中。
that you want to put into that array.

685
00:33:07,400 --> 00:33:09,727
因此，在我的计算机中执行了第6行之后，
So after this line 6 has executed in my computer,

686
00:33:09,727 --> 00:33:11,810
我将剩下一个叫做数字的数组，
I'm going to be left with an array called numbers,

687
00:33:11,809 --> 00:33:14,479
其中列出了七个整数
inside of which are seven integers listed

688
00:33:14,480 --> 00:33:17,895
可以这么说，从左到右在计算机的内存中。
from left to right in the computer's memory, so to speak, in this way.

689
00:33:17,894 --> 00:33:19,769
现在，我要如何处理这些数字？
Now, what do I want to do with these numbers?

690
00:33:19,769 --> 00:33:21,559
好吧，让我们实现线性搜索。
Well, let's implement linear search.

691
00:33:21,559 --> 00:33:24,169
线性搜索，正如我们之前提到的，
Linear search, as we latched on to earlier,

692
00:33:24,170 --> 00:33:27,110
是从左到右或等效地从右到左的搜索-
is a searching from left to right or equivalently right to left--

693
00:33:27,109 --> 00:33:29,459
但惯例倾向于从左到右。
but convention tends to go left to right.

694
00:33:29,460 --> 00:33:31,700
因此，我将为循环做一个标准。
So I'm going to do a standard for loop.

695
00:33:31,700 --> 00:33:34,730
对于int我得到0，我小于-
For int i gets 0, i is less than--

696
00:33:34,730 --> 00:33:36,980
我现在将其简化并对此进行硬编码，
I'm going to keep it simple for now and hardcode this,

697
00:33:36,980 --> 00:33:40,400
但是我们可以根据需要清理它，我将在每一个上执行i ++
but we could clean this up if we want, and I'm going to do i++ on each

698
00:33:40,400 --> 00:33:41,130
迭代。
iteration.

699
00:33:41,130 --> 00:33:45,330
所以我很确定我的第8行会引发一个for循环，
So I'm pretty sure that my line 8 will induce a for loop that

700
00:33:45,329 --> 00:33:47,089
总共重复八次。
iterates eight total times.

701
00:33:47,089 --> 00:33:49,459
在每次迭代中我想问什么问题？
And what question do I want to ask on each iteration?

702
00:33:49,460 --> 00:33:56,270
好吧，如果位置i处的数字数组等于-
Well, if the numbers array at location i equals equals--

703
00:33:56,269 --> 00:34:00,169
例如，我最初搜索的号码，
for instance, the number I was searching for initially,

704
00:34:00,170 --> 00:34:02,060
让我们继续搜索0-
let's go ahead and search for 0--

705
00:34:02,059 --> 00:34:03,619
那我想怎么办？
then what do I want to do?

706
00:34:03,619 --> 00:34:06,859
让我继续打印出一些任意但有用的内容，
Let me go ahead and print out something arbitrary but useful,

707
00:34:06,859 --> 00:34:09,786
就像“找到”，引用，取消引用一样，因此人类知道。
like "Found," quote, unquote, so the human knows.

708
00:34:09,786 --> 00:34:12,619
然后，让我继续前进，只是为了好措施，让我继续前进
And then let me go ahead, and just for good measure, let me go ahead

709
00:34:12,619 --> 00:34:13,999
并返回0。
and return 0.

710
00:34:14,000 --> 00:34:16,109
我们将在片刻后再谈到这一点。
And we'll come back to that in just a moment.

711
00:34:16,110 --> 00:34:20,389
但在该程序结束时，我还将执行此操作– printf“未找到”
But at the end of this program, I'm also going to do this-- printf "Not found"

712
00:34:20,389 --> 00:34:21,610
反斜杠
with a backslash n.

713
00:34:21,610 --> 00:34:23,719
然后我将继续并返回1。
And then I'm going to go ahead and return 1.

714
00:34:23,719 --> 00:34:26,000
但是在我们梳理那些回报之前，
But before we tease apart those returns, just

715
00:34:26,000 --> 00:34:27,949
考虑汇总中的代码。
consider the code in the aggregate.

716
00:34:27,949 --> 00:34:30,020
这是我的整个主要功能。
Here's my entire main function.

717
00:34:30,019 --> 00:34:32,749
在第6行，回顾一下，我初始化了数组，
And on line 6, to recap, I initialized the array,

718
00:34:32,750 --> 00:34:37,908
就像我们一开始所做的那样，看似随机的数字列表
just as we did at the very beginning, with a seemingly random list of numbers

719
00:34:37,909 --> 00:34:39,020
在门后面。
behind the doors.

720
00:34:39,019 --> 00:34:41,569
然后在第8行，我将使用此for循环进行迭代
Then on line 8, I'm going to iterate with this for loop

721
00:34:41,570 --> 00:34:44,600
共七个时间，每回合增加i。
seven total times, incrementing i in each turn.

722
00:34:44,599 --> 00:34:48,468
然后是10号线，就像我一次打开一扇门一样，
And then line 10, just like I was opening the doors one at a time,

723
00:34:48,469 --> 00:34:51,469
我要检查此数组中的第i个数字
I'm going to check if the i-th number in this array

724
00:34:51,469 --> 00:34:54,949
equals等于我在第一个演示中关心的数字0。
equals equals the number I care about, 0, with that first demo.

725
00:34:54,949 --> 00:34:56,570
我将打印“找到”。
I'm going to print "Found."

726
00:34:56,570 --> 00:35:00,110
否则-本身不是其他-否则，
Otherwise-- not else, per se-- but otherwise,

727
00:35:00,110 --> 00:35:04,550
如果我经历了整个循环，请检查是否，是否，是否，是否和
if I go through this entire loop, checking if, if, if, if, if, and I

728
00:35:04,550 --> 00:35:08,870
从来没有真正找到0，我将在最后使用这个包包
never actually find 0, I'm going to have this catchall at the end that just

729
00:35:08,869 --> 00:35:13,789
表示无论如何，如果到达第16行，则打印“未找到”，
says no matter what, if you reach line 16, print "Not found,"

730
00:35:13,789 --> 00:35:15,504
然后返回1。
and then return 1.

731
00:35:15,505 --> 00:35:16,880
现在，这有点微妙。
Now, this is a bit of a subtlety.

732
00:35:16,880 --> 00:35:20,800
但是有人可以提醒我们返回0到底是怎么回事
But could someone remind us what's going on with the return 0

733
00:35:20,800 --> 00:35:26,566
在第13行，在行17返回1？
on line 13 and the return 1 on line 17?

734
00:35:26,565 --> 00:35:31,929
为什么0比1，为什么我要返回？
Why 0 in 1, and why am I returning at all?

735
00:35:31,929 --> 00:35:35,629
这对我来说解决了什么问题？
What problem is this solving for me?

736
00:35:35,630 --> 00:35:37,380
即使到目前为止我们的大多数程序
Even though most of our programs thus far,

737
00:35:37,380 --> 00:35:39,150
我们对此并没有太在意。
we haven't bothered too much with this.

738
00:35:39,150 --> 00:35:40,710
黛咪，是吗？
Demi, is it?

739
00:35:40,710 --> 00:35:42,340
你怎么认为？
What do you think?

740
00:35:42,340 --> 00:35:45,600
听众：是黛咪，但基本上是返回0
AUDIENCE: It's Demi, but basically, return 0

741
00:35:45,599 --> 00:35:49,489
就像它已正确执行，还是找到了，
is like it was executed correctly, or it found it,

742
00:35:49,489 --> 00:35:52,169
并存在一个退出循环，说已找到它。
and it kind of exits that loop saying that it was found.

743
00:35:52,170 --> 00:35:58,375
然后return 1就像return false一样，它也退出。
And then return 1 is like the return false, and it exits as well.

744
00:35:58,375 --> 00:35:59,250
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

745
00:35:59,250 --> 00:36:00,917
而“退出”确实是有效的词。
And "exit" really is the operative word.

746
00:36:00,916 --> 00:36:02,579
总的来说，当您完成后-
In main, when you are done--

747
00:36:02,579 --> 00:36:05,339
准备退出程序，就像我们用单词做完一样
ready to quit the program, as we've done with the word

748
00:36:05,340 --> 00:36:09,000
过去在某些伪代码中“退出”后，您可以按字面值返回一个值。
"quit" in some of our pseudocode in the past, you can literally return a value.

749
00:36:09,000 --> 00:36:11,970
回想上周末，我们介绍了事实
And recall at the end of last week, we introduced the fact

750
00:36:11,969 --> 00:36:14,249
该main始终返回一个int。
that main always returns an int.

751
00:36:14,250 --> 00:36:17,129
您和我至少一两个星期都忽略了这一点，
You and I have ignored that for at least a week or two,

752
00:36:17,130 --> 00:36:20,130
但是有时候返回一个明确的值很有用，
but sometimes it's useful to return an explicit value,

753
00:36:20,130 --> 00:36:22,410
是否用于自动分级，是否
whether it's for autograding purposes, whether it's

754
00:36:22,409 --> 00:36:24,734
用于在现实世界中自动测试您的代码，
for automated testing of your code in the real world,

755
00:36:24,735 --> 00:36:27,360
或只是向用户发出信号，表明确实发生了某些情况
or just so it's a signal to the user that something indeed went

756
00:36:27,360 --> 00:36:28,030
错误的。
Wrong.

757
00:36:28,030 --> 00:36:30,180
因此，您可以从main返回一个值。
So you can return a value from main.

758
00:36:30,179 --> 00:36:33,506
正如Demi所提议的，0表示“一切都很好”。
And as Demi proposed, 0 means "all is well."

759
00:36:33,507 --> 00:36:35,340
这有点违反直觉，因为
And it's a little counter-intuitive, because

760
00:36:35,340 --> 00:36:37,330
到目前为止，正确往往是一件好事。
thus far true tends to be a good thing.

761
00:36:37,329 --> 00:36:39,419
但是在这种情况下，0是一件好事。
But in this case, 0 is a good thing.

762
00:36:39,420 --> 00:36:40,140
一切都很好。
All is well.

763
00:36:40,139 --> 00:36:41,219
成功了
It's success.

764
00:36:41,219 --> 00:36:44,699
如果您返回任何其他值，例如1，
And if you return any other value, for instance 1,

765
00:36:44,699 --> 00:36:46,659
这表明出了点问题。
that indicates that something went wrong.

766
00:36:46,659 --> 00:36:51,389
所以我打印出来的原因是，在“找到”一词之后，我返回0，
So the reason I'm printing out, after the word "Found" I'm returning 0,

767
00:36:51,389 --> 00:36:54,497
这样程序才能在该点有效退出。
is so that effectively the program exits at that point.

768
00:36:54,498 --> 00:36:56,790
我已经不想再走一遍了
I don't want to keep going again and again if I already

769
00:36:56,789 --> 00:36:58,319
找到了我关心的电话号码。
found the number I care about.

770
00:36:58,320 --> 00:37:02,160
在这里，这绝对不是必需的，
And down here, this one admittedly isn't strictly necessary,

771
00:37:02,159 --> 00:37:06,119
因为如果我点击第16行并且可能删除了第17行，
because if I hit line 16 and maybe deleted line 17,

772
00:37:06,119 --> 00:37:07,739
该程序将要结束。
the program's going to end anyway.

773
00:37:07,739 --> 00:37:10,799
但是不会有所谓的退出状态
But there wouldn't be that so-called exit status

774
00:37:10,800 --> 00:37:12,960
我们在上周简要讨论过，
that we discussed last week briefly, whereby

775
00:37:12,960 --> 00:37:15,293
您可以向计算机发出某种信号
you can kind of signal to the computer whether something

776
00:37:15,293 --> 00:37:17,190
是成功还是失败。
was successful or unsuccessful.

777
00:37:17,190 --> 00:37:21,690
而0是好东西而1或其他任何数字都不是的原因，
And the reason that 0 is a good thing and 1 or any other number is not,

778
00:37:21,690 --> 00:37:24,780
考虑在您编写的程序中有多少事情可能出错
consider how many things can go wrong in programs that you write

779
00:37:24,780 --> 00:37:26,607
或现实世界中的公司写
or that companies in the real world write

780
00:37:26,606 --> 00:37:28,439
当您收到这些错误消息时，有时
when you get those error messages, sometimes

781
00:37:28,440 --> 00:37:30,060
与那些神秘的错误代码。
with those cryptic error codes.

782
00:37:30,059 --> 00:37:32,429
有成千上万的问题
There are hundreds, thousands of problems

783
00:37:32,429 --> 00:37:35,789
在计算机程序中可能会发生那么多错误
that might happen in a computer program that could be that many error

784
00:37:35,789 --> 00:37:37,679
您在屏幕上看到的代码，原因
codes that you see on the screen, reasons

785
00:37:37,679 --> 00:37:40,629
解释为什么程序崩溃或冻结等。
explaining why the program crashed or froze or the like.

786
00:37:40,630 --> 00:37:46,020
但是0有点特殊，因为它只是世界所拥有的一个价值
But 0 is sort of special in that it's just one value that the world has

787
00:37:46,019 --> 00:37:47,759
决定的意思是“成功”。
decided means "success."

788
00:37:47,760 --> 00:37:50,460
因此，从某种意义上说，只有一种方法可以使您的程序正确无误，
So there's only one way to get your program right, in a sense,

789
00:37:50,460 --> 00:37:54,000
但是有数百万种可能出错的方法。
but there's so many millions of ways in which things can go wrong.

790
00:37:54,000 --> 00:37:57,810
这就是为什么人类采用了该特定约定的原因。
And that's why humans have adopted that particular convention.

791
00:37:57,809 --> 00:37:58,309
好的。
All right.

792
00:37:58,309 --> 00:38:02,377
但是，现在让我们不仅考虑数字，还要让事情变得更有趣。
But let's consider now not just numbers, but let's make things more interesting.

793
00:38:02,378 --> 00:38:04,170
除了门，假设我们实际上
Besides the doors, suppose that we actually

794
00:38:04,170 --> 00:38:06,300
后面有人们的名字。
had people's names behind them.

795
00:38:06,300 --> 00:38:08,790
好吧，这次我们继续编写程序
Well, let's go ahead and write a program this time

796
00:38:08,789 --> 00:38:13,129
不仅搜索数字，而且搜索名称。
that not only searches for numbers, but instead searches for names.

797
00:38:13,130 --> 00:38:16,850
因此，我将继续在此处创建一个名为names.c的其他文件。
So I'm going to go ahead and create a different file here called names.c.

798
00:38:16,849 --> 00:38:18,599
我将以类似的方式开始。
And I'm going to start a little similarly.

799
00:38:18,599 --> 00:38:23,459
我将在顶部包含cs50.h，在顶部将包含stdio。
I'm going to include cs50.h at the top, I'm going to include stdio at the top.

800
00:38:23,460 --> 00:38:26,332
但是我这次也要包含string.h，
But I'm also this time going to include string.h,

801
00:38:26,331 --> 00:38:28,039
这是我们上周简要介绍的，因此
which we introduced briefly last week, so

802
00:38:28,039 --> 00:38:31,109
我们可以使用strlen来获取字符串的长度，
that we have access to strlen for getting the length of a string,

803
00:38:31,110 --> 00:38:33,100
事实证明，还有其他一些功能。
and, it turns out, some other functions.

804
00:38:33,099 --> 00:38:35,789
让我继续照常声明int main void。
Let me go ahead and declare int main void as usual.

805
00:38:35,789 --> 00:38:38,189
然后在这里，我需要一些任意名称。
And then inside here, I need some arbitrary names.

806
00:38:38,190 --> 00:38:40,260
因此，我们在这里拿出七个名字。
So let's come up with seven names here.

807
00:38:40,260 --> 00:38:43,825
在这里，我也可以像以前一样声明一个数组。
And here, too, I can declare an array just as I did before.

808
00:38:43,824 --> 00:38:45,449
但是它不必只存储整数。
But it doesn't have to store only ints.

809
00:38:45,449 --> 00:38:47,399
它可以存储字符串。
It can store strings instead.

810
00:38:47,400 --> 00:38:49,560
因此，我将数据类型从int更改为string，
So I've changed the data type from int to string,

811
00:38:49,559 --> 00:38:52,479
并且我已经将变量名称从数字更改为名称。
and I've changed the variable name from numbers to names.

812
00:38:52,480 --> 00:38:55,350
而且我仍然可以使用这种新的花括号符号，
And I can still use this new curly brace notation,

813
00:38:55,349 --> 00:39:01,469
我可以给自己起个名字，例如比尔（Bill），也许是查理（Charlie），也许是弗雷德（Fred），
and I can give myself a name like Bill, and maybe Charlie, and maybe Fred,

814
00:39:01,469 --> 00:39:07,479
也许是乔治，也许是金妮，也许是珀西，最后，
and maybe George, and maybe Ginny, and maybe Percy, and lastly,

815
00:39:07,480 --> 00:39:09,510
也许像罗恩这样的名字。
maybe a name like Ron.

816
00:39:09,510 --> 00:39:12,700
而且它几乎不适合我的屏幕。
And it just barely fits on my screen.

817
00:39:12,699 --> 00:39:16,109
这样说，我现在有了这个名称数组。
So with that said, I now have this array of names.

818
00:39:16,110 --> 00:39:19,620
除此之外，对于他们来说，也许还有一个显而易见的模式，
And beyond there being a perhaps obvious pattern to them,

819
00:39:19,619 --> 00:39:23,309
对他们来说，还有第二种不太明显的，或者也许是显而易见的模式。
there's a second less obvious, or maybe obvious, pattern to them.

820
00:39:23,309 --> 00:39:28,589
您将如何描述我刚刚想出的名字列表？
How would you describe the list of names I arbitrarily just came up with?

821
00:39:28,590 --> 00:39:31,350
它们的有用特性是什么？
What's a useful characteristic of them?

822
00:39:31,349 --> 00:39:34,409
您对这些名字有什么注意？
What do you notice about these names?

823
00:39:34,409 --> 00:39:37,529
我认为这个问题至少有两个正确答案。
And there's at least two right answers to this question, I think.

824
00:39:37,530 --> 00:39:40,370
您对这些名字有什么注意？
What do you notice about these names?

825
00:39:40,369 --> 00:39:41,532
杰克？
Jack?

826
00:39:41,532 --> 00:39:43,199
听众：它们是按字母顺序排列的。
AUDIENCE: They're in alphabetical order.

827
00:39:43,199 --> 00:39:43,499
戴维·马兰：是的。
DAVID MALAN: Yes.

828
00:39:43,500 --> 00:39:46,331
因此，除了成为哈利·波特（Harry Potter）中的韦斯莱（Weasley）孩子的名字之外，
So beyond being the names of the Weasley children in Harry Potter,

829
00:39:46,331 --> 00:39:47,789
它们也按字母顺序排列。
they're also in alphabetical order.

830
00:39:47,789 --> 00:39:49,079
这是更重要的细节。
And that's the more salient detail.

831
00:39:49,079 --> 00:39:50,969
为了我们的目的，我已经有了深谋远虑
For our purposes, I've had the forethought

832
00:39:50,969 --> 00:39:53,339
这次要预先对这些名称进行排序。
this time to sort these names in advance.

833
00:39:53,340 --> 00:39:56,580
如果我对这些名称进行了排序，则意味着
And if I've sorted these names, that means implicitly

834
00:39:56,579 --> 00:39:59,669
我可以使用比线性搜索更好的算法。
I can use a better algorithm than linear search.

835
00:39:59,670 --> 00:40:02,160
例如，我可以使用旧的二进制搜索。
I can use, for instance, our old binary search.

836
00:40:02,159 --> 00:40:05,614
但是，让我们先进行一下，然后就立即对其进行天真搜索。
But let's go ahead first and just search them naively for now.

837
00:40:05,614 --> 00:40:07,739
让我们继续应用线性搜索，因为您知道，
Let's still apply linear search, because, you know,

838
00:40:07,739 --> 00:40:12,924
我们还没有做的是必须将字符串相互比较。
what we haven't yet done is necessarily compare strings against one another.

839
00:40:12,925 --> 00:40:15,300
我们已经做了大量的数字比较，例如整数。
We've done a lot of comparisons of numbers like integers.

840
00:40:15,300 --> 00:40:16,178
但是名字呢？
But what about names?

841
00:40:16,177 --> 00:40:17,469
因此，让我继续执行此操作。
So let me go ahead and do this.

842
00:40:17,469 --> 00:40:22,199
所以对于int来说，我得到0，就像以前一样，我小于7，我++-
So for int i gets 0, just like before, i less than 7, i++--

843
00:40:22,199 --> 00:40:25,199
我之所以这样做，是因为我事先知道有七个名字。
and I'm doing this only because I know in advance there are seven names.

844
00:40:25,199 --> 00:40:27,629
我认为我们可能可以改进此代码的设计，
I think we could probably improve the design of this code,

845
00:40:27,630 --> 00:40:31,200
也可以通过具有存储该值的变量或常量来实现。
too, by having a variable or a constant storing that value.

846
00:40:31,199 --> 00:40:34,469
但是我将保持简单，现在仅关注新细节。
But I'm going to keep it simple and focus only on the new details for now.

847
00:40:34,469 --> 00:40:38,279
事实证明，由于某些原因，我们将在下周进行更详细的探讨，
And it turns out, for reasons we'll explore in more detail next week,

848
00:40:38,280 --> 00:40:42,560
仅仅做我们以前做的事情并做这样的事情是不够的
it is not sufficient to do what we did before and do something like this

849
00:40:42,559 --> 00:40:44,329
如果我要搜索“罗恩”。
if I'm searching for "Ron."

850
00:40:44,329 --> 00:40:49,339
事实证明，在C语言中，不能使用equals equals来比较两个字符串。
It turns out that in C, you can't use equals equals to compare two strings.

851
00:40:49,340 --> 00:40:52,080
您可以为整数，也可以为字符。
You can for an int, you can for a char.

852
00:40:52,079 --> 00:40:53,869
过去，我们都做到了。
And we've done both of those in the past.

853
00:40:53,869 --> 00:40:57,919
但是有一个微妙之处，我们下周将详细介绍，
But there's a subtlety that we'll dive into in more detail next week that

854
00:40:57,920 --> 00:41:00,003
表示您实际上无法执行此操作。
means you can't actually do this.

855
00:41:00,003 --> 00:41:02,420
这很好奇，因为如果您事先进行过编程
And this is curious, because if you have prior programming

856
00:41:02,420 --> 00:41:06,270
具备Python之类的语言经验，您可以执行此操作。
experience in languages like Python or the like, you can do this.

857
00:41:06,269 --> 00:41:09,769
因此，在C语言中您不能这样做，但是下次我们将看到原因。
So in C you can't, but we'll see next time why.

858
00:41:09,769 --> 00:41:13,039
但是现在，事实证明C可以解决这个问题，
But for now, it turns out that C can solve this problem,

859
00:41:13,039 --> 00:41:15,599
从历史上看，您执行此操作的方法是使用函数。
and historically the way you do this is with a function.

860
00:41:15,599 --> 00:41:18,559
因此，在string.h头文件中，
So inside of the string.h header file, there

861
00:41:18,559 --> 00:41:22,789
不仅是strlen的声明，还像上周一样是字符串的长度。
is not only a declaration for strlen, the length of a string like last week.

862
00:41:22,789 --> 00:41:25,399
还有另一个名为strcmp的函数。
There's another function called strcmp.

863
00:41:25,400 --> 00:41:29,000
简称为STRCMP的“搅拌比较”，
And "stir compare," for short, S-T-R-C-M-P,

864
00:41:29,000 --> 00:41:33,589
允许我传递两个字符串，一个要与之比较的字符串
allows me to pass in two strings, one string that I want to compare against

865
00:41:33,590 --> 00:41:34,880
另一个字符串。
another string.

866
00:41:34,880 --> 00:41:37,250
因此语法并不完全相同。
So it's not quite the same syntax.

867
00:41:37,250 --> 00:41:38,830
确实，这有点难读。
Indeed, it's a little harder to read.

868
00:41:38,829 --> 00:41:40,579
它不像平等一样简单。
It's not quite as simple as equals equals.

869
00:41:40,579 --> 00:41:43,759
但是strcmp，如果我们阅读了它的文档，
But strcmp, if we read the documentation for it,

870
00:41:43,760 --> 00:41:46,430
会告诉我们这比较两个字符串。
will tell us that this compares two strings.

871
00:41:46,429 --> 00:41:49,159
并且它返回三个可能值之一。
And it returns one of three possible values.

872
00:41:49,159 --> 00:41:54,409
如果这两个字符串相等，即字母对字母相同，
If those two strings are equal, that is, identically the same letter for letter,

873
00:41:54,409 --> 00:41:58,549
然后该函数将返回0，结果是。
then this function is going to return 0, it turns out.

874
00:41:58,550 --> 00:42:03,470
如果第一个字符串应该在第二个字符串之前
If the first string is supposed to come before the second string

875
00:42:03,469 --> 00:42:06,759
从某种意义上讲，按字母顺序排列
alphabetically, in some sense, then this function

876
00:42:06,760 --> 00:42:09,140
将返回负值。
is going to return a negative value.

877
00:42:09,139 --> 00:42:13,549
如果第一个字符串应该按字母顺序排在第二个字符串之后，
If the first string is supposed to come after the second string alphabetically,

878
00:42:13,550 --> 00:42:16,320
如果可以的话，它将返回一个正值。
if you will, then it's going to return a positive value.

879
00:42:16,320 --> 00:42:20,690
因此，存在三种可能的结果-等于0或小于0，
So there's three possible outcomes-- either equal to 0, or less than 0,

880
00:42:20,690 --> 00:42:22,460
或大于0。
or greater than 0.

881
00:42:22,460 --> 00:42:26,090
但是您会注意到，实际上，如果您看了一段时间的文档，
But you'll notice, and in fact, if you look at the documentation some time,

882
00:42:26,090 --> 00:42:30,890
它不会指定小于0的值或大于0的值。
it doesn't specify what value less than 0 or what value greater than 0.

883
00:42:30,889 --> 00:42:34,789
您只需要检查任何负值或正值即可。
You have to just check for any negative value or any positive value.

884
00:42:34,789 --> 00:42:37,069
我刚才也讲了一个白色的谎言。
And I also told a bit of a white lie a moment ago.

885
00:42:37,070 --> 00:42:39,620
这不会按字母顺序检查内容，
This does not check things alphabetically,

886
00:42:39,619 --> 00:42:42,529
即使有时碰巧也是如此。
even though it coincidentally does sometimes.

887
00:42:42,530 --> 00:42:45,590
实际上是按所谓的ASCII顺序比较字符串，
Actually compares strings in what's called ASCII order,

888
00:42:45,590 --> 00:42:49,670
或ASCIIbetically，这是一种愚蠢的描述方式
or ASCIIbetically which is kind of a goofy way of describing

889
00:42:49,670 --> 00:42:54,830
此函数从左到右查看两个字符串中的每个字符，
this function looks at every character in the two strings, from left to right,

890
00:42:54,829 --> 00:42:59,569
它检查它们的ASCII值，然后比较那些ASCII值
it checks the ASCII values of them, and then it compares those ASCII values

891
00:42:59,570 --> 00:43:01,440
逐个字符。
character by character.

892
00:43:01,440 --> 00:43:03,680
如果ASCII值小于另一个，
And if the ASCII value is less than the other,

893
00:43:03,679 --> 00:43:06,779
然后返回负值，反之亦然。
then it returns a negative value or vice versa.

894
00:43:06,780 --> 00:43:10,790
因此，例如，如果字符串中包含字母A，大写A，
So if you have, for instance, the letter A, capital A in the string,

895
00:43:10,789 --> 00:43:12,962
首先转换为65。
that gets converted first to 65.

896
00:43:12,963 --> 00:43:15,380
然后，如果另一个字符串中的A大写，
And then if you have an A in the other string capitalized,

897
00:43:15,380 --> 00:43:18,455
它也被比较为65，这将是相等的。
it, too, gets compared to 65, and those would be equal.

898
00:43:18,454 --> 00:43:21,079
但是，当然，所有这些名称都有一个以上的字符，
But of course, all of these names have more than one character,

899
00:43:21,079 --> 00:43:25,619
因此，此ASCII顺序（即ASCIIbetical）在从左到右的前面
so this ASCII order, or ASCIIbetical, precedes left to right

900
00:43:25,619 --> 00:43:29,749
这样strcmp会为您检查名称中的每个字符。
so that strcmp checks every character in the names for you.

901
00:43:29,750 --> 00:43:33,290
当它碰到终止的空字符时，它将停止。
And it stops when it hits that terminating null character.

902
00:43:33,289 --> 00:43:35,479
回想一下引擎盖下面的琴弦，
Recall that strings, underneath the hood,

903
00:43:35,480 --> 00:43:39,780
总是以这个反斜杠0或8个0位以C结尾。
always end in C with this backslash 0, or eight 0 bits.

904
00:43:39,780 --> 00:43:43,470
这就是strcmp知道何时停止比较值的方式。
So that's how strcmp knows when to stop comparing values.

905
00:43:43,469 --> 00:43:46,256
但是如果我继续寻找像罗恩这样的人，那就让我继续吧
But if I go ahead and find someone like Ron, let me go ahead

906
00:43:46,257 --> 00:43:47,840
并打印出引号，取消引号“ Found”。
and print out quote, unquote, "Found."

907
00:43:47,840 --> 00:43:50,840
和以前一样，我会继续前进，就像黛咪建议的那样，
And like before, I'll go ahead and return, like Demi proposed,

908
00:43:50,840 --> 00:43:54,710
0，仅表示一切成功。
0, just to imply that all is successful.

909
00:43:54,710 --> 00:43:57,360
否则，如果我们一直深入到代码的底部，
Otherwise, if we get all the way to the bottom of my code,

910
00:43:57,360 --> 00:44:00,620
我将打印出“未找到”的故事，以告诉我们我们没有
I'm going to print out "Not found" to tell the story that we did not

911
00:44:00,619 --> 00:44:04,309
即使罗恩碰巧在那儿，也能找到罗恩
find Ron in this array, even though he does happen to be there,

912
00:44:04,309 --> 00:44:06,569
我将继续并返回1。
and I'm going to go ahead and return 1.

913
00:44:06,570 --> 00:44:08,480
因此，即使我已经对所有内容进行了硬编码-
So even though I've hardcoded everything--

914
00:44:08,480 --> 00:44:11,960
在程序中对某些内容进行硬编码意味着要明确输入-
to hardcode something in a program means to type it out explicitly--

915
00:44:11,960 --> 00:44:15,200
您可以想象使用上周这样的命令行参数
you could imagine using a command line argument like last week

916
00:44:15,199 --> 00:44:16,309
获取用户的输入。
to get user's input.

917
00:44:16,309 --> 00:44:17,719
您想搜寻谁？
Who would you like to search for?

918
00:44:17,719 --> 00:44:20,899
您可以想象使用get_string来获取用户的输入并询问他们，
You could imagine using get_string to get user's input and ask them,

919
00:44:20,900 --> 00:44:22,460
您想搜寻谁？
who would you like to search for?

920
00:44:22,460 --> 00:44:26,150
但是现在，仅出于演示目的，我仅使用了罗恩的名字。
But for now, just for demonstration sake, I've used only Ron's name.

921
00:44:26,150 --> 00:44:28,310
如果我没有打错字，
And if I haven't made any typos--

922
00:44:28,309 --> 00:44:35,029
让我继续输入make name，Enter，到目前为止，。/ names很好。
let me go ahead and type in make names, Enter, so far so good, ./names.

923
00:44:35,030 --> 00:44:37,400
希望我们会看到的确是“发现”
And hopefully, we'll see, indeed, "Found,"

924
00:44:37,400 --> 00:44:42,140
因为“罗恩”在七个兄弟姐妹的数组中非常多。
because "Ron" is very much in this array of seven siblings.

925
00:44:42,139 --> 00:44:44,119
但是这里的新组成部分
But the building blocks that are new here

926
00:44:44,119 --> 00:44:47,539
再次是当我们声明某个固定大小的数组时
are, again, the fact that when we declare an array of some fixed size

927
00:44:47,539 --> 00:44:49,579
我们严格不需要在这里输入数字，
we don't strictly need to put a number here,

928
00:44:49,579 --> 00:44:51,889
当我们有大括号表示法时
and we have this curly brace notation when we

929
00:44:51,889 --> 00:44:54,109
事先了解数组的内容。
know the array's contents in advance.

930
00:44:54,110 --> 00:44:56,150
但也许最后也是最有力的是，我们
But perhaps lastly and most powerfully, we

931
00:44:56,150 --> 00:45:01,730
在C中确实有一个称为strcmp的函数，它将允许我们实际
do have this function in C called strcmp that will allow us to actually

932
00:45:01,730 --> 00:45:05,370
以这种方式存储和比较字符串。
store and compare strings in this way.

933
00:45:05,369 --> 00:45:07,549
所以让我在这里暂停一下，只是问是否有
So let me pause here and just ask if there's

934
00:45:07,550 --> 00:45:12,320
关于我们如何将这些想法转换为数字编码的任何疑问，
any questions about how we translated these ideas to code for numbers,

935
00:45:12,320 --> 00:45:15,650
以及我们现在如何将这些想法转换为代码
and how we translated these ideas to code for now

936
00:45:15,650 --> 00:45:19,280
名称，每次使用线性搜索，而不是二进制。
names, each time using linear search, not, binary.

937
00:45:19,280 --> 00:45:21,670
迦勒，有问题吗？
Caleb, question?

938
00:45:21,670 --> 00:45:22,400
听众：是的。
AUDIENCE: Yeah.

939
00:45:22,400 --> 00:45:29,585
因此，如果“ Ron”就像所有大写字母一样，该程序仍然可以正常工作，
So would that program still work if "Ron," for example, was like all caps,

940
00:45:29,585 --> 00:45:30,960
例如，如果您要搜索-
like if you're trying to search--

941
00:45:30,960 --> 00:45:35,643
例如，如果大小写不同，情况是否相同？
like, if the cases are different in terms of uppercase and lowercase?

942
00:45:35,643 --> 00:45:37,060
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

943
00:45:37,059 --> 00:45:40,509
让我提出一个对总体而言很有用的本能-
And let me propose an instinct that's useful to acquire in general--

944
00:45:40,510 --> 00:45:41,457
如有疑问，请尝试。
when in doubt, try it.

945
00:45:41,456 --> 00:45:42,789
因此，我将确切地做到这一点。
So I'm going to do exactly that.

946
00:45:42,789 --> 00:45:44,997
我碰巧知道答案，但假设我没有。
I do happen to know the answer, but suppose I didn't.

947
00:45:44,998 --> 00:45:47,560
让我继续，将“ Ron”更改为全部大写，仅仅是因为。
Let me go ahead and change "Ron" to all caps, just because.

948
00:45:47,559 --> 00:45:49,419
可能是人类按下了Caps Lock键，
Maybe the human, the Caps Lock key was on,

949
00:45:49,420 --> 00:45:51,220
然后他们有点草率地打字。
and they typed it in a little sloppily.

950
00:45:51,219 --> 00:45:53,299
让我继续进行，不要进行其他更改。
Let me go ahead and make no other changes.

951
00:45:53,300 --> 00:45:57,820
请注意，我将仅使用大写字母R保留原始数组。
Notice that I'm leaving the original array alone with only a capital R.

952
00:45:57,820 --> 00:46:01,900
让我重新制作该程序，命名为./names。
Let me remake this program, make name, ./names.

953
00:46:01,900 --> 00:46:06,950
瞧，他仍然被发现了。
And voila, he's still, in fact, found.

954
00:46:10,860 --> 00:46:11,570
支持。
Stand by.

955
00:46:14,690 --> 00:46:15,960
哦好的。
Oh, OK.

956
00:46:19,909 --> 00:46:22,279
Caleb，您刚刚帮助我发掘了一个错误
Caleb, you have just helped me unearth, a bug that

957
00:46:22,280 --> 00:46:23,810
在前面的示例中是潜在的。
was latent in the previous example.

958
00:46:23,809 --> 00:46:26,599
你们都不应该接受这个事实
None of you should have accepted the fact

959
00:46:26,599 --> 00:46:29,316
以前的程序与“ RON”一起使用，因为我没有
that the previous program worked with "RON," because I didn't

960
00:46:29,317 --> 00:46:30,900
从字面上练习我的讲道。
practice literally what I'm preaching.

961
00:46:30,900 --> 00:46:34,070
卡莱布，请稍等片刻，以便我可以倒带一点
So Caleb, hold that thought for just a moment so I can rewind a little bit

962
00:46:34,070 --> 00:46:35,540
并修复我的明显错误。
and fix my apparent bug.

963
00:46:35,539 --> 00:46:37,339
因此确实发现了“ RON”。
So "RON" was indeed found.

964
00:46:37,340 --> 00:46:39,650
但是没有找到他，因为找到了“ RON”。
But he wasn't found because "RON" was found.

965
00:46:39,650 --> 00:46:41,240
我在这里做了一些愚蠢的事情。
I did something stupid here.

966
00:46:41,239 --> 00:46:45,439
而且也许在教学上更合适
And it's perhaps all the more pedagogically appropriate

967
00:46:45,440 --> 00:46:47,420
现在强调一下。
now to highlight that.

968
00:46:47,420 --> 00:46:53,870
因此，该程序如何说“ Ron”被找到，即使这次也
So how did this program say "Ron" was found, even though this time it also

969
00:46:53,869 --> 00:46:57,049
说在所有大写字母中都找到了“ RON”？
says "RON" was found in all caps?

970
00:46:57,050 --> 00:47:00,480
你知道吗，让我在这里有点好奇。
And you know what, let me get a little curious here.

971
00:47:00,480 --> 00:47:03,920
让我继续搜索，甚至不要搜索“罗恩”。
Let me go ahead and search for, not even "Ron."

972
00:47:03,920 --> 00:47:07,310
我们如何搜索罗恩的妈妈“莫莉”？
How about we search for Ron's mom, "Molly"?

973
00:47:07,309 --> 00:47:08,599
做名字。
Make names.

974
00:47:08,599 --> 00:47:09,679
好的。
All right.

975
00:47:09,679 --> 00:47:14,329
现在，为了说明我确实做了一些愚蠢的事情，。/ names。
And now, just to reveal that I really did do something stupid, ./names.

976
00:47:14,329 --> 00:47:16,909
好吧，现在明显有问题吧？
OK, now something's clearly wrong, right?

977
00:47:16,909 --> 00:47:22,472
我什至可以搜索父亲“亚瑟”（Arthur），命名为./name。
I can even search for the father "Arthur", make names, ./name.

978
00:47:22,472 --> 00:47:25,639
看来我写了一个程序，该程序实际上总是说“找到”。
It seems that I wrote you a program that just literally always says "Found."

979
00:47:25,639 --> 00:47:27,829
因此，我们不应该接受这种说法是正确的。
So we shouldn't have accepted this as correct.

980
00:47:27,829 --> 00:47:32,869
到目前为止，谁能根据我的定义发现该错误？
Can anyone spot the bug based on my definition thus far?

981
00:47:32,869 --> 00:47:34,879
任何人都可以发现该错误吗？
Can anyone spot the bug?

982
00:47:34,880 --> 00:47:38,900
同时，这不是放鸭的好时机
In the meantime, this isn't really a bad time to open up the duck

983
00:47:38,900 --> 00:47:41,130
并说：“你好，鸭子。
and say, "Hello, duck.

984
00:47:41,130 --> 00:47:50,240
我遇到一个问题，我的程序始终在打印找到
I am having a problem whereby my program is always printing Found

985
00:47:50,239 --> 00:47:54,319
即使有人不在阵列中。
even when someone is not in the array.

986
00:47:54,320 --> 00:47:56,630
我可以继续向鸭子解释我的逻辑，
And I could proceed to explain my logic to the duck,

987
00:47:56,630 --> 00:48:00,640
但希望索菲亚能比鸭子更快地指出解决方案。
but hopefully Sophia can point me at the solution even faster than the duck.

988
00:48:00,639 --> 00:48:03,349
观众：您需要比较我们的价值
AUDIENCE: You need to compare the value that we

989
00:48:03,349 --> 00:48:05,909
从strcmp收到的东西。
received from strcmp with something.

990
00:48:05,909 --> 00:48:08,029
因此，我们需要将其与0进行比较，并确保
So we need to compare it with like 0 and make sure

991
00:48:08,030 --> 00:48:11,265
我们得到了他们相等的价值。
that we receive the value that they're equal.

992
00:48:11,264 --> 00:48:12,139
大卫·马兰（David MALAN）：完美。
DAVID MALAN: Perfect.

993
00:48:12,139 --> 00:48:16,399
所以我说了正确的事，但我确实没有做正确的事。
So I said the right thing, but I literally did not do the right thing.

994
00:48:16,400 --> 00:48:19,070
如果我想检查是否相等，我会按字面意思
If I want to check for equality, I literally

995
00:48:19,070 --> 00:48:22,580
比较名称括号i时需要检查返回值
need to check the return value when comparing names bracket i

996
00:48:22,579 --> 00:48:24,379
反对“罗恩”等于0。
against "Ron" to equal 0.

997
00:48:24,380 --> 00:48:28,130
因为仅在strcmp的返回值为0的情况下
Because only in the case when the return value of strcmp is 0

998
00:48:28,130 --> 00:48:31,280
我真的有比赛吗？
do I actually have a match.

999
00:48:31,280 --> 00:48:36,590
相反，如果函数返回负值或函数
By contrast, if the function returns a negative value or the function

1000
00:48:36,590 --> 00:48:39,470
返回一个正值，这意味着它不是一个匹配项。
returns a positive value, that means it's not a match.

1001
00:48:39,469 --> 00:48:42,229
这意味着一个名字应该先于另一个名字
That means that one name is supposed to come before the other

1002
00:48:42,230 --> 00:48:44,240
或之后。
or after the other.

1003
00:48:44,239 --> 00:48:47,869
但是，这里的速记语法并不总是适用
But the catch with my shorthand syntax here, which is not always

1004
00:48:47,869 --> 00:48:52,879
每当内部有布尔表达式时，都会使用不正确的语法
an incorrect syntax to use, whenever you have a Boolean expression inside

1005
00:48:52,880 --> 00:48:56,340
其中是这样的函数调用-
of which is a function call like this--

1006
00:48:56,340 --> 00:48:58,550
注意我整个布尔表达式
notice that the entirety of my Boolean expression

1007
00:48:58,550 --> 00:49:01,830
可以这么说，这只是给strcmp的电话。
is just a call, so to speak, to strcmp.

1008
00:49:01,829 --> 00:49:06,349
我传入了两个输入，名称括弧i和引号，取消引号“ Ron”。
I'm passing in two inputs, names bracket i and quote, unquote "Ron."

1009
00:49:06,349 --> 00:49:10,069
因此，我期望strcmp返回输出，即所谓的return
And therefore, I'm expecting strcmp to return output, a so-called return

1010
00:49:10,070 --> 00:49:10,730
价值。
value.

1011
00:49:10,730 --> 00:49:15,200
该返回值将是负数或正数或0。
That return value is going to be negative or positive or 0.

1012
00:49:15,199 --> 00:49:18,529
实际上，要明确的是，是否要搜索名字
And in fact, to be clear, if the first name being searched

1013
00:49:18,530 --> 00:49:22,760
对于“ Bill”和名称括号i或名称括号0
for is "Bill" and names bracket i or names bracket 0

1014
00:49:22,760 --> 00:49:26,540
是“比尔”，“比尔”逗号，“罗恩”实际上是什么
is "Bill," "Bill" comma "Ron" is effectively what

1015
00:49:26,539 --> 00:49:28,729
我的输入是在第一次迭代中。
my input is on the first iteration.

1016
00:49:28,730 --> 00:49:31,820
“帐单”，按字母顺序和ASCII，按字母顺序，
"Bill," alphabetically and ASCIIbetically,

1017
00:49:31,820 --> 00:49:34,520
在“罗恩”之前，这意味着它应该
comes before "Ron," which means it should

1018
00:49:34,519 --> 00:49:36,979
向我返回负值。
be returning a negative value to me.

1019
00:49:36,980 --> 00:49:41,450
在这种情况下，布尔表达式的问题在于
And the problem with Boolean expressions is, as implemented in this context,

1020
00:49:41,449 --> 00:49:44,869
是只有0为假。
is that only 0 is false.

1021
00:49:44,869 --> 00:49:50,239
根据定义，任何其他返回值都为true或“是”，
Any other return value is by definition true or a Yes answer,

1022
00:49:50,239 --> 00:49:53,809
无论是负数1还是正数1，负数100万
whether it's negative 1 or positive 1, negative 1 million

1023
00:49:53,809 --> 00:49:55,339
或正数100万-
or positive 1 million--

1024
00:49:55,340 --> 00:49:58,850
计算机语言（例如C）中的任何非零值
any non-zero value in a computer language like C

1025
00:49:58,849 --> 00:50:02,659
被认为是真实的，也被称为真实。
is considered true, also known as truthy.

1026
00:50:02,659 --> 00:50:06,259
任何值为0的值都被视为false，但仅
Any value that is 0 is considered false, but only

1027
00:50:06,260 --> 00:50:07,880
该值被认为是错误的。
that value is considered false.

1028
00:50:07,880 --> 00:50:12,560
真的，起初我很幸运，因为我的程序正在查找“帐单”，
So really, I was getting lucky at first, because my program was finding "Bill,"

1029
00:50:12,559 --> 00:50:14,449
但是我把“比尔”换成了“罗恩”。
but I was confusing "Bill" for "Ron."

1030
00:50:14,449 --> 00:50:17,959
然后，当我再次为Caleb做这件事时，我大写了“ Ron”，
Then when I did it again for Caleb and I capitalized "Ron,"

1031
00:50:17,960 --> 00:50:20,690
我变得不走运，因为突然之间我
I was getting unlucky, because suddenly I

1032
00:50:20,690 --> 00:50:23,030
知道大写的“ RON”不在数组中，
knew "RON" capitalized wasn't in the array,

1033
00:50:23,030 --> 00:50:24,590
但是我仍然说他被发现了。
and yet I'm still saying he's found.

1034
00:50:24,590 --> 00:50:28,580
但这是因为我没有按照索菲亚的发现去实践我所讲的道。
But that's because I didn't practice what I preach per Sophia's find.

1035
00:50:28,579 --> 00:50:31,489
因此，如果我将其实际与0进行比较-现在，Caleb，
And so if I actually compare this against 0-- and now, Caleb,

1036
00:50:31,489 --> 00:50:33,259
我们全盘回答您的问题-
we come full circle to your question--

1037
00:50:33,260 --> 00:50:37,970
我用make名称重建该程序，现在执行./names并搜索所有内容
I rebuild this program with make names, I now do ./names and search for all

1038
00:50:37,969 --> 00:50:43,279
大写“ RON”，幸运的是，现在我应该看到“未找到”。
caps "RON," I should now see, thankfully, "Not found."

1039
00:50:43,280 --> 00:50:46,550
所以我希望我可以说是故意的，但是因此
So I wish I could say that was deliberate, but thus

1040
00:50:46,550 --> 00:50:48,410
是bug的常见情况。
is the common case of bugs.

1041
00:50:48,409 --> 00:50:50,819
因此，在20年后的今天，我在代码中产生了错误。
So here I am 20 years later making bugs in my code.

1042
00:50:50,820 --> 00:50:53,360
因此，如果您本周遇到类似的问题，
So if you run up to a similar problem this week,

1043
00:50:53,360 --> 00:50:58,910
放心，它永远不会结束。
rest assured that it never ends.

1044
00:50:58,909 --> 00:51:01,429
但是希望你不会有几个人看着你
But hopefully you won't have several people watching you

1045
00:51:01,429 --> 00:51:03,119
在您本周解决问题时。
while you do your problem set this week.

1046
00:51:03,119 --> 00:51:03,619
好的。
All right.

1047
00:51:03,619 --> 00:51:05,659
那么，除了Caleb的问题之外，还有其他问题吗？
Any questions, then, beyond Caleb's?

1048
00:51:05,659 --> 00:51:07,639
卡勒布（Caleb）真是个好问题，答案是否定的。
So great question, Caleb, and the answer is no.

1049
00:51:07,639 --> 00:51:09,539
区分大小写。
It is case sensitive.

1050
00:51:09,539 --> 00:51:11,779
因此它找不到“ Rob”
So it does not find "Rob"--

1051
00:51:11,780 --> 00:51:13,270
“ RON。”
"RON."

1052
00:51:13,269 --> 00:51:16,529
有什么问题吗？
Any questions here?

1053
00:51:16,530 --> 00:51:20,640
对使用字符串进行线性搜索有任何疑问吗？
Any questions on linear search using strings?

1054
00:51:20,639 --> 00:51:21,139
不？
No?

1055
00:51:21,139 --> 00:51:24,229
好吧，让我们继续做一个最后的例子，我想，
All right, well, let's go ahead and do one final example, I think,

1056
00:51:24,230 --> 00:51:25,280
搜索。
with searching.

1057
00:51:25,280 --> 00:51:27,260
但是，让我们仅介绍另一个功能。
But let's introduce just one other feature.

1058
00:51:27,260 --> 00:51:29,540
而且这个实际上很酷而且功能强大。
And this one's actually pretty cool and powerful.

1059
00:51:29,539 --> 00:51:33,349
到目前为止，我们一直在使用C附带的数据类型
Up until now, we've been using data types that just come with C

1060
00:51:33,349 --> 00:51:37,769
或来自CS50，例如int，char，float等。
or come from CS50, like int, and char, and float, and the like.

1061
00:51:37,769 --> 00:51:41,329
现在您会看到实际上有时
And you'll see now that there's actually sometimes

1062
00:51:41,329 --> 00:51:44,569
您或我可能想要创建自己的自定义数据类型的原因，
reasons where you or I might want to create our own custom data types,

1063
00:51:44,570 --> 00:51:48,500
我们自己的类型，这些类型在发明C本身时就不存在。
our own types that didn't exist when C itself was invented.

1064
00:51:48,500 --> 00:51:51,890
例如，假设我想代表的不仅仅是
So for instance, suppose that I wanted to represent not just

1065
00:51:51,889 --> 00:51:54,439
一堆数字，而不仅仅是一堆名字，
a whole bunch of numbers and not just a whole bunch of names,

1066
00:51:54,440 --> 00:51:57,065
但是假设我想像完整的电话簿一样实施。
but suppose I want to implement like a full-fledged phone book.

1067
00:51:57,065 --> 00:52:00,110
电话簿当然包含名称和号码。
A phone book, of course, contains both names and numbers.

1068
00:52:00,110 --> 00:52:02,870
并假设我想将这两个想法结合在一起。
And suppose I want to combine these two ideas together.

1069
00:52:02,869 --> 00:52:06,949
如果我可以有一个数据结构，那会不会很好
Wouldn't it be nice if I could have a data structure that

1070
00:52:06,949 --> 00:52:10,549
是具有某种结构的数据类型，它实际上可以
is a data type that has some structure to it that can actually

1071
00:52:10,550 --> 00:52:11,850
一次存储两个？
store both at once?

1072
00:52:11,849 --> 00:52:16,669
实际上，如果C拥有一个名为person的数据类型，那会不会很好，
And in fact, wouldn't it be nice if C had a data type called person,

1073
00:52:16,670 --> 00:52:19,550
因此，如果我想代表一个人，例如电话簿中的人，
so that if I want to represent a person, like in a phone book, who

1074
00:52:19,550 --> 00:52:22,490
既有名字又有数字，我可以
had both a name and a number, I can actually

1075
00:52:22,489 --> 00:52:27,319
通过调用人员类型的变量来实现该代码？
implement that and code by calling that variable of type person?

1076
00:52:27,320 --> 00:52:30,170
现在，当然，C的设计师没有远见
Now, of course, the designers of C did not have the foresight

1077
00:52:30,170 --> 00:52:32,308
创建一个称为人员的数据类型。
to create a data type called person.

1078
00:52:32,307 --> 00:52:34,099
实际上，那将是一个湿滑的斜坡
And, indeed, that would be a slippery slope

1079
00:52:34,099 --> 00:52:37,819
如果您可以想到每个现实世界实体的数据类型。
if they had a data type for every real-world entity you can think of.

1080
00:52:37,820 --> 00:52:40,830
但是它们确实为我们提供了执行此操作的能力。
But they did give us the capabilities to do this.

1081
00:52:40,829 --> 00:52:44,809
因此，如果一个人在我们这里有限的电话簿中，
So if a person, in our limited world here of phone books,

1082
00:52:44,809 --> 00:52:49,609
既有名称又有数字，我们可能会这样认为：
has both a name and a number, we might think of it as follows--

1083
00:52:49,610 --> 00:52:51,770
名称和数字，均为string类型。
a name and a number, both of type string.

1084
00:52:51,769 --> 00:52:53,059
但是在这里快速检查。
But a quick check here.

1085
00:52:53,059 --> 00:52:56,329
为什么现在我有些自以为是地决定，
Why have I now decided, somewhat presumptuously,

1086
00:52:56,329 --> 00:53:00,109
也可以拨打电话号码字符串？
to call phone numbers strings as well?

1087
00:53:00,110 --> 00:53:02,360
我们一直在谈论这些门后面的整数。
We've been talking about ints behind these doors.

1088
00:53:02,360 --> 00:53:04,580
我们一直在寻找代码中的整数。
We've been searching for ints in code.

1089
00:53:04,579 --> 00:53:08,149
但是为什么我只想建议我们
But why did I just presume to propose that we instead

1090
00:53:08,150 --> 00:53:12,560
使用字符串作为名称和数字来实现电话簿？
implement a phone book using strings for names and numbers?

1091
00:53:12,559 --> 00:53:14,649
在这里有什么想法吗，库尔特？
Any thoughts here, Kurt?

1092
00:53:14,650 --> 00:53:16,070
听众：是的。
AUDIENCE: Yeah.

1093
00:53:16,070 --> 00:53:17,570
因为我们没有对此进行数学运算。
Because we're not doing math on it.

1094
00:53:17,570 --> 00:53:21,065
就像-电话号码可能就像我们关心的所有字母一样。
It's like-- a phone number could be, like, letters for all we care.

1095
00:53:21,065 --> 00:53:22,940
实际上，我的意思是，有时您会看到，
And in fact, I mean, sometimes you see, like,

1096
00:53:22,940 --> 00:53:26,160
1-800联系人或类似的内容，也许我们想允许它。
1-800 Contacts or something like that, and maybe we want to allow that.

1097
00:53:26,159 --> 00:53:27,409
大卫·马兰（David MALAN）：是的，绝对如此。
DAVID MALAN: Yeah, absolutely.

1098
00:53:27,409 --> 00:53:30,779
电话号码尽管有名字，但不一定只是一个数字。
A phone number, despite its name, isn't necessarily just a number.

1099
00:53:30,780 --> 00:53:33,710
可能是1-800个Contacts，这是一个英文单词。
It might be 1-800 Contacts, which is an English word.

1100
00:53:33,710 --> 00:53:36,020
它可能带有连字符或破折号。
It might have hyphens in it or dashes.

1101
00:53:36,019 --> 00:53:37,639
它可能带有括号。
It might have parentheses in it.

1102
00:53:37,639 --> 00:53:39,799
国家代码可能带有加号。
It might have a plus sign for country codes.

1103
00:53:39,800 --> 00:53:41,720
我们绝对有很多角色
There's a lot of characters that we absolutely

1104
00:53:41,719 --> 00:53:46,256
可以使用我们无法使用int在C中表示的字符串在C中表示。
can represent in C using strings that we couldn't represent in C using int.

1105
00:53:46,257 --> 00:53:48,090
的确如此，即使在现实世界中
And so indeed, even though in the real world

1106
00:53:48,090 --> 00:53:51,710
您和我会不时谈论这些“数字”，例如电话
there are these "numbers" that you and I talk about once in a while like phone

1107
00:53:51,710 --> 00:53:55,580
号码，例如美国社会保险号，信用卡号，
numbers, maybe in the US Social Security numbers, credit card numbers,

1108
00:53:55,579 --> 00:54:00,169
这些不一定是您要视为实际整数的值。
those aren't necessarily values that you want to treat as actual integers.

1109
00:54:00,170 --> 00:54:02,570
实际上，你们中那些发生信用问题的人
And in fact, those of you who did the credit problem

1110
00:54:02,570 --> 00:54:04,760
并尝试验证信用卡号
and tried to validate credit card numbers

1111
00:54:04,760 --> 00:54:08,720
可能会很长一段时间用信用来表示挑战
may very well have run into challenges by using a long to represent a credit

1112
00:54:08,719 --> 00:54:09,649
卡号。
card number.

1113
00:54:09,650 --> 00:54:11,900
回想起来也许很好
It probably in retrospect might very well

1114
00:54:11,900 --> 00:54:15,560
您可以更轻松地将信用卡号视为字符串。
have been easier for you to treat credit card numbers as strings.

1115
00:54:15,559 --> 00:54:17,809
当然，要抓住的地方是您还没有
The catch, of course, by design is that you didn't yet

1116
00:54:17,809 --> 00:54:21,409
至少在C语言中，您的词汇表中包含字符串。
have strings in your vocabulary, at least in C yet.

1117
00:54:21,409 --> 00:54:23,389
所以假设我要创建自己的自定义数据
So suppose I want to create my own custom data

1118
00:54:23,389 --> 00:54:27,799
如果可以的话，它封装两种不同类型的值。
type that encapsulates, if you will, two different types of values.

1119
00:54:27,800 --> 00:54:31,430
此后，一个人将是一个名字和一个数字。
A person shall be henceforth a name and a number.

1120
00:54:31,429 --> 00:54:34,849
事实证明，C在这里为我们提供了这种语法。
It turns out that C gives us this syntax here.

1121
00:54:34,849 --> 00:54:39,769
这是除了那些花括号之外唯一的多汁的新语法
This is the only juicy piece of new syntax besides those curly braces

1122
00:54:39,769 --> 00:54:42,879
不久之前，我们今天将在C中看到typedef。
a moment ago that we'll see today in C, typedef.

1123
00:54:42,880 --> 00:54:44,810
顾名思义，
And as the name rather succinctly suggests,

1124
00:54:44,809 --> 00:54:47,239
这使您可以定义类型。
this allows you to define a type.

1125
00:54:47,239 --> 00:54:50,119
类型将是某种结构。
And the type will be a structure of some sort.

1126
00:54:50,119 --> 00:54:52,609
因此，一种编程语言中的数据结构
So a data structure in a programming language

1127
00:54:52,610 --> 00:54:56,600
通常是具有某种结构的数据类型。
is typically a data type that has some structure to it.

1128
00:54:56,599 --> 00:54:57,979
我们所说的“结构”是什么意思？
What do we mean by "structure"?

1129
00:54:57,980 --> 00:55:01,610
它通常在其中具有一个或多个值。
It typically has one or more values inside of it.

1130
00:55:01,610 --> 00:55:04,940
因此，使用typedef，然后使用struct关键字，
So using typedef, and in turn using the struct keyword,

1131
00:55:04,940 --> 00:55:06,770
我们可以创建自己的自定义类型
we can create our own custom types that's

1132
00:55:06,769 --> 00:55:10,319
一个结构，由多个其他数据类型组成。
a structure, a composition of multiple other data types.

1133
00:55:10,320 --> 00:55:14,360
因此，如果我们想让人们在一起作为他们自己的自定义数据类型，
So if we want to keep persons together as their own custom data type,

1134
00:55:14,360 --> 00:55:15,890
语法在这里有点晦涩难懂。
the syntax is a little cryptic here.

1135
00:55:15,889 --> 00:55:19,309
您实际上是用typedef struct打开花括号的，
You literally do typedef struct open curly brace,

1136
00:55:19,309 --> 00:55:22,136
然后每行指定一个您想要的数据类型
then one per line you specify the data types that you want

1137
00:55:22,137 --> 00:55:24,470
以及您要为这些数据类型指定的名称，
and the names that you want to give to those data types,

1138
00:55:24,469 --> 00:55:26,269
例如名称和编号。
for instance name and number.

1139
00:55:26,269 --> 00:55:28,849
然后在右花括号外面，
And then outside of the closing curly brace,

1140
00:55:28,849 --> 00:55:33,289
如果您确实是数据类型，则应直接输入“人”一词
you literally put the word "person," if that's indeed the data type

1141
00:55:33,289 --> 00:55:35,279
您想发明的。
that you want to invent.

1142
00:55:35,280 --> 00:55:37,790
那么我们如何才能更有效地使用它呢？
So how can we use this more powerfully?

1143
00:55:37,789 --> 00:55:42,019
好吧，让我们继续前进，以错误的方式做事，而不先使用此功能，
Well, let's go ahead and do things the wrong way without this feature first,

1144
00:55:42,019 --> 00:55:44,059
从而激发它的存在。
so as to motivate its existence.

1145
00:55:44,059 --> 00:55:47,015
让我继续将此文件另存为phonebook.c。
Let me go ahead and save this file as phonebook.c.

1146
00:55:47,016 --> 00:55:50,420
让我像往常一样从包含cs50.h开始。
And let me start, as always, with includes cs50.h.

1147
00:55:50,420 --> 00:55:53,030
然后让我继续并包含stdio.h。
And then let me go ahead and include stdio.h.

1148
00:55:53,030 --> 00:55:56,180
最后，让我也包含string.h，
And then lastly, let me also include string.h,

1149
00:55:56,179 --> 00:55:59,099
因为我知道我稍后会处理一些字符串。
because I know I'm going to be manipulating some strings in a moment.

1150
00:55:59,099 --> 00:56:03,199
现在让我继续前进，在我的主要职责范围内，让我继续前进
Let me go ahead now, and within my main function, let me go ahead

1151
00:56:03,199 --> 00:56:06,049
首先给我自己，作为该程序的第一个版本，
and give myself initially, for the first version of this program,

1152
00:56:06,050 --> 00:56:07,370
一堆名字。
a whole bunch of names.

1153
00:56:07,369 --> 00:56:10,939
具体来说，“布莱恩”逗号“大卫”怎么样？
Specifically, how about "Brian" comma "David"?

1154
00:56:10,940 --> 00:56:15,200
我们将其简短，以便仅关注思想而非实际数据
We'll keep it short, just so as to focus on the ideas and not the actual data

1155
00:56:15,199 --> 00:56:15,861
他们进来了。
they're in.

1156
00:56:15,862 --> 00:56:17,570
然后我和Brian都有电话号码。
Then Brian and I each have phone numbers.

1157
00:56:17,570 --> 00:56:19,890
因此，让我们继续将它们存储在一个数组中-
So let's go ahead and store them in an array--

1158
00:56:19,889 --> 00:56:28,889
数字等于，再次像以前一样使用花括号，以及+ 1-617-495-1000--
numbers equals, again the curly braces as before, and +1-617-495-1000--

1159
00:56:28,889 --> 00:56:32,669
实际上，按照库尔特（Kurt）的评论，已经有动机使用字符串，
and indeed, there's already motivation, per Kurt's comment, to use strings,

1160
00:56:32,670 --> 00:56:35,250
因为那里有一个加号和几个破折号-
because we've got a plus and a couple of dashes in there--

1161
00:56:35,250 --> 00:56:36,459
然后是我的电话号码
and then my number here.

1162
00:56:36,460 --> 00:56:43,020
因此，我们将做+ 1-949-468-2750右花括号，分号。
So we'll do +1-949-468-2750 close curly brace, semicolon.

1163
00:56:43,019 --> 00:56:45,899
因此，我继续声明了两个数组，其中一个称为名称，
So I've gone ahead and declared two arrays, one called names,

1164
00:56:45,900 --> 00:56:47,040
一个叫数字。
one called numbers.

1165
00:56:47,039 --> 00:56:52,409
我将要达成某种握手协议
And I'm just going to have sort of a handshake agreement

1166
00:56:52,409 --> 00:56:56,379
名称中的名字对应于数字中的名字，
that the first name in names corresponds to the first number in numbers,

1167
00:56:56,380 --> 00:56:59,702
名称中的第二个名称对应于数字中的第二个数字。
the second name in names corresponds to the second number in numbers.

1168
00:56:59,702 --> 00:57:02,910
您可以想象只要您不犯任何错误，就能很好地工作，
And you can imagine that working well so long as you don't make any mistakes,

1169
00:57:02,909 --> 00:57:04,949
而且每个数字都有正确的数字
and you have just the right number in each.

1170
00:57:04,949 --> 00:57:08,519
现在让我继续并做int我等于0，我小于2--
Now let me go ahead and do int i equals 0, i less than 2--

1171
00:57:08,519 --> 00:57:11,579
我现在将仅对硬编码进行演示。
I'm going to keep that hardcoded for now just to do the demonstration.

1172
00:57:11,579 --> 00:57:14,909
然后在这个循环中，让我继续搜索我的电话号码，
And then inside of this loop, let me go ahead and search for my phone number,

1173
00:57:14,909 --> 00:57:17,349
例如，即使我碰巧在最后。
for instance, even though I happen to be at the end.

1174
00:57:17,349 --> 00:57:22,589
所以如果名字括号的strcmp我等于-
So if strcmp of names bracket i equals--

1175
00:57:22,590 --> 00:57:27,360
逗号“ David”等于0
rather, comma "David" equals equals 0--

1176
00:57:27,360 --> 00:57:29,200
所以我不会再犯这个错误了。
so I'm not going to make that mistake again.

1177
00:57:29,199 --> 00:57:37,289
让我在此循环内，在此条件内继续进行。
Let me go ahead inside of this loop, inside of this condition here.

1178
00:57:37,289 --> 00:57:41,649
我将继续进行以下操作-打印出我发现的内容，
And I'm going to go ahead and do the following-- print out that I found,

1179
00:57:41,650 --> 00:57:43,910
例如我的电话号码。
for instance my number.

1180
00:57:43,909 --> 00:57:45,159
我要插入它。
And I'm going to plug that in.

1181
00:57:45,159 --> 00:57:47,729
所以数字括起来。
So numbers bracket i.

1182
00:57:47,730 --> 00:57:50,430
然后像以前一样，我将继续并返回0。
And then as before, I'm going to go ahead and return 0.

1183
00:57:50,429 --> 00:57:54,089
如果所有这些都没有解决，而我碰巧不在这个数组中，
And if none of this works out, and I happen not to be in this array,

1184
00:57:54,090 --> 00:57:59,200
我将继续打印，并像以前一样用分号打印“未找到”。
I'll go ahead and print out as before "Not found" with a semicolon.

1185
00:57:59,199 --> 00:58:00,869
然后我将任意返回1。
And then I'll return 1 arbitrarily.

1186
00:58:00,869 --> 00:58:03,749
我可以返回负1，我可以返回一百万，负一百万。
I can return negative 1, I could return a million, negative million.

1187
00:58:03,750 --> 00:58:07,529
但是人类的惯例通常会让您从0变到1到2变到3
But human convention would typically have you go from 0 to 1 to 2 to 3

1188
00:58:07,530 --> 00:58:11,050
继续，如果您有那么多可能的错误情况。
on up, if you have that many possible error conditions.

1189
00:58:11,050 --> 00:58:11,760
好的。
All right.

1190
00:58:11,760 --> 00:58:14,730
因此，我基本上在C中实现了各种电话簿。
So I essentially have implemented in C a phone book of sorts.

1191
00:58:14,730 --> 00:58:16,710
我们在第0周以口头方式进行了此操作。
We did this verbally in week 0.

1192
00:58:16,710 --> 00:58:17,987
现在，我正在用代码来做。
Now I'm doing it in code.

1193
00:58:17,987 --> 00:58:19,070
这是一本有限的电话簿。
It's a limited phone book.

1194
00:58:19,070 --> 00:58:21,030
它只有两个名字和两个数字。
It's only got two names and two numbers.

1195
00:58:21,030 --> 00:58:22,988
但我当然可以实施这本电话簿
But I could certainly implement this phone book

1196
00:58:22,987 --> 00:58:26,229
通过使用两个数组，两个并行数组，如果您愿意的话，
by just using two arrays, two parallel arrays, if you will,

1197
00:58:26,230 --> 00:58:29,490
通过仅使用第一个元素和名称行的荣誉系统
by just using the honor system that the first element and names lines

1198
00:58:29,489 --> 00:58:32,071
与第一个元素和数字，依此类推。
up with the first elements and numbers and so forth.

1199
00:58:32,072 --> 00:58:33,780
现在希望，如果我不做任何错别字，
Now hopefully, if I don't make any typos,

1200
00:58:33,780 --> 00:58:36,030
让我继续制作电话簿。
let me go ahead and make phonebook.

1201
00:58:36,030 --> 00:58:36,530
好的。
All right.

1202
00:58:36,530 --> 00:58:41,440
它编译OK。 ./phonebook，然后发现那里似乎是我的电话号码。
It compiled OK. ./phonebook, and it found what seems to be my number there.

1203
00:58:41,440 --> 00:58:45,040
因此，它似乎正常工作，尽管我已尝试将其拉到您的身上
So it seems to work correctly, though I've tried to pull that one over you

1204
00:58:45,039 --> 00:58:45,539
前。
before.

1205
00:58:45,539 --> 00:58:48,099
但是我敢肯定，这实际上是可以正常工作的。
But I'm pretty sure this one actually works correctly.

1206
00:58:48,099 --> 00:58:51,989
因此，我们找到了我的名字和依次的号码。
And so we found my name and in turn number.

1207
00:58:51,989 --> 00:58:57,029
但是，为什么此代码的设计不一定是最好的？
But why is the design of this code not necessarily the best?

1208
00:58:57,030 --> 00:59:00,090
诚然，这开始变得越来越微妙。
This is starting to get more subtle, admittedly.

1209
00:59:00,090 --> 00:59:02,980
而且我们已经看到我们可以以不同的方式进行操作。
And we've seen that we can do this differently.

1210
00:59:02,980 --> 00:59:05,372
但是，什么使您对这里的错误方式感到困惑呢？
But what rubs you the wrong way about here?

1211
00:59:05,371 --> 00:59:07,829
这是我们称为“代码气味”的另一个示例。
This is another example of what we might call "code smell."

1212
00:59:07,829 --> 00:59:10,709
就像，这里有点时髦，像，啊，这个
Like, something's a little funky here, like, ah, this

1213
00:59:10,710 --> 00:59:13,500
长期来看，尼克可能不是最好的解决方案，您怎么看？
might not be the best solution long term Nick, what do you think?

1214
00:59:13,500 --> 00:59:14,125
听众：是的。
AUDIENCE: Yeah.

1215
00:59:14,125 --> 00:59:15,377
所以我猜是
So what I'm guessing is that--

1216
00:59:15,378 --> 00:59:18,420
例如，您知道在新数据结构之前如何制作数据框，
like, you know how you made the data frame before the new data structure,

1217
00:59:18,420 --> 00:59:20,920
这两件事在哪里联系在一起？
where the two things were linked together?

1218
00:59:20,920 --> 00:59:23,010
在这种情况下，我们只是依靠事实
In this case, we're just banking on the fact

1219
00:59:23,010 --> 00:59:27,270
我们不会搞砸并且无意间取消链接
that we don't screw something up and unintentionally unlink them

1220
00:59:27,269 --> 00:59:29,389
来自相同的索引。
from the same index.

1221
00:59:29,389 --> 00:59:32,811
因此，它们之间没有内在的联系，这可能不是-
So they're not intrinsically linked, which might not be--

1222
00:59:32,811 --> 00:59:34,769
戴维·马兰（David MALAN）：这是正确的本能。
DAVID MALAN: That's exactly the right instinct.

1223
00:59:34,769 --> 00:59:38,789
总的来说，就像您渴望成为一名程序员一样伟大，
In general, as great as a programmer as you're maybe aspiring to be,

1224
00:59:38,789 --> 00:59:39,689
你还不是全部。
you're not all that.

1225
00:59:39,690 --> 00:59:41,357
就像，您将要犯错误。
And like, you're going to make mistakes.

1226
00:59:41,356 --> 00:59:44,699
而且，您可以编写更多的自卫代码，
And the more you can write code that's self-defensive,

1227
00:59:44,699 --> 00:59:47,879
保护您免受自己伤害，您将获得更好的生活，
that protects you from yourself, the better off you're going to be,

1228
00:59:47,880 --> 00:59:49,890
您的代码越正确，
the more correct your code is going to be,

1229
00:59:49,889 --> 00:59:53,459
而且您将更容易成功地进行协作，
and the more easily you're going to be able to collaborate successfully,

1230
00:59:53,460 --> 00:59:56,710
如果您在现实世界中选择，在现实世界中的编程项目中，
if you so choose in the real world, on real-world programming projects,

1231
00:59:56,710 --> 00:59:59,520
是否用于研究项目，全职工作，个人项目
whether for a research project, a full-time job, a personal project

1232
00:59:59,519 --> 01:00:00,209
或类似的东西。
or the like.

1233
01:00:00,210 --> 01:00:04,290
一般来说，您不应该信任自己或其他人
Generally speaking, you should not trust yourself or other people

1234
01:00:04,289 --> 01:00:06,059
与您一起编写代码的人
that-- with whom you're writing code, you

1235
01:00:06,059 --> 01:00:11,319
应该沿着这些路线建立尽可能多的防御机制。
should have as many defense mechanisms in place exactly along these lines.

1236
01:00:11,320 --> 01:00:15,030
所以是的，我所做的一切都没有错
So yes, there's nothing wrong with what I have done in the sense

1237
01:00:15,030 --> 01:00:16,620
这是正确的。
that this is correct.

1238
01:00:16,619 --> 01:00:21,479
但是如前所述，如果您搞砸了，也许您因一个错误而失败了-
But as noted, if you screw up, and maybe you get an off by one error--

1239
01:00:21,480 --> 01:00:24,210
也许您调换了两个名字或两个数字。
maybe you transpose two names or two numbers.

1240
01:00:24,210 --> 01:00:26,910
我的意思是，假设您有很多名字和数字，
I mean, imagine if you've got dozens of names and numbers,

1241
01:00:26,909 --> 01:00:29,219
数百个名称和数字，其中数千个
hundreds of names and numbers, thousands of them

1242
01:00:29,219 --> 01:00:32,819
您或某人将订单弄乱的几率
the odds that you or someone messes the order up at some point

1243
01:00:32,820 --> 01:00:35,370
可能太高了。
is just probably going to be too, too high.

1244
01:00:35,369 --> 01:00:39,249
因此，如果我们可以将相关数据保持在一起，那就太好了。
So it would be nice, then, if we could sort of keep related data together.

1245
01:00:39,250 --> 01:00:42,805
只是在荣誉系统上说，我的阵列排列整齐，
This is kind of a hack, to just on the honor system say, my arrays line up,

1246
01:00:42,804 --> 01:00:45,179
我只是要确保它们的长度相同。
I'm just going to make sure to keep them the same length.

1247
01:00:45,179 --> 01:00:46,109
我们可以做得更好。
We can do better.

1248
01:00:46,110 --> 01:00:51,030
让我们将相关数据保持在一起，并对其进行更简洁的设计。
Let's keep related data together and design this a little more cleanly.

1249
01:00:51,030 --> 01:00:53,570
我可以通过定义自己的类型来做到这一点
And I can do this by defining my own type

1250
01:00:53,570 --> 01:00:55,650
例如，我将称呼一个人。
that I'll call for instance, a person.

1251
01:00:55,650 --> 01:00:58,790
因此，在此文件的开头，在main之前，我是
So at the top of this file, before main, I'm

1252
01:00:58,789 --> 01:01:01,829
继续在内部定义一个结构
going to go ahead and typedef a structure, inside

1253
01:01:01,829 --> 01:01:04,379
我关心的是两种类型的数据，
of which are the two types of data that I care about,

1254
01:01:04,380 --> 01:01:08,520
字符串名称和字符串编号，与以前一样。
string name and string number, just as before.

1255
01:01:08,519 --> 01:01:15,029
但是请注意，这里我所做的并不是给自己一个数组。
Notice, though, here that what I have done here is not give myself an array.

1256
01:01:15,030 --> 01:01:17,738
我给自己起了一个名字和一个号码。
I've given myself one name and one number.

1257
01:01:17,737 --> 01:01:20,279
在花括号之外，我将提供此数据类型
Outside of this curly brace, I'm going to give this data type

1258
01:01:20,280 --> 01:01:21,690
一个名字，我可以称之为“人”。
a name, which I could call "person."

1259
01:01:21,690 --> 01:01:23,482
我可以叫它任何我想要的东西，但是人
I could call it anything I want, but person

1260
01:01:23,481 --> 01:01:25,409
在这种情况下似乎很合理。
seems pretty reasonable in this case.

1261
01:01:25,409 --> 01:01:29,889
现在，在这里，我将继续进行一些更改。
And now down here, I'm going to go ahead and change this code a little bit.

1262
01:01:29,889 --> 01:01:32,369
我要继续给自己一个数组，
I'm going to go ahead and give myself an array still,

1263
01:01:32,369 --> 01:01:36,239
但是这次我要给自己一些人。
but this time I'm going to give myself an array of persons.

1264
01:01:36,239 --> 01:01:39,359
我将以某种调皮的方式将其称为“人”，
And I'm going to call that array, somewhat playfully, "people,"

1265
01:01:39,360 --> 01:01:44,940
因为我想在这个程序中有两个人，两个人，我和布莱恩。
because I want to have two persons, two people, in this program, me and Brian.

1266
01:01:44,940 --> 01:01:47,215
现在，我要继续并填充此数组。
Now I want to go ahead and populate this array.

1267
01:01:47,215 --> 01:01:48,840
也就是说，我想用值填充它。
That is, I want to fill it with values.

1268
01:01:48,840 --> 01:01:50,940
这个语法有点新，但这只是
And this syntax is a little new, but it's just

1269
01:01:50,940 --> 01:01:55,230
使我们能够将值实际存储在结构内部。
to enable us to actually store values inside of a structure.

1270
01:01:55,230 --> 01:01:58,050
如果我想索引到这个数组，有
If I want to index into this array, there's

1271
01:01:58,050 --> 01:01:59,460
与上周没什么不同。
nothing different from last week.

1272
01:01:59,460 --> 01:02:01,380
我将人括号设为0。
I do people bracket 0.

1273
01:02:01,380 --> 01:02:06,270
这会给我里面的第一人称变量，所以大概在哪里
That's going to give me the first person variable inside, so probably where

1274
01:02:06,269 --> 01:02:07,889
“布莱恩”应该走了。
"Brian" is supposed to go.

1275
01:02:07,889 --> 01:02:10,349
我需要的最后一句语法是如何
The one last piece of syntax I need is how do I

1276
01:02:10,349 --> 01:02:14,729
进入那个结构，那个人数据结构，
go inside of that structure, that person data structure,

1277
01:02:14,730 --> 01:02:16,450
并访问此人的名字？
and access the person's name?

1278
01:02:16,449 --> 01:02:17,709
我实际上只是做一个点。
I literally just do a dot.

1279
01:02:17,710 --> 01:02:22,620
因此，人员括号0使我成为人员数组中的第一个人。
So people bracket 0 gives me the first person in the people array.

1280
01:02:22,619 --> 01:02:26,579
然后，点表示进入其中并获取person变量。
And then the dot means, go inside of it and grab the person variable.

1281
01:02:26,579 --> 01:02:29,879
我将继续将该名称设置为引号，取消引号“ Brian”。
I'm going to go ahead and set that name equal to quote, unquote "Brian."

1282
01:02:29,880 --> 01:02:31,990
现在，他的名字的语法几乎是相同的-
The syntax now for his name is almost identical--

1283
01:02:31,989 --> 01:02:39,629
人括号0点号等于引号，取消引号“ + 1-617-495-1000”
people bracket 0 dot number equals quote, unquote "+1-617-495-1000"

1284
01:02:39,630 --> 01:02:40,740
分号。
semicolon.

1285
01:02:40,739 --> 01:02:43,091
同时，如果我想自己访问一个位置，
Meanwhile, if I want to access a location for myself,

1286
01:02:43,092 --> 01:02:45,300
我要继续将它放在位置1
I'm going to go ahead and put it at location 1, which

1287
01:02:45,300 --> 01:02:46,620
是第二个位置。
is the second location.

1288
01:02:46,619 --> 01:02:48,629
名称将用引号引起来，而不用引号“ David”。
Name will be, quote, unquote "David."

1289
01:02:48,630 --> 01:02:52,020
然后在这里，我将把方括号1点号等于
And then over here, I'm going to do people bracket 1 dot number equals

1290
01:02:52,019 --> 01:02:59,249
引号，取消引号“ + 1-949-468-2750”，引号，分号。
quote, unquote "+1-949-468-2750" close quote, semicolon.

1291
01:02:59,250 --> 01:03:01,319
诚然，这有点冗长。
So it's a bit verbose, admittedly.

1292
01:03:01,320 --> 01:03:05,430
但是您可以想象，如果我们让我们的思想超越自我
But you could imagine, if we just let our thoughts run ahead of ourselves

1293
01:03:05,429 --> 01:03:08,369
在这里，如果您使用了get_string，可以自动执行此操作。
here, if you used get_string, could sort of automatically do this.

1294
01:03:08,369 --> 01:03:11,452
如果您使用了命令行参数，也许您可以填充其中的一些。
If you used command line arguments, maybe you could populate some of this.

1295
01:03:11,452 --> 01:03:14,189
我们不仅需要硬编码，也就是写下我的姓名和电话号码
We don't just have to hardcode, that is, write my name and number

1296
01:03:14,190 --> 01:03:15,668
布赖恩（Brian）进入了这个计划。
and Brian's into this program.

1297
01:03:15,668 --> 01:03:17,460
您可以想象更动态地执行此操作
You can imagine doing this more dynamically

1298
01:03:17,460 --> 01:03:20,700
从第一周开始，使用我们的一些技术，使用get_string等。
using some of our techniques, using get_string and so forth, from week 1.

1299
01:03:20,699 --> 01:03:22,919
但是现在，这只是为了演示。
But for now, it's just for demonstration's sake.

1300
01:03:22,920 --> 01:03:29,040
所以现在如果我要搜索这个新的数组，这个新的单个数组的人，
So now if I want to search this new array, this new single array of people,

1301
01:03:29,039 --> 01:03:31,409
我认为我的for循环可以保持不变。
I think my for loop can stay the same.

1302
01:03:31,409 --> 01:03:33,989
而且我认为我仍然可以使用strcmp。
And I think I can still use strcmp.

1303
01:03:33,989 --> 01:03:38,969
但是现在我需要进入的不是名字而是人，
But now I need to go inside of not names but people,

1304
01:03:38,969 --> 01:03:41,739
并查找点名称字段。
and look for the dot name field.

1305
01:03:41,739 --> 01:03:45,007
因此，数据结构内部具有字段或变量。
So data structures have fields or variables inside of them.

1306
01:03:45,007 --> 01:03:46,799
所以我将在此处使用点符号，
So I'm going to use the dot notation there,

1307
01:03:46,800 --> 01:03:50,670
同样，进入人员阵列中的第i个人，
too, go into the i-th person in the people array,

1308
01:03:50,670 --> 01:03:53,610
并将该名称与引号，未引号“ David”进行比较。
and compare that name against, for instance, quote, unquote "David."

1309
01:03:53,610 --> 01:03:57,300
然后，如果我自己找到了“大卫”，
And then if I have found "David," in this case myself,

1310
01:03:57,300 --> 01:04:01,920
继续并再次访问人员数组，但使用printf打印
go ahead and access the people array again, but print out using printf

1311
01:04:01,920 --> 01:04:02,830
数字。
the number.

1312
01:04:02,829 --> 01:04:05,819
同样，点运算符是唯一的新语法
So again, the dot operator is the only new piece of syntax

1313
01:04:05,820 --> 01:04:10,120
这让我们进入了称为数据结构的新功能。
that's letting us go inside of this new feature known as a data structure.

1314
01:04:10,119 --> 01:04:12,929
如果我在进行了这些更改之后继续制作电话簿，
If I go ahead and make phonebook again after making those changes,

1315
01:04:12,929 --> 01:04:13,609
一切都很好。
all is well.

1316
01:04:13,610 --> 01:04:14,850
它编译OK。
It compiled OK.

1317
01:04:14,849 --> 01:04:20,409
而且，如果我运行./phonebook，现在希望可以再次找到我的电话号码。
And if I run ./phonebook, I now have hopefully found my number again.

1318
01:04:20,409 --> 01:04:24,419
所以这似乎是无用的练习，因为
So here is a seemingly useless exercise, in that all

1319
01:04:24,420 --> 01:04:28,050
我真正要做的是使用更多的代码行来重新实现同一程序
I really did was re-implement the same program using more lines of code

1320
01:04:28,050 --> 01:04:29,630
并使它变得更加复杂。
and making it more complicated.

1321
01:04:29,630 --> 01:04:31,460
但是现在它的设计更好了。
But it's now better designed.

1322
01:04:31,460 --> 01:04:34,130
还是朝着更好的设计迈出了一步，因为现在我已经
Or it's a step toward being better designed, because now I've

1323
01:04:34,130 --> 01:04:38,330
将所有内容封装在一个变量内，例如，人括号0，
encapsulated all inside of one variable, for instance, people bracket 0,

1324
01:04:38,329 --> 01:04:42,589
人括号1，我们关心的有关Brian的所有信息，
people bracket 1, all of the information we care about with respect to Brian,

1325
01:04:42,590 --> 01:04:46,800
或我，或者我们可能会加入此程序的其他任何人。
or me, or anyone else we might put into this program.

1326
01:04:46,800 --> 01:04:49,880
的确，这就是程序，这就是Google的世界，
And indeed, this is how programs, this is how Googles, of the world,

1327
01:04:49,880 --> 01:04:52,520
世界各地的Facebook将大量信息存储在一起。
Facebooks of the world store lots of information together.

1328
01:04:52,519 --> 01:04:55,219
考虑一下您的任何社交媒体帐户（例如Instagram），
Consider any of your social media accounts like Instagram,

1329
01:04:55,219 --> 01:04:57,229
或Facebook，或Snapchat等。
or Facebook, or Snapchat and the like.

1330
01:04:57,230 --> 01:04:59,810
您有多个关联的数据
You have multiple pieces of data associated

1331
01:04:59,809 --> 01:05:02,809
与您在所有这些平台上合作-不只是您的用户名
with you on all of those platforms-- not just your username

1332
01:05:02,809 --> 01:05:06,049
还有您的密码，您的帖子历史记录，
but also your password, also your history of posts,

1333
01:05:06,050 --> 01:05:08,265
还有你的朋友和追随者之类的。
also your friends and followers and the like.

1334
01:05:08,264 --> 01:05:11,389
因此，有很多信息表明这些公司，不管情况好坏，
So there's a lot of information that these companies, for better for worse,

1335
01:05:11,389 --> 01:05:12,949
正在收集我们所有人。
are collecting on all of us.

1336
01:05:12,949 --> 01:05:17,659
您能想象他们是否只有一个包含我们所有用户名的大型阵列，
And can you imagine if they just had one big array with all of our usernames,

1337
01:05:17,659 --> 01:05:21,891
一个包含我们所有密码的大型阵列，一个包含我们所有朋友的大型阵列？
one big array with all of our passwords, one big array with all of our friends?

1338
01:05:21,891 --> 01:05:23,599
就像，您可以肯定地想像一下，
Like, you can imagine certainly at scale,

1339
01:05:23,599 --> 01:05:26,417
要相信这肯定是一个糟糕的设计
that's got to be a bad design, to just trust

1340
01:05:26,418 --> 01:05:29,210
您将正确处理所有这些事情。
that you're going to get the ordering of all of these things right.

1341
01:05:29,210 --> 01:05:30,110
他们不那样做。
They don't do that.

1342
01:05:30,110 --> 01:05:34,040
相反，他们用某种语言编写的代码以某种方式封装
They instead write code in some language that somehow encapsulates

1343
01:05:34,039 --> 01:05:36,589
与我和布莱恩有关的所有信息
all the information related to me and Brian

1344
01:05:36,590 --> 01:05:39,620
和您进入某种数据结构。
and you inside of some kind of data structure.

1345
01:05:39,619 --> 01:05:43,369
那就是他们放入数据库或其他服务器的内容
And that's what they put in their database or some other server

1346
01:05:43,369 --> 01:05:44,359
在他们的后端。
on their back end.

1347
01:05:44,360 --> 01:05:47,720
因此，这种封装是我们现在使用C的一项功能。
So this encapsulation is a feature we now have in terms of C.

1348
01:05:47,719 --> 01:05:51,739
它允许我们创建自己的数据结构，然后可以使用
And it allows us to create our own data structures that we can then use

1349
01:05:51,739 --> 01:05:56,089
为了使相关数据保持在一起。
in order to keep related data together.

1350
01:05:56,090 --> 01:05:59,990
好吧，关于数据结构的任何问题，或者更多
All right, any questions, then, on data structures, or more

1351
01:05:59,989 --> 01:06:04,129
特别是typedef和struct，C关键字
specifically typedef and struct, the C keywords

1352
01:06:04,130 --> 01:06:08,360
使用它可以创建自己的自定义类型
with which you can create your own custom types

1353
01:06:08,360 --> 01:06:10,760
本身就是数据结构？
that themselves are data structures?

1354
01:06:10,760 --> 01:06:11,720
贝斯利？
Besley?

1355
01:06:11,719 --> 01:06:12,589
听众：嗨。
AUDIENCE: Hi.

1356
01:06:12,590 --> 01:06:17,450
因此，通常在main之外定义新的数据结构，例如
So is it typical to define the new data structure outside of main, like

1357
01:06:17,449 --> 01:06:17,949
在标题中？
in a header?

1358
01:06:17,949 --> 01:06:19,366
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

1359
01:06:19,367 --> 01:06:22,070
在main之外定义新的数据结构是否很典型？
Is it typical to define a new data structure outside of main?

1360
01:06:22,070 --> 01:06:23,270
通常是的。
Quite often yes.

1361
01:06:23,269 --> 01:06:26,269
在这种情况下，这无关紧要，因为我只有
In this case, it's immaterial, because I only have

1362
01:06:26,269 --> 01:06:28,189
这个程序的一个功能是main。
one function in this program, main.

1363
01:06:28,190 --> 01:06:30,530
但是正如我们将在本周，下周及以后看到的那样，
But as we'll see this week and next week and onward,

1364
01:06:30,530 --> 01:06:34,370
我们的程序将开始变得更加复杂
our programs are going to start to get a little more complicated by nature

1365
01:06:34,369 --> 01:06:35,929
只是具有更多功能。
of just having more features.

1366
01:06:35,929 --> 01:06:38,986
并且，一旦拥有更多功能，您可能就会拥有更多功能。
And once you have more features, you probably have more functions.

1367
01:06:38,987 --> 01:06:41,570
而且，当您拥有更多功能时，您就需要数据结构
And when you have more functions, you want your data structure

1368
01:06:41,570 --> 01:06:44,930
可供所有这些功能使用。
to be available to all of those functions.

1369
01:06:44,929 --> 01:06:49,099
因此，我们将开始看到其中一些结构的定义，
And so we'll begin to see definition of some of these structures being,

1370
01:06:49,099 --> 01:06:51,619
确实，超出了我们自己的职能范围。
indeed, outside of our own functions.

1371
01:06:51,619 --> 01:06:52,999
彼得，交给你。
Peter, over to you.

1372
01:06:53,000 --> 01:06:54,020
听众：哦，是的。
AUDIENCE: Oh, yeah.

1373
01:06:54,019 --> 01:06:58,159
稍后我们将在头文件中定义新的类吗？
Will we define new classes in header files later,

1374
01:06:58,159 --> 01:07:00,349
还是我们会继续在main之外定义它们？
or will we keep defining them outside of main?

1375
01:07:00,349 --> 01:07:01,766
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

1376
01:07:01,766 --> 01:07:05,429
我们可以在头文件中定义自己的类型和数据结构吗？
Might we define our own types and our own data structures in header files?

1377
01:07:05,429 --> 01:07:05,929
是的。
Yes.

1378
01:07:05,929 --> 01:07:07,219
最终，我们也会这样做。
Eventually we'll do that, too.

1379
01:07:07,219 --> 01:07:11,209
到目前为止，您和我仅使用了其他人编写的头文件。
Thus far, you and I have only been using header files that other people wrote.

1380
01:07:11,210 --> 01:07:15,770
我们一直在使用C的作者创建的stdio.h，string.h。
We've been using stdio.h, string.h, that the authors of C created.

1381
01:07:15,769 --> 01:07:19,069
您一直在使用我们工作人员写的cs50.h。
You've been using cs50.h which we the staff wrote.

1382
01:07:19,070 --> 01:07:23,210
事实证明，您还可以创建自己的头文件，自己的.h文件，
It turns out, you can also create your own header files, your own .h files,

1383
01:07:23,210 --> 01:07:27,870
其中包含您要在多个文件中共享的代码段
inside of which are pieces of code that you want to share across multiple files

1384
01:07:27,869 --> 01:07:28,369
你自己。
of your own.

1385
01:07:28,369 --> 01:07:29,452
我们还没到那儿。
We're not quite there yet.

1386
01:07:29,452 --> 01:07:32,989
但是是的，彼得，这将是解决这个问题的方法
But yes, Peter, that would be a solution to this problem

1387
01:07:32,989 --> 01:07:36,129
通过将其放在一个中央位置。
by putting it in one central place.

1388
01:07:36,130 --> 01:07:37,580
Thiago，交给您。
Thiago, over to you.

1389
01:07:41,119 --> 01:07:43,369
听众：我是-
AUDIENCE: I was--

1390
01:07:43,369 --> 01:07:54,264
我当时在想，这门课程确实需要足够的信息来解决问题，
I was thinking, this course really takes enough information to solve the sets,

1391
01:07:54,264 --> 01:08:00,589
因为我感觉缺少信息。
because I feel there is missing information.

1392
01:08:00,590 --> 01:08:07,490
我是大一新生，我正在服用-
I am a freshman, and I was taking--

1393
01:08:07,489 --> 01:08:14,779
我是如此专心，无法继续前进。
I was so concentrating, and I can't go on, go ahead on the sets.

1394
01:08:14,780 --> 01:08:17,302
有什么我想念的吗？
Is there anything that I'm missing?

1395
01:08:17,301 --> 01:08:19,009
戴维·马兰（DAVID MALAN）：这是一个非常好的问题。
DAVID MALAN: It's a really good question.

1396
01:08:19,010 --> 01:08:19,700
而且很公平。
And quite fair.

1397
01:08:19,699 --> 01:08:21,919
诚然，我们的行动确实非常快。
We do move quite quickly, admittedly.

1398
01:08:21,920 --> 01:08:26,720
所以确实，从第0周起回想起消防水带的隐喻
So indeed, recall from week 0 the fire hose metaphor

1399
01:08:26,720 --> 01:08:29,270
是我从麻省理工学院的饮水机借来的。
that I borrowed from MIT's water fountain.

1400
01:08:29,270 --> 01:08:31,069
确实，情况确实如此。
Indeed, that's very much the case.

1401
01:08:31,069 --> 01:08:33,569
有很多新的语法，一次有很多新的想法。
There's a lot of new syntax, a lot of new ideas all at once.

1402
01:08:33,569 --> 01:08:37,310
但是当涉及到问题集中的个别问题时，
But when it comes to individual problems in the problem sets,

1403
01:08:37,310 --> 01:08:39,920
确实意识到您应该逐步采取这些措施。
do realize that you should take those step by step.

1404
01:08:39,920 --> 01:08:45,460
而且，它们总是从较不复杂到较复杂的工作。
And invariably, they tend to work from less complicated to more complicated.

1405
01:08:45,460 --> 01:08:47,960
在每个讲座和每个示例中
And throughout each of the lectures and each of the examples

1406
01:08:47,960 --> 01:08:50,390
我们所做的，无论是现场直播还是通过示例
that we do, either live or via the examples that

1407
01:08:50,390 --> 01:08:53,060
已在课程的网站上预先制作，以供您审核，
are premade on the course's website for your review,

1408
01:08:53,060 --> 01:08:57,529
您总是可以找到一些线索，提示或示例。
there's always little clues or hints or examples that you can then do.

1409
01:08:57,529 --> 01:09:01,910
当然，通过其他资源（例如实验室等），
And certainly, by way of other resources like labs and the like,

1410
01:09:01,909 --> 01:09:04,199
您还会看到其他构建基块吗？
will you see additional building blocks as well.

1411
01:09:04,199 --> 01:09:06,079
因此，随时可以联系更多个人。
So feel free to reach out more individually afterword.

1412
01:09:06,079 --> 01:09:07,996
很高兴为您指出其中的一些资源。
Happy to point you at some of those resources.

1413
01:09:07,997 --> 01:09:10,910
实际上，最近，您也会在该课程的网站上注意到这一点吗？
In fact, most recently, too, will you notice on the course's website

1414
01:09:10,909 --> 01:09:13,398
我们所说的“短裤”是指制作的较短的视频
what we call "shorts," which are shorter videos made

1415
01:09:13,399 --> 01:09:17,120
我的另一位同事CS50的道格·劳埃德（Doug Lloyd）
by another colleague of mine, CS50's own Doug Lloyd, which are literally

1416
01:09:17,119 --> 01:09:19,679
有关特定主题的简短视频。
short videos on very specific topics.

1417
01:09:19,680 --> 01:09:22,490
所以从今天起，您将看到Doug的短片
So after today, you'll see short videos by Doug

1418
01:09:22,489 --> 01:09:25,579
对线性搜索，二进制搜索有不同的看法，
with a different perspective on linear search, on binary search,

1419
01:09:25,579 --> 01:09:28,259
以及许多其他算法。
and on a number of other algorithms as well.

1420
01:09:28,260 --> 01:09:28,859
好问题。
Good question.

1421
01:09:28,859 --> 01:09:30,567
索菲娅，回到你身边。
Sophia, back to you.

1422
01:09:30,567 --> 01:09:32,609
听众：我很想知道返回值
AUDIENCE: I was wondering, with the return values

1423
01:09:32,609 --> 01:09:37,380
对于不同的错误情况，我们会-
that we have for different error cases, would that be--

1424
01:09:37,380 --> 01:09:39,630
就像，我们将用它做什么的一个例子？
like, what's an example of what we would use that for?

1425
01:09:39,630 --> 01:09:42,540
如果以后有几种不同的情况，那是为了以后
Is that for later if there are like several different cases

1426
01:09:42,539 --> 01:09:44,355
我们想以某种方式跟踪它们？
and we want to somehow keep track of them?

1427
01:09:44,355 --> 01:09:45,688
大卫·马兰（David MALAN）：正是后者。
DAVID MALAN: Exactly the latter.

1428
01:09:45,689 --> 01:09:47,790
所以说实话，这有点愚蠢
So right now, honestly, it's kind of stupid

1429
01:09:47,789 --> 01:09:52,026
我们甚至不愿意花时间返回0或返回1。
that we're even bothering to spend time returning 0 or returning 1.

1430
01:09:52,027 --> 01:09:54,360
就像，我们真的不需要这样做，因为我们不是
Like, we don't really need to do that, because we're not

1431
01:09:54,359 --> 01:09:55,409
使用信息。
using the information.

1432
01:09:55,409 --> 01:09:58,199
但是我们正在努力做的是奠定基础
But what we're trying to do is lay the foundation

1433
01:09:58,199 --> 01:09:59,781
对于更复杂的程序。
for more complicated programs.

1434
01:09:59,782 --> 01:10:01,740
实际上，在本周，下周及以后，
And indeed, this week and next week and beyond,

1435
01:10:01,739 --> 01:10:05,519
随着您自己的程序花费更长的时间，并且随着我们课程的进行，
as your own programs get a little longer, and as we, the course,

1436
01:10:05,520 --> 01:10:08,520
开始为您提供入门代码或分发
start providing you with starter code or distribution

1437
01:10:08,520 --> 01:10:12,210
代码，即工作人员和我写给您的代码行
code, that is, lines of code that the staff and I write that you then

1438
01:10:12,210 --> 01:10:15,630
必须建立，这将是一个非常有用的机制
have to build upon, it's going to be a very useful mechanism

1439
01:10:15,630 --> 01:10:19,360
以便能够表明这是错误的或另一件事是错误的。
to be able to signal that this went wrong or this other thing went wrong.

1440
01:10:19,359 --> 01:10:22,109
所以我们要做的就是为这种必然性做准备，
So all we're doing is preparing for that inevitability,

1441
01:10:22,109 --> 01:10:25,869
即使目前看来，这似乎并没有an痒。
even if right now it doesn't really seem to be scratching an itch.

1442
01:10:25,869 --> 01:10:26,629
安东尼？
Anthony?

1443
01:10:26,630 --> 01:10:28,672
听众：我只是想很快问一下，
AUDIENCE: I was just going to ask really quickly,

1444
01:10:28,671 --> 01:10:32,199
显然，在此代码中，我们有“ Brian”和您的名字“ David”。
obviously in this code we have "Brian" and your name, "David."

1445
01:10:32,199 --> 01:10:33,309
那是两个人。
And that's two people.

1446
01:10:33,310 --> 01:10:35,500
假设我们有10或20甚至30个人。
So let's say we had 10 or 20 or even 30 people.

1447
01:10:35,500 --> 01:10:37,500
我知道这是聊天中的问题，但我只是
I know it was a question in the chat, but I just

1448
01:10:37,500 --> 01:10:39,459
我也想为自己澄清。
wanted to clarify for myself, too.

1449
01:10:39,460 --> 01:10:42,000
戴维·马兰（DAVID MALAN）：“如果”将发生什么变化？
DAVID MALAN: And the "what if" being what would change?

1450
01:10:42,000 --> 01:10:44,209
还是那个问题的结尾是什么？
Or, what was the end of that question?

1451
01:10:44,210 --> 01:10:44,850
听众：是的。
AUDIENCE: Yeah.

1452
01:10:44,850 --> 01:10:46,100
代码会发生什么变化？
What would change in the code?

1453
01:10:46,100 --> 01:10:48,017
还是我们为解决该问题所做的工作？
Or what we do exactly to address that problem?

1454
01:10:48,016 --> 01:10:48,849
戴维·马兰：好的，好的。
DAVID MALAN: Ah, OK.

1455
01:10:48,850 --> 01:10:49,450
好问题。
Good question.

1456
01:10:49,449 --> 01:10:53,304
因此，如果我们要使用更多的名称，例如第三名或第十名或类似名称，
So if we were to have more names, like a third name or a tenth name or the like,

1457
01:10:53,305 --> 01:10:56,430
在此版本的程序中，我们唯一需要更改的就是
the only things that we would have to change in this version of the program

1458
01:10:56,430 --> 01:10:58,947
首先是第14行，数组的大小。
is first, on line 14, the size of the array.

1459
01:10:58,947 --> 01:11:00,780
因此，如果我们要有10个人，我们需要
So if we're going to have 10 people, we need

1460
01:11:00,779 --> 01:11:03,179
提前决定我们将要有10个人。
to decide in advance that we're going to have 10 people.

1461
01:11:03,180 --> 01:11:08,048
更好的是，例如，我可以在这里分配一个常数。
Better still, I could, for instance, allocate myself a constant up here.

1462
01:11:08,047 --> 01:11:09,839
所以让我实际上上去，就像我们一样
So let me actually go up here, just like we

1463
01:11:09,840 --> 01:11:17,670
在上一课中做了类似的工作-const int NUMBER。
did in a previous class, where we did something like this-- const int NUMBER.

1464
01:11:17,670 --> 01:11:19,380
我将其初始化为10。
And I'll just initialize this to 10.

1465
01:11:19,380 --> 01:11:21,450
记得const表示常量。
And recall that const means constant.

1466
01:11:21,449 --> 01:11:23,139
这意味着该变量不能更改。
That means this variable can't change.

1467
01:11:23,140 --> 01:11:24,930
Int，当然意味着它是一个整数。
Int, of course means it's an integer.

1468
01:11:24,930 --> 01:11:27,450
我大写的事实只是人类的惯例
The fact that I've capitalized it is just a human convention

1469
01:11:27,449 --> 01:11:29,639
为了使人在视觉上清楚一点，这是
to make a little visually clear that this is

1470
01:11:29,640 --> 01:11:32,200
一个常数，这样您就不会忘记。
a constant, just so you don't forget.

1471
01:11:32,199 --> 01:11:33,659
但是它没有功能性作用。
But it has no functional role.

1472
01:11:33,659 --> 01:11:36,359
然后，当然，这只是要分配给NUMBER的值。
And then this, of course, is just the value to assign to NUMBER.

1473
01:11:36,359 --> 01:11:40,186
然后我可以在第16行下到这里并插入该变量
Then I could go down here on line 16 and plug in that variable

1474
01:11:40,186 --> 01:11:42,269
这样我就不必硬编码人们会做什么
so that I don't have to hardcode what people would

1475
01:11:42,270 --> 01:11:44,730
称为“魔数”，这只是一个数字
call a "magic number," which is just a number that

1476
01:11:44,729 --> 01:11:46,409
似乎无处不在。
appears seemingly out of nowhere.

1477
01:11:46,409 --> 01:11:50,519
现在，我已将所有特殊编号放在文件的顶部，
Now I've put all of my special numbers at the top of my file,

1478
01:11:50,520 --> 01:11:54,190
或文件顶部，现在我在这里使用此变量。
or toward the top of my file, and now I'm using this variable here.

1479
01:11:54,189 --> 01:11:57,389
然后我能做的-以前我只是在口头上提到过这一点-
And then what I could do-- and I alluded to this only verbally before--

1480
01:11:57,390 --> 01:12:00,120
例如，我绝对可以开始进行硬编码
I could absolutely start hardcoding in, for instance,

1481
01:12:00,119 --> 01:12:03,419
蒙塔古（Montague）的名字和编号，里斯维克（Rithvik）和本尼迪克特（Benedict）以及科迪（Cody）
Montague's name and number, and Rithvik's and Benedict's, and Cody's

1482
01:12:03,420 --> 01:12:04,110
和别的。
and others.

1483
01:12:04,109 --> 01:12:07,047
但说实话，如果您只是硬编码，这似乎有点愚蠢
But honestly, this seems kind of stupid if you're just hardcoding

1484
01:12:07,047 --> 01:12:08,339
所有这些名称和数字。
all of these names and numbers.

1485
01:12:08,340 --> 01:12:10,423
再过几周，我们将看到您如何实际
And in a few weeks, we'll see how you can actually

1486
01:12:10,422 --> 01:12:13,199
将所有相同的信息存储在电子表格中，
store all of the same information in like a spreadsheet,

1487
01:12:13,199 --> 01:12:14,909
或所谓的CSV文件-
or what's called a CSV file--

1488
01:12:14,909 --> 01:12:19,559
逗号分隔的值-甚至在适当的数据库中，Facebook都使用
Comma Separated Values-- or even in a proper database, which the Facebooks

1489
01:12:19,560 --> 01:12:21,065
世界各地的Google都会使用。
and Googles of the world would use.

1490
01:12:21,064 --> 01:12:23,189
但是我现在能做的就是这样。
But what I could do for now is something like this.

1491
01:12:23,189 --> 01:12:28,939
因为int我得到0，所以我少于人数，即i ++。
For int i gets 0, i less than the number of people, i++.

1492
01:12:28,939 --> 01:12:30,719
也许我可以做这样的事情-
And maybe I could do something like this--

1493
01:12:30,720 --> 01:12:38,250
括号中的点名称等于get_string，“名称是什么”
people bracket i dot name equals get_string, "What's the name"

1494
01:12:38,250 --> 01:12:39,150
问号。
question mark.

1495
01:12:39,149 --> 01:12:43,079
然后在这里我可以将括号括起来，点号等于
And then here I could do people bracket i dot number equals

1496
01:12:43,079 --> 01:12:46,379
get_string，“他们的电话号码是多少？”
get_string, "What's their number?"

1497
01:12:46,380 --> 01:12:48,220
我也可以问这个问题。
And I could ask that question, too.

1498
01:12:48,220 --> 01:12:51,320
因此，现在程序的设计变得更好了。
So now the program's getting to be a little better designed.

1499
01:12:51,319 --> 01:12:53,699
我不是随便对我和Brian进行硬编码。
I'm not arbitrarily hardcoding just me and Brian.

1500
01:12:53,699 --> 01:12:54,779
现在它是动态的。
Now it's dynamic.

1501
01:12:54,779 --> 01:12:58,329
从技术上讲，电话簿目前仅支持10个人，
And technically, the phone book only supports 10 people at the moment,

1502
01:12:58,329 --> 01:12:59,849
但我也可以使它充满活力。
but I could make that dynamic, too.

1503
01:12:59,850 --> 01:13:01,630
我也可以叫get_int。
I could also call get_int.

1504
01:13:01,630 --> 01:13:04,860
或者，就像您上周所做的一样，使用命令行参数
Or, like you did this past week, use a command line argument

1505
01:13:04,859 --> 01:13:07,769
并参数化代码，以便它实际上可以
and parameterize the code so that it can actually

1506
01:13:07,770 --> 01:13:09,990
适用于2个人，10个人-无论您想要什么，
be for 2 people, 10 people-- whatever you want,

1507
01:13:09,989 --> 01:13:15,269
该程序可以为您动态地适应它。
the program can dynamically adapt to it for you.

1508
01:13:15,270 --> 01:13:16,890
还有其他问题吗？
Other questions?

1509
01:13:16,890 --> 01:13:22,420
在结构上，在类型上还是类似的？
On structs, on types, or the like?

1510
01:13:22,420 --> 01:13:23,170
不？
No?

1511
01:13:23,170 --> 01:13:23,670
好的。
All right.

1512
01:13:23,670 --> 01:13:25,110
那我们怎么到这里的？
So how did we get here?

1513
01:13:25,109 --> 01:13:27,809
回想一下我们从搜索这个问题开始，
Recall that we started with this problem of searching,

1514
01:13:27,810 --> 01:13:30,420
因此我们只想在门口找人。
whereby we just want to find someone in the doors.

1515
01:13:30,420 --> 01:13:32,625
我们只想在数组中找到一个人。
We just want to find someone in the array.

1516
01:13:32,625 --> 01:13:34,500
我们很快就将事情升级了
We've sort of escalated things pretty quickly

1517
01:13:34,500 --> 01:13:36,720
不仅要查找数字或名称，而且要查找
to finding not just numbers or names but now

1518
01:13:36,720 --> 01:13:40,380
这些数据结构形式的带有数字的名称。
names with numbers in the form of these data structures.

1519
01:13:40,380 --> 01:13:43,770
但是要有效地做到这一点，实际上需要一个更智能的算法
But to do this efficiently really requires a smarter algorithm

1520
01:13:43,770 --> 01:13:44,850
像二进制搜索一样。
like binary search.

1521
01:13:44,850 --> 01:13:50,100
到目前为止，尽管回想起，我们仅在C代码线性搜索中使用过，
Up until now, we've only used in C code linear search, even though, recall,

1522
01:13:50,100 --> 01:13:54,240
我们确实拥有用于二进制搜索的伪代码。
that we did have at our disposal the pseudocode for binary search.

1523
01:13:54,239 --> 01:13:58,019
但是，使用二进制搜索时，我们将需要对数据进行排序。
But with binary search, we're going to need the data to be sorted.

1524
01:13:58,020 --> 01:14:01,080
因此，如果您想获得搜索的速度优势
And so if you want to get the speed benefits of searching

1525
01:14:01,079 --> 01:14:04,289
通过对数字进行排序可以更快地找到某人
more quickly by having sorted numbers, somehow someone

1526
01:14:04,289 --> 01:14:06,119
必须为我们做到这一点。
is going to have to do that for us.

1527
01:14:06,119 --> 01:14:09,747
例如，乔为我们整理了所有这些数字。
Joe, for instance, sorted behind the curtain all of these numbers for us.

1528
01:14:09,747 --> 01:14:11,789
但是他使用什么算法将打开
But what algorithm did he use is going to open up

1529
01:14:11,789 --> 01:14:15,004
关于如何有效地对数字进行排序的一堆蠕虫。
a whole can of worms as to how we can sort numbers efficiently.

1530
01:14:15,005 --> 01:14:17,130
实际上，如果您是Google和Facebook
And indeed, if you're the Googles and the Facebooks

1531
01:14:17,130 --> 01:14:19,240
以及全世界数以百万计的Instagram，
and the Instagrams of the world, with millions,

1532
01:14:19,239 --> 01:14:22,739
数十亿条数据和用户，您当然可以
billions of pieces of data and users, you surely

1533
01:14:22,739 --> 01:14:24,849
想保持数据排序，大概是，
want to keep that data sorted, presumably,

1534
01:14:24,850 --> 01:14:26,940
这样您就可以使用二进制搜索等算法
so that you can use algorithms like binary search

1535
01:14:26,939 --> 01:14:30,519
在您搜索朋友或内容时快速查找信息。
to find information quickly when you're searching for friends or for content.

1536
01:14:30,520 --> 01:14:32,730
但是，让我们继续，这里需要休息五分钟。
But let's go ahead and here take a five-minute break.

1537
01:14:32,729 --> 01:14:35,159
当我们回来时，我们将考虑一些算法
And when we come back, we'll consider a few algorithms

1538
01:14:35,159 --> 01:14:39,599
进行排序，这将使我们能够执行我们刚才讨论的所有事情。
for sorting that's going to enable us to do everything we've just now discussed.

1539
01:14:39,600 --> 01:14:40,910
五分见。
See you in five.

1540
01:14:40,909 --> 01:14:41,789
好的。
All right.

1541
01:14:41,789 --> 01:14:43,049
我们回来了。
We are back.

1542
01:14:43,050 --> 01:14:47,760
回顾一下，我们有两种不同的搜索算法，线性搜索
So to recap, we have a couple different algorithms for searching, linear search

1543
01:14:47,760 --> 01:14:48,870
和二进制搜索。
and binary search.

1544
01:14:48,869 --> 01:14:52,559
到目前为止，二元搜索显然是所有指标中的赢家。
Binary search is clearly the winner from all measures we've seen thus far.

1545
01:14:52,560 --> 01:14:56,910
问题是数据需要按顺序进行高级排序
The catch is that the data needs to be sorted in advanced in order

1546
01:14:56,909 --> 01:14:58,106
应用该算法。
to apply that algorithm.

1547
01:14:58,106 --> 01:14:59,939
所以让我们给自己一个工作模型
So let's just give ourselves a working model

1548
01:14:59,939 --> 01:15:01,349
整理东西的意思。
for what it means to sort something.

1549
01:15:01,350 --> 01:15:04,560
好吧，一如既往，如果您认为这只是要解决的另一个问题，
Well, as always, if you think of this as just another problem to be solved,

1550
01:15:04,560 --> 01:15:07,970
它具有输入和输出，目标是获取输入
it's got input and output, and the goal is to take that input

1551
01:15:07,970 --> 01:15:08,970
并产生该输出。
and produce that output.

1552
01:15:08,970 --> 01:15:09,990
好吧，输入的是什么？
Well, what's the input?

1553
01:15:09,989 --> 01:15:12,359
这将是一大堆未排序的值。
It's going to be a whole bunch of unsorted values.

1554
01:15:12,359 --> 01:15:14,461
当然，目标是获得排序后的值。
And the goal, of course, is to get sorted values.

1555
01:15:14,462 --> 01:15:16,420
因此，该过程中有趣的部分正在进行
So the interesting part of the process is going

1556
01:15:16,420 --> 01:15:18,270
成为中间的任何东西。
to be whatever there is in the middle.

1557
01:15:18,270 --> 01:15:22,710
但是更具体地说，如果我们现在就这个未分类的问题进行思考
But just to be even more concrete, if we think now in terms of this unsorted

1558
01:15:22,710 --> 01:15:25,650
输入是输入数组-因为毕竟，
input as being an array of input-- because after all,

1559
01:15:25,649 --> 01:15:28,469
这可能是迄今为止我们所见过的最有用的机制，
that's perhaps the most useful mechanism we've seen thus far,

1560
01:15:28,470 --> 01:15:32,880
只需使用一个变量名即可一次传递一堆值-
to pass around a bunch of values at once using just one variable name--

1561
01:15:32,880 --> 01:15:37,710
我们可能有一个像这样的数组6 3 8 5 2 7 4 1
we might have an array like this, 6 3 8 5 2 7 4 1, which seems to be, indeed,

1562
01:15:37,710 --> 01:15:40,050
随机排序，即未排序。
randomly ordered, that is unsorted.

1563
01:15:40,050 --> 01:15:43,594
我们想将其转换为仅1 2的等效数组
And we want to turn that into an equivalent array that's just 1 2

1564
01:15:43,594 --> 01:15:45,120
3 4 5 6 7 8。
3 4 5 6 7 8.

1565
01:15:45,119 --> 01:15:47,489
所以这次是八个数字，而不是七个。
So eight numbers this time instead of seven.

1566
01:15:47,489 --> 01:15:51,189
但是，这次的目的不是要搜索它们本身，而是要对其进行排序。
But the goal this time is not to search them, per se, but to sort them.

1567
01:15:51,189 --> 01:15:53,729
但是在我超越自己之前，有人
But before I get ahead of myself, could someone

1568
01:15:53,729 --> 01:15:56,639
退缩整个智力活动
push back on this whole intellectual exercise

1569
01:15:56,640 --> 01:15:59,400
我们将要首先进行排序吗？
we're about to do with sorting in the first place?

1570
01:15:59,399 --> 01:16:02,279
有人可以争论为什么我们不这样做
Could someone make an argument as to why we might not

1571
01:16:02,279 --> 01:16:06,989
想打扰使用排序数组，为什么我们不
want to bother using a sorted array, why we might not

1572
01:16:06,989 --> 01:16:11,999
想打扰元素排序，等等，让我们只使用线性搜索
want to bother sorting the elements, and heck, let's just use linear search

1573
01:16:12,000 --> 01:16:13,570
寻找一些元素-
to find some element--

1574
01:16:13,569 --> 01:16:17,459
无论是门后面的数字，还是数组中的名称。
whether it's a number behind a door, a name in an array.

1575
01:16:17,460 --> 01:16:23,850
就像，什么时候我们可能只想使用线性搜索而不理会排序？
Like, when might we want to just use linear search and not bother sorting?

1576
01:16:23,850 --> 01:16:25,940
索菲娅，你觉得呢？
Sophia, what do you think?

1577
01:16:25,939 --> 01:16:28,369
观众：我们在排序时可能会遇到错误，
AUDIENCE: We could encounter errors in sorting,

1578
01:16:28,369 --> 01:16:33,009
并可能导致错误，例如，
and that might cause errors, like, unpredictability in terms of,

1579
01:16:33,010 --> 01:16:34,620
就像，如果我们能找到一些东西。
like, if we can find something.

1580
01:16:34,619 --> 01:16:37,142
与线性搜索相比，我们知道可以找到它。
Versus linear search, we know we can find it.

1581
01:16:37,143 --> 01:16:38,310
戴维·马兰：好的，很公平。
DAVID MALAN: OK, quite fair.

1582
01:16:38,310 --> 01:16:41,940
我承认，我们已经实现了二进制搜索，而不是伪代码。
I will concede that implementing binary search, not in pseudocode, which we've

1583
01:16:41,939 --> 01:16:44,849
已经完成，但是在代码中实际上更困难，
already done, but in code is actually more difficult,

1584
01:16:44,850 --> 01:16:47,040
因为你必须处理四舍五入，特别是
because you have to deal with rounding, especially

1585
01:16:47,039 --> 01:16:49,789
如果您有奇怪数量的门，例如奇数门
if you've got a weird number of doors, like an odd number of doors

1586
01:16:49,789 --> 01:16:52,409
而不是偶数门或这些长度的阵列。
versus an even number of doors or an array of those lengths.

1587
01:16:52,409 --> 01:16:54,617
老实说，您必须处理这些极端情况，
Honestly, you've got to deal with these corner cases,

1588
01:16:54,618 --> 01:16:57,180
如四舍五入或四舍五入，因为任何时候
like rounding down or rounding up, because anything time

1589
01:16:57,180 --> 01:16:59,857
将某物除以2，可能会得到一个分数
you divide something by 2, you might get a fractional value

1590
01:16:59,856 --> 01:17:01,189
否则您可能会得到一个整数。
or you might get a whole number.

1591
01:17:01,189 --> 01:17:02,349
因此，我们必须做出一些决定。
So we've got to make some decisions.

1592
01:17:02,350 --> 01:17:03,630
因此，它是完全可解决的。
So it's totally solvable.

1593
01:17:03,630 --> 01:17:06,870
几十年来，人类一直在编写实现二进制搜索的代码。
And humans for decades have been writing code that implements binary search.

1594
01:17:06,869 --> 01:17:08,159
这是完全可能的。
It's totally possible.

1595
01:17:08,159 --> 01:17:09,449
有可以使用的库。
There's libraries you can use.

1596
01:17:09,449 --> 01:17:12,491
但这绝对是更具挑战性的，您需要承担风险。
But it's definitely more challenging, and you open yourselves up to risk.

1597
01:17:12,492 --> 01:17:14,385
但是让我规定那是可以的。
But let me stipulate that that's OK.

1598
01:17:14,385 --> 01:17:17,763
在我漂亮的进步中，我现在已经足够好了
I am good enough at this point in my progression where I'm pretty

1599
01:17:17,762 --> 01:17:19,179
确保我可以正确实施它。
sure I can implement it correctly.

1600
01:17:19,180 --> 01:17:21,480
因此，正确性与我无关。
So correctness is not my concern.

1601
01:17:21,479 --> 01:17:26,879
还有什么可能使我无法对元素数组进行排序？
What else might demotivate me from sorting an array of elements?

1602
01:17:26,880 --> 01:17:30,420
是什么促使我去做啊，只要使用线性搜索即可。
And what might motivate me to, ah, just use linear search.

1603
01:17:30,420 --> 01:17:33,150
很简单
It's so simple.

1604
01:17:33,149 --> 01:17:34,929
有人可以提出为什么吗？
Can anyone propose why?

1605
01:17:34,930 --> 01:17:36,480
奥利维亚，你怎么看？
Olivia, what do you think?

1606
01:17:36,479 --> 01:17:39,419
观众：如果游戏的名字是效率，
AUDIENCE: If the name of the game is efficiency,

1607
01:17:39,420 --> 01:17:42,180
并且您有足够小的数据集，那么
and you have a small enough data set, then

1608
01:17:42,180 --> 01:17:46,040
您最好只是搜索而不是排序
you might as well just search it versus sort

1609
01:17:46,039 --> 01:17:47,919
它，这将是额外的费用。
it, which would be an extra expense.

1610
01:17:47,920 --> 01:17:49,420
大卫·马兰（David MALAN）：是的，说得很好。
DAVID MALAN: Yeah, really well said.

1611
01:17:49,420 --> 01:17:51,450
如果您的数据集相对较小，
If you've got a relatively small data set,

1612
01:17:51,449 --> 01:17:55,049
您的计算机以每秒十亿次的速度运行，
and your computer operates at a billion operations per second,

1613
01:17:55,050 --> 01:17:59,130
例如，我的上帝，谁在乎您的代码是否糟透了，而且速度有点慢？
for instance, my God, who cares if your code sucks and it's a little bit slow?

1614
01:17:59,130 --> 01:18:00,580
只是以低效的方式来做。
Just do it the inefficient way.

1615
01:18:00,579 --> 01:18:01,079
为什么？
Why?

1616
01:18:01,079 --> 01:18:04,204
因为可能要花几分钟才能实施更简单的方法
Because it's going to take you maybe a few minutes to implement the simpler

1617
01:18:04,204 --> 01:18:07,199
像线性搜索这样的算法，即使它需要花费更长的时间
algorithm like linear search, even though it's going to take longer

1618
01:18:07,199 --> 01:18:10,349
运行，而这可能要花费您数十分钟甚至一小时的时间
to run, whereas it might take you tens of minutes, maybe an hour

1619
01:18:10,350 --> 01:18:12,810
左右，不仅可以编写而且可以调试某些东西
or so, to not only write but debug something

1620
01:18:12,810 --> 01:18:16,200
像是更高级的算法，例如二进制搜索
like a fancier algorithm, like binary search, at which point

1621
01:18:16,199 --> 01:18:19,709
您可能比您花费了更多的时间来编写代码，更快的代码
you might have spent more time writing the code, the faster code, than you

1622
01:18:19,710 --> 01:18:22,342
本来只运行较慢的代码。
would have just running the slower code.

1623
01:18:22,341 --> 01:18:23,799
我可以亲自谈一谈。
And I can speak to this personally.

1624
01:18:23,800 --> 01:18:26,008
回到研究生院，我正在做的一些研究
Back in grad school, some of the research I was doing

1625
01:18:26,007 --> 01:18:28,169
涉及非常大的数据集的分析。
involved analysis of very large data sets.

1626
01:18:28,170 --> 01:18:30,960
而且我必须编写代码才能分析这些数据。
And I had to write code in order to analyze this data.

1627
01:18:30,960 --> 01:18:33,330
我本来可以花数小时，数天甚至
And I could have spent hours, days, even,

1628
01:18:33,329 --> 01:18:37,319
编写我可以分析的最佳设计算法
writing the best designed algorithm I could to analyze

1629
01:18:37,319 --> 01:18:39,479
尽可能高效地处理数据。
the data as efficiently as possible.

1630
01:18:39,479 --> 01:18:42,239
或者，坦率地说，我可以编写糟糕的代码版本，
Or, frankly, I could write the crappy version of the code,

1631
01:18:42,239 --> 01:18:44,549
睡了八个小时，我的代码只会
go to sleep for eight hours, and my code will just

1632
01:18:44,550 --> 01:18:46,770
早上产生我想要的输出。
produce the output I want by morning.

1633
01:18:46,770 --> 01:18:49,513
这是一个非常现实的，合理的权衡。
And that is a very real-world, reasonable trade-off to make.

1634
01:18:49,512 --> 01:18:51,929
实际上，在接下来的几周中，这将成为主题
And indeed, this is going to be thematic in the weeks that

1635
01:18:51,930 --> 01:18:54,615
在过程中继续进行权衡。
proceed in the course, where there's going to be this trade-off.

1636
01:18:54,614 --> 01:18:56,489
很多时候，权衡是
And quite often, the trade-off is going to be

1637
01:18:56,489 --> 01:19:01,109
时间，复杂性或您正在使用的空间或内存量。
time, or complexity, or the amount of space or memory that you're using.

1638
01:19:01,109 --> 01:19:04,739
作为一名优秀的计算机科学家的一部分艺术，
And part of the art of being a good computer scientist,

1639
01:19:04,739 --> 01:19:08,139
然后程序员试图确定该行在哪里。
and in turn programmer, is trying to decide where the line is.

1640
01:19:08,140 --> 01:19:11,430
您是否会付出更多的努力来使自己变得更好，更快，更高效
Do you exert more effort upfront to make a better, faster, more efficient

1641
01:19:11,430 --> 01:19:13,800
算法，或者您可能偷偷摸摸地走了
algorithm, or do you maybe cut some corners

1642
01:19:13,800 --> 01:19:17,580
在那里，您可以专注于自己最宝贵的资源，人的时间，
there so that you can focus your most precious resource, human time,

1643
01:19:17,579 --> 01:19:20,429
还有其他更具根本挑战性的问题吗？
on other, more fundamentally challenging problems?

1644
01:19:20,430 --> 01:19:22,620
因此，我们针对该课程的问题集和实验
So we for the course's problem sets and labs

1645
01:19:22,619 --> 01:19:24,879
将始终规定最重要的内容。
will always prescribe what's most important.

1646
01:19:24,880 --> 01:19:27,113
但是在几个星期的时间里，我们遇到了一个问题
But in a few weeks' time, with one of our problem

1647
01:19:27,113 --> 01:19:29,280
设置您将实现自己的拼写检查器。
sets will you implement your very own spell checker.

1648
01:19:29,279 --> 01:19:30,987
在那个拼写检查器的目标中
And among the goals of that spell checker

1649
01:19:30,988 --> 01:19:33,690
将尽量减少时间
are going to be to minimize the amount of time

1650
01:19:33,689 --> 01:19:37,979
您的代码需要运行，并且还可以最大程度地减少空间或内存量
your code is taking to run, and also to minimize the amount of space or memory

1651
01:19:37,979 --> 01:19:41,069
您的程序在运行时正在执行的操作。
that your program is taking while running.

1652
01:19:41,069 --> 01:19:44,009
因此，我们将开始更加欣赏这些折衷。
And so we'll begin to appreciate those trade-offs ever more.

1653
01:19:44,010 --> 01:19:47,370
但是确实如此-我真的很喜欢Olivia的表述-
But indeed, it's the case-- and I really like Olivia's formulation of it--

1654
01:19:47,369 --> 01:19:50,339
如果您的数据集很小，则可能不值得
if your data set is pretty small, it's probably not worth

1655
01:19:50,340 --> 01:19:54,330
编写尽可能最快，设计最好的算法。
writing the fastest, best designed algorithm as possible.

1656
01:19:54,329 --> 01:19:56,399
只需以简单的方式，正确的方式编写，
Just write it the simple way, the correct way,

1657
01:19:56,399 --> 01:19:58,439
并迅速得到答案，然后继续前进。
and get the answer quickly, and move on.

1658
01:19:58,439 --> 01:20:01,529
但是，我敢说，这不会出现很多问题。
But that's not going to be the case for a lot of problems, dare I say,

1659
01:20:01,529 --> 01:20:03,419
生活中的大多数问题。
most problems in life.

1660
01:20:03,420 --> 01:20:06,150
如果您要建立Facebook或Instagram或Whatsapp，
If you're building Facebook or Instagram or Whatsapp,

1661
01:20:06,149 --> 01:20:10,979
或获得数以百万计的当今任何最受欢迎的服务
or any of today's most popular services that are getting thousands, millions

1662
01:20:10,979 --> 01:20:13,499
一次存储新数据，您不能只是
of new pieces of data at a time, you can't just

1663
01:20:13,500 --> 01:20:17,310
有效地线性搜索您在LinkedIn上的所有朋友或联系。
linearly search all of your friends or connections on LinkedIn efficiently.

1664
01:20:17,310 --> 01:20:20,430
您不能只线性搜索数十亿个网页
You can't just linearly search the billions of web pages

1665
01:20:20,430 --> 01:20:23,820
Google和Microsoft在其搜索引擎中建立索引。
that Google and Microsoft index in their search engines.

1666
01:20:23,819 --> 01:20:25,449
您必须对此更加精明。
You've got to be smarter about it.

1667
01:20:25,449 --> 01:20:28,199
毫无疑问，您的程序越成功
And undoubtedly, the more successful your programs are

1668
01:20:28,199 --> 01:20:31,349
和您的代码或网站，无论您的应用是什么情况，
and your code are, or websites, your apps, whatever the case may be,

1669
01:20:31,350 --> 01:20:33,810
更重要的设计确实发挥了作用。
the more important design does come into play.

1670
01:20:33,810 --> 01:20:38,850
因此，确实，让我们现在规定，目标是不要一次搜索这些门；
So indeed, let's stipulate now that the goal is not to search these doors once;

1671
01:20:38,850 --> 01:20:41,040
目标是不要一次搜索这些灯泡；
the goal is not to search these light bulbs once;

1672
01:20:41,039 --> 01:20:44,429
目标不是一次搜索电话簿，而是再次搜索
the goal is not to search the phone book once, but rather again

1673
01:20:44,430 --> 01:20:45,970
一遍又一遍。
and again and again.

1674
01:20:45,970 --> 01:20:48,600
如果是这种情况，那么我们可能
And if that's going to be the case, then we probably

1675
01:20:48,600 --> 01:20:52,890
应该花更多的时间和更多的前期复杂性
should spend a little more time and a little more complexity upfront

1676
01:20:52,890 --> 01:20:56,250
得到我们的代码，不仅正确而且高效，
getting our code, not only right but also efficient,

1677
01:20:56,250 --> 01:20:59,669
这样我们就可以一次又一次地从这种效率中受益
so that we can benefit from that efficiency again and again

1678
01:20:59,670 --> 01:21:01,480
再一次，随着时间的流逝。
and again, over time.

1679
01:21:01,479 --> 01:21:04,049
那么我们应该如何对一些数字进行排序。
So how might we go about sorting some numbers.

1680
01:21:04,050 --> 01:21:06,390
所以实际上，让我看看，如果可以的话，
So in fact, let me see, to do this, if we can maybe

1681
01:21:06,390 --> 01:21:10,470
从布莱恩那里得到帮助。
get a hand from Brian in back.

1682
01:21:10,470 --> 01:21:12,180
布莱恩，您介意协助分类吗？
Brian, do you mind helping with sorting?

1683
01:21:12,180 --> 01:21:13,210
布莱恩：是的，绝对如此。
BRIAN: Yeah, absolutely.

1684
01:21:13,210 --> 01:21:16,950
因此，我现在这里有八个数字，所有数字似乎都没有排序。
So I've got eight numbers here right now that all seem to be in unsorted order.

1685
01:21:16,949 --> 01:21:17,699
戴维·马兰：是的。
DAVID MALAN: Yeah.

1686
01:21:17,699 --> 01:21:21,399
布赖恩，您可以继续吗，您能为我们对这八个数字进行排序吗？
And Brian, could you go ahead, and could you sort these eight numbers for us?

1687
01:21:21,399 --> 01:21:22,899
布莱恩：是的，我将它们整理好。
BRIAN: Yeah, I'll put them in order.

1688
01:21:22,899 --> 01:21:27,639
因此，我们将采用这些，并且-
So we'll take these and--

1689
01:21:27,640 --> 01:21:35,450
嗯，好吧。
um-- and all right.

1690
01:21:35,449 --> 01:21:37,032
我认为这些现在已经排序了。
I think these are now in sorted order.

1691
01:21:37,033 --> 01:21:38,117
戴维·马兰（David MALAN）：是的，的确如此。
DAVID MALAN: Yeah, indeed.

1692
01:21:38,117 --> 01:21:38,630
我同意。
I agree.

1693
01:21:38,630 --> 01:21:42,420
现在，让我们从听众中进行一些评论，进行一些观察。
And now let's take some critique from the audience, some observations.

1694
01:21:42,420 --> 01:21:49,140
有人介意解释Brian是如何对这8个数字进行排序的吗？
Would someone mind explaining how Brian just sorted those eight numbers?

1695
01:21:49,140 --> 01:21:54,650
为了达到最终结果，Brian只是一步一步地做了什么？
What did Brian just do, step by step, in order to get to that end result?

1696
01:21:54,649 --> 01:21:57,779
输入未排序，现在输出已排序。
The input was unsorted, the output now is sorted.

1697
01:21:57,779 --> 01:21:58,549
他做了什么？
So what did he do?

1698
01:21:58,550 --> 01:22:01,190
彼得，您看到了什么？
Peter, what did you see happen?

1699
01:22:01,189 --> 01:22:03,199
听众：他一步一步地经历了他们。
AUDIENCE: He went through them step by step.

1700
01:22:03,199 --> 01:22:07,199
如果他们的顺序在增加，他会翻转他们，
And if they were in increasing order, he flipped them,

1701
01:22:07,199 --> 01:22:10,729
并继续这样做，直到他们都正确[听不清]。
and kept doing it until they were all in the correct [INAUDIBLE]..

1702
01:22:10,729 --> 01:22:11,479
戴维·马兰：是的。
DAVID MALAN: Yeah.

1703
01:22:11,479 --> 01:22:13,819
他一步一步地寻找小价值
He kept step by step kind of looking for small values

1704
01:22:13,819 --> 01:22:16,129
然后将它们向左移动，并寻找更大的价值
and moving them to the left, and looking for big values

1705
01:22:16,130 --> 01:22:18,380
并将它们向右移动，以便有效地选择
and moving them to the right, so effectively selecting

1706
01:22:18,380 --> 01:22:21,330
一次编号，并将其放置在正确的位置。
numbers one at a time and putting it into its right place.

1707
01:22:21,329 --> 01:22:24,162
因此，让我们看看，如果可能的话，这可能是慢动作，布莱恩。
So let's see this is, maybe in more slow motion, if you will, Brian.

1708
01:22:24,162 --> 01:22:25,912
而且，如果您可以做些古怪的话
And if you could be a little more pedantic

1709
01:22:25,912 --> 01:22:27,899
并确切说明您在做什么。
and explain exactly what you're doing.

1710
01:22:27,899 --> 01:22:32,389
我看到您已经将数字重设为其原始的，未排序的顺序。
I see you've already reset the numbers to their original, unsorted order.

1711
01:22:32,390 --> 01:22:35,240
我们为什么不继续有条不紊地开始呢？
Why don't we go ahead and start a little more methodically?

1712
01:22:35,239 --> 01:22:37,909
您能继续前进吗？对我们来说，这次比较缓慢，
And could you go ahead and for us, more slowly this time,

1713
01:22:37,909 --> 01:22:40,099
选择最小值。
select the smallest value.

1714
01:22:40,100 --> 01:22:41,860
因为我确实认为，按照彼得的说法，
Because I do think, per Peter, it's going

1715
01:22:41,859 --> 01:22:44,099
需要结束在最左边。
to need to end up at the far left.

1716
01:22:44,100 --> 01:22:44,850
布莱恩：是的，当然。
BRIAN: Yeah, sure.

1717
01:22:44,850 --> 01:22:47,370
所以我在看数字，而1是最小的数字。
So I'm looking at the numbers, and the 1 is the smallest.

1718
01:22:47,369 --> 01:22:49,339
所以我现在的价值最小。
So I now have the smallest value.

1719
01:22:49,340 --> 01:22:49,580
戴维·马兰：好的。
DAVID MALAN: All right.

1720
01:22:49,579 --> 01:22:50,871
因此，您确实很快地做到了。
So you did that really quickly.

1721
01:22:50,872 --> 01:22:52,880
但是我觉得你像是自由自在
But I feel like you took the liberty of being

1722
01:22:52,880 --> 01:22:56,120
可以同时俯瞰所有事物的人。
a human who can kind of have this bird's eye view of everything all at once.

1723
01:22:56,119 --> 01:22:58,161
但是，如果可以的话，可以像计算机一样。
But be a little more computer-like, if you could.

1724
01:22:58,162 --> 01:23:00,650
而且如果这8个数字在技术上是排列在一起的，
And if these eight numbers are technically in an array,

1725
01:23:00,649 --> 01:23:02,689
有点像我在这里的七个门
kind of like my seven doors out here, such

1726
01:23:02,689 --> 01:23:06,709
一次只能看一个数字，你能否变得更有条理
that you can only look at one number at a time, can you be even more methodical

1727
01:23:06,710 --> 01:23:10,010
并仔细地告诉我们您如何找到最小的
and deliberate this time in telling us how you found the smallest

1728
01:23:10,010 --> 01:23:11,760
放置多少？
number to put into place?

1729
01:23:11,760 --> 01:23:12,260
布莱恩：当然。
BRIAN: Sure.

1730
01:23:12,260 --> 01:23:15,110
我猜，由于计算机一次只能看到一个数字，
I guess, since the computer can only look at one number at a time,

1731
01:23:15,109 --> 01:23:17,219
我将从这个数组的左侧开始
I would start at the left side of this array

1732
01:23:17,220 --> 01:23:20,490
然后按照正确的方式工作，一次查看每个数字。
and work my way through the right, looking at each number one at a time.

1733
01:23:20,489 --> 01:23:22,909
所以我可能会从6开始，然后说，好的，现在
So I might start with the 6 and say, OK, this right now

1734
01:23:22,909 --> 01:23:25,179
是到目前为止我查看过的最小的数字。
is the smallest number I've looked at so far.

1735
01:23:25,180 --> 01:23:28,430
但是，我看下一个数字，它是3，小于6。
But then I look at the next number, and it's a 3, and that's smaller than a 6.

1736
01:23:28,430 --> 01:23:31,700
所以现在3，这是我到目前为止发现的最小数字。
So now the 3, that's the smallest number I found so far.

1737
01:23:31,699 --> 01:23:33,439
因此，我会记住这一点并继续寻找。
So I'll remember that and keep looking.

1738
01:23:33,439 --> 01:23:36,106
8比3大，所以我不必担心。
The 8 is bigger than the 3, so I don't need to worry about that.

1739
01:23:36,106 --> 01:23:37,519
5比3大。
The 5 is bigger than the 3.

1740
01:23:37,520 --> 01:23:39,680
2小于3，所以现在是
The 2 is smaller than the 3, so that now is

1741
01:23:39,680 --> 01:23:41,905
到目前为止我发现的最小的数字。
the smallest number I've found so far.

1742
01:23:41,904 --> 01:23:42,779
但是我还没有完成。
But I'm not done yet.

1743
01:23:42,779 --> 01:23:43,654
所以我会继续寻找。
So I'll keep looking.

1744
01:23:43,654 --> 01:23:46,489
7大于2，4大于2。
The 7 is bigger than the 2, the 4 is bigger than the 2.

1745
01:23:46,489 --> 01:23:47,989
但是1小于2。
But the 1 is smaller than the 2.

1746
01:23:47,989 --> 01:23:50,749
因此，现在我一直走到阵列的尽头。
So now I've made my way all the way to the end of the array.

1747
01:23:50,750 --> 01:23:53,023
我可以说1是我找到的最小数字。
And 1, I can say, is the smallest number that I found.

1748
01:23:53,023 --> 01:23:53,690
戴维·马兰：好的。
DAVID MALAN: OK.

1749
01:23:53,689 --> 01:23:56,231
所以我听到的是您正在做所有这些比较，
So what I'm hearing is you're doing all of these comparisons,

1750
01:23:56,231 --> 01:23:58,866
也与彼得的暗示相似，您不断检查，
also similar to what Peter implied, and you keep checking,

1751
01:23:58,867 --> 01:24:00,950
这个小一点，这个小一点，这个小一点，
is this smaller, is this smaller, is this smaller,

1752
01:24:00,949 --> 01:24:04,099
您是否正在跟踪所看到的当前最小数字？
and you're keeping track of the currently smallest number you've seen?

1753
01:24:04,100 --> 01:24:05,180
布莱恩：是的，听起来不错。
BRIAN: Yeah, that sounds about right.

1754
01:24:05,180 --> 01:24:05,420
戴维·马兰：好的。
DAVID MALAN: All right.

1755
01:24:05,420 --> 01:24:06,260
所以你找到了。
So you found it.

1756
01:24:06,260 --> 01:24:07,930
我认为这是一开始的事情。
And I think it belongs at the beginning.

1757
01:24:07,930 --> 01:24:09,760
那么，我们现在如何将其落实到位？
So how do we put this into place now?

1758
01:24:09,760 --> 01:24:11,250
布莱恩：是的，所以我想放在开头。
BRIAN: Yeah, so I want to put it at the beginning.

1759
01:24:11,250 --> 01:24:12,582
确实没有空间。
There's not really space for it.

1760
01:24:12,582 --> 01:24:15,382
因此，只要将这些数字移开，我就可以腾出空间。
So I could make space for it, just by shifting these numbers over.

1761
01:24:15,382 --> 01:24:16,049
戴维·马兰：好的。
DAVID MALAN: OK.

1762
01:24:16,050 --> 01:24:16,500
等等。
Wait, wait.

1763
01:24:16,500 --> 01:24:19,375
但是我觉得您只是-现在您的工作量翻了一番。
But I feel like you're just-- now you're doubling the amount of work.

1764
01:24:19,375 --> 01:24:20,707
我觉得-不要那样做。
I feel like-- don't do all that.

1765
01:24:20,707 --> 01:24:23,166
感觉您将要做的步骤比我们需要的更多。
That feels like you're going to do more steps than we need.

1766
01:24:23,167 --> 01:24:24,530
我们在这里还能做什么？
What else could we do here?

1767
01:24:24,529 --> 01:24:25,029
布莱恩：好的。
BRIAN: OK.

1768
01:24:25,029 --> 01:24:27,342
因此，另一种选择是，它需要进入该位置，
So the other option is, it needs to go in this spot,

1769
01:24:27,342 --> 01:24:28,759
像阵列中的第一个点。
like this first spot in the array.

1770
01:24:28,760 --> 01:24:30,267
所以我可以把它放在那里。
So I could just put it there.

1771
01:24:30,266 --> 01:24:33,349
但是，如果我这样做，我将不得不拿现在的6
But if I do that, I'm going to have to take the 6 which is there right now

1772
01:24:33,350 --> 01:24:34,790
并拉出6。
and pull the 6 out.

1773
01:24:34,789 --> 01:24:35,059
戴维·马兰（David MALAN）：好的，但是我认为是-
DAVID MALAN: All right, but I think that's--

1774
01:24:35,060 --> 01:24:37,170
布莱恩：所以1在正确的位置，但是6在不正确的位置。
BRIAN: So the 1 is in the right place, but the 6 isn't.

1775
01:24:37,170 --> 01:24:37,670
戴维·马兰（David MALAN）：是的，我同意。
DAVID MALAN: Yeah, I agree.

1776
01:24:37,670 --> 01:24:38,878
但是我认为可以，对吗？
But I think that's OK, right?

1777
01:24:38,877 --> 01:24:42,659
因为这些数字是随机开始的，所以6放在错误的位置
Because these numbers started randomly, and so the 6 is in the wrong place

1778
01:24:42,659 --> 01:24:43,159
反正。
anyway.

1779
01:24:43,159 --> 01:24:46,309
我认为，仅将其移至其他位置不会使问题变得更糟。
I don't think we're making the problem any worse by just moving it elsewhere.

1780
01:24:46,310 --> 01:24:49,280
实际上，我想，交换两个数字要快得多，
And indeed, it's a lot faster, I would think, to just swap two numbers,

1781
01:24:49,279 --> 01:24:51,529
将一个移动到另一个，反之亦然，然后
move one to the other and vice versa, then

1782
01:24:51,529 --> 01:24:54,019
在所有这些数字之间移动。
shift all of those numbers in between.

1783
01:24:54,020 --> 01:24:54,520
布莱恩：是的。
BRIAN: Yeah.

1784
01:24:54,520 --> 01:24:56,728
所以我在最后一刻从头寸中取出了1
So I took the 1 out of the position at the very end

1785
01:24:56,728 --> 01:24:58,770
阵列的所有位置，一直到右侧。
of the array, all the way on the right-hand side.

1786
01:24:58,770 --> 01:25:01,320
所以我想我可以拿6放到那里，
So I guess I could take the 6 and just put it there,

1787
01:25:01,319 --> 01:25:04,099
因为那是一个可以放置数字的开放空间。
because that's where there's an open space to put the number.

1788
01:25:04,100 --> 01:25:04,370
戴维·马兰：是的。
DAVID MALAN: Yeah.

1789
01:25:04,369 --> 01:25:07,109
而且它并不完全在正确的空间中，但同样，情况也不会更糟。
And it's not exactly in the right space, but again, it's no worse off.

1790
01:25:07,109 --> 01:25:07,609
所以我喜欢。
So I like that.

1791
01:25:07,609 --> 01:25:07,819
好的。
All right.

1792
01:25:07,819 --> 01:25:10,486
但现在，事实是1的位置正确-实际上，
But now, the fact that the 1 is in the right place-- and indeed,

1793
01:25:10,487 --> 01:25:12,380
您已将其照亮以表示尽可能多的内容-
you've illuminated it to indicate as much--

1794
01:25:12,380 --> 01:25:14,630
我觉得我们几乎可以忽略以后的1
I feel like we can pretty much ignore the 1 henceforth

1795
01:25:14,630 --> 01:25:16,680
现在只需选择下一个最小的元素。
and now just select the next smallest element.

1796
01:25:16,680 --> 01:25:18,210
那你能带我们经历一下吗？
So can you walk us through that?

1797
01:25:18,210 --> 01:25:19,790
布莱恩：是的，所以我想我会重复同样的过程。
BRIAN: Yeah, so I guess I'd repeat the same process.

1798
01:25:19,789 --> 01:25:20,869
我将从3开始。
I'd start with the 3.

1799
01:25:20,869 --> 01:25:22,927
这是我到目前为止发现的最小数字。
That's the smallest number I've found so far.

1800
01:25:22,927 --> 01:25:23,719
我一直在寻找。
And I keep looking.

1801
01:25:23,720 --> 01:25:26,750
8大于3，5大于3。
The 8 is bigger than the 3, the 5 is bigger than the 3.

1802
01:25:26,750 --> 01:25:27,989
2小于3。
The 2 is smaller than the 3.

1803
01:25:27,989 --> 01:25:29,059
所以我会记得2。
So I'll remember that 2.

1804
01:25:29,060 --> 01:25:31,023
到目前为止，这是我所见过的最小的东西。
That's the smallest thing I've seen so far.

1805
01:25:31,023 --> 01:25:34,190
然后，我只需要检查是否有小于2的东西。
And then I just need to check to see if there's anything smaller than the 2.

1806
01:25:34,189 --> 01:25:36,557
我看一下7、4和6
And I look at the 7, the 4, and the 6.

1807
01:25:36,557 --> 01:25:38,099
这些都不比2小。
None of those are smaller than the 2.

1808
01:25:38,100 --> 01:25:41,623
因此，我可以说2是数组的下一个最小数字。
So the 2, I can say is the next smallest number for the array.

1809
01:25:41,622 --> 01:25:42,289
戴维·马兰：好的。
DAVID MALAN: OK.

1810
01:25:42,289 --> 01:25:43,807
那你该放在哪里呢？
And where would you put that then?

1811
01:25:43,807 --> 01:25:45,599
布莱恩：那需要排在第二位。
BRIAN: That needs to go in the second spot.

1812
01:25:45,600 --> 01:25:47,060
因此，我需要将3个拉出。
So I need to pull the 3 out.

1813
01:25:47,060 --> 01:25:50,450
我想我可以拿3放到这个空旷的地方
And I guess I can take the 3 and just put it into this open spot, where

1814
01:25:50,449 --> 01:25:51,769
有可用空间。
there's available space.

1815
01:25:51,770 --> 01:25:52,520
戴维·马兰：是的。
DAVID MALAN: Yeah.

1816
01:25:52,520 --> 01:25:54,650
我觉得它开始变得清晰起来
And I feel like it's starting to become clear

1817
01:25:54,649 --> 01:25:56,869
我们处于某种循环之中，因为您几乎被告知
that we're inside some kind of loop, because you pretty much told

1818
01:25:56,869 --> 01:25:58,669
同样的故事，但数字不同。
the same story again but with a different number.

1819
01:25:58,670 --> 01:26:00,710
您介意将算法继续到底吗
Do you mind just continuing the algorithm to the end

1820
01:26:00,710 --> 01:26:03,168
然后选择下一个最小，下一个最小，下一个最小的
and select the next smallest, next smallest, next smallest,

1821
01:26:03,167 --> 01:26:04,000
并得到排序？
and get that sorted?

1822
01:26:04,001 --> 01:26:04,501
布莱恩：当然。
BRIAN: Sure.

1823
01:26:04,501 --> 01:26:05,225
所以我们得到了8。
So we got the 8.

1824
01:26:05,225 --> 01:26:07,768
5小于该值，3小于该值。
5 is smaller than that, 3 is smaller than that.

1825
01:26:07,768 --> 01:26:09,560
然后其余的数字是7、4、6。
And then the rest of the number is 7, 4, 6.

1826
01:26:09,560 --> 01:26:10,760
这些都更大。
Those are all bigger.

1827
01:26:10,760 --> 01:26:13,850
因此，这里的3将进入排序位置。
So the 3, that's going to go into sorted position here.

1828
01:26:13,850 --> 01:26:15,900
我将拿8交换它。
And I'll take the 8 and swap it.

1829
01:26:15,899 --> 01:26:17,379
现在我来看看5。
Now I'm going to look at the 5.

1830
01:26:17,380 --> 01:26:18,830
8和7都更大。
8 and 7 are both bigger.

1831
01:26:18,829 --> 01:26:21,679
4比5小，但6大。
The 4 is smaller than the 5, but the 6 is bigger.

1832
01:26:21,680 --> 01:26:24,540
因此，这是我到目前为止所看到的最小的数字4。
So the 4, that's the smallest number I've seen so far.

1833
01:26:24,539 --> 01:26:28,159
因此，将要安装的4，我将与5交换它。
So the 4, that's going to go into place, and I'll swap it with the 5.

1834
01:26:28,159 --> 01:26:29,484
现在我有了8。
And now I've got the 8.

1835
01:26:29,484 --> 01:26:31,609
7小于8，因此我会记住这一点。
The 7 is smaller than the 8, so I'll remember that.

1836
01:26:31,609 --> 01:26:33,039
5小于那个。
5 is smaller than that.

1837
01:26:33,039 --> 01:26:34,549
6更大。
The 6 is bigger.

1838
01:26:34,550 --> 01:26:37,190
因此，下一个数字是5。
So the 5, that's going to be the next number.

1839
01:26:37,189 --> 01:26:39,876
现在我剩下了7。
And now I'm left with 7.

1840
01:26:39,877 --> 01:26:41,960
8更大，所以7仍然是我所见过的最小的。
8 is bigger, so 7 is still the smallest I've seen.

1841
01:26:41,960 --> 01:26:45,350
但是6较小，因此下一个6。
But 6 is smaller, so 6 goes next.

1842
01:26:45,350 --> 01:26:47,570
现在我只剩下最后两个了。
And now I'm down to the last two.

1843
01:26:47,569 --> 01:26:50,899
在最后两个数字8和7之间，则7较小。
And between the last two, the 8 and the 7, the 7 is smaller.

1844
01:26:50,899 --> 01:26:53,449
因此7将会在这个位置上。
So the 7 is going to go in this spot.

1845
01:26:53,449 --> 01:26:55,729
至此，我只剩下一个号码了。
And at this point, I've only got one number left.

1846
01:26:55,729 --> 01:26:58,459
因此，该数字必须位于已排序的位置。
So that number must be in sorted position.

1847
01:26:58,460 --> 01:27:01,310
现在，我要说的是这是一组排序的数字。
And now I would say that this is a sorted array of numbers.

1848
01:27:01,310 --> 01:27:02,060
戴维·马兰：好的。
DAVID MALAN: Nice.

1849
01:27:02,060 --> 01:27:04,250
因此，这绝对是正确的。
So it definitely seems to be correct.

1850
01:27:04,250 --> 01:27:05,600
感觉有点慢。
It felt a little slow.

1851
01:27:05,600 --> 01:27:07,808
但是，当然，计算机可以更快地完成此任务
But of course, the computer could do this much faster

1852
01:27:07,807 --> 01:27:09,131
比我们，使用一个实际的数组。
than we, using an actual array.

1853
01:27:09,131 --> 01:27:11,089
如果您不介意我的观察，
And if you don't mind my making an observation,

1854
01:27:11,090 --> 01:27:15,870
看起来如果我们有八个数字开头，或者更一般地，n
it looks like if we have eight numbers to begin with, or n more generally,

1855
01:27:15,869 --> 01:27:20,119
看起来您基本上进行了n减1的比较，
it looks like you essentially did n minus 1 comparisons,

1856
01:27:20,119 --> 01:27:23,896
因为您一直在继续比较数字-实际上，没有进行过n次比较。
because you kept comparing numbers again-- actually, did n comparisons.

1857
01:27:23,896 --> 01:27:25,729
您看了第一个数字，然后
You looked at the first number, and then you

1858
01:27:25,729 --> 01:27:28,999
一遍又一遍地将其与所有其他可能值进行比较
compared it again and again and again at all of the other possible values

1859
01:27:29,000 --> 01:27:31,439
为了找到最小的元素。
in order to find the smallest element.

1860
01:27:31,439 --> 01:27:31,939
布莱恩：是的。
BRIAN: Yeah.

1861
01:27:31,939 --> 01:27:35,189
因为对于数组中的每个数字，我必须进行比较才能看到，
Because for each of the numbers in the array, I had to do a comparison to see,

1862
01:27:35,189 --> 01:27:38,249
它比我到目前为止所见的最小物体还小吗？
is it smaller than the smallest thing that I've seen so far?

1863
01:27:38,250 --> 01:27:40,540
如果它更小，则比我需要记住的要小。
And if it is smaller, than I needed to remember that.

1864
01:27:40,539 --> 01:27:41,289
戴维·马兰：是的。
DAVID MALAN: Yeah.

1865
01:27:41,289 --> 01:27:44,509
因此，在每个通行证中，您都会考虑每个数字，因此首先要考虑n个数字。
So in each pass you considered every number, so a total of n numbers first.

1866
01:27:44,510 --> 01:27:46,760
因此，您找到了将数字1放在它的位置，
And so you found the number 1 you put it in its place,

1867
01:27:46,760 --> 01:27:50,300
这样一来，您便可以清楚地得到n减1的数字。
and that left you to be clear with n minus 1 numbers thereafter.

1868
01:27:50,300 --> 01:27:53,630
然后，n减2个数字，n减3个数字，点，
And then after that, n minus 2 numbers, n minus 3 numbers, dot,

1869
01:27:53,630 --> 01:27:56,130
点，点，一直到最后一个数字。
dot, dot, all the way down to one final number.

1870
01:27:56,130 --> 01:27:57,440
所以我认为这是正确的。
So I think this is correct.

1871
01:27:57,439 --> 01:28:00,049
我认为这是一种非常刻意的方式
And I think that's a pretty deliberate way

1872
01:28:00,050 --> 01:28:03,428
这些元素的排序比您的第一种方法更故意，
of sorting these elements, a little more deliberately than your first approach,

1873
01:28:03,427 --> 01:28:05,719
布赖恩（Brian），我可能会形容为更加有机。
Brian, which I might describe as a little more organic.

1874
01:28:05,720 --> 01:28:06,560
你有点喜欢-
You kind of did it like--

1875
01:28:06,560 --> 01:28:09,352
更像人类，只是一种盯着眼睛的东西和动人的东西
more like a human, just kind of eyeballing things and moving things

1876
01:28:09,351 --> 01:28:09,929
大约。
around.

1877
01:28:09,930 --> 01:28:11,722
但是如果我们将其翻译成代码，
But if we were to translate this into code,

1878
01:28:11,721 --> 01:28:13,789
回想一下，我们必须如此精确。
recall that we have to be ever so precise.

1879
01:28:13,789 --> 01:28:18,469
因此，让我一起考虑一下，我们到底可以如何翻译布莱恩
And so let me consider altogether how exactly we might translate what Brian

1880
01:28:18,470 --> 01:28:20,820
最终还是要伪代码。
did ultimately to, again, pseudocode.

1881
01:28:20,819 --> 01:28:23,279
因此，他所做的实际上是一个具有名称的算法。
So what he did is actually an algorithm that has a name.

1882
01:28:23,279 --> 01:28:24,989
这称为选择排序。
It's called selection sort.

1883
01:28:24,989 --> 01:28:25,529
为什么？
Why?

1884
01:28:25,529 --> 01:28:27,379
好吧，它最终是对元素进行排序。
Well, it's sorting the elements ultimately.

1885
01:28:27,380 --> 01:28:30,530
这是通过让Brian或真正的计算机来实现的，
And it's doing so by having Brian, or really the computer,

1886
01:28:30,529 --> 01:28:33,829
一遍又一遍地选择最小的元素。
select the smallest elements again and again and again.

1887
01:28:33,829 --> 01:28:35,659
一旦找到每个如此小的元素，
And once you found each such small element,

1888
01:28:35,659 --> 01:28:37,819
您将获得忽略它的额外好处。
you get the added benefit of just ignoring it.

1889
01:28:37,819 --> 01:28:39,679
确实，每次Brian点亮数字时，
Indeed, every time Brian lit up a number,

1890
01:28:39,680 --> 01:28:43,610
他不需要一直比较它，所以他正在做的工作量
he didn't need to keep comparing it, so the amount of work he was doing

1891
01:28:43,609 --> 01:28:47,299
在减少每次迭代-n个数字，然后n减1，
was decreasing each iteration-- n numbers, then n minus 1,

1892
01:28:47,300 --> 01:28:49,950
然后n减2，n减3，依此类推。
then n minus 2, n minus 3, and so forth.

1893
01:28:49,949 --> 01:28:53,449
所以我们可以考虑一下该算法的运行时间
And so we can think about the running time of this algorithm

1894
01:28:53,449 --> 01:28:56,819
作为在其实际伪代码中的清单。
as being manifest in its actual pseudocode.

1895
01:28:56,819 --> 01:28:58,482
那么我们如何定义伪代码呢？
So how might we define the pseudocode?

1896
01:28:58,483 --> 01:29:00,650
好吧，让我建议我们这样考虑-
Well, let me propose that we think of it like this--

1897
01:29:00,649 --> 01:29:03,299
因为我从0到n减去1。
for i from 0 to n minus 1.

1898
01:29:03,300 --> 01:29:05,390
现在，无疑这可能是最神秘的
Now, undoubtedly this is probably the most cryptic

1899
01:29:05,390 --> 01:29:07,972
在屏幕上三行伪代码中查找一行。
looking line of the three lines of pseudocode on the screen.

1900
01:29:07,971 --> 01:29:09,679
但是同样，这是那种
But again, this is the kind of thing that

1901
01:29:09,680 --> 01:29:13,470
随着时间的流逝，它应该成为死记硬背的内存，或者仅仅是代码的本能。
should become rote memory over time, or just instincts with code.

1902
01:29:13,470 --> 01:29:15,470
我们已经在C语言中看到了如何编写for循环。
We've seen in C how you can write a for loop.

1903
01:29:15,470 --> 01:29:18,680
按照惯例，对于循环而言，通常从0开始计数。
For loops typically, by convention, start counting at 0.

1904
01:29:18,680 --> 01:29:22,400
但是，如果您有n个元素，则您不想累加n个元素。
But if you have n elements, you don't want to count up through n.

1905
01:29:22,399 --> 01:29:27,559
您要计数最多n或等效地直到n减去1，
You want to count up to n or equivalently up through n minus 1,

1906
01:29:27,560 --> 01:29:29,430
所以从0到n减去1。
so from 0 to n minus 1.

1907
01:29:29,430 --> 01:29:29,930
好的。
All right.

1908
01:29:29,930 --> 01:29:31,580
现在，我接下来要做什么-
Now what do I want to do on the next--

1909
01:29:31,579 --> 01:29:32,899
在第一次迭代？
on the first iteration?

1910
01:29:32,899 --> 01:29:37,579
在第i个项目和最后一个项目之间找到最小的项目。
Find the smallest item between the i-th item and the last item.

1911
01:29:37,579 --> 01:29:40,579
乍一看，这并不是很明显。
So this is not quite obvious, I think, at first glance.

1912
01:29:40,579 --> 01:29:43,699
但是，我确实认为这是Brian所做的事情的合理描述。
But I do think it's a fair characterization of what Brian did.

1913
01:29:43,699 --> 01:29:47,539
因为如果我初始化为0，那就像Brian指向
Because if i is initialized to 0, that was like Brian pointing

1914
01:29:47,539 --> 01:29:51,829
他的左手放在架子最左边的第一个数字上。
his left hand at the first number on the very left of the shelf.

1915
01:29:51,829 --> 01:29:56,249
然后他做的就是发现第i个元素之间的最小元素，
And what he then did was he found the smallest element between the i-th item,

1916
01:29:56,250 --> 01:29:58,654
第一项为0，最后一项为。
the first item 0, and the last item.

1917
01:29:58,654 --> 01:30:00,529
所以这是一种非常奇特的说法，
So that's kind of a very fancy way of saying,

1918
01:30:00,529 --> 01:30:04,789
Brian，在所有n个元素中找到最小的元素。
Brian, find the smallest elements among all n elements.

1919
01:30:04,789 --> 01:30:09,679
然后他所做的就是将最小的物品换成第i个物品。
Then what he did was swapped the smallest item with the i-th item.

1920
01:30:09,680 --> 01:30:12,140
所以他只是做了那个switcheroo，以至于没有
So he just did that switcheroo, so as to not have

1921
01:30:12,140 --> 01:30:15,080
浪费时间转移一切。
to waste time shifting everything over.

1922
01:30:15,079 --> 01:30:17,329
相反，他只是通过交换为它腾出了空间
He instead just made room for it by swapping it

1923
01:30:17,329 --> 01:30:20,216
带有错误位置的价值。
with the value that was in its wrong place.

1924
01:30:20,216 --> 01:30:23,299
但是现在，在此循环的下一个迭代中，请考虑for循环的工作方式。
But now in the next iteration of this loop, consider how a for loop works.

1925
01:30:23,300 --> 01:30:25,582
您可以使用伪代码隐式地执行i ++。
You do an i++ implicitly in pseudocode.

1926
01:30:25,582 --> 01:30:26,790
这就是这里发生的事情。
That's what's happening here.

1927
01:30:26,789 --> 01:30:28,369
所以现在我等于1。
So now i equals 1.

1928
01:30:28,369 --> 01:30:33,799
在第i个项目（索引为1 0的项目）之间找到最小的项目，
Find the smallest item between the i-th item, item 1 0 indexed,

1929
01:30:33,800 --> 01:30:34,880
和最后一个项目。
and the last item.

1930
01:30:34,880 --> 01:30:39,140
所以这是一种奇特的说法，布莱恩，检查所有n个元素
So this is a fancy way of saying, Brian, check all of the n elements

1931
01:30:39,140 --> 01:30:42,200
再次，除了第一个，因为现在你是
again, except for the first, because now you're

1932
01:30:42,199 --> 01:30:45,679
从位置1而不是位置0开始。
starting at location 1 instead of location 0.

1933
01:30:45,680 --> 01:30:47,300
现在算法继续进行。
And now the algorithm proceeds.

1934
01:30:47,300 --> 01:30:49,490
所以你可以用不同的方式写这段代码
So you could write this code in different ways

1935
01:30:49,489 --> 01:30:51,409
在英语中就像伪代码，但这似乎
in English like pseudocode, but this seems

1936
01:30:51,409 --> 01:30:54,649
是该算法的合理表述。
to be a reasonable formulation of exactly that algorithm.

1937
01:30:54,649 --> 01:30:57,469
但是现在让我们更直观地看待它，
But let's see it a little more visually now,

1938
01:30:57,470 --> 01:31:00,808
却没有人类在数字周围移动的所有切换。
without all of the switching around of the humans moving around the numbers.

1939
01:31:00,807 --> 01:31:02,599
让我继续使用此可视化。
Let me go ahead and use this visualization.

1940
01:31:02,600 --> 01:31:04,040
我们将在课程的网站上放置一个链接
And we'll put a link on the course's website

1941
01:31:04,039 --> 01:31:05,706
如果您也想与此一起玩。
if you'd like to play with this as well.

1942
01:31:05,707 --> 01:31:10,520
这只是某人对数字数组的可视化。
This is just someone's visualization of an array of numbers.

1943
01:31:10,520 --> 01:31:14,540
但是这次，不是将数字表示为符号，十进制数字，
But this time, rather than represent the numbers as symbols, decimal digits,

1944
01:31:14,539 --> 01:31:17,509
现在此人正在使用垂直条，例如条形图。
now this person is using vertical bars, like a bar chart.

1945
01:31:17,510 --> 01:31:20,720
这意味着小条就像是一个小数字，
And what this means is that a small bar is like a small number,

1946
01:31:20,720 --> 01:31:22,430
一个大酒吧是一个很大的数目。
and a big bar is a big number.

1947
01:31:22,430 --> 01:31:26,810
因此，此处的目标是这些条形图，这些条形图同样可能是数字，
So the goal here is to these bars, which equivalently might as well be numbers,

1948
01:31:26,810 --> 01:31:29,777
从短条到高条，从左到右。
from short bars over to tall bars, left to right.

1949
01:31:29,777 --> 01:31:30,860
我要继续。
And I'm going to go ahead.

1950
01:31:30,859 --> 01:31:34,099
在这里的顶部，我可以选择我的排序算法。
And along the top of the here, I can choose my sorting algorithm.

1951
01:31:34,100 --> 01:31:36,830
回想一下，我们刚才描述的是选择排序。
And the one we just described, recall, was selection sort.

1952
01:31:36,829 --> 01:31:39,169
因此，让我继续执行此操作。
So let me go ahead and do this.

1953
01:31:39,170 --> 01:31:41,900
请注意，我想花点时间来整理一下您的想法
And notice, it takes a moment, I think, to wrap your mind

1954
01:31:41,899 --> 01:31:43,739
围绕这里发生的事情。
around what's happening here.

1955
01:31:43,739 --> 01:31:48,199
但是请注意，这条粉红色的线是从左到右，因为那是
But notice that this pink line is going from left to right, because that's

1956
01:31:48,199 --> 01:31:49,729
本质上是Brian在做什么。
essentially what Brian was doing.

1957
01:31:49,729 --> 01:31:52,729
他来回走动，来回走动，来回走动
He was walking back and forth, back and forth, back and forth

1958
01:31:52,729 --> 01:31:56,179
在那组数字中，寻找下一个最小的数字，
through that shelf of numbers, looking for the next smallest number,

1959
01:31:56,180 --> 01:32:00,260
他一直将最小的数字放在左边。
and he kept putting the smallest number over on the left where it belongs.

1960
01:32:00,260 --> 01:32:02,660
的确，这就是为什么在此可视化中
And indeed, that's why in this visualization

1961
01:32:02,659 --> 01:32:07,729
您会看到左侧开始放有少量数字
you see the small numbers beginning to be put into place on the left

1962
01:32:07,729 --> 01:32:09,499
随着我们不断突袭。
as we keep swooping through.

1963
01:32:09,500 --> 01:32:13,759
但请注意，彩色条形会越来越迟地开始显示，
But notice, the colored bar keeps starting later and later,

1964
01:32:13,760 --> 01:32:18,222
越来越向右，也越来越向右，就像布莱恩没有追回自己的脚步一样。
more rightward and more rightward, just like Brian was not retracing his steps.

1965
01:32:18,221 --> 01:32:20,429
一旦他点亮了数字，他就让他们一个人呆着。
As soon as he lit up the numbers, he left them alone.

1966
01:32:20,430 --> 01:32:23,257
瞧，所有这些数字现在都已排序。
And voila, all of these numbers are now sorted.

1967
01:32:23,256 --> 01:32:26,089
因此，这只是考虑相同算法的一种图形方式。
So that's just a graphical way of thinking about the same algorithm.

1968
01:32:26,090 --> 01:32:28,970
但是那有效率还是低效率？
But how efficient or inefficient was that?

1969
01:32:28,970 --> 01:32:31,100
好吧，让我们看看是否可以在此处应用一些数字。
Well, let's see if we can apply some numbers here.

1970
01:32:31,100 --> 01:32:33,517
但是也有一些方法可以更直观地做到这一点
But there's also ways to do this a little more intuitively

1971
01:32:33,516 --> 01:32:35,159
随着时间的流逝，我们也会这样做。
over time, which we'll do, too.

1972
01:32:35,159 --> 01:32:38,449
因此，如果是第一次通过数字架子，他
So if the first time through the shelf of numbers, he

1973
01:32:38,449 --> 01:32:41,419
有八个数字可供使用-他必须查看所有八个数字
had eight numbers at his disposal-- he had to look at all eight numbers

1974
01:32:41,420 --> 01:32:43,560
以便确定其中哪一个最小。
in order to decide which of these is the smallest.

1975
01:32:43,560 --> 01:32:45,380
因此，这最初是n步。
So that's n steps initially.

1976
01:32:45,380 --> 01:32:48,090
下次他穿过书架时，
The next time he did a pass through the shelf,

1977
01:32:48,090 --> 01:32:51,140
他忽略了灯火通明的数字1，因为它已经
he ignored the brightly lit number 1, because it was already

1978
01:32:51,140 --> 01:32:53,660
根据他已经做过的事情定义。
in place by definition of what he had already done.

1979
01:32:53,659 --> 01:32:56,479
所以现在他只有n负1步要走。
So now he had n minus 1 steps to go.

1980
01:32:56,479 --> 01:33:01,859
然后他又执行了n减2步，然后n减3，n减4，n减5，
Then he did another n minus 2 steps, then n minus 3, n minus 4, n minus 5,

1981
01:33:01,859 --> 01:33:05,269
点，点，点，一直到最后一步，他只是
dot, dot, dot, all the way down to the final step, where he just

1982
01:33:05,270 --> 01:33:08,210
必须找到并留下数字8
had to find and leave alone the number 8,

1983
01:33:08,210 --> 01:33:11,280
因为那是最大的数字，所以只需一步。
because that was the biggest number, so one single step.

1984
01:33:11,279 --> 01:33:13,987
因此，这是数学上的某种系列。
So this is some kind of series here, mathematically.

1985
01:33:13,988 --> 01:33:17,030
您可能会在数学书的背面回忆起类似的内容
You might recall something like this in, like, the back of your math book

1986
01:33:17,029 --> 01:33:19,696
或在高中时，或在物理教科书或类似书籍的背面。
or in high school, or back of your physics textbook or the like.

1987
01:33:19,697 --> 01:33:23,330
事实证明，这实际上是这里的公式-
It turns out that this actually sums up to this formula here--

1988
01:33:23,329 --> 01:33:25,691
n乘以n加1除以2。
n times n plus 1 divided by 2.

1989
01:33:25,692 --> 01:33:28,400
如果不熟悉，您将不会记住，没什么大不了的。
And if that's not familiar, you don't remember that, no big deal.

1990
01:33:28,399 --> 01:33:31,279
让我规定一下我们用来计算的数学公式
Just let me stipulate that the mathematical formula with which we

1991
01:33:31,279 --> 01:33:34,999
开始时，我们得到n的序列，加上n减去1，再加上n减去2，
began, where we had the series of n, plus n minus 1, plus n minus 2,

1992
01:33:35,000 --> 01:33:38,149
加n减3，点，点，点，最终简单地求和
plus n minus 3, dot, dot, dot, simply sums up ultimately

1993
01:33:38,149 --> 01:33:42,649
到更简洁的n乘以n加1除以2。
to the more succinct n times n plus 1 divided by 2.

1994
01:33:42,649 --> 01:33:46,999
当然，如果将其相乘，将得到n平方加n除以2。
This, of course, if we multiply it out, gives us n squared plus n divided by 2.

1995
01:33:47,000 --> 01:33:50,770
我现在建议，这就是给我们……
And this now, I will propose, gives us just this--

1996
01:33:50,770 --> 01:33:54,440
n平方除以2加n / 2。
n squared divided by 2 plus n/2.

1997
01:33:54,439 --> 01:33:56,899
因此，如果我们真的想挑剔，这
So if we really wanted to be nit-picky, this

1998
01:33:56,899 --> 01:34:01,399
是步骤或操作或秒的总数，
is the total number of steps, or operations, or seconds,

1999
01:34:01,399 --> 01:34:04,039
但是我们要测量Brian的跑步时间。
however we want to measure Brian's running time.

2000
01:34:04,039 --> 01:34:07,969
因此，这似乎是精确的数学公式。
This seems to be the precise mathematical formula therefore.

2001
01:34:07,970 --> 01:34:11,700
但是在本周初，我们再次考虑，
But at the beginning of this week, we considered again,

2002
01:34:11,699 --> 01:34:13,159
一种大O表示法。
the sort of Big O notation.

2003
01:34:13,159 --> 01:34:16,759
挥挥手，我们更在乎数量级
With a wave of the hand, we care more about the order of magnitude

2004
01:34:16,760 --> 01:34:18,080
在其上运行算法。
on which an algorithm operates.

2005
01:34:18,079 --> 01:34:22,849
我真的不在乎这些除以2和n / 2。
I really don't care about these divided by 2 and n/2.

2006
01:34:22,850 --> 01:34:26,120
因为随着n变大，这些因素中的哪一个将变得重要？
Because which of these factors is going to matter as n gets big?

2007
01:34:26,119 --> 01:34:29,209
电话簿越大，我们拥有的门就越多，
The bigger the phone book gets, the more doors we have,

2008
01:34:29,210 --> 01:34:33,370
我们拥有的灯泡越多，货架上的数量就越多，
the more light bulbs we have, the more numbers we have on the shelf,

2009
01:34:33,369 --> 01:34:35,809
n将越来越大。
n is going to keep getting bigger and bigger and bigger.

2010
01:34:35,810 --> 01:34:38,430
鉴于此，主要因素是什么？
And given that, which is the dominant factor?

2011
01:34:38,430 --> 01:34:42,080
容欣如果我们可以在这里请人，请问以下哪些因素，
Rongxin, if we could call on someone here, which of these factors,

2012
01:34:42,079 --> 01:34:48,319
从长远来看，n平方除以2或n除以2
n squared divided by 2, or n divided by 2, really matters in the long run

2013
01:34:48,319 --> 01:34:54,089
随着我们的问题越来越大，随着n越来越大？
as our problems get bigger and bigger, as n gets bigger and bigger?

2014
01:34:54,090 --> 01:34:57,630
数学上哪些因素占主导地位？
Which of those factors mathematically dominates?

2015
01:34:57,630 --> 01:34:58,130
阿妮卡？
Anika?

2016
01:34:58,130 --> 01:35:00,218
听众：哦，是Anika，但是-
AUDIENCE: Oh, it's Anika, but--

2017
01:35:00,217 --> 01:35:01,009
DAVID MALAN：Anika。
DAVID MALAN: Anika.

2018
01:35:01,010 --> 01:35:02,635
听众：没问题。
AUDIENCE: It would be the-- no problem.

2019
01:35:02,635 --> 01:35:04,272
这将是n平方。
It would be the n squared.

2020
01:35:04,271 --> 01:35:05,479
戴维·马兰（David MALAN）：是的，n为平方。
DAVID MALAN: Yeah, n squared.

2021
01:35:05,479 --> 01:35:05,979
正确的。
Right.

2022
01:35:05,979 --> 01:35:08,389
如果您将n取任何数字并将其平方，
If you take any number for n and you square it,

2023
01:35:08,390 --> 01:35:11,150
从长远来看，肯定会更大
that's going to be bigger, certainly in the long run,

2024
01:35:11,149 --> 01:35:12,719
而不是只做n除以2。
than just doing n divided by 2.

2025
01:35:12,720 --> 01:35:15,470
因此，使用Big O符号，我们可以描述运行时间
And so with our Big O notation, we could describe the running time

2026
01:35:15,470 --> 01:35:20,930
布赖恩（Brian）的选择排序实现的公式，啊，它的n平方的数量级。
of Brian's selection sort implementation as, ah, it's on the order of n squared.

2027
01:35:20,930 --> 01:35:23,150
是的，我忽略了一些数字，是的，如果我们真的
Yes, I'm ignoring some numbers, and yes, if we really

2028
01:35:23,149 --> 01:35:25,759
想要挑剔，并计数每一步
wanted to be nit-picky and count up every single step

2029
01:35:25,760 --> 01:35:29,450
是布莱恩接受的，是n的平方除以2加n / 2。
that Brian took, yes, it's n squared divided by 2 plus n/2.

2030
01:35:29,449 --> 01:35:33,079
但是再说一次，如果您随着时间的流逝思考问题，
But again, if you think about the problem over time and n

2031
01:35:33,079 --> 01:35:36,169
变得非常大，有点像Facebook大小，Twitter大小，
getting really large, sort of Facebook-sized, Twitter-sized,

2032
01:35:36,170 --> 01:35:39,890
Google大小，真正在数学上占主导地位
Google-sized, what's really going to dominate mathematically

2033
01:35:39,890 --> 01:35:41,690
这是更大的因素吗？
is this bigger factor here.

2034
01:35:41,689 --> 01:35:44,419
那就是要使总步数的方式
That's what's going to make the total number of steps way

2035
01:35:44,420 --> 01:35:47,370
比那些较小的订单条款更大。
bigger than just those smaller order terms.

2036
01:35:47,369 --> 01:35:49,249
因此，在大O表示法中，选择排序将
So in Big O notation, selection sort would

2037
01:35:49,250 --> 01:35:51,540
似乎是n平方的量级。
seem to be on the order of n squared.

2038
01:35:51,539 --> 01:35:54,139
因此，如果我们考虑之前的图表
So if we consider our chart from before where

2039
01:35:54,140 --> 01:35:57,920
我们在搜索算法上设置了上限，
we had the upper bounds on our searching algorithms,

2040
01:35:57,920 --> 01:36:01,410
线性和二进制，不幸的是，
both linear and binary, this one, unfortunately,

2041
01:36:01,409 --> 01:36:05,764
实际上是此特定运行时间列表的最顶端。
is at really the tip top of this particular list of running times.

2042
01:36:05,765 --> 01:36:07,140
还有无限的更多。
And there's infinitely many more.

2043
01:36:07,140 --> 01:36:09,470
这些只是更常见公式的一个子集
These are just a subset of the more common formulas

2044
01:36:09,470 --> 01:36:11,807
计算机科学家可能会使用和思考的东西。
that a computer scientist might use and think about.

2045
01:36:11,806 --> 01:36:13,639
选择排序是列表的顶部。
Selection sort is kind of a top of the list.

2046
01:36:13,640 --> 01:36:15,800
并且在此列表上排名第一是不好的。
And being number one on this list is bad.

2047
01:36:15,800 --> 01:36:18,980
n平方肯定比说慢得多，
n squared is certainly much slower than, say,

2048
01:36:18,979 --> 01:36:22,609
1的大O，这当然是固定时间或一步。
big O of 1, which, of course, was constant time or one step.

2049
01:36:22,609 --> 01:36:24,579
所以我想知道我们是否可以-
So I wonder if we could be--

2050
01:36:24,579 --> 01:36:25,879
如果我们能做得更好。
if we could do a little better.

2051
01:36:25,880 --> 01:36:27,770
我想知道我们是否可以做得更好。
I wonder if we could do a little better.

2052
01:36:27,770 --> 01:36:29,970
彼得实际上确实早先说了别的话，
And Peter actually did say something else earlier,

2053
01:36:29,970 --> 01:36:33,890
这就像共享两个数字并解决问题一样。
which was about like sharing two numbers and fixing problems.

2054
01:36:33,890 --> 01:36:35,720
如果可以的话，让我
And if I can kind of run with that, let me

2055
01:36:35,720 --> 01:36:39,620
建议Brian，请您回过头来看看一种算法，
propose that we, Brian, return to you for a look at an algorithm that

2056
01:36:39,619 --> 01:36:43,389
可能被称为泡沫排序，泡沫排序
might be called instead bubble sort, bubble sort

2057
01:36:43,390 --> 01:36:45,740
是一种不同的算法，
being a different algorithm, this one that

2058
01:36:45,739 --> 01:36:47,286
尝试更本地解决问题。
tries to fix problems more locally.

2059
01:36:47,287 --> 01:36:49,370
所以事实上，布莱恩，如果你看一下数字，
So in fact, Brian, if you look at the numbers that

2060
01:36:49,369 --> 01:36:51,439
在您的面前，您已将其重置
are in front of you, which you've kindly reset

2061
01:36:51,439 --> 01:36:55,099
到他们原来未分类的位置，我真的是这样，
to their original, unsorted location, I feel like this really,

2062
01:36:55,100 --> 01:36:58,578
如果我们只关注数字对，那就是很多小数字。
if we focus on just pairs of numbers, it's just a lot of small numbers.

2063
01:36:58,578 --> 01:37:00,620
像上次一样，我们试图解决大问题
Like last time, we tried to solve the big problem

2064
01:37:00,619 --> 01:37:02,029
并整理整个东西。
and sorting the whole thing.

2065
01:37:02,029 --> 01:37:06,049
如果我们只看彼此相邻的数字对，那该怎么办？
What if we just look at pairs of numbers that are adjacent to one another?

2066
01:37:06,050 --> 01:37:09,860
我们可以做一些小的调整并从根本上改变我们的算法吗？
Can we maybe make some little tweaks and change our algorithm fundamentally?

2067
01:37:09,859 --> 01:37:14,449
举例来说，六岁和三岁的布莱恩（Brian），您能为我们做些什么观察？
So for instance, Brian, 6 and 3, what observation can you make there for us?

2068
01:37:14,449 --> 01:37:15,199
布莱恩：是的，当然。
BRIAN: Yeah, sure.

2069
01:37:15,199 --> 01:37:18,232
所以6和3就是数组中的第一对数字。
So 6 and 3 that's, the first pair of numbers in the array.

2070
01:37:18,233 --> 01:37:20,900
如果我想对数组进行排序，我希望较小的数字
And if I want the array to be sorted, I want the smaller numbers

2071
01:37:20,899 --> 01:37:23,669
在左边，更大的数字在右边。
to be on the left and the bigger numbers to be on the right.

2072
01:37:23,670 --> 01:37:27,227
因此，只要看一下这对货币对，我就可以告诉您6和3还是乱序。
So just looking at this pair, I can tell you that the 6 and 3 or out of order.

2073
01:37:27,226 --> 01:37:29,809
3应该在左边，而6应该在右边。
The 3 should be on the left, and the 6 should be on the right.

2074
01:37:29,810 --> 01:37:30,140
戴维·马兰：好的。
DAVID MALAN: All right.

2075
01:37:30,140 --> 01:37:31,932
所以，让我们继续前进，然后继续前进
So let's go ahead and do that, and go ahead

2076
01:37:31,931 --> 01:37:34,069
并通过交换这两个来解决。
and fix that by swapping those two.

2077
01:37:34,069 --> 01:37:35,631
并解决一个小问题。
And just fix a small little problem.

2078
01:37:35,631 --> 01:37:37,339
现在让我们重复这个过程，对吗？
And now let's repeat this process, right?

2079
01:37:37,340 --> 01:37:39,690
在我们的许多算法中，循环似乎无处不在。
Loops seem to be omnipresent in a lot of our algorithms.

2080
01:37:39,689 --> 01:37:41,212
所以6和8是下一个这样的对。
So 6 and 8 is the next such pair.

2081
01:37:41,212 --> 01:37:43,129
您想要什么-您如何看待这些？
What you want-- what do you think about those?

2082
01:37:43,130 --> 01:37:46,362
布莱恩：那对特别好，因为6较小，而且已经
BRIAN: That particular pair seems OK, because the 6 is smaller and already

2083
01:37:46,362 --> 01:37:47,070
在左侧。
on the left side.

2084
01:37:47,069 --> 01:37:48,559
所以我想我可以不理this这对。
So I think I can leave this pair alone.

2085
01:37:48,560 --> 01:37:49,518
戴维·马兰：好的。
DAVID MALAN: All right.

2086
01:37:49,518 --> 01:37:50,380
8和5呢？
How about 8 and 5?

2087
01:37:50,380 --> 01:37:51,920
布莱恩：8比5大。
BRIAN: The 8 is bigger than the 5.

2088
01:37:51,920 --> 01:37:53,300
所以我将交换这两个。
So I'm going to swap these two.

2089
01:37:53,300 --> 01:37:55,190
5应该在8的左边。
The 5 should be on the left of the 8.

2090
01:37:55,189 --> 01:37:56,147
戴维·马兰：好的。
DAVID MALAN: All right.

2091
01:37:56,148 --> 01:37:56,870
还有8和2？
And 8 and 2?

2092
01:37:56,869 --> 01:37:58,536
布莱恩：同样，这8个更大。
BRIAN: Same thing here, the 8 is bigger.

2093
01:37:58,537 --> 01:38:00,337
因此8将与2交换。
So the 8 is going to be swapped with the 2.

2094
01:38:00,337 --> 01:38:01,670
DAVID MALAN：好的，分别是8和7。
DAVID MALAN: All right, 8 and 7.

2095
01:38:01,670 --> 01:38:06,133
布莱恩：8大于7，所以我应该将8换成7。
BRIAN: The 8 is bigger than the 7, so the 8 I should switch with the 7.

2096
01:38:06,132 --> 01:38:07,424
大卫·马兰：好吧8和4？
DAVID MALAN: All right 8 and 4?

2097
01:38:07,425 --> 01:38:09,968
布莱恩：8和4，是同一件事，比4大。
BRIAN: 8 and 4, same thing, it's bigger than the 4.

2098
01:38:09,967 --> 01:38:11,009
戴维·马兰（DAVID MALAN）：还有8和1。
DAVID MALAN: And 8 and 1.

2099
01:38:11,010 --> 01:38:12,385
布莱恩：我最后一次可以做到。
BRIAN: I can do it one last time.

2100
01:38:12,385 --> 01:38:14,912
8比1大，我认为仅此而已。
The 8 is bigger than the 1, and I think that's all.

2101
01:38:14,912 --> 01:38:16,870
戴维·马兰（David MALAN）：
DAVID MALAN: And with a nice dramatic flourish,

2102
01:38:16,869 --> 01:38:18,899
如果您走到一边，瞧-
if you step off to the side, voila--

2103
01:38:18,899 --> 01:38:20,339
没有排序。
not sorted.

2104
01:38:20,340 --> 01:38:23,070
实际上，它看起来并没有那么好。
In fact, it doesn't really look all that much better.

2105
01:38:23,069 --> 01:38:26,069
但是我确实认为Brian在这里做了一些聪明的事情。
But I do think Brian's done something smart here.

2106
01:38:26,069 --> 01:38:29,549
布赖恩，您能否谈谈至少一些边际改进
Brian, can you speak to at least some of the marginal improvements

2107
01:38:29,550 --> 01:38:30,300
你做的？
that you've made?

2108
01:38:30,300 --> 01:38:30,590
布莱恩：是的。
BRIAN: Yeah.

2109
01:38:30,590 --> 01:38:32,298
因此，至少有一些改进。
So there are some improvements, at least.

2110
01:38:32,297 --> 01:38:36,889
1最初是一路走到尽头，然后又退了一位。
The 1 originally was all the way at the very end, and it moved back one spot.

2111
01:38:36,890 --> 01:38:39,390
我认为另一个改进是，最初的8
And the other improvement, I think, is that the 8 originally

2112
01:38:39,390 --> 01:38:42,150
在数组左侧某处的此处。
was way over here on the left side of the array somewhere.

2113
01:38:42,149 --> 01:38:44,129
但是因为8是最大的数字，我
But because the 8 is the biggest number, I

2114
01:38:44,130 --> 01:38:46,380
不断地反复切换，直到成功为止
kept switching it over and over again until it made it

2115
01:38:46,380 --> 01:38:47,640
一路走到尽头。
all the way to the end.

2116
01:38:47,640 --> 01:38:51,270
所以现在实际上，我认为这8位置正确。
And so now actually, I think this 8 is in the correct place.

2117
01:38:51,270 --> 01:38:54,660
这是最大的数字，最终一路走来
It's the biggest number, and it ended up moving its way all the way

2118
01:38:54,659 --> 01:38:56,189
在数组的右侧。
to the right side of the array.

2119
01:38:56,189 --> 01:38:56,549
戴维·马兰：是的。
DAVID MALAN: Yeah.

2120
01:38:56,550 --> 01:38:59,130
这就是我们稍后将看到其余算法的地方
And this is where this algorithm that we'll see the rest of in just a moment

2121
01:38:59,130 --> 01:39:00,720
得名，泡沫排序-
gets its name, bubble sort--

2122
01:39:00,720 --> 01:39:04,470
暗示着一个事实，即最大的数字开始冒泡
alludes to the fact that the biggest numbers start bubbling their way up

2123
01:39:04,470 --> 01:39:08,220
在列表的顶部或列表的右侧
to the top of, or the end of, the list, at the right-hand side

2124
01:39:08,220 --> 01:39:09,570
正如Brian所说的那样。
of the shelf as Brian notes.

2125
01:39:09,569 --> 01:39:14,349
但是请注意，就像Brian一样，数字1只能移至一个位置。
But notice, as Brian does, too, the number 1 only moved over one position.

2126
01:39:14,350 --> 01:39:16,080
因此，显然还有更多工作要做。
So there's clearly more work to be done.

2127
01:39:16,079 --> 01:39:18,689
从其他顺序错误的数据中也可以明显看出这一点。
And that's obvious from the other numbers being misordered as well.

2128
01:39:18,689 --> 01:39:19,949
但是，我们已经改善了。
But we have improved things.

2129
01:39:19,949 --> 01:39:23,759
8就位，而1更接近就位。
The 8 is in place, and the 1 is closer to being in place.

2130
01:39:23,760 --> 01:39:25,377
那么下一步我们该怎么做？
So how might we proceed next?

2131
01:39:25,377 --> 01:39:28,210
好吧，布莱恩，让我们继续解决一些小问题。
Well, Brian, let's continue to solve some small bite-sized problems.

2132
01:39:28,210 --> 01:39:29,668
让我们从头开始。
Let's start at the beginning again.

2133
01:39:29,667 --> 01:39:30,399
3和6？
3 and 6?

2134
01:39:30,399 --> 01:39:30,899
布莱恩：当然。
BRIAN: Sure.

2135
01:39:30,899 --> 01:39:33,539
3和6，似乎是按顺序排列的，因此我将不理会它们。
The 3 and the 6, those seem to be in order, so I'll leave those alone.

2136
01:39:33,539 --> 01:39:34,589
大卫·马兰（David MALAN）：6和5。
DAVID MALAN: 6 and 5.

2137
01:39:34,590 --> 01:39:37,420
布莱恩：6和5或顺序不对，所以我继续进行6
BRIAN: 6 and 5 or out of the order, so I'll go ahead and take the 6

2138
01:39:37,420 --> 01:39:38,420
并放在右边。
and put it to the right.

2139
01:39:38,420 --> 01:39:39,300
大卫·马兰（David MALAN）：6和2。
DAVID MALAN: 6 and 2.

2140
01:39:39,300 --> 01:39:42,045
布莱恩：那些也是乱序的，所以我将2和6换掉。
BRIAN: Those are out of order as well, so I'll swap the 2 and the 6.

2141
01:39:42,045 --> 01:39:42,930
大卫·马兰（David MALAN）：6和7。
DAVID MALAN: 6 and 7.

2142
01:39:42,930 --> 01:39:44,032
布莱恩：6和7可以。
BRIAN: 6 and 7 are OK.

2143
01:39:44,032 --> 01:39:44,740
他们是有秩序的。
They're in order.

2144
01:39:44,739 --> 01:39:45,689
大卫·马兰（David MALAN）：7和4。
DAVID MALAN: 7 and 4.

2145
01:39:45,689 --> 01:39:48,534
布莱恩：那些乱七八糟，所以我将4和7切换。
BRIAN: Those are out of order, so I'll switch the 4 and the 7.

2146
01:39:48,534 --> 01:39:49,409
大卫·马兰（David MALAN）：7和1。
DAVID MALAN: 7 and 1.

2147
01:39:49,409 --> 01:39:52,299
布莱恩：那两个也乱七八糟，所以我将其交换。
BRIAN: And those two are out of order as well, so I'll swap those.

2148
01:39:52,300 --> 01:39:55,800
现在，我认为7也已升至排序位置。
And now I think the 7 has made its way to the sorted position as well.

2149
01:39:55,800 --> 01:39:56,783
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

2150
01:39:56,783 --> 01:39:58,200
所以现在我们正在取得一些进展。
So now we're making some progress.

2151
01:39:58,199 --> 01:40:02,099
7冒泡到列表的顶部，在8之前停止
7 has bubbled its way up to the top of the list, stopping just before the 8,

2152
01:40:02,100 --> 01:40:05,550
而1则继续前进到正确的位置。
whereas the 1 has continued its advance to its correct location.

2153
01:40:05,550 --> 01:40:08,490
所以，我敢打赌，布莱恩，如果我们继续一遍又一遍地这样做
So I bet, Brian, if we keep doing this again and again

2154
01:40:08,489 --> 01:40:11,609
再一次，只要列表中的部分内容未排序，
and again, so long as the list remains in part unsorted,

2155
01:40:11,609 --> 01:40:13,529
我认为我们可能会到达终点。
I think we'll probably get to the finish line.

2156
01:40:13,529 --> 01:40:15,689
您要从这里拿走剩下的东西吗？
Do you want to take it from here and sort the rest?

2157
01:40:15,689 --> 01:40:16,269
布莱恩：是的，当然。
BRIAN: Yeah, sure.

2158
01:40:16,270 --> 01:40:17,830
因此，我再次重复该过程。
So I just repeat the process again.

2159
01:40:17,829 --> 01:40:19,409
3和5都可以。
The 3 and the 5 are OK.

2160
01:40:19,409 --> 01:40:22,069
2和5乱序，所以我将其交换。
The 2 and the 5 are out of order, so I'll swap them.

2161
01:40:22,069 --> 01:40:24,329
5和6，可以很好地配对使用。
The 5 and the 6, those are fine as a pair.

2162
01:40:24,329 --> 01:40:28,199
6和4彼此相对乱序，因此我将其切换。
The 6 and the 4, out of order relative to each other, so I'll switch those.

2163
01:40:28,199 --> 01:40:31,509
而6和1也一样，因此我将它们交换了一下。
And the 6 and the 1, those are out of order as well, so I'll swap those.

2164
01:40:31,510 --> 01:40:34,680
现在，我可以说6是正确的位置。
And now the 6, that I can say is in its correct position.

2165
01:40:34,680 --> 01:40:36,010
我会再重复一次。
And I'll repeat it again.

2166
01:40:36,010 --> 01:40:38,820
3和2乱序，所以它们被切换了。
The 3 and the 2 are out of order, so those get switched.

2167
01:40:38,819 --> 01:40:40,379
3和5都可以。
The 3 and the 5 are OK.

2168
01:40:40,380 --> 01:40:43,080
5和4乱序，所以它们被交换了。
The 5 and the 4 are out of order, so those get switched.

2169
01:40:43,079 --> 01:40:47,519
然后也需要切换5和1。
And then the 5 and the 1 need to be switched as well.

2170
01:40:47,520 --> 01:40:49,325
因此，有5个处于排序位置。
So there's the 5 in sorted position.

2171
01:40:49,324 --> 01:40:50,699
现在我剩下这四个了。
And now I'm left with these four.

2172
01:40:50,699 --> 01:40:53,069
2和3正常，3和4正常。
The 2 and the 3 are OK, the 3 and the 4 OK.

2173
01:40:53,069 --> 01:40:55,109
但是4和1出故障了。
But the 4 and the 1 are out of order.

2174
01:40:55,109 --> 01:40:58,789
这样就可以切换了，而现在这四个就可以了。
So those get switched, and now the four, that's in its place.

2175
01:40:58,789 --> 01:41:02,719
2和3可以，但是3和1则不行，所以我将其交换。
The 2 and the 3 are OK, but the 3 and the 1 are not, so I'll swap those.

2176
01:41:02,720 --> 01:41:05,700
现在3进入其排序位置。
And now the 3 goes into its sorted place.

2177
01:41:05,699 --> 01:41:08,899
最后，要考虑的最后一对是2和1。
And then finally, the last pair to consider is just the 2 and the 1.

2178
01:41:08,899 --> 01:41:12,689
这些是乱序的，所以我将交换它们，现在2到位了。
Those are out of order, so I'll swap those, and now the 2 is in place.

2179
01:41:12,689 --> 01:41:16,279
还有1是唯一剩余的数字，所以我可以说那个也已经到位。
And 1 is the only remaining number, so I can say that that one's in place, too.

2180
01:41:16,279 --> 01:41:18,439
现在，我认为我们有一个排序数组。
And now I think we have a sorted array.

2181
01:41:18,439 --> 01:41:19,189
戴维·马兰：好的。
DAVID MALAN: Nice.

2182
01:41:19,189 --> 01:41:21,859
所以感觉这是一种根本不同的方法，
So it felt like this was a fundamentally different approach,

2183
01:41:21,859 --> 01:41:23,761
但是我们仍然到达了相同的终点。
but we still got to the same end point.

2184
01:41:23,761 --> 01:41:26,719
因此，现在确实引发了有关是否存在气泡或是否存在气泡的问题。
So that really now invites the question as to whether bubbles or it was

2185
01:41:26,720 --> 01:41:29,370
更好或更坏，也许没有什么不同。
better or worse or maybe no different.

2186
01:41:29,369 --> 01:41:33,269
但也请注意，我们从根本上不同地解决了相同的问题。
But notice, too, that we've solved the same problem fundamentally differently.

2187
01:41:33,270 --> 01:41:36,427
第一次，我们采用了更人性化的自然直觉，
The first time, we took the more human natural intuition of just,

2188
01:41:36,426 --> 01:41:37,509
找到最小的元素。
find the smallest element.

2189
01:41:37,510 --> 01:41:39,480
好吧，再做一次，再做一次，再做一次。
All right, do it again, do it again, do it again.

2190
01:41:39,479 --> 01:41:42,229
这次，我们通过不同的角度看待问题。
This time, we sort of viewed the problem through a different lens.

2191
01:41:42,229 --> 01:41:44,359
我们考虑了一下，这是怎么回事
And we thought about, it would seem, what does it

2192
01:41:44,359 --> 01:41:46,129
列表未排序的意思是什么？
mean for the list to be unsorted?

2193
01:41:46,130 --> 01:41:48,260
正如Peter所指出的，这是事情出现故障的时候。
As Peter noted, it's when things are out of order.

2194
01:41:48,260 --> 01:41:51,380
就像那个非常基本的原始图元
Like that very basic primitive where something is out of order

2195
01:41:51,380 --> 01:41:54,380
建议以这种方式解决问题的机会。
suggests an opportunity to solve the problem that way.

2196
01:41:54,380 --> 01:41:57,170
只需解决所有微小的问题即可。
Just fix all of the tiny bite-sized problems.

2197
01:41:57,170 --> 01:42:00,470
似乎如果使用循环，如果我们重复这种直觉，
And it would seem that using a loop, if we repeat that intuition,

2198
01:42:00,470 --> 01:42:03,506
最终将通过固定，固定，固定来获得回报，
is going to pay off eventually by fixing, fixing, fixing,

2199
01:42:03,506 --> 01:42:06,620
解决所有小问题，直到大问题解决
fixing all of the little problems until the big one itself

2200
01:42:06,619 --> 01:42:07,999
似乎会消失。
would seem to go away.

2201
01:42:08,000 --> 01:42:12,150
好吧，让我从以前回到可视化，重新随机化这些条形-
Well, let me return to the visualization from before, re-randomize the bars--

2202
01:42:12,149 --> 01:42:15,479
短条是小数字，大条是大数字。
short bar is small number, big bar is big number.

2203
01:42:15,479 --> 01:42:17,899
让我继续运行气泡排序算法，
And let me go ahead and run the bubble sort algorithm,

2204
01:42:17,899 --> 01:42:20,389
这次有了这种可视化。
this time with this visualization.

2205
01:42:20,390 --> 01:42:24,680
您会注意到现在从左向右扫过的是两个彩色条，
And you'll notice now sweeping from left to right are two colored bars that

2206
01:42:24,680 --> 01:42:30,320
一次又一次地表示两个相邻数字的比较。
represent the comparison of two adjacent numbers again and again and again.

2207
01:42:30,319 --> 01:42:33,769
这次您会看到标杆变得有点聪明了，
And you'll see this time that the bars are being a little smart,

2208
01:42:33,770 --> 01:42:36,470
他们并没有每次都走到尽头
and they're not going all the way to the end every time,

2209
01:42:36,470 --> 01:42:39,440
就像布莱恩照亮了数字并停下来一样
just like Brian illuminated the numbers and stopped

2210
01:42:39,439 --> 01:42:43,079
观察8、7和6到位后的状态。
looking at the 8 and the 7 and the 6 once they were in place.

2211
01:42:43,079 --> 01:42:46,909
但是他和这种可视化确实的确回到了开始，
But he and this visualization do indeed keep returning to the beginning,

2212
01:42:46,909 --> 01:42:50,329
做另一遍，另一遍和另一遍。
doing another pass, another pass, and another pass.

2213
01:42:50,329 --> 01:42:53,269
因此，如果我们考虑一下该算法的分析，
So if we think ahead to the analysis of this algorithm,

2214
01:42:53,270 --> 01:42:57,560
有点邀请我们考虑，总共有多少个比较
it sort of invites us to consider, well, how many total comparisons are there

2215
01:42:57,560 --> 01:42:58,610
这次？
this time?

2216
01:42:58,609 --> 01:43:01,279
似乎是第一次穿过酒吧，
It would seem that the very first time through the bars,

2217
01:43:01,279 --> 01:43:04,249
或等效地第一次上架，布莱恩
or equivalently the very first time through the shelf, Brian

2218
01:43:04,250 --> 01:43:07,830
而且这种可视化效果确实像n减1的比较。
and this visualization did like n minus 1 comparisons.

2219
01:43:07,829 --> 01:43:10,089
所以从左到右n减1比较
So n minus 1 comparisons from left to right, out

2220
01:43:10,090 --> 01:43:13,880
的n个元素中，您可以比较n个负1邻接关系。
of n elements you can compare n minus 1 adjacencies.

2221
01:43:13,880 --> 01:43:17,780
之后，它是n减2，n减3，n减4，
After that it was n minus 2, n minus 3, n minus 4,

2222
01:43:17,779 --> 01:43:22,049
n减5，直到只剩下两个或一个，此时您已完成。
n minus 5, until just two or one remain, and at that point you're done.

2223
01:43:22,050 --> 01:43:25,070
因此，即使该算法从根本上采取了不同的方法
So even though this algorithm fundamentally took a different approach

2224
01:43:25,069 --> 01:43:29,159
并且达到了相同的目标，它成功地对元素进行了排序。
and achieved the same goal, it sorted the elements successfully.

2225
01:43:29,159 --> 01:43:31,399
让我们考虑一下它是如何在代码中实现的
Let's consider how it was implemented in code

2226
01:43:31,399 --> 01:43:35,269
以及实际上是快还是慢。
and whether it's actually a little faster or a little slower.

2227
01:43:35,270 --> 01:43:37,910
实际上，让我们设置一个最后的标准。
And let's set one final bar, in fact, too.

2228
01:43:37,909 --> 01:43:42,217
之前，我们仅考虑了选择排序的上限，
Earlier, we considered only the upper bound on selection sort,

2229
01:43:42,217 --> 01:43:44,509
只是为了让我们有一些东西可以与之进行比较。
just so that we have something to compare this against.

2230
01:43:44,510 --> 01:43:48,590
让我们再考虑一下运行时间是多少
Let's also consider for a moment what the running time is

2231
01:43:48,590 --> 01:43:52,940
选择范围的下限-最佳情况。
of selection sort in terms of a lower bound-- best case scenario.

2232
01:43:52,939 --> 01:43:56,689
对于选择排序，如果您有n个元素，
With selection sort, if you have n elements,

2233
01:43:56,689 --> 01:43:59,809
然后，您一次又一次地寻找下一个最小的元素
and you keep looking for the next smallest element, again and again

2234
01:43:59,810 --> 01:44:04,390
事实证明，选择排序并不是我们的真正朋友。
and again, it turns out that selection sort is not really our friend.

2235
01:44:04,390 --> 01:44:07,790
例如，这是我们从欧米茄表示法上停止的图表
Here's, for instance, the chart of where we left off in terms of omega notation

2236
01:44:07,789 --> 01:44:08,449
前。
before.

2237
01:44:08,449 --> 01:44:10,849
线性搜索和二进制搜索可能很好
Linear search and binary search could very well

2238
01:44:10,850 --> 01:44:13,910
幸运的话，只要碰巧打开一扇门，就迈出一步
get lucky and take just one step if you happen to open a door

2239
01:44:13,909 --> 01:44:17,339
瞧，您要查找的电话号码已经存在。
and, voila, the number you're looking for is already there.

2240
01:44:17,340 --> 01:44:20,360
但是随着选择排序的实现，
But with selection sort, as we've implemented it,

2241
01:44:20,359 --> 01:44:23,149
通过Brian和可视化，
both with Brian and with the visualization,

2242
01:44:23,149 --> 01:44:26,989
不幸的是，下限并不是那么好。
unfortunately it's none so good with the lower bound.

2243
01:44:26,989 --> 01:44:27,919
为什么？
Why?

2244
01:44:27,920 --> 01:44:32,720
好吧，Brian天真地天真，每次他搜索一个数字时，
Well, Brian pretty naively, every time he searched for a number,

2245
01:44:32,720 --> 01:44:37,230
从左边开始，一直到右边，从左边开始，
started at the left and went all the way to the right, started at the left,

2246
01:44:37,229 --> 01:44:38,479
一路向右走。
went all the way to the right.

2247
01:44:38,479 --> 01:44:41,807
公平地说，他确实忽略了已经存在的数字。
To be fair, he did ignore the numbers that were already in place.

2248
01:44:41,807 --> 01:44:44,599
所以他没有一直看1
So he didn't keep looking at the 1, he didn't keep looking at the 2

2249
01:44:44,600 --> 01:44:46,260
一旦到位。
once they were in place.

2250
01:44:46,260 --> 01:44:50,390
但是他确实不断地重复自己，触摸
But he did keep repeating himself again and again, touching

2251
01:44:50,390 --> 01:44:52,400
这些数字分别多次。
those numbers multiple times each.

2252
01:44:52,399 --> 01:44:55,399
再说一次，即使你和我，人类，可以看那些数字
So again, even though you and I, the humans, could look at those numbers

2253
01:44:55,399 --> 01:44:57,691
就像，显然有1，显然有
and be like, obviously there's the 1, obviously there's

2254
01:44:57,692 --> 01:44:59,540
2，显然有3，布莱恩
the 2, the obviously there's the 3, Brian

2255
01:44:59,539 --> 01:45:01,429
必须更加有条理地做到这一点。
had to do it much more methodically.

2256
01:45:01,430 --> 01:45:07,220
实际上，即使该数字列表得到了很好的排序，
And in fact, even if that list of numbers were perfectly sorted,

2257
01:45:07,220 --> 01:45:09,480
他会浪费很多时间。
he would have wasted just as much time.

2258
01:45:09,479 --> 01:45:11,839
实际上，布莱恩，如果您不介意的话，您能
In fact, Brian, if you don't mind, could you quickly

2259
01:45:11,840 --> 01:45:14,510
再次对所有八个数字进行排序？
sort all eight numbers again?

2260
01:45:14,510 --> 01:45:17,210
布赖恩，如果我们从排序列表开始，
And Brian, if we start with a sorted list,

2261
01:45:17,210 --> 01:45:21,190
如果您愿意的话，这是一个不错的变态算法。
this is kind of a nice perversion to consider, if you will, algorithmically.

2262
01:45:21,189 --> 01:45:22,939
分析算法时，有时您
When analyzing an algorithm, sometimes you

2263
01:45:22,939 --> 01:45:25,357
想考虑最好的情况和最坏的情况。
want to consider best cases and worst cases.

2264
01:45:25,358 --> 01:45:28,400
而且似乎没有什么比这更好的了，列表已经
And there would seem to be nothing better than, heck, the list is already

2265
01:45:28,399 --> 01:45:31,529
排序，您很幸运，实际上没有任何工作可以完成。
sorted, you got lucky, there's really no work to be done.

2266
01:45:31,529 --> 01:45:34,039
最糟糕的情况是，列表可能完全倒退了，
The worst case is the list is maybe completely backwards,

2267
01:45:34,039 --> 01:45:36,019
这是大量的工作要做。
and that's a huge amount of work to be done.

2268
01:45:36,020 --> 01:45:40,262
不幸的是，选择排序并没有真正针对那种幸运的情况进行优化
Unfortunately, selection sort doesn't really optimize for that lucky case

2269
01:45:40,261 --> 01:45:41,469
他们已经被排序的地方。
where they're already sorted.

2270
01:45:41,470 --> 01:45:44,780
因此，布莱恩，我看到您从左到右使用了我们的数字。
So Brian, I see you've resorted the numbers for us from left to right.

2271
01:45:44,779 --> 01:45:48,379
如果我们要像以前一样重新执行选择排序，
If we were to re-execute selection sort as before,

2272
01:45:48,380 --> 01:45:51,005
您将如何寻找最小的数字？
how would you go about finding the smallest number?

2273
01:45:51,005 --> 01:45:53,630
布莱恩：所以我们早些时候决定，要找到最小的数字，
BRIAN: So we decided earlier that, to find the smallest number,

2274
01:45:53,630 --> 01:45:55,422
我需要从左看所有数字
I need to look at all the numbers from left

2275
01:45:55,421 --> 01:45:58,579
在阵列中的右边，每次检查看是否找到了东西。
to right in the array and each time check to see if I found something.

2276
01:45:58,579 --> 01:45:59,389
较小。
smaller.

2277
01:45:59,390 --> 01:46:00,590
所以我将从1开始。
So I would start with the 1.

2278
01:46:00,590 --> 01:46:02,530
到目前为止，这是我所见过的最小的东西。
That's the smallest thing I've seen so far.

2279
01:46:02,529 --> 01:46:04,069
但我必须继续寻找，因为也许
But I would have to keep looking, because maybe there's

2280
01:46:04,069 --> 01:46:05,779
以后为0或负数。
a 0 or a negative number later on.

2281
01:46:05,779 --> 01:46:08,019
我需要检查是否有更小的东西。
I need to check to see if there's anything smaller.

2282
01:46:08,020 --> 01:46:11,240
所以我会检查，2较大，3，4，5，6，7，8。
So I would check, the 2 is bigger, the 3, 4, 5, 6, 7, 8.

2283
01:46:11,239 --> 01:46:12,116
他们都更大。
They're all bigger.

2284
01:46:12,117 --> 01:46:13,700
事实证明，我一直都是对的。
So it turns out I was right all along.

2285
01:46:13,699 --> 01:46:16,729
1是最小的数字，并且已经存在。
The 1 was the smallest number, and it's already in place.

2286
01:46:16,729 --> 01:46:18,589
所以现在这个数字到位了。
So now that number is in place.

2287
01:46:18,590 --> 01:46:20,090
DAVID MALAN：然后找到下一个最小的数字，
DAVID MALAN: And then to find the next smallest number,

2288
01:46:20,090 --> 01:46:21,260
你会怎么做？
what would you have done?

2289
01:46:21,260 --> 01:46:22,635
布莱恩：我会做同样的事情。
BRIAN: I would do the same thing.

2290
01:46:22,635 --> 01:46:24,320
2是我到目前为止发现的最小数字。
2 is the smallest number I found so far.

2291
01:46:24,319 --> 01:46:25,579
然后我会仔细检查其余的所有内容
And then I would look through all the rest

2292
01:46:25,579 --> 01:46:27,496
看看是否有小于2的东西。
to see if there's anything smaller than the 2.

2293
01:46:27,497 --> 01:46:30,170
我会看3、4、5、6、7、8。
And I would look at 3, 4, 5, 6, 7, 8.

2294
01:46:30,170 --> 01:46:31,880
没有比2小的了。
Nothing's smaller than the 2.

2295
01:46:31,880 --> 01:46:34,910
所以我回到两者，然后说，好的，这个数字现在必须
So I go back to the two and say, OK, that number must now

2296
01:46:34,909 --> 01:46:36,326
处于排序位置。
be in its sorted position.

2297
01:46:36,327 --> 01:46:37,160
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

2298
01:46:37,159 --> 01:46:40,034
这个故事对于3、4和5来说都是一样的。
And that story would be the same for the 3, for the 4, and for the 5.

2299
01:46:40,034 --> 01:46:43,609
就像，无处选择伪代码或实际代码
Like, nowhere in selection sort pseudocode or actual code

2300
01:46:43,609 --> 01:46:46,849
如果已经对数字进行了排序，那么有没有什么情报，
is there any sort of intelligence of, eh, if the numbers are already sorted,

2301
01:46:46,850 --> 01:46:47,630
辞职。
quit.

2302
01:46:47,630 --> 01:46:50,540
就像，没有机会短路和中止
Like, there was no opportunity to short circuit and abort

2303
01:46:50,539 --> 01:46:51,644
较早的算法。
that algorithm earlier.

2304
01:46:51,645 --> 01:46:53,520
Brian实际上会做同样的工作，
Brian would literally be doing the same work,

2305
01:46:53,520 --> 01:46:55,340
是否一开始就将它们分类
whether they're all sorted from the get-go

2306
01:46:55,340 --> 01:46:57,620
或完全未分类，甚至倒退。
or completely unsorted, and even backwards.

2307
01:46:57,619 --> 01:47:00,659
因此，选择排序的效果并不是很高。
And so selection sort doesn't really perform very highly.

2308
01:47:00,659 --> 01:47:03,047
因此，现在我们希望确实可以进行气泡排序。
So now we're hoping bubble sort, indeed, does.

2309
01:47:03,047 --> 01:47:05,589
因此，为此，我们来看看一些拟议的伪
So toward that end, let's take a look at some proposed pseudo

2310
01:47:05,590 --> 01:47:09,040
冒泡排序的代码，假设输入是任何东西。
code for bubble sort, assuming that the input is anything.

2311
01:47:09,039 --> 01:47:10,789
不管是排序还是未排序，伪代码
Whether sorted or unsorted, the pseudocode

2312
01:47:10,789 --> 01:47:13,069
总是看起来像这样。
is always going to look like this.

2313
01:47:13,069 --> 01:47:14,509
重复直到排序。
Repeat until sorted.

2314
01:47:14,510 --> 01:47:17,100
对于i从0到n减去2--
For i from 0 to n minus 2--

2315
01:47:17,100 --> 01:47:18,190
现在，这是什么意思？
now, what does this mean?

2316
01:47:18,189 --> 01:47:22,009
0到n减1从第一个元素到最后一个元素。
0 to n minus 1 goes from the first element to the last.

2317
01:47:22,010 --> 01:47:27,050
所以0到n减去2从第一个元素到第二个元素到最后一个元素。
So 0 to n minus 2 goes from the first element to the second to last.

2318
01:47:27,050 --> 01:47:27,950
我为什么要这么做？
Why am I doing that?

2319
01:47:27,949 --> 01:47:29,209
待会儿我们会看到。
We'll see in just a moment.

2320
01:47:29,210 --> 01:47:34,010
如果第i个和第i个加第1个元素，则此循环内的条件是
The condition inside of this loop is, if the i-th and the i plus 1th elements

2321
01:47:34,010 --> 01:47:36,720
乱了，换掉它们。
are out of order, swap them.

2322
01:47:36,720 --> 01:47:38,590
这就是我有点聪明。
So this is me being a little clever.

2323
01:47:38,590 --> 01:47:41,090
如果您认为所有这些数字都在数组中
If you think about all of these numbers as being in an array

2324
01:47:41,090 --> 01:47:46,100
或在门后，如果您从0迭代到n减去2，
or behind doors, if you iterate from 0 to n minus 2,

2325
01:47:46,100 --> 01:47:49,010
就像从第一扇门到第二扇门再到最后一扇门。
that's like going from the first door to the second to last door.

2326
01:47:49,010 --> 01:47:52,830
但这很好，因为我的状况是正在检查i号门和i + 1号门。
But that's good, because my condition is checking door i and i plus 1.

2327
01:47:52,829 --> 01:47:57,529
所以，如果我从这里的起点开始，而我只迭代到这扇门，
So if I start at the beginning here, and I only iterate up to this door,

2328
01:47:57,529 --> 01:47:58,519
这是好事。
that's a good thing.

2329
01:47:58,520 --> 01:48:02,070
因为当我比较门我和我加1时，
Because when I compared door i and i plus 1, at the very end

2330
01:48:02,069 --> 01:48:05,099
我要比较1号门和1号门。
I'm going to compare door i and i plus 1.

2331
01:48:05,100 --> 01:48:09,020
我不想做的是将此门我与门我进行比较
What I don't want to do is compare this door i against door i

2332
01:48:09,020 --> 01:48:10,763
加1，甚至不存在。
plus 1, which doesn't even exist.

2333
01:48:10,762 --> 01:48:13,429
确实，这将是一个错误，可能所有人
And indeed, that's going to be an error that probably all of you

2334
01:48:13,430 --> 01:48:14,510
在某个时候-
make at some point--

2335
01:48:14,510 --> 01:48:19,040
超越数组的边界，触及内存
going beyond the boundary of an array, touching memory

2336
01:48:19,039 --> 01:48:22,232
这会使数组中的空格超出一个或多个空间，
that is going one or more spaces too far in the array,

2337
01:48:22,233 --> 01:48:24,150
即使您没有为其分配内存。
even though you didn't allocate memory for it.

2338
01:48:24,149 --> 01:48:26,939
因此，这避免了这种可能性。
So this hedges against that possibility.

2339
01:48:26,939 --> 01:48:29,629
因此，这似乎是一个非常聪明的算法。
So this would seem to be a pretty smart algorithm.

2340
01:48:29,630 --> 01:48:35,030
但是按照书面形式，它实际上并没有理想的性能。
But as written, it's not actually as performant as might be ideal.

2341
01:48:35,029 --> 01:48:39,829
对于冒泡排序，假设列表已完全排序。
With bubble sort, suppose the list were entirely sorted.

2342
01:48:39,829 --> 01:48:43,909
布赖恩，不要让您对数字进行过多的排序和重复操作。
Brian, not to make you sort and resort numbers too many times.

2343
01:48:43,909 --> 01:48:47,299
您介意再给我们一个排序的清单吗？
Do you mind giving us a sorted list one more time real quick?

2344
01:48:47,300 --> 01:48:50,660
片刻之后，我想看看是否我们考虑与
In a moment, I want to see, if we consider that same sorted list as

2345
01:48:50,659 --> 01:48:54,919
以前，这次用泡沫排序，我们能从根本上做得更好吗？
before, this time with bubble sort, can we do fundamentally better?

2346
01:48:54,920 --> 01:48:58,160
我有这段代码说，重复直到排序。
I have this code saying, repeat until sorted.

2347
01:48:58,159 --> 01:48:59,329
那么，这种变化将如何呢？
So how might this change?

2348
01:48:59,329 --> 01:49:01,309
所以Brian，您又得到了排序后的数字。
So Brian, you've got the sorted numbers again.

2349
01:49:01,310 --> 01:49:02,660
这应该是一个很好的情况。
This should be a good case.

2350
01:49:02,659 --> 01:49:05,989
但是选择排序并没有从此输入中受益，
But selection sort did not benefit from this input,

2351
01:49:05,989 --> 01:49:07,699
即使我们本来可以很幸运。
even though we could have gotten lucky.

2352
01:49:07,699 --> 01:49:10,084
冒泡排序，您的思考过程将在这里进行吗？
Bubble sort, what would your thought process be here?

2353
01:49:10,085 --> 01:49:11,960
布莱恩：关于泡沫排序的思考过程
BRIAN: So the thought process for bubble sort

2354
01:49:11,960 --> 01:49:14,030
一次要经历每一对
was to go through each of the pairs one at a time

2355
01:49:14,029 --> 01:49:16,999
并查看是否需要为该特定对进行交换。
and see if I need to make a swap for that particular pair.

2356
01:49:17,000 --> 01:49:18,620
因此，我将看一下1和2。
So I'd look at the 1 and the 2.

2357
01:49:18,619 --> 01:49:20,599
那两个没关系，我不需要交换它们。
Those two are OK, I don't need to swap them.

2358
01:49:20,600 --> 01:49:21,763
2和3都可以。
The 2 and the 3 are OK.

2359
01:49:21,762 --> 01:49:23,179
我不需要在那里交换。
I don't need to make a swap there.

2360
01:49:23,180 --> 01:49:24,270
3和4都可以。
The 3 and the 4 are OK.

2361
01:49:24,270 --> 01:49:25,820
4和5都可以。
The 4 and the 5 are OK.

2362
01:49:25,819 --> 01:49:29,749
与5和6、6和7、7和8相同。
Same with the 5 and the 6, and the 6 and the 7, and the 7 and the 8.

2363
01:49:29,750 --> 01:49:32,479
所以我遍历了整个数组，
So I made my way through all the entire array,

2364
01:49:32,479 --> 01:49:36,019
而且我不需要进行任何交换，因为我看过的每一对，
and I never needed to make any swap, because every pair that I looked at,

2365
01:49:36,020 --> 01:49:38,840
他们彼此之间已经处于正确的顺序。
they were already in the correct order relative to each other.

2366
01:49:38,840 --> 01:49:39,673
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

2367
01:49:39,672 --> 01:49:42,439
因此，这次这将是愚蠢的，如此明显
And so it would be foolish and so obvious this time

2368
01:49:42,439 --> 01:49:45,139
如果Brian从字面上回溯了这些步骤并做到了
if Brian literally retraced those steps and did it

2369
01:49:45,140 --> 01:49:49,130
再次使用n减去1个元素，然后再次使用n减去2个元素。
again with n minus 1 elements, and then did it again with n minus 2 elements.

2370
01:49:49,130 --> 01:49:52,490
我的意思是，如果他没有做任何工作，那么任何人都会在第一关中互换掉，
I mean, if he didn't do any work, any swaps the first pass,

2371
01:49:52,489 --> 01:49:54,829
他甚至在浪费自己的时间，甚至
he's literally wasting his own time by even

2372
01:49:54,829 --> 01:49:57,049
做另一遍或另一遍。
doing another pass or another pass.

2373
01:49:57,050 --> 01:50:00,650
因此，这在伪代码中是隐式的，重复此操作直到将其排序为止。
And so that's kind of implicit in the pseudocode, this repeat until sorted.

2374
01:50:00,649 --> 01:50:03,109
即使它不能完美地转换为for循环
Even though it doesn't translate perfectly into a for loop

2375
01:50:03,109 --> 01:50:07,249
或C中的while循环，有点直观地说明了他应该做什么-
or a while loop in C, it kind of says intuitively what he should do--

2376
01:50:07,250 --> 01:50:08,389
重复直到排序。
repeat until sorted.

2377
01:50:08,390 --> 01:50:11,150
布赖恩已经天生就认出了事实
Brian has already identified the fact, by nature of him

2378
01:50:11,149 --> 01:50:13,669
没有进行任何交换，该列表已排序。
not having made any swaps, that this list is sorted.

2379
01:50:13,670 --> 01:50:16,400
因此，他可以停下来，而此循环不会
Therefore, he can just stop, and this loop does not

2380
01:50:16,399 --> 01:50:18,019
必须一次又一次地继续。
have to continue again and again.

2381
01:50:18,020 --> 01:50:21,620
我们可以更明确地将其映射到类似C的代码。
We can map this to C-like code a little more explicitly.

2382
01:50:21,619 --> 01:50:24,769
默认情况下，我们可以说以下n次减1次。
We can by default say, do the following n minus 1 times.

2383
01:50:24,770 --> 01:50:29,570
因为在n个元素中，您可以从左看n减去1对总数
Because among n elements, you can look at n minus 1 total pairs from left

2384
01:50:29,569 --> 01:50:31,619
向右走而不会太远。
to right without going too far.

2385
01:50:31,619 --> 01:50:35,099
但是请注意，我可以在此处添加其他代码行
But notice, I can add an additional line of code here

2386
01:50:35,100 --> 01:50:40,070
这可能表示，如果没有交换，则完全退出该算法。
which might say, if no swaps, quit from the algorithm altogether.

2387
01:50:40,069 --> 01:50:42,889
所以，只要Brian跟踪多少交换
So, so long as Brian is keeping track of how many swaps

2388
01:50:42,890 --> 01:50:47,160
他通过或未通过，例如使用称为counter的变量
he made or didn't make through one pass, as with a variable called counter

2389
01:50:47,159 --> 01:50:50,939
或其他任何事情，他都可以提早中止该算法，当然
or whatever, he can simply abort this algorithm early and certainly

2390
01:50:50,939 --> 01:50:52,686
然后为我们节省一些时间。
then save us some time.

2391
01:50:52,686 --> 01:50:55,019
因此，让我们考虑一下
So with that said, let's consider for just a moment what

2392
01:50:55,020 --> 01:50:59,280
气泡排序的运行时间可能是一个上限，
the running time of bubble sort might be in terms of an upper bound,

2393
01:50:59,279 --> 01:51:01,119
如果您愿意，在最坏的情况下。
in the worst case, if you will.

2394
01:51:01,119 --> 01:51:05,069
好吧，如果是冒泡排序，请注意伪代码
Well, in the case of bubble sort, notice with the pseudocode

2395
01:51:05,069 --> 01:51:08,159
我们在做n负1次的事情，
where we're doing something n minus 1 times,

2396
01:51:08,159 --> 01:51:11,819
在里面，我们正在做n负1次。
and inside of that we're doing something n minus 1 times.

2397
01:51:11,819 --> 01:51:14,129
再一次，按字面意思重复n减1次
So again, repeat n minus 1 times literally

2398
01:51:14,130 --> 01:51:17,040
说，做下面的n减1次。
says, do the following n minus 1 times.

2399
01:51:17,039 --> 01:51:19,829
这里的for循环，这只是伪代码中的另一种方式
The for loop here, which is just a different way in pseudocode

2400
01:51:19,829 --> 01:51:24,539
表达类似的想法，但是这次给我们一个变量，因为我从0开始
of expressing a similar idea but giving us a variable this time, for i from 0

2401
01:51:24,539 --> 01:51:25,949
至n减去1--
to n minus 1--

2402
01:51:25,949 --> 01:51:32,889
n减2，是n减1比较的总数。
n minus 2, is a total number of n minus 1 comparisons.

2403
01:51:32,890 --> 01:51:37,490
所以这是重复中的n减1的东西，
So this is an n minus 1 thing inside the repeat,

2404
01:51:37,489 --> 01:51:39,679
重复序列外为n减1。
and an n minus 1 outside the repeat.

2405
01:51:39,680 --> 01:51:44,720
所以我认为给我的是n减1倍n减1倍。
So I think what that gives me is n minus 1 things times n minus 1 times.

2406
01:51:44,720 --> 01:51:47,180
所以现在如果我只是喜欢这种方式，那是在高中
So now if I just kind of FOIL this, sort of in high school

2407
01:51:47,180 --> 01:51:51,080
或中学数学，n平方减去1n减去1n加1。
or middle school math, n squared minus 1n minus 1n plus 1.

2408
01:51:51,079 --> 01:51:54,114
我们可以将类似的项组合在一起，即n平方减去2n加1。
We can combine like terms, n squared minus 2n plus 1.

2409
01:51:54,114 --> 01:51:57,239
但是，根据我们前面的讨论，嗯，这确实正在杂草之中。
But per our discussion earlier, ugh, this is really getting into the weeds.

2410
01:51:57,239 --> 01:51:59,869
谁在乎2n或1n？
Who cares about the 2n or the 1?

2411
01:51:59,869 --> 01:52:04,319
当n变大时，主导因素肯定是n的平方。
The dominant factor as n gets large is definitely going to be the n squared.

2412
01:52:04,319 --> 01:52:06,439
因此，如果您实际上
So it would seem that bubble sort, if you actually

2413
01:52:06,439 --> 01:52:10,129
算出数学和公式，将有一个n的上限
do out the math and the formulas, is going to have an upper bound of n

2414
01:52:10,130 --> 01:52:13,200
平方，或者说，是n平方阶的数量级。
squared, or rather, on the order of n squared steps.

2415
01:52:13,199 --> 01:52:17,419
因此，从某种意义上讲，它等同于选择排序。
So in that sense, it is equivalent to selection sort.

2416
01:52:17,420 --> 01:52:19,490
从根本上说没有更好的选择。
It is no better fundamentally.

2417
01:52:19,489 --> 01:52:22,429
这就是我们所说的渐近等效。
It's what we would say ask asymptotically equivalent.

2418
01:52:22,430 --> 01:52:25,220
也就是说，当n变得很大时，此公式
That is, as n gets really large, this formula

2419
01:52:25,220 --> 01:52:28,670
就所有意图和目的而言，等同于选择排序
is, for all intents and purposes, equivalent to the selection sort

2420
01:52:28,670 --> 01:52:30,750
公式，即使它们略有不同
formula, even though they differed slightly

2421
01:52:30,750 --> 01:52:32,930
就其较低阶而言。
in terms of their lower order terms.

2422
01:52:32,930 --> 01:52:37,080
出于所有意图和目的，啊，它们的均n平方。
For all intents and purposes, ah, they're on the order of n squared both.

2423
01:52:37,079 --> 01:52:40,459
但是，如果我们考虑一个下限，
But if we consider a lower bound, perhaps,

2424
01:52:40,460 --> 01:52:43,520
即使冒泡排序具有相同的上限运行时间，
even though bubble sort has the same upper bound running time,

2425
01:52:43,520 --> 01:52:47,420
如果我们考虑下限（如此更聪明的代码），那么Brian可能会
if we consider a lower bound, as with this smarter code, where Brian might

2426
01:52:47,420 --> 01:52:50,840
其实有足够的钱要注意，请稍等，我没有进行任何调换，
actually have the wherewithal to notice, wait a minute, I didn't do any swaps,

2427
01:52:50,840 --> 01:52:54,630
我将尽早退出此循环-
I'm just going to exit out of this looping pretty much early--

2428
01:52:54,630 --> 01:52:56,540
甚至不是过早而是早期，因为它
not even prematurely but early, because it

2429
01:52:56,539 --> 01:52:59,119
继续做越来越多的工作是徒劳的-
would be fruitless to keep doing more and more work--

2430
01:52:59,119 --> 01:53:01,759
然后，我们可以减少运行时间。
we can then whittle down this running time.

2431
01:53:01,760 --> 01:53:07,610
我认为-不如欧米茄1的恒定时间好-
I think-- not quite as good as omega of 1, which was constant time--

2432
01:53:07,609 --> 01:53:12,199
像这样，除非您没有明确的结论，否则不能确定数组已排序
like, you cannot conclude definitively that an array is sorted unless you

2433
01:53:12,199 --> 01:53:14,359
至少一次查看所有元素。
minimally look at all of the elements once.

2434
01:53:14,359 --> 01:53:17,539
因此，固定时间是完全天真且不切实际的。
So constant time is completely naive and unrealistic.

2435
01:53:17,539 --> 01:53:21,229
您看不到一个或两个或三个元素，然后说是的，这是已排序的。
You can't look at one element, or two or three, and say, yes, this is sorted.

2436
01:53:21,229 --> 01:53:24,649
您显然必须至少一次查看所有元素。
You've got to obviously look at all of the elements at least once.

2437
01:53:24,649 --> 01:53:28,399
因此，这似乎暗示着它的欧米茄符号
So this would seem to suggest that the omega notation for it, that

2438
01:53:28,399 --> 01:53:31,519
是，气泡排序运行时间的下限，
is, the lower bound on bubble sort's running time,

2439
01:53:31,520 --> 01:53:37,850
如果我们很聪明并且不必不必要地追溯我们的步骤，则以n的欧米茄表示。
if we're clever and don't retrace our steps unnecessarily, is in omega of n.

2440
01:53:37,850 --> 01:53:39,950
或者从技术上讲，这是n减1步，对吧？
Or technically, it's n minus 1 steps, right?

2441
01:53:39,949 --> 01:53:41,949
因为如果您有n个元素并且您进行比较
Because if you've got n elements and you compare

2442
01:53:41,949 --> 01:53:44,029
这两个，这两个，这两个，这两个，
these two, these two, these two, these two,

2443
01:53:44,029 --> 01:53:45,649
这是n减去1个总比较。
that's n minus 1 total comparisons.

2444
01:53:45,649 --> 01:53:47,449
但是谁在乎负1？
But who cares about the minus 1?

2445
01:53:47,449 --> 01:53:53,379
在这里，它的数量级为n或n的欧米茄。
It's on the order of n, or omega of n notation here.

2446
01:53:53,380 --> 01:53:57,240
因此，回顾一下，选择排序一次又一次地选择了下一个最小的元素
So to recap, selection sort selects the next smallest element again and again

2447
01:53:57,239 --> 01:53:57,869
然后再次。
and again.

2448
01:53:57,869 --> 01:54:01,019
不幸的是，基于伪代码和实际代码的实现方式
Unfortunately, based on how it's implemented in pseudocode and actual

2449
01:54:01,020 --> 01:54:03,330
代码，它在n的大O平方中。
code, it's in Big O of n squared.

2450
01:54:03,329 --> 01:54:05,369
但这也是n平方的欧米茄，
But it's also an omega of n squared, which

2451
01:54:05,369 --> 01:54:10,169
意味着它将总是渐近地花费相同的时间，也就是说，
means it's always going to take the same amount of time asymptotically, that is,

2452
01:54:10,170 --> 01:54:11,490
随着n变大。
as n gets large.

2453
01:54:11,489 --> 01:54:16,082
不幸的是，气泡排序似乎也不是更好，
Unfortunately, too, bubble sort is no better, it would seem,

2454
01:54:16,082 --> 01:54:17,249
在上限方面。
in terms of the upper bound.

2455
01:54:17,250 --> 01:54:19,500
它也将采取多达n个平方的步骤。
It's going to take as many as n squared steps, too.

2456
01:54:19,500 --> 01:54:23,610
但是在使用某些东西方面至少要好一点
But it's at least marginally better when it comes to using something

2457
01:54:23,609 --> 01:54:26,279
就像已经排序的输入一样。
like an input that's already sorted.

2458
01:54:26,279 --> 01:54:30,879
它可以短路而不浪费时间。
It can short circuit and not waste time.

2459
01:54:30,880 --> 01:54:32,850
但老实说，n平方是不好的。
But honestly, n squared is bad.

2460
01:54:32,850 --> 01:54:34,950
就像，n平方真的会很快相加。
Like, n squared is really going to add up quickly.

2461
01:54:34,949 --> 01:54:39,179
如果您有n个平方，并且n是一百万或n是十亿，我的意思是，
If you've got n squared and n is a million or n is a billion, I mean,

2462
01:54:39,180 --> 01:54:40,860
我的上帝，那是很多0。
my God, that's a lot of 0's.

2463
01:54:40,859 --> 01:54:44,819
这是算法总运行时间的许多步骤。
That's a lot of steps in the total running time of your algorithm.

2464
01:54:44,819 --> 01:54:46,179
我们可以做得更好吗？
Can we do better?

2465
01:54:46,180 --> 01:54:47,500
我们可以做得更好吗？
Can we do better?

2466
01:54:47,500 --> 01:54:48,719
事实证明我们可以做到。
And it turns out we can.

2467
01:54:48,720 --> 01:54:52,560
而且，我们今天将考虑一种最终的算法，该算法在根本上会做得更好。
And we'll consider one final algorithm today that does fundamentally better.

2468
01:54:52,560 --> 01:54:57,000
就像在第0周一样，我们有点陷入了二进制搜索的局面，而今天又再次陷入困境-
Just like in week 0, we sort of latched onto binary search and again today--

2469
01:54:57,000 --> 01:55:01,389
从根本上说，它比线性搜索好一个数量级，
it's just fundamentally better than linear search by an order of magnitude,

2470
01:55:01,390 --> 01:55:01,890
可以这么说。
so to speak.

2471
01:55:01,890 --> 01:55:05,250
它的图片表示形式根本不同。
Its picture representation was fundamentally different.

2472
01:55:05,250 --> 01:55:09,048
我认为我们可以从根本上胜过泡沫排序和选择排序。
I think we can do fundamentally better than bubble sort and selection sort.

2473
01:55:09,047 --> 01:55:10,839
因此，虽然气泡排序和选择
And so while both bubble sort and selection

2474
01:55:10,840 --> 01:55:13,465
可能是我在读研究生时使用的那种东西
sort might be the sort of thing that I was using in grad school

2475
01:55:13,465 --> 01:55:15,840
只是为了快速整理代码然后入睡，
just to rip up the code quickly and then go to sleep,

2476
01:55:15,840 --> 01:55:18,272
对于非常大的数据集，它不能很好地工作。
it's not going to work well for very large data sets.

2477
01:55:18,271 --> 01:55:19,979
坦白说，它不会做得很好
And frankly, it wouldn't have worked well

2478
01:55:19,979 --> 01:55:22,139
如果我不想只是解决问题。
if I didn't want to just sleep through the problem.

2479
01:55:22,140 --> 01:55:26,190
相反，我们希望一开始就尽可能高效地做事。
Rather, we want to do things as efficiently as we can from the get go.

2480
01:55:26,189 --> 01:55:29,559
我建议我们利用一种技术-
And let me propose that we leverage a technique--

2481
01:55:29,560 --> 01:55:32,310
这是一种几乎可以在任何编程中使用的技术
and this is a technique that you can use in almost any programming

2482
01:55:32,310 --> 01:55:33,960
语言，其中的C
language, C among them--

2483
01:55:33,960 --> 01:55:35,430
称为递归。
known as recursion.

2484
01:55:35,430 --> 01:55:41,940
简单来说，递归就是函数调用自身的能力。
And recursion, quite simply, is the ability for a function to call itself.

2485
01:55:41,939 --> 01:55:44,759
到目前为止，我们还没有看到任何示例。
Up until now, we have not seen any examples of this.

2486
01:55:44,760 --> 01:55:47,070
我们已经看到了调用其他函数的函数。
We've seen functions calling other functions.

2487
01:55:47,069 --> 01:55:49,169
Main继续调用printf。
Main keeps calling printf.

2488
01:55:49,170 --> 01:55:51,000
Main已开始致电strlen。
Main has started to call strlen.

2489
01:55:51,000 --> 01:55:54,930
今天早些时候，主要称为strcmp，进行比较。
Main called strcmp, compare, earlier today.

2490
01:55:54,930 --> 01:55:56,700
但是我们从来没有见过main main。
But we've never seen main call main.

2491
01:55:56,699 --> 01:55:59,769
人们不这样做，所以那不会解决问题。
And people don't do that, so that's not going to solve the problem.

2492
01:55:59,770 --> 01:56:02,640
但是我们可以实现我们自己的功能并拥有
But we can implement our own functions and have

2493
01:56:02,640 --> 01:56:05,100
我们自己的功能称呼自己。
our own functions call themselves.

2494
01:56:05,100 --> 01:56:07,290
现在，原则上这似乎是一个坏主意。
Now, this would seem to be a bad idea in principle.

2495
01:56:07,289 --> 01:56:10,019
如果函数调用了自己，我的天哪，它在哪里结束？
If a function calls itself, my God, where does it end?

2496
01:56:10,020 --> 01:56:11,820
它似乎永远会做某事，
It would seem to just do something forever,

2497
01:56:11,819 --> 01:56:13,486
然后可能会发生一些不好的事情。
and then something bad probably happens.

2498
01:56:13,487 --> 01:56:14,132
而且可以。
And it could.

2499
01:56:14,131 --> 01:56:15,839
这就是使用递归的危险。
And that's the danger of using recursion.

2500
01:56:15,840 --> 01:56:17,495
您可以轻松地将其拧紧。
You can screw it up easily.

2501
01:56:17,494 --> 01:56:19,619
但这也是一项非常强大的技术，因为它
But it's also a very powerful technique, because it

2502
01:56:19,619 --> 01:56:21,869
让我们思考潜在的解决方案
allows us to think about potential solutions

2503
01:56:21,869 --> 01:56:25,769
以一种非常有趣且敢于优雅的方式解决问题。
to problems in a very interesting, and daresay elegant, way.

2504
01:56:25,770 --> 01:56:29,160
因此，我们不仅能够实现正确性，而且还能更好地
So we're not only going to be able to achieve correctness but also better

2505
01:56:29,159 --> 01:56:32,609
设计，因为效率更高，似乎在这里。
design, because of better efficiency, it would seem, here.

2506
01:56:32,609 --> 01:56:33,959
因此，让我提出这个建议。
So let me propose this.

2507
01:56:33,960 --> 01:56:37,830
记得从第0周开始的这段代码，这是寻找某人的伪代码
Recall this code from week 0, which was the pseudocode for finding someone

2508
01:56:37,829 --> 01:56:38,789
在电话簿中。
in a phone book.

2509
01:56:38,789 --> 01:56:42,179
并回想一下，在此伪代码的功能中，
And recall that, among the features of this pseudocode,

2510
01:56:42,180 --> 01:56:44,520
这些行是“回到第3行”吗？
were these lines here, "Go back to line 3."

2511
01:56:44,520 --> 01:56:48,950
我们将第0周的那些描述为循环的代表，
And we describe those in week 0 as being representative of loops,

2512
01:56:48,949 --> 01:56:52,949
一遍又一遍的编程构造。
a programming construct that has something happen again and again.

2513
01:56:52,949 --> 01:56:56,639
但是您知道吗，此伪代码中有一个错失的机会
But you know what, there's a missed opportunity here in this pseudocode

2514
01:56:56,640 --> 01:56:59,590
使用一种称为递归的技术。
to use a technique known as recursion.

2515
01:56:59,590 --> 01:57:02,280
我们将这种实现称为迭代。
This implementation is what we would call iterative.

2516
01:57:02,279 --> 01:57:04,289
它是纯粹基于循环的。
It is purely loop based.

2517
01:57:04,289 --> 01:57:07,229
它从字面上告诉我，回到这一行，回到这一行，
It tells me literally, go back to this line, go back to this line,

2518
01:57:07,229 --> 01:57:08,399
回到这条线。
go back to this line.

2519
01:57:08,399 --> 01:57:10,229
没有打电话给自己。
There's no calling yourself.

2520
01:57:10,229 --> 01:57:13,619
但是，如果我将第0周的伪代码更改为更多，该怎么办
But what if I changed week 0's pseudocode to be a little more

2521
01:57:13,619 --> 01:57:14,549
像这样？
like this?

2522
01:57:14,550 --> 01:57:19,110
让我继续摆脱，不仅是那一行，而是两行
Let me go ahead and get rid of, not just that one line but two lines

2523
01:57:19,109 --> 01:57:20,999
在这两种情况下。
in both of those conditions.

2524
01:57:21,000 --> 01:57:23,310
我要简单地说，而不是开放
And let me quite simply say, instead of open

2525
01:57:23,310 --> 01:57:26,280
到书的左半部分的中间，然后回到第3行，
to the middle of the left half of the book and then go back to line 3,

2526
01:57:26,279 --> 01:57:29,909
或打开到书的右半部分的中间，然后回到第3行，
or open to the middle of the right half of the book and then go back to line 3,

2527
01:57:29,909 --> 01:57:34,949
我为什么不更优雅地说，搜索书的左半部分，
why don't I just more elegantly say, search left half of book,

2528
01:57:34,949 --> 01:57:36,659
搜索书的右半部分？
search right half of book?

2529
01:57:36,659 --> 01:57:39,779
现在，我可以立即将代码缩短一点。
Now, immediately I can shorten the code a little bit.

2530
01:57:39,779 --> 01:57:44,879
但我声称，只说搜索左半边书，然后搜索右半边
But I claim that by just saying search left half of book and search right

2531
01:57:44,880 --> 01:57:49,140
一半的书，我声称这是足够的信息
half of book, I claim that this is enough information

2532
01:57:49,140 --> 01:57:50,760
实现完全相同的算法
to implement the very same algorithm.

2533
01:57:50,760 --> 01:57:53,100
但是它本身并没有使用循环。
But it's not using a loop per se.

2534
01:57:53,100 --> 01:57:56,010
它会诱使我成为人类或我成为计算机
It's going to induce me the human or me the computer

2535
01:57:56,010 --> 01:57:57,840
一次又一次地做某事。
to do something again and again.

2536
01:57:57,840 --> 01:58:00,270
但是还有其他方式可以一遍又一遍地做事-
But there's other ways to do things again and again--

2537
01:58:00,270 --> 01:58:03,690
而不是通过for循环，while循环或do while循环，
not by way of a for loop, or a while loop, or a do while loop,

2538
01:58:03,689 --> 01:58:06,359
或重复的方块，或永远的方块-
or a repeat block, or a forever block--

2539
01:58:06,359 --> 01:58:08,609
您实际上可以使用递归。
you can actually use recursion.

2540
01:58:08,609 --> 01:58:12,689
再说一次，递归就是这种技术，函数可以调用它自己。
And recursion, again, is this technique where a function can call itself.

2541
01:58:12,689 --> 01:58:15,659
毕竟，如果我们考虑的是伪代码，
And if we consider, after all, the pseudocode we are looking at

2542
01:58:15,659 --> 01:58:18,209
是用于搜索的伪代码。
is the pseudocode for searching.

2543
01:58:18,210 --> 01:58:24,210
现在在第7行和第9行，我的意思是说：“搜索书的左半部分”
And on line 7 and 9 now, I am literally saying, "Search left half of book,"

2544
01:58:24,210 --> 01:58:28,800
和“搜索书的右半部分”，即使是伪代码形式也是如此，
and "Search right half of book," this is already, even in pseudocode form,

2545
01:58:28,800 --> 01:58:30,270
递归的例子。
an example of recursion.

2546
01:58:30,270 --> 01:58:34,530
我在11行代码中有一个算法或函数
Here I have in 11 lines of code an algorithm or a function

2547
01:58:34,529 --> 01:58:36,439
搜索电话簿。
that searches a phone book.

2548
01:58:36,439 --> 01:58:40,829
在第7和9行中，我有几行代码，字面意思是：搜索
In lines 7 and 9, I have lines of code that literally say, search

2549
01:58:40,829 --> 01:58:44,459
电话簿，但更具体地说，搜索一半的电话簿。
a phone book, but more specifically, search half of the phone book.

2550
01:58:44,460 --> 01:58:47,520
这就是递归真正发挥作用的地方。
And that's where recursion really works its magic.

2551
01:58:47,520 --> 01:58:50,760
这将是愚蠢的，不正确的，完全会适得其反
It would be foolish and incorrect and completely counterproductive

2552
01:58:50,760 --> 01:58:53,148
只是使用相同的输入进行函数调用，
to just have a function call itself with the same input,

2553
01:58:53,148 --> 01:58:55,440
使用相同的输入，使用相同的输入，因为您会
with the same input, with the same input, because you'd

2554
01:58:55,439 --> 01:58:57,959
必须有点疯狂以期望获得不同的输出
have to be kind of crazy to expect different output

2555
01:58:57,960 --> 01:59:00,120
如果输入始终相同。
if the input is constantly the same.

2556
01:59:00,119 --> 01:59:03,539
但这不是我们在第0周所做的事情，也不是我们现在正在做的事情。
But that's not what we did in week 0, and that's not what we're doing now.

2557
01:59:03,539 --> 01:59:07,109
如果您使用相同的函数或等效算法，
If you use the same function, or equivalently algorithm,

2558
01:59:07,109 --> 01:59:11,579
但将输入变得越来越小，
but change the input to be smaller and smaller and smaller,

2559
01:59:11,579 --> 01:59:14,769
函数调用自身可能没关系，
it's probably OK that a function is calling itself,

2560
01:59:14,770 --> 01:59:18,120
只要您至少有一行代码
so long as you have at least one line of code in there

2561
01:59:18,119 --> 01:59:20,819
很有智慧地说，如果你不在屋外，
that very intelligently says, if you're out of doors,

2562
01:59:20,819 --> 01:59:23,309
如果您不在电话簿页面中，请退出。
if you're out of phone book pages, quit.

2563
01:59:23,310 --> 01:59:25,500
您需要有一个所谓的基本案例。
You need to have a so-called base case.

2564
01:59:25,500 --> 01:59:28,649
您需要注意以下几行代码，请稍等片刻，
You need some line of code that's going to notice, wait a minute, there's

2565
01:59:28,649 --> 01:59:31,949
没有更多要解决的问题，请立即退出。
no more problem to be solved, quit now.

2566
01:59:31,949 --> 01:59:35,189
那么我们如何将其映射到实际代码？
And so how can we map this to actual code?

2567
01:59:35,189 --> 01:59:38,129
好吧，让我们考虑一下从第一周开始就非常熟悉的事情。
Well, let's consider something very familiar from week 1.

2568
01:59:38,130 --> 01:59:40,440
回想一下当您重建马里奥的金字塔之一时。
Recall when you reconstructed one of Mario's pyramids.

2569
01:59:40,439 --> 01:59:43,329
看起来有点像这样。
It looked a little something like this.

2570
01:59:43,329 --> 01:59:46,049
让我们考虑一下，这是一个由金字塔构成的金字塔，
And let's consider that this is a pyramid of blocks,

2571
01:59:46,050 --> 01:59:47,880
砖的高度为4。
of bricks, that's of height 4.

2572
01:59:47,880 --> 01:59:48,420
为什么是4？
Why 4?

2573
01:59:48,420 --> 01:59:52,450
好吧，从上到下依次为1、2、3、4块砖。
Well, there's 1, then 2, then 3, then 4 bricks from top to bottom.

2574
01:59:52,449 --> 01:59:54,209
所以这里的总高度是4。
So the total height here is 4.

2575
01:59:54,210 --> 01:59:58,740
但是，让我天真地问一个问题，您如何去创造，
But let me ask the question, a little naively, how do you go about creating,

2576
01:59:58,739 --> 02:00:02,729
或如何打印高度为4的金字塔？
or how do you go about printing a pyramid of height 4?

2577
02:00:02,729 --> 02:00:05,999
好吧，事实证明，这个简单的马里奥金字塔
Well, it turns out that this simple Mario pyramid, that's

2578
02:00:06,000 --> 02:00:09,209
如果我们摆脱了不必要的背景，就会更加清楚，
ever more clear if we get rid of the unnecessary background,

2579
02:00:09,210 --> 02:00:12,700
是某种递归结构。
is a recursive structure of some sort.

2580
02:00:12,699 --> 02:00:14,249
这是递归的物理结构。
It's a recursive physical structure.

2581
02:00:14,250 --> 02:00:15,020
为什么？
Why?

2582
02:00:15,020 --> 02:00:18,780
好吧，请注意，这个结构，这个砖头，这个金字塔，
Well, notice that this structure, this brick, this pyramid,

2583
02:00:18,779 --> 02:00:20,969
是根据自身定义的。
is kind of defined in terms of itself.

2584
02:00:20,970 --> 02:00:21,690
为什么？
Why?

2585
02:00:21,689 --> 02:00:24,659
好吧，您如何制作高度为4的金字塔？
Well, how do you make a pyramid of height 4?

2586
02:00:24,659 --> 02:00:27,869
我会有点令人讨厌地，有点循环地争论，好吧，
I would argue, a little obnoxiously, a little circularly, well,

2587
02:00:27,869 --> 02:00:30,239
您创建一个高度为3的金字塔，然后
you create a pyramid of height 3, and then

2588
02:00:30,239 --> 02:00:32,669
您添加了另一排积木。
you add an additional row of bricks.

2589
02:00:32,670 --> 02:00:33,400
好的。
All right.

2590
02:00:33,399 --> 02:00:34,439
好吧，让我们继续这个逻辑。
Well, let's continue that logic.

2591
02:00:34,439 --> 02:00:35,106
好吧好吧
All right, fine.

2592
02:00:35,106 --> 02:00:38,159
您如何建造高度为3的金字塔？
How do you build a pyramid of height 3?

2593
02:00:38,159 --> 02:00:41,669
好吧，你微笑着说，好吧，你建造了一座高度为2的金字塔
Well, you sort of smile and say, well, you build a pyramid of height 2,

2594
02:00:41,670 --> 02:00:43,110
然后再添加一层。
and then you add one more layer.

2595
02:00:43,109 --> 02:00:43,589
好吧好吧
All right, fine.

2596
02:00:43,590 --> 02:00:45,215
您如何建造高度为2的金字塔？
How do you build a pyramid of height 2?

2597
02:00:45,215 --> 02:00:49,165
好吧，您将建立一个高度为1的金字塔，然后再添加一层。
Well, you build a pyramid of height 1, and then you add one more layer.

2598
02:00:49,164 --> 02:00:51,039
那么，您如何建造高度为1的金字塔？
Well, how do you build a pyramid of height 1?

2599
02:00:51,039 --> 02:00:53,609
好吧，你只是放下愚蠢的砖头。
Well, you just put the stupid brick down.

2600
02:00:53,609 --> 02:00:56,279
您有一个基本案例，您可以在其中陈述明显的情况
You have a base case, where you sort of state the obvious

2601
02:00:56,279 --> 02:00:57,989
并只做一次。
and just do something once.

2602
02:00:57,989 --> 02:00:59,549
您对逻辑进行硬编码。
You hardcode the logic.

2603
02:00:59,550 --> 02:01:02,610
但是请注意，这是什么心智弯曲或
But notice what's kind of mind bending, or kind

2604
02:01:02,609 --> 02:01:05,549
在人类互动中令人讨厌，
of obnoxious in a human interaction, like,

2605
02:01:05,550 --> 02:01:08,640
您只是根据自身定义答案。
you're just defining the answer in terms of itself.

2606
02:01:08,640 --> 02:01:10,470
我一直在说同样的话。
I keep saying the same thing.

2607
02:01:10,470 --> 02:01:14,790
但这没关系，因为金字塔越来越小
But that's OK, because the pyramid keeps getting smaller and smaller and smaller

2608
02:01:14,789 --> 02:01:16,894
直到我能处理那一种特殊情况。
until I can handle that one special case.

2609
02:01:16,895 --> 02:01:19,770
所以我们可以做些有趣的事情，用这些小纸板砖
And so we can do this just for fun with these little cardboard bricks

2610
02:01:19,770 --> 02:01:20,920
例如，在这里。
here, for instance.

2611
02:01:20,920 --> 02:01:24,010
如果我想建造一个高度为4的金字塔，该怎么做？
If I want to build a pyramid of height 4, how do I do it?

2612
02:01:24,010 --> 02:01:26,220
好吧，我可以建造一个高度为3的金字塔。
Well, I can build a pyramid of height 3.

2613
02:01:26,220 --> 02:01:29,280
好吧，让我继续前进，建造一个高度为3的金字塔。
All right, let me go ahead and build a pyramid of height 3.

2614
02:01:29,279 --> 02:01:31,094
如何建立高度为3的金字塔？
How do I build a pyramid of height 3?

2615
02:01:31,095 --> 02:01:33,970
好吧，我建立了一个高度为2的金字塔，然后添加了它。
All right, well, I build a pyramid of height 2, and then I add to it.

2616
02:01:33,970 --> 02:01:37,090
好了，我该如何建造一个高度为2的金字塔？
OK, how do I build a pyramid of height 2?

2617
02:01:37,090 --> 02:01:38,790
好吧，您将建立一个高度为1的金字塔。
Well, you build a pyramid of height 1.

2618
02:01:38,789 --> 02:01:39,772
我怎么做？
How do I do that?

2619
02:01:39,773 --> 02:01:41,190
好吧，你只是放下砖头。
Well, you just put the brick down.

2620
02:01:41,189 --> 02:01:43,139
因此，这里是一些触底反弹的地方，
And so here's where things kind of bottom out,

2621
02:01:43,140 --> 02:01:45,390
并且不再是周期性的论点。
and it's no longer a cyclical argument.

2622
02:01:45,390 --> 02:01:47,640
您最终只会做一些实际的工作。
You eventually just do some actual work.

2623
02:01:47,640 --> 02:01:51,780
但是在我看来，我必须记住您刚才给我的所有说明，
But in my mind, I have to remember all of the instructions you just gave me,

2624
02:01:51,779 --> 02:01:53,039
或者我给了我自己。
or I gave myself.

2625
02:01:53,039 --> 02:01:56,849
我必须建造一个高度为4的金字塔。不，3;不，2;不，1。
I had to build a pyramid of height 4; nope, 3; nope, 2; nope, 1.

2626
02:01:56,850 --> 02:01:58,270
现在，我实际上正在这样做。
Now I'm actually doing that.

2627
02:01:58,270 --> 02:02:00,090
所以这是一个高度为1的金字塔。
So here's a pyramid of height 1.

2628
02:02:00,090 --> 02:02:02,610
我现在如何建造高度为2的金字塔？
How do I now build a pyramid of height 2?

2629
02:02:02,609 --> 02:02:04,349
好吧，倒带故事吧。
Well, rewind in the story.

2630
02:02:04,350 --> 02:02:07,950
要构建高度为2的金字塔，您可以构建高度为1的金字塔。
To build a pyramid of height 2, you build a pyramid of height 1,

2631
02:02:07,949 --> 02:02:09,939
然后再添加一层。
and then you add one more layer.

2632
02:02:09,939 --> 02:02:14,439
所以我想再增加一层，我基本上需要这样做。
So I think to add one more layer, I essentially need to do this.

2633
02:02:14,439 --> 02:02:14,939
好的。
All right.

2634
02:02:14,939 --> 02:02:16,739
现在我有一个高度为2的金字塔。
Now I have a pyramid of height 2.

2635
02:02:16,739 --> 02:02:17,489
但是请稍等。
But wait a minute.

2636
02:02:17,489 --> 02:02:20,009
故事开始于，我如何建造一个高度为3的金字塔？
The story began with, how do I build a pyramid of height 3?

2637
02:02:20,010 --> 02:02:22,740
好吧，您拿起一个高度为2的金字塔，我在这里，
Well, you take a pyramid of height 2, which I have here,

2638
02:02:22,739 --> 02:02:24,329
然后添加一个附加层。
and you add an additional layer.

2639
02:02:24,329 --> 02:02:26,369
所以我必须建立这个额外的层。
So I've got to build this additional layer.

2640
02:02:26,369 --> 02:02:30,899
我要继续给自己一个层次，一个层次，一个层次。
I'm going to go ahead and give myself the layer, the layer, the layer.

2641
02:02:30,899 --> 02:02:34,949
然后，我将原始的高度金字塔放在其顶部。
And then I'm going to put the original pyramid of height to on top of it.

2642
02:02:34,949 --> 02:02:37,597
瞧，这是现在高度3的金字塔。
And voila, it's a pyramid of height 3 now.

2643
02:02:37,597 --> 02:02:38,639
好吧，我怎么到这里的？
Well, how did I get here?

2644
02:02:38,640 --> 02:02:40,230
好吧，让我继续回顾故事。
Well, let me keep rewinding in the story.

2645
02:02:40,229 --> 02:02:42,119
我问自己的第一个问题是，
The very first question I asked myself was,

2646
02:02:42,119 --> 02:02:43,827
您如何建造高度为4的金字塔？
how do you build a pyramid of height 4?

2647
02:02:43,828 --> 02:02:45,870
好吧，答案是建造一个高度为3的金字塔。
Well, the answer was build a pyramid of height 3.

2648
02:02:45,869 --> 02:02:47,109
太好了！
Great, that's done.

2649
02:02:47,109 --> 02:02:49,221
然后再添加一层。
Then add one additional layer.

2650
02:02:49,221 --> 02:02:51,929
如果我有更多的双手，我可以做得更优雅一些，
And if I had more hands, I could do this a little more elegantly,

2651
02:02:51,930 --> 02:02:54,190
但让我继续，然后将其布局。
but let me go ahead and just lay this out.

2652
02:02:54,189 --> 02:02:57,279
这是新的高度3。
Here's the new level of height 3.

2653
02:02:57,279 --> 02:02:58,919
现在我要走了
And now I'm going to go--

2654
02:02:58,920 --> 02:03:00,840
宽度4。
of width 4.

2655
02:03:00,840 --> 02:03:05,940
现在我要去把高度为3的金字塔放在上面，直到瞧，
Now I'm going to go and put the pyramid of height 3 on top of it, until voila,

2656
02:03:05,939 --> 02:03:09,839
我在这里有马里奥金字塔的这种形式。
I have this form here of Mario's pyramid.

2657
02:03:09,840 --> 02:03:13,020
因此，这是周期性的，每次我
So it's a bit cyclical in that, every time I

2658
02:03:13,020 --> 02:03:15,627
问自己要建造一个一定高度的金字塔，
asked myself to build a pyramid of a certain height,

2659
02:03:15,627 --> 02:03:18,210
我有点，说，不，要建一个如此高的金字塔。
I kind of punted and said, no, build a pyramid of this height.

2660
02:03:18,210 --> 02:03:19,290
不，建造这个高度的金字塔。
No, build a pyramid of this height.

2661
02:03:19,289 --> 02:03:20,939
不，建造这个高度的金字塔。
No, build a pyramid of this height.

2662
02:03:20,939 --> 02:03:25,889
但是该算法的魔力在于
But the magic of that algorithm was that there was constantly

2663
02:03:25,890 --> 02:03:29,520
这个，做更多的工作，建立一层，做更多的工作，
this, do a little more work, build a layer, do a little more work,

2664
02:03:29,520 --> 02:03:30,690
建立一层。
build a layer.

2665
02:03:30,689 --> 02:03:35,159
它是在一层又一层的隐式构建中
And it's in that implicit building of layer after layer after layer

2666
02:03:35,159 --> 02:03:38,482
实际上金字塔本身就是最终目标。
that the pyramid itself, the end goal, actually emerges.

2667
02:03:38,483 --> 02:03:41,400
因此，您可以使用for循环或while循环实现相同的操作。
So you could implement the same thing with a for loop or a while loop.

2668
02:03:41,399 --> 02:03:42,329
坦白说，你做到了。
And frankly, you did.

2669
02:03:42,329 --> 02:03:45,209
问题集1的形状略有不同
It was a slightly different shape for problem set 1,

2670
02:03:45,210 --> 02:03:47,340
但是您使用循环做了同样的事情。
but you did the same thing using a loop.

2671
02:03:47,340 --> 02:03:51,060
而且您至少必须按照我们的规定那样进行。
And you kind of had to do it that way, at least as we prescribed it.

2672
02:03:51,060 --> 02:03:54,327
因为使用printf，您必须从屏幕顶部进行打印
Because with printf, you have to print from the top of the screen

2673
02:03:54,327 --> 02:03:54,910
至底部。
to the bottom.

2674
02:03:54,909 --> 02:03:57,909
就像，我们还没有向您展示一种打印图层的技术
Like, we haven't shown you a technique yet to print a layer

2675
02:03:57,909 --> 02:03:59,252
然后回到最上面。
and then go back on top.

2676
02:03:59,252 --> 02:04:01,419
所以我有点在这里获得一些现实世界的自由
So I'm kind of taking some real-world liberties here

2677
02:04:01,420 --> 02:04:03,503
通过提起这些东西并移动它们。
by lifting these things up and moving them around.

2678
02:04:03,502 --> 02:04:06,009
您必须在代码上更加聪明。
You'd have to be a little more clever in code.

2679
02:04:06,010 --> 02:04:07,300
但是想法是一样的。
But the idea is the same.

2680
02:04:07,300 --> 02:04:09,280
因此，即使像这样的物理对象也可以
And so even physical objects like this can

2681
02:04:09,279 --> 02:04:12,769
对它们有一些递归定义。
have some recursive definition to them.

2682
02:04:12,770 --> 02:04:14,800
因此，我们提出了这种愚蠢的例子，
And so we present this sort of goofy example,

2683
02:04:14,800 --> 02:04:18,708
因为这种递归概念是一种基本的编程技术
because this notion of recursion is a fundamental programming technique

2684
02:04:18,707 --> 02:04:20,499
您现在可以利用它来解决问题
that you can leverage now to solve problems

2685
02:04:20,500 --> 02:04:22,479
以根本不同的方式。
in a fundamentally different way.

2686
02:04:22,479 --> 02:04:26,499
我想为此，我们需要对合并排序进行最后的可视化处理，
And I think for this, we need one final visualization of merge sort,

2687
02:04:26,500 --> 02:04:28,449
在Brian的帮助和计算机的帮助下。
with both Brian's help and the computer's.

2688
02:04:28,449 --> 02:04:32,169
敢于说，合并排序将是一种算法，其伪代码为
And merge sort is going to be an algorithm whose pseudocode is, daresay,

2689
02:04:32,170 --> 02:04:35,440
到目前为止，我们所见过的最简单的方法，但是看似简单。
the simplest we've seen thus far, but deceptively simple.

2690
02:04:35,439 --> 02:04:38,739
很简单，用于合并排序的伪代码是-
The pseudocode for merge sort, quite simply, is this--

2691
02:04:38,739 --> 02:04:42,689
对数字的左半部分进行排序，对数字的右半部分进行排序，
sort the left half of numbers, sort the right half of numbers,

2692
02:04:42,689 --> 02:04:44,949
合并排序的两半。
merge the sorted halves.

2693
02:04:44,949 --> 02:04:48,639
请注意，即使乍一看，这种感觉还是不公平的。
And notice, even at first glance this feels kind of unfair.

2694
02:04:48,640 --> 02:04:51,310
就像，这是一个排序算法，但是我
Like, here's an algorithm for sorting, and yet I'm

2695
02:04:51,310 --> 02:04:54,820
字面上是在我的算法中使用“ sort”一词进行排序的。
literally using the word "sort" in my algorithm for sorting.

2696
02:04:54,819 --> 02:04:57,069
就像是英语，如果要求您定义一个单词，
It's like in English if you're asked to define a word,

2697
02:04:57,069 --> 02:04:59,289
并且您实际上在定义中使用了该词。
and you literally use the word in the definition.

2698
02:04:59,289 --> 02:05:03,949
就像这样，这种情况很少会发生，因为您只是在做一个循环的论点。
Like, that rarely flies, because you're just making a circular argument.

2699
02:05:03,949 --> 02:05:08,739
但是在代码中，没关系，只要有一个特殊的步骤在做某事
But in code, it's OK, so long as there's one special step that's doing something

2700
02:05:08,739 --> 02:05:10,989
稍有不同，只要问题一直存在
a little differently, and so long as the problem keeps

2701
02:05:10,989 --> 02:05:12,156
越来越小。
getting smaller and smaller.

2702
02:05:12,157 --> 02:05:13,180
确实是这样。
And indeed it is.

2703
02:05:13,180 --> 02:05:16,593
这个伪代码不是说要对数字排序，对数字排序，
This pseudocode is not saying, sort the numbers, sort the numbers,

2704
02:05:16,592 --> 02:05:17,259
某种数字。
sort of numbers.

2705
02:05:17,260 --> 02:05:22,060
不，它将问题分成两半，然后解决另一半
No, it's dividing the problem in half and then solving the other half

2706
02:05:22,060 --> 02:05:22,700
也一样
as well.

2707
02:05:22,699 --> 02:05:25,089
因此，它可以缩小每次迭代的问题。
So it's shrinking the problem on each iteration.

2708
02:05:25,090 --> 02:05:28,667
现在，我将否认我们将再次需要这种所谓的基本情况。
Now, I will disclaim we're going to need that so-called base case again.

2709
02:05:28,667 --> 02:05:31,000
我将不得不做一些愚蠢的事情，但有必要，
I'm going to have to do something stupid, but necessary,

2710
02:05:31,000 --> 02:05:33,669
并说，如果只有一个数字，请退出。
and say, if there's only one number, quit.

2711
02:05:33,670 --> 02:05:34,540
已排序。
It's sorted.

2712
02:05:34,539 --> 02:05:36,369
这就是所谓的基本情况。
That's the so-called base case.

2713
02:05:36,369 --> 02:05:39,969
递归的情况是函数调用自身。
The recursive case is where the function calls itself.

2714
02:05:39,970 --> 02:05:44,920
但这确实是我们的第三个也是最后一个排序算法，称为合并排序。
But this is, indeed, our third and final sorting algorithm called merge sort.

2715
02:05:44,920 --> 02:05:48,290
我们将在这里真正专注于最有趣的部分，
And we'll focus here really on the juiciest pieces,

2716
02:05:48,289 --> 02:05:49,869
一，合并的概念。
one, this notion of merging.

2717
02:05:49,869 --> 02:05:52,269
所以事实上，布莱恩，我们可以过来找你吗
So in fact, Brian, can we come over to you

2718
02:05:52,270 --> 02:05:56,300
如此一来，我们就可以在定义合并排序算法本身之前进行定义，
just so we can define, before we look at the merge sort algorithm itself,

2719
02:05:56,300 --> 02:06:00,010
当我们说合并排序的两半时，我们什至是什么意思？
what do we even mean when we say merge sorted halves?

2720
02:06:00,010 --> 02:06:04,510
例如，Brian在这里的架子上有两个大小为4的阵列。
So for instance, Brian has on his shelf here two arrays of size 4.

2721
02:06:04,510 --> 02:06:08,680
在左侧的第一个数组中，有四个整数3、5、6、8。
In the first array on the left are four integers, 3, 5, 6, 8.

2722
02:06:08,680 --> 02:06:12,460
在右边，在另一个大小为4的数组中
And in the right side, in another array of size 4,

2723
02:06:12,460 --> 02:06:15,160
也是四个数字1,2,4,7
are four numbers, too, 1, 2, 4, 7.

2724
02:06:15,159 --> 02:06:18,369
左边和右边都被排序。
Both the left is sorted and the right is sorted.

2725
02:06:18,369 --> 02:06:21,879
但是现在，布莱恩，我希望您将这些分类的两半合并。
But now, Brian, I would like you to merge these sorted halves.

2726
02:06:21,880 --> 02:06:23,480
告诉我们这意味着什么。
Tell us what that means.

2727
02:06:23,479 --> 02:06:23,979
布莱恩：当然。
BRIAN: Sure.

2728
02:06:23,979 --> 02:06:26,679
因此，如果我有一个左半部分从最小的排序
So if I have a left half that sorted from smallest

2729
02:06:26,680 --> 02:06:30,490
到最大和右边的一半（也从最小到最大）排序，
to largest and a right half that's also sorted from smallest to largest,

2730
02:06:30,489 --> 02:06:34,119
我想将它们合并到一个具有所有相同数字的新列表中
I want to merge them into a new list that has all of the same numbers

2731
02:06:34,119 --> 02:06:36,089
也从最小到最大。
also from smallest to largest.

2732
02:06:36,090 --> 02:06:38,890
我想我可以从这里开始的地方是最小的
And I guess where I could start here is that the smallest

2733
02:06:38,890 --> 02:06:43,570
组合数组的数量必须以最小的一个开始
number of the combined array needs to begin with either the smallest

2734
02:06:43,569 --> 02:06:46,539
左半部分的数目或右半部分的最小数目。
number of the left half or the smallest number of the right half.

2735
02:06:46,539 --> 02:06:49,689
所以在左边最小的数字是3，在右边
So on the left the smallest number is the 3, and on the right

2736
02:06:49,689 --> 02:06:51,579
最小的数字是1。
the smallest number is the 1.

2737
02:06:51,579 --> 02:06:55,029
在整个阵列中，这两个必须是最小的数字。
Of those two has got to be the smallest number for the entire array.

2738
02:06:55,029 --> 02:06:58,029
在3和1之间，1较小。
And between the 3 and the 1, the 1 is smaller.

2739
02:06:58,029 --> 02:07:03,099
所以我取那个1，这将是第一个数字，最小的
So I would take that 1, and that's going to be the first number, the smallest

2740
02:07:03,100 --> 02:07:06,297
合并后的两半的数量。
number, of the merged two halves.

2741
02:07:06,296 --> 02:07:08,379
然后我想我会再次重复该过程。
And then I guess I would repeat the process again.

2742
02:07:08,380 --> 02:07:10,960
在左侧，最小的数字是3。
On the left side the smallest number is the 3.

2743
02:07:10,960 --> 02:07:13,060
在右侧，最小的数字是2。
On the right side the smallest number is the 2.

2744
02:07:13,060 --> 02:07:16,120
并且在3和2之间，2较小。
And between the 3 and the 2, 2 is smaller.

2745
02:07:16,119 --> 02:07:19,269
因此，我将取2 [音频不清晰]，这将是下一个数字。
So I would take the 2 [INAUDIBLE] and that's going to be the next number.

2746
02:07:19,270 --> 02:07:22,090
所以我正在慢慢建立这个排序的数组
So I'm slowly building up this sorted array that

2747
02:07:22,090 --> 02:07:23,770
是两者结合的结果。
is the result of combining these two.

2748
02:07:23,770 --> 02:07:27,040
现在，我将左侧的3与右侧的4进行比较。
Now I'm comparing the 3 on the left to the 4 on the right.

2749
02:07:27,039 --> 02:07:29,169
在3和4之间，3较小。
Between the 3 and the 4, the 3 is smaller.

2750
02:07:29,170 --> 02:07:33,020
因此，我将采用3，然后将其放置到位。
So I'll take the 3, and we'll put that one into position.

2751
02:07:33,020 --> 02:07:36,010
现在，我将左侧的5与右侧的4进行比较。
Now I'm comparing the 5 on the left with the 4 on the right.

2752
02:07:36,010 --> 02:07:38,380
在5和4之间，4较小。
Between the 5 and the 4, the 4 is smaller.

2753
02:07:38,380 --> 02:07:41,130
这样就可以了。
So that one goes into position.

2754
02:07:41,130 --> 02:07:44,970
然后，我将左侧的5与右侧的7进行比较。
And then now I'm comparing the 5 on the left with the 7 on the right.

2755
02:07:44,970 --> 02:07:47,811
5较小，因此5紧随其后。
5 is smaller, so the 5 goes next.

2756
02:07:47,810 --> 02:07:50,879
接下来，我将比较左边的6和右边的7。
Next I'm comparing the 6 on the left with the 7 on the right.

2757
02:07:50,880 --> 02:07:55,200
6仍然较小，因此下一个将要使用。
The 6 is still smaller, so that one is going to go next.

2758
02:07:55,199 --> 02:07:58,289
现在，我比较8和7，只剩下两个数字。
Now I'm comparing the 8 and the 7, the only two numbers left.

2759
02:07:58,289 --> 02:08:00,649
7是两者中较小的一个。
The 7 is the smaller between the two.

2760
02:08:00,649 --> 02:08:03,529
因此，我将采用7并将其放置到位。
So I'll take the 7 and put that into place.

2761
02:08:03,529 --> 02:08:05,279
现在我只剩下一个数字
And now I'm only left with one number that

2762
02:08:05,279 --> 02:08:09,899
尚未纳入两个半的合并中，那就是数字8。
hasn't been put into the merging of the two halves, and that's the number 8.

2763
02:08:09,899 --> 02:08:12,509
因此，该数字将占据最终位置。
So that number is going to take up the final position.

2764
02:08:12,510 --> 02:08:16,440
现在我将它们分成两半，每个半按原先的顺序分类，
And now I've taken these to halves, each of which was originally sorted,

2765
02:08:16,439 --> 02:08:19,886
并制作了一个完整的数组，其中包含所有这些数字的排序顺序。
and made one complete array that has all of those numbers in sorted order.

2766
02:08:19,886 --> 02:08:20,719
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

2767
02:08:20,720 --> 02:08:21,930
并考虑我们做了什么。
And consider what we've done.

2768
02:08:21,930 --> 02:08:24,120
从本质上讲，我们在口头和身体上都有
We've essentially verbally and physically kind of

2769
02:08:24,119 --> 02:08:27,359
定义了一个辅助函数，如果您愿意的话，可以使用我们自己的自定义函数，
defined a helper function, our own custom function if you will,

2770
02:08:27,359 --> 02:08:32,429
Brian定义了合并两个数组的含义-
whereby Brian has defined what does it mean to merge two arrays--

2771
02:08:32,430 --> 02:08:35,080
专门合并两个排序的数组。
specifically merge two sorted arrays.

2772
02:08:35,079 --> 02:08:35,639
因为为什么？
Because why?

2773
02:08:35,640 --> 02:08:37,050
好吧，这是我认为的基本要素
Well, that's a building block that I think

2774
02:08:37,050 --> 02:08:38,920
我们将要使用这种合并排序算法。
we're going to want in this merge sort algorithm.

2775
02:08:38,920 --> 02:08:40,795
因此，就像在实际的C代码中一样，
So just like in actual C code, you might have

2776
02:08:40,795 --> 02:08:43,230
定义了一个可以完成一些小任务的函数，
defined a function that does some small task,

2777
02:08:43,229 --> 02:08:46,439
因此，我们现在在口头和物理上是否定义了合并的概念。
so have we now verbally and physically defined the notion of merging.

2778
02:08:46,439 --> 02:08:49,619
这里的思想弯曲部分是“向左排序
The mind bending part here is that "Sort left

2779
02:08:49,619 --> 02:08:52,769
数字的一半”和“按数字的右半排序”
half of numbers" and "Sort right half of numbers"

2780
02:08:52,770 --> 02:08:54,690
是已经实施的一种。
is kind of already implemented.

2781
02:08:54,689 --> 02:08:58,169
Brian和我没有什么要定义的了。
There's nothing more for Brian or me to define.

2782
02:08:58,170 --> 02:09:01,890
剩下的就是让我们执行此算法，特别是专注
All that remains is for us to execute this algorithm, focusing especially

2783
02:09:01,890 --> 02:09:04,300
在这三行突出显示的代码行上。
on these three highlighted lines of code.

2784
02:09:04,300 --> 02:09:08,220
而且，让我否认我们到目前为止所研究的算法，
And let me disclaim that of the algorithms we've looked at thus far,

2785
02:09:08,220 --> 02:09:10,290
很有可能这将不是真的
odds are this will be the one that doesn't really

2786
02:09:10,289 --> 02:09:11,886
像其他人一样迅速陷入。
sink in as quickly as the others.

2787
02:09:11,886 --> 02:09:14,219
即使其他人可能花了您一点时间，一天，
Even if the others might have taken you a moment, a day,

2788
02:09:14,220 --> 02:09:16,887
一个星期安顿下来-也许您还没有到那儿，
a week to settle in-- or maybe you're still not quite there yet,

2789
02:09:16,886 --> 02:09:17,519
没关系 -
that's fine--

2790
02:09:17,520 --> 02:09:20,610
合并排序有点麻烦，
merge sort is a bit of a mind bending one,

2791
02:09:20,609 --> 02:09:23,129
因为它似乎神奇地工作。
because it seems to work magically.

2792
02:09:23,130 --> 02:09:25,387
但这确实可以更智能地工作。
But it really just works more intelligently.

2793
02:09:25,386 --> 02:09:27,719
而且您将开始对驾驭变得更加自在
And you'll begin to get more comfortable with harnessing

2794
02:09:27,720 --> 02:09:31,190
这些原始类型，以便我们最终可以确实解决问题
these kinds of primitives so that we can ultimately, indeed, solve problems

2795
02:09:31,189 --> 02:09:31,959
更有效率。
more efficiently.

2796
02:09:31,960 --> 02:09:35,130
因此，Brian好心地将数字重新放在了最顶层。
So Brian has kindly put the numbers again on the top shelf.

2797
02:09:35,130 --> 02:09:37,740
他将它们按照原始的，未分类的顺序放置，
And he has put them into their original, unsorted order,

2798
02:09:37,739 --> 02:09:40,079
就像选择排序和气泡排序一样。
just like for selection sort and bubble sort.

2799
02:09:40,079 --> 02:09:44,049
布赖恩，我现在想建议我们执行此合并排序算法。
And Brian, I'd like to propose now that we execute this merge sort algorithm.

2800
02:09:44,050 --> 02:09:47,500
而且，如果您不介意，我会先大声念出几个步骤。
And if you don't mind, I'll recite aloud first the few steps.

2801
02:09:47,500 --> 02:09:51,690
因此，这里是一个大小为8且未排序数字的数组。
So here is one array of size 8 with unsorted numbers.

2802
02:09:51,689 --> 02:09:54,149
目标是使用合并排序对这些数字进行排序。
The goal is to these numbers using merge sort.

2803
02:09:54,149 --> 02:09:57,519
回想一下，合并排序本质上只是三个步骤-
And recall that merge sort essentially is just three steps--

2804
02:09:57,520 --> 02:10:00,330
排序左半部分，排序右半部分，合并排序的两半。
sort left half, sort right half, merge sorted halves.

2805
02:10:00,329 --> 02:10:02,279
因此，布莱恩，看看那里的那些数字，
So Brian, looking at those numbers there,

2806
02:10:02,279 --> 02:10:04,859
您可以继续对数字的左半部分进行排序吗？
could you go ahead and sort the left half of numbers?

2807
02:10:04,859 --> 02:10:05,099
布莱恩：好的。
BRIAN: All right.

2808
02:10:05,100 --> 02:10:06,225
因此，共有八个数字。
So there are eight numbers.

2809
02:10:06,225 --> 02:10:09,810
左半部分是这四个数字，因此我将对它们进行排序。
The left half would be these four numbers, so I will sort those.

2810
02:10:09,810 --> 02:10:13,020
除非我不太确定如何对这四个数字进行排序。
Except I'm not really sure how do I now sort these four numbers.

2811
02:10:13,020 --> 02:10:13,770
戴维·马兰：是的。
DAVID MALAN: Yeah.

2812
02:10:13,770 --> 02:10:16,353
因此，我们已经看到了选择排序，我们已经看到了气泡排序。
So granted, we've seen selection sort, we've seen bubble sort.

2813
02:10:16,353 --> 02:10:19,530
但是我们不想回归那些较旧，较慢的算法。
But we don't want to regress to those older, slower algorithms.

2814
02:10:19,529 --> 02:10:22,109
布莱恩，我有点聪明。
Brian, I can kind of be a little clever here.

2815
02:10:22,109 --> 02:10:24,219
好吧，我给你一个排序算法。
Well, I'm giving you a sorting algorithm.

2816
02:10:24,220 --> 02:10:28,140
因此，现在您实际上遇到了一个较小的问题，即大小为4的数组
So now you effectively have a smaller problem, an array of size 4,

2817
02:10:28,140 --> 02:10:30,870
而且我很确定我们可以使用相同的算法，合并排序，
and I'm pretty sure we can use the same algorithm, merge sort,

2818
02:10:30,869 --> 02:10:32,669
通过排序左半部分，排序右半部分，
by sorting left half, sorting right half,

2819
02:10:32,670 --> 02:10:34,520
然后合并分类的两半。
and then merging the sorted halves.

2820
02:10:34,520 --> 02:10:38,232
那么，您可以继续对这四个数字的左半部分进行排序吗？
So could you go ahead and sort the left half of these four numbers?

2821
02:10:38,231 --> 02:10:38,939
布莱恩：好的。
BRIAN: All right.

2822
02:10:38,939 --> 02:10:40,019
所以我有这四个数字。
So I have these four numbers.

2823
02:10:40,020 --> 02:10:41,228
我想对左半部分进行排序。
I want to sort the left half.

2824
02:10:41,228 --> 02:10:42,893
这就是这两个数字。
That's these two numbers.

2825
02:10:42,893 --> 02:10:45,060
因此，现在我需要弄清楚如何对两个数字进行排序。
So now I need to figure out how to sort two numbers.

2826
02:10:45,060 --> 02:10:45,390
戴维·马兰：好的。
DAVID MALAN: All right.

2827
02:10:45,390 --> 02:10:48,490
现在，具有人类直觉的我们可能显然知道我们在这里要做的事情。
Now, us with human intuition might obviously know what we have to do here.

2828
02:10:48,489 --> 02:10:51,359
再说一次，让我们应用算法-左半排序，右半排序，
But again, let's apply the algorithm-- sort left half, sort right half,

2829
02:10:51,359 --> 02:10:52,169
合并排序一半。
merge sorted half.

2830
02:10:52,170 --> 02:10:55,257
Brian，您能对这个2号数组的右半部分进行排序吗？
Brian, could you sort the right half of this array of size 2?

2831
02:10:55,256 --> 02:10:57,339
布莱恩：所以我有两个数组，所以我先
BRIAN: So I've got the array of two, so I'll first

2832
02:10:57,340 --> 02:11:00,150
排序两个数组的左半部分，即6。
sort the left half of the array of two, which is the 6.

2833
02:11:00,149 --> 02:11:03,119
大卫·马兰（David MALAN）：这就是幻灯片上白色的基本情况
DAVID MALAN: And this is where the base case in white on the slide

2834
02:11:03,119 --> 02:11:04,259
发挥作用-
comes into play--

2835
02:11:04,260 --> 02:11:06,180
如果只有一个数字，请退出。
if only one number, quit.

2836
02:11:06,180 --> 02:11:07,830
所以Brian，我可以让你摆脱困境。
So Brian, I can let you off the hook.

2837
02:11:07,829 --> 02:11:12,219
那个编号为6的大小为1的列表已排序。
That list of size one with the number 6 is sorted.

2838
02:11:12,220 --> 02:11:13,650
这是完成的三个步骤之一。
So that's step one of three done.

2839
02:11:13,649 --> 02:11:16,949
布赖恩，你能排序那个大小为2的数组的右半部分吗？
Brian, could you sort the right half of that array of size two?

2840
02:11:16,949 --> 02:11:18,619
布莱恩：右半边是数字3。
BRIAN: The right half is the number 3.

2841
02:11:18,619 --> 02:11:20,769
它也只是一个数字，所以一个完成了。
It's also just one number, so that one is done.

2842
02:11:20,770 --> 02:11:21,520
戴维·马兰（David MALAN）：很好。
DAVID MALAN: Good.

2843
02:11:21,520 --> 02:11:22,890
因此，请考虑我们在故事中的位置。
So think about where we are on the story.

2844
02:11:22,890 --> 02:11:25,710
我们已经对左半部分进行了排序，并且已经开始对右半部分进行了排序，
We've sorted the left half, and we've started the right half,

2845
02:11:25,710 --> 02:11:29,030
即使看起来Brian和我都没有做任何有用的工作。
even though it looks like neither Brian nor I have done any useful work yet.

2846
02:11:29,029 --> 02:11:30,269
但是现在魔术发生了。
But now the magic happens.

2847
02:11:30,270 --> 02:11:34,290
Brian，您现在有两个大小为1的数组。
Brian, you now have two arrays of size 1.

2848
02:11:34,289 --> 02:11:36,221
您可以将它们合并在一起吗？
Could you merge them together?

2849
02:11:36,221 --> 02:11:36,929
布莱恩：好的。
BRIAN: All right.

2850
02:11:36,930 --> 02:11:38,670
所以我将把这两个合并在一起。
So I'm going to merge these two together.

2851
02:11:38,670 --> 02:11:40,530
在6和3之间，3较小。
Between the 6 and the 3, the 3 is smaller.

2852
02:11:40,529 --> 02:11:42,299
这样我就先放在那儿。
So that one I'll put there first.

2853
02:11:42,300 --> 02:11:44,700
然后我拿6，接着是那一个。
And then I'll take the 6, and that one goes next.

2854
02:11:44,699 --> 02:11:47,891
现在，我已经完成了大小为2的排序数组。
And now I have a sorted array of size 2 that is now done.

2855
02:11:47,891 --> 02:11:48,849
戴维·马兰：好的。
DAVID MALAN: All right.

2856
02:11:48,850 --> 02:11:51,725
这是您现在需要开始逐步记忆的地方
And this is where you now need to start remembering step by step sort

2857
02:11:51,725 --> 02:11:53,850
随着事物堆积而在您的大脑中产生作用。
of in your brain as the things pile up.

2858
02:11:53,850 --> 02:11:55,180
我们如何到达这一点？
How did we get to this point?

2859
02:11:55,180 --> 02:11:57,120
我们从大小为8的列表开始。
We started with a list of size 8.

2860
02:11:57,119 --> 02:12:00,359
然后，我们查看了左半部分，它是大小为4的数组。
We then looked at the left half, which was an array of size 4.

2861
02:12:00,359 --> 02:12:03,629
然后，我们查看其中的左半部分，它是大小为2的数组
We then looked at the left half of that, which was an array of size 2,

2862
02:12:03,630 --> 02:12:06,990
然后是两个大小为1的数组，然后我们将这两个排序的两半合并。
then two arrays of size 1, then we merged those two sorted halves.

2863
02:12:06,989 --> 02:12:09,599
所以我想现在，如果我回顾那个故事，布莱恩，
So I think now if I rewind in that story, Brian,

2864
02:12:09,600 --> 02:12:14,262
您需要对原始数字的左半部分的右半部分进行排序。
you need to sort the right half of the left half of the original numbers.

2865
02:12:14,261 --> 02:12:14,969
布莱恩：好的。
BRIAN: All right.

2866
02:12:14,970 --> 02:12:16,770
因此，左半部分是这四个部分。
So the left half is these four.

2867
02:12:16,770 --> 02:12:20,430
左半部分的右半部分将是这两个数字。
The right half of the left half is going to be these two numbers.

2868
02:12:20,430 --> 02:12:23,790
现在，对于那两个，我想我会再次重复该过程-
And so now to those two, I guess I would repeat the process again--

2869
02:12:23,789 --> 02:12:25,239
单独看数字。
look at the numbers individually.

2870
02:12:25,239 --> 02:12:27,824
我将看看这两个的左半部分，即8。
I would look at the left half of these two, which is the 8.

2871
02:12:27,824 --> 02:12:29,249
那个完成了。
That one is done.

2872
02:12:29,250 --> 02:12:31,179
而5，那也做完了。
And the 5, that one is done as well.

2873
02:12:31,180 --> 02:12:32,138
戴维·马兰：好的。
DAVID MALAN: All right.

2874
02:12:32,137 --> 02:12:35,261
因此，三分之三的步骤是将这两个排序的半部分合并。
So step three of three, then, is merge those two sorted halves.

2875
02:12:35,261 --> 02:12:35,969
布莱恩：好的。
BRIAN: All right.

2876
02:12:35,970 --> 02:12:39,830
因此，在8和5之间，5较小，因此第一个进入。
So between the 8 and the 5, the 5 is smaller, so that one will go in first.

2877
02:12:39,829 --> 02:12:41,459
8将在那之后。
And the 8 will go after that.

2878
02:12:41,460 --> 02:12:45,157
现在，我有了第二个大小为2的数组，该数组也已排序。
And now I have a second array of size 2 that is also now sorted.

2879
02:12:45,157 --> 02:12:45,990
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

2880
02:12:45,989 --> 02:12:49,749
因此，这里又是您必须倒回头脑的地方。
So here's where, again, you have to rewind in your mind's eye.

2881
02:12:49,750 --> 02:12:53,940
我们刚刚对左半部分进行了排序，
We've just now sorted the left half, and we've

2882
02:12:53,939 --> 02:12:58,239
对左半部分的左半部分和右半部分进行排序。
sorted the left half and the right half of the left half.

2883
02:12:58,239 --> 02:13:02,699
因此，我认为故事的这一部分的第三步也是最后一步是布莱恩，
So I think the third and final step at this part of the story is, Brian,

2884
02:13:02,699 --> 02:13:07,691
合并那些已排序的两半，每个半的大小现在为2。
to merge those sorted halves, each of which now is of size 2.

2885
02:13:07,692 --> 02:13:08,400
布莱恩：好的。
BRIAN: All right.

2886
02:13:08,399 --> 02:13:12,007
我有两个大小为2的数组，每个数组都已排序，需要合并。
I have two arrays of size 2, each of which is sorted, that I need to merge.

2887
02:13:12,007 --> 02:13:14,299
因此，我将比较每个数字中的最小数字。
So I'm going to compare the smallest numbers from each.

2888
02:13:14,300 --> 02:13:16,110
我将比较3和5。
I'm going to compare the 3 and the 5.

2889
02:13:16,109 --> 02:13:18,569
3较小，因此第一个进入。
The 3 is smaller, so that one will go in first.

2890
02:13:18,569 --> 02:13:21,959
现在，在这两个数组之间，我有一个6和一个5进行比较。
Now between these two arrays, I have a 6 and a 5 to compare.

2891
02:13:21,960 --> 02:13:24,210
5较小，因此下一个将继续。
The 5 is smaller, so that one will go next.

2892
02:13:24,210 --> 02:13:26,830
在6和8之间，6较小。
Between the 6 and the 8, the 6 is smaller.

2893
02:13:26,829 --> 02:13:28,529
我只剩下8个。
And I'm left with just the 8.

2894
02:13:28,529 --> 02:13:32,249
所以，如果我们回到我正在排序的八个数字的原始故事，
So if we go back to the original story of eight numbers that I was sorting,

2895
02:13:32,250 --> 02:13:35,970
我想我现在已经对左四个数字的左半部分进行了排序
I think I have now sorted the left half of the left four numbers

2896
02:13:35,970 --> 02:13:37,230
从那个原始数组。
from that original array.

2897
02:13:37,229 --> 02:13:37,559
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

2898
02:13:37,560 --> 02:13:39,210
因此，如果您在家中玩耍，请考虑
So if you're playing along at home, think

2899
02:13:39,210 --> 02:13:41,335
关于-您可能拥有所有这些想法
about-- you've got all these thoughts probably kind

2900
02:13:41,335 --> 02:13:42,430
在你脑海中堆积。
of piling up in your mind.

2901
02:13:42,430 --> 02:13:43,860
确实应该是这样。
That's indeed supposed to be the case.

2902
02:13:43,859 --> 02:13:46,151
诚然，很难跟踪所有这些信息。
And admittedly, it's hard to keep track of all of that.

2903
02:13:46,152 --> 02:13:48,520
因此，我们让Brian现在完全执行此操作
So we'll let Brian now execute this altogether

2904
02:13:48,520 --> 02:13:52,213
现在，通过对所有正确的一半进行排序，一起做同一件事
together doing the same thing now, by sorting the right half all

2905
02:13:52,212 --> 02:13:53,129
完成的方式。
the way to completion.

2906
02:13:53,130 --> 02:13:53,963
布莱恩，如果可以的话。
Brian, if you could.

2907
02:13:53,962 --> 02:13:54,671
布莱恩：好的。
BRIAN: All right.

2908
02:13:54,671 --> 02:13:56,339
所以右半部分，您有四个数字。
So the right half, you got four numbers.

2909
02:13:56,340 --> 02:13:59,670
我将从对右半部分的左半部分进行排序开始，即
I'm going to start by sorting the left half of the right half, which

2910
02:13:59,670 --> 02:14:01,180
这两个数字是这里吗
is these two numbers here.

2911
02:14:01,180 --> 02:14:02,930
为此，我将重复相同的过程-
To do that, I'll repeat the same process--

2912
02:14:02,930 --> 02:14:06,240
排序这两个数字的左半部分，即2。
sort the left half of these two numbers, which is just the 2.

2913
02:14:06,239 --> 02:14:08,079
完成一个，只有一个数字。
That one's done, it's only one number.

2914
02:14:08,079 --> 02:14:09,371
右半边也一样。
Same thing with the right half.

2915
02:14:09,372 --> 02:14:11,100
7只是一个数字，所以完成了。
The 7 is only one number, so it's done.

2916
02:14:11,100 --> 02:14:13,410
现在，我将分类的两半合并在一起。
And now I'll merge the sorted halves together.

2917
02:14:13,409 --> 02:14:17,159
在2和7之间，2较小，然后是7。
Between the 2 and the 7, the 2 is smaller and then the 7.

2918
02:14:17,159 --> 02:14:21,539
所以现在是右半部分的左半部分，大小为2的数组
So here now is the left half of the right half, an array of size 2,

2919
02:14:21,539 --> 02:14:22,499
那是排序的。
that is sorted.

2920
02:14:22,500 --> 02:14:25,259
我将在右半部分的右半部分做同样的事情，
And I'll do the same thing with the right half of the right half,

2921
02:14:25,260 --> 02:14:27,120
从左半数开始，即4。
starting with the left half, which is 4.

2922
02:14:27,119 --> 02:14:28,089
做完了
That's done.

2923
02:14:28,090 --> 02:14:29,200
1完成。
The 1 is done.

2924
02:14:29,199 --> 02:14:30,949
现在，将这两部分合并在一起，我将
And now to merge these two together, I'll

2925
02:14:30,949 --> 02:14:33,189
比较它们并说1较小。
compare them and say the 1 is smaller.

2926
02:14:33,189 --> 02:14:36,329
因此，我先将1放下，再将4放下。
So I'll put the 1 down and then the 4.

2927
02:14:36,329 --> 02:14:39,869
所以现在我有两个排序数组，每个数组的大小为2
So now I have two sorted arrays, each of size 2,

2928
02:14:39,869 --> 02:14:42,359
我现在需要回溯并合并在一起
that I now need to backtrack and now merge together

2929
02:14:42,359 --> 02:14:44,459
形成大小为4的数组。
to form an array of size 4.

2930
02:14:44,460 --> 02:14:45,930
因此，我将比较2和1。
So I'll compare the 2 and the 1.

2931
02:14:45,930 --> 02:14:48,000
在这两个之间，1较小。
Between those two, the 1 is smaller.

2932
02:14:48,000 --> 02:14:49,979
然后，我将2与4进行比较。
Then I'll compare the 2 with the 4.

2933
02:14:49,979 --> 02:14:51,569
2较小。
The 2 is smaller.

2934
02:14:51,569 --> 02:14:53,189
然后，我将7与4进行比较。
Then I'll compare the 7 with the 4.

2935
02:14:53,189 --> 02:14:54,479
4较小。
The 4 is smaller.

2936
02:14:54,479 --> 02:14:57,209
最后，我只取最后一个数字7
And then finally, I'll just take the 7, the last number,

2937
02:14:57,210 --> 02:14:59,010
并把它放在最后的位置。
and put that in the final spot.

2938
02:14:59,010 --> 02:15:01,740
现在，从最初的八个数字数组开始，
And so now from the original array of eight numbers,

2939
02:15:01,739 --> 02:15:05,519
现在，我对左半部分进行了排序，对右半部分进行了排序。
I've now sorted the left half, and I've sorted the right half.

2940
02:15:05,520 --> 02:15:09,030
DAVID MALAN：现在，我们进入了第三步，也是最后一步。
DAVID MALAN: And now that brings us to our third and very final step.

2941
02:15:09,029 --> 02:15:11,949
布赖恩，您可以将分类的两半合并吗？
Could you, Brian, merge the sorted halves?

2942
02:15:11,949 --> 02:15:12,449
布莱恩：是的。
BRIAN: Yeah.

2943
02:15:12,449 --> 02:15:14,519
我认为这实际上是我们已经看到的一个例子。
And I think this is actually an example we've seen already.

2944
02:15:14,520 --> 02:15:16,728
为了这两个半，我要做的是
And what I'm going to do in order to these two halves

2945
02:15:16,728 --> 02:15:19,080
只是从每一半取较小的数字
is just take the smaller number from each half

2946
02:15:19,079 --> 02:15:20,639
并一遍又一遍地比较它们。
and compare them again and again.

2947
02:15:20,640 --> 02:15:24,240
因此，在3和1之间，即1是最小的数字。
So between the 3 and the 1, the 1, that's the smallest number.

2948
02:15:24,239 --> 02:15:25,799
这样就到位了。
So that goes into place.

2949
02:15:25,800 --> 02:15:29,070
然后在3和2之间，2较小，
Then between the 3 and the 2, the 2 is smaller,

2950
02:15:29,069 --> 02:15:31,349
所以我们将其放到位。
so we'll take that and put that into place.

2951
02:15:31,350 --> 02:15:33,930
现在，我将3与4进行比较。
Now I'm comparing the 3 with the 4.

2952
02:15:33,930 --> 02:15:36,420
3，接下来。
The 3, that goes next.

2953
02:15:36,420 --> 02:15:38,640
接下来，我将5与4进行比较。
Next I'm comparing the 5 with the 4.

2954
02:15:38,640 --> 02:15:42,450
4较小，因此接下来要放置4。
4 is smaller, so the 4 goes into place next.

2955
02:15:42,449 --> 02:15:44,669
现在，我将5与7进行比较。
Now I'm comparing the 5 with the 7.

2956
02:15:44,670 --> 02:15:47,930
5较小，因此一个就位。
5 is smaller, so that one goes into place.

2957
02:15:47,930 --> 02:15:51,630
接下来，将6与7进行比较，因此6较小。
And next, comparing the 6 with the 7, so the 6 is smaller.

2958
02:15:51,630 --> 02:15:52,870
接下来。
That goes next.

2959
02:15:52,869 --> 02:15:55,319
现在剩下两个数字，分别是8和7。
And now I'm left with two numbers, the 8 and the 7.

2960
02:15:55,319 --> 02:15:59,099
7是2中的较小者，因此下一个继续。
The 7 is the smaller of the 2, so that one goes next.

2961
02:15:59,100 --> 02:16:02,200
至此，我只剩下一个数字，即8。
And at this point, I only have one number left, which is the 8.

2962
02:16:02,199 --> 02:16:05,099
这样一个人就可以进入它的排序位置
And so that one's going to go into its sorted position

2963
02:16:05,100 --> 02:16:06,607
在数组的末尾。
at the end of the array.

2964
02:16:06,606 --> 02:16:07,439
戴维·马兰（David MALAN）：的确如此。
DAVID MALAN: Indeed.

2965
02:16:07,439 --> 02:16:10,109
因此，即使感觉我们并没有真正做任何事情
So even though it felt like we weren't really doing anything

2966
02:16:10,109 --> 02:16:12,299
在那个故事的几个点上，
at several points in that story, it all sort of

2967
02:16:12,300 --> 02:16:16,110
当我们开始合并以及合并和合并这些列表时，他们走到了一起。
came together when we started merging and merging and merging these lists.

2968
02:16:16,109 --> 02:16:19,649
Brian使用多个架子并不是偶然的，
And it's not an accident that Brian was using multiple shelves,

2969
02:16:19,649 --> 02:16:22,319
将数字从上到下移动以使其清晰
moving the numbers from top to bottom, to make clear

2970
02:16:22,319 --> 02:16:26,284
他有效地将该列表划分了多少次。
just how many times he was effectively dividing that list up.

2971
02:16:26,284 --> 02:16:28,409
我们从八个列表开始
We started with a list of eight, and we essentially

2972
02:16:28,409 --> 02:16:33,509
将其带到大小为4的两个列表中，大小为2的四个列表中，大小为1的八个列表中。
took it to two lists of size 4, four lists of size 2, eight lists of size 1.

2973
02:16:33,510 --> 02:16:35,740
虽然不是完全按照这个顺序，
And while it wasn't exactly in that order,

2974
02:16:35,739 --> 02:16:38,849
如果您倒带并分析所有步骤，那的确是他所做的。
if you rewind and analyze all of the steps, that's indeed what he did.

2975
02:16:38,850 --> 02:16:42,809
他从8变为2的4到4 2到8的1。
He went from 8 to two 4's to four 2's to eight 1's.

2976
02:16:42,808 --> 02:16:47,039
这就是为什么他将这些数字从最上面的架子上调下三遍了-
And that's why he moved those numbers from the top shelf down three times--

2977
02:16:47,040 --> 02:16:50,920
从8到4，到2到1&#39;r。
from 8's, to 4's, to 2's, to 1'r.

2978
02:16:50,920 --> 02:16:53,100
那么他将数字移动了多少次？
So how many times did he move the numbers?

2979
02:16:53,100 --> 02:16:55,590
他总共搬了三遍。
He moved them three times total.

2980
02:16:55,590 --> 02:17:00,150
在每个架子上，他必须合并多少个数字？
And on each of those shelves, how many numbers did he have to merge together?

2981
02:17:00,149 --> 02:17:04,019
在每个架子上，他最终都触及了所有八个数字。
On each of those shelves, he ultimately touched all eight numbers.

2982
02:17:04,020 --> 02:17:08,087
他首先插入最小的数字，然后插入第二个最小的数字，然后
He first inserted the smallest number, then the second smallest, then

2983
02:17:08,086 --> 02:17:08,878
第三小。
the third smallest.

2984
02:17:08,879 --> 02:17:13,709
但是与选择排序不同的是，他已经巧妙地将这些一半进行了排序，
But unlike selection sort, he had smartly already sorted those halves,

2985
02:17:13,709 --> 02:17:16,072
所以他只是一次把它们摘下来。
so he was just plucking them off one at a time.

2986
02:17:16,072 --> 02:17:18,030
他没有来回走动，来回走动。
He wasn't going back and forth, back and forth.

2987
02:17:18,030 --> 02:17:22,469
从那一半的清单的开头开始，他一直在不断地取录。
He was constantly taking from the beginning of each of those half lists.

2988
02:17:22,468 --> 02:17:26,308
因此，在每个架子上，他都在做n步，
So on every shelf, he was doing, let's say, n steps,

2989
02:17:26,308 --> 02:17:29,789
因为他正在合并该架子的所有n个元素。
because he was merging in all n elements of that shelf.

2990
02:17:29,790 --> 02:17:34,379
但是他将n个元素合并了多少次？
But how many times did he merge n elements together?

2991
02:17:34,379 --> 02:17:36,633
好吧，他总共做了三遍。
Well, he did that three total times.

2992
02:17:36,632 --> 02:17:39,549
但是如果考虑二进制搜索，实际上是除法过程
But if you think about binary search, and really the process of divide

2993
02:17:39,549 --> 02:17:43,069
然后更普遍地征服，只要您将事物一分为二
and conquer more generally, anytime you divide something in half and half

2994
02:17:43,069 --> 02:17:47,149
一半，就像他从8到4到2到1一样。
and half, as he was doing from 8's to 4's to 2's to 1's.

2995
02:17:47,149 --> 02:17:48,169
这是一个对数。
That's a logarithm.

2996
02:17:48,170 --> 02:17:49,639
这是基于日志的2。
That's log base 2.

2997
02:17:49,638 --> 02:17:52,729
确实，这就是这个架子的高度。
And indeed, that is wonderfully the height of this shelf.

2998
02:17:52,729 --> 02:17:56,479
如果货架上有八个元素，则额外的货架数
If you have eight elements on the shelf, the number of additional shelves

2999
02:17:56,479 --> 02:18:03,179
布莱恩（Brian）使用3，正是通过对数进行2的数学对数后得出的结果。
Brian used, 3, is exactly what you get by doing the math log base 2 of 8.

3000
02:18:03,180 --> 02:18:08,059
就是说，布莱恩做了n次记录n次。
Which is to say, Brian did n things log n times.

3001
02:18:08,058 --> 02:18:10,519
再次挥手，计算机科学家
And again with a wave of the hand, computer scientists

3002
02:18:10,520 --> 02:18:13,129
不要打扰用Big O表示法提及基数。
don't bother mentioning the base with Big O notation.

3003
02:18:13,129 --> 02:18:14,840
只需说log n--
It suffices just to say log n--

3004
02:18:14,840 --> 02:18:18,410
布赖恩（Brian）做了n次记录n次。
Brian did n things log n times.

3005
02:18:18,409 --> 02:18:22,489
因此，如果我们考虑渐近复杂性
And so if we consider, then, the asymptotic complexity

3006
02:18:22,489 --> 02:18:25,429
该算法的运行时间，即该算法的运行时间，
of this algorithm, that is to say the running time of this algorithm,

3007
02:18:25,430 --> 02:18:30,230
在大O表示法方面，请注意，它的性能绝对好于
in terms of big O notation, notice that it performs strictly better then

3008
02:18:30,229 --> 02:18:32,659
选择排序和气泡排序
selection sort and bubble sort--

3009
02:18:32,659 --> 02:18:34,779
n次登录n。
n times log n.

3010
02:18:34,780 --> 02:18:37,760
再说一次，如果您对数有些生疏，请登录n，
And even, again, if you're a little rusty on logarithms, log n,

3011
02:18:37,760 --> 02:18:40,040
从二进制搜索的第0周开始，
we have seen as of week 0 in binary search,

3012
02:18:40,040 --> 02:18:43,040
肯定比n步快。
is definitely faster than n steps.

3013
02:18:43,040 --> 02:18:45,530
所以n的平方是n乘以n。
So n squared is n times n.

3014
02:18:45,530 --> 02:18:49,459
n log n是n乘以log n，这在数学上确实是
n log n is n times log n, which is indeed mathematically

3015
02:18:49,459 --> 02:18:51,980
最好然后n平方。
better then n squared.

3016
02:18:51,979 --> 02:18:55,399
但是，与合并排序一样，如果我们考虑下限，
As with merge sort, though, if we consider the lower bound,

3017
02:18:55,399 --> 02:19:00,048
注意气泡排序，是的，使我们低至n的欧米茄。
notice that bubble sort, yes, got us as low as omega of n.

3018
02:19:00,049 --> 02:19:03,750
原来合并排序有点像选择排序
Turns out merge sort is a little bit like selection sort

3019
02:19:03,750 --> 02:19:07,940
因为它不会自我优化，并且会让您尽早退出算法。
in that it doesn't optimize itself and get you out of the algorithm early.

3020
02:19:07,940 --> 02:19:13,375
它始终为n log n，因此它是n log n的下界ω。
It's always n log n, so it's lower bound omega of n log n.

3021
02:19:13,375 --> 02:19:14,750
这可能是不可接受的。
And that might not be acceptable.

3022
02:19:14,750 --> 02:19:16,729
有时您可能会有某些数据输入
Sometimes you might have certain data inputs

3023
02:19:16,729 --> 02:19:19,699
可能倾向于将其排序的地方，而您不想浪费时间。
where maybe it tends to be sorted and you don't want to waste time.

3024
02:19:19,700 --> 02:19:21,799
因此，也许您会选择冒泡排序的。
So maybe you'd be OK with bubble sort.

3025
02:19:21,799 --> 02:19:24,920
但说实话，当n变大时，
But honestly, as n gets large, the probability

3026
02:19:24,920 --> 02:19:29,540
您排序算法的输入只是偶然地被排序
that the input to your sorting algorithm is just by chance going to be sorted

3027
02:19:29,540 --> 02:19:33,200
可能是如此之低，以至于你变得更好
is probably so, so low that you're just better

3028
02:19:33,200 --> 02:19:36,940
通常情况下，使用诸如合并排序之类的算法
off in the general case using an algorithm like merge sort that's

3029
02:19:36,940 --> 02:19:38,660
n始终记录n。
n log n always.

3030
02:19:38,659 --> 02:19:41,298
我们也可以使用条形图直观地看到这一点。
We can see this visually using our bars, too.

3031
02:19:41,299 --> 02:19:43,850
请注意，就像Brian在分而治之一样
And notice, just as Brian was dividing and conquering

3032
02:19:43,850 --> 02:19:47,150
一半又一半又一半的问题，然后重新构成
the problem in half and half and half, and then reconstituting

3033
02:19:47,149 --> 02:19:51,619
通过合并这两个部分，您可以在此处直观地看到它。
the array by merging those halves, you can kind of see that visually here.

3034
02:19:51,620 --> 02:19:53,618
还有很多事情要做。
There's a lot more going on.

3035
02:19:53,618 --> 02:19:56,660
一会儿，一切似乎都变得神奇起来
And it's going to seem in a moment that everything just kind of magically

3036
02:19:56,659 --> 02:19:57,159
工作了。
worked.

3037
02:19:57,159 --> 02:20:00,679
但是您可以在褪色的紫色条中看到，确实
But you can see in the faded purple bars that, indeed, this

3038
02:20:00,680 --> 02:20:04,400
正在将事物分成两半，然后将这些两半合并在一起。
is sorting things in halves and then merging those halves together.

3039
02:20:04,399 --> 02:20:06,589
而且这种可视化有些不同。
And this visualization was a little different.

3040
02:20:06,590 --> 02:20:08,510
它没有三个架子的豪华。
It did not have the luxury of three shelves.

3041
02:20:08,510 --> 02:20:10,760
它只是从上到下，从上到下移动。
It just moved top to bottom, top to bottom.

3042
02:20:10,760 --> 02:20:13,460
老实说，Brian在那里可能会更好一些。
And honestly, Brian could have been a little more optimal there.

3043
02:20:13,459 --> 02:20:16,249
我们想弄清楚总共有多少个架子。
We wanted to make clear how many total shelves there were.

3044
02:20:16,250 --> 02:20:18,470
但说实话，没有理由他不能只是
But honestly, there's no reason he couldn't have just

3045
02:20:18,469 --> 02:20:21,949
将数字向下移动，然后向上备份，然后向下移动，然后向上备份。
moved the numbers down then back up, then back down then back up.

3046
02:20:21,950 --> 02:20:24,440
而且，的确是您通过合并排序支付的价格。
And, indeed that's the price you pay with merge sort.

3047
02:20:24,440 --> 02:20:27,920
即使n log n优于n平方和ergo
Even though n log n is better than n squared, and ergo

3048
02:20:27,920 --> 02:20:31,790
可以说，合并排序比选择排序和冒泡排序更好，
merge sort is arguably better than selection sort and bubble sort,

3049
02:20:31,790 --> 02:20:32,960
你付出代价。
you pay a price.

3050
02:20:32,959 --> 02:20:35,749
这证明了我之前提到的权衡。
And this speaks to the trade-off I mentioned earlier.

3051
02:20:35,750 --> 02:20:39,560
几乎总是，当您在代码中做得更好时
Almost always, when you do something better in code

3052
02:20:39,559 --> 02:20:42,896
或更聪明地解决问题，您已经付出了代价。
or solve a problem more intelligently, you have paid a price.

3053
02:20:42,897 --> 02:20:45,230
也许您花了更多的时间来编写代码，
Maybe you spent more time as the human writing the code,

3054
02:20:45,229 --> 02:20:47,419
因为它更难，而且更加复杂。
because it was harder and took more sophistication.

3055
02:20:47,420 --> 02:20:48,620
那是代价。
That is a cost.

3056
02:20:48,620 --> 02:20:51,680
也许您实际上必须使用更多的空间。
Maybe you had to use actually more space.

3057
02:20:51,680 --> 02:20:56,950
Brian必须至少有一个额外的架子才能实施合并排序。
Brian had to have at least one extra shelf in order to implement merge sort.

3058
02:20:56,950 --> 02:20:59,360
如果在代码和C中实现合并排序，
If implementing merge sort in code and C,

3059
02:20:59,360 --> 02:21:05,180
您将需要至少第二个数组以将数字临时放入其中
you will need at least a second array to temporarily put the numbers into as you

3060
02:21:05,180 --> 02:21:06,800
来回合并东西。
merge things back and forth.

3061
02:21:06,799 --> 02:21:09,739
如果要奢侈，可以有三个单独的阵列
If you want to be extravagant, you can have three separate arrays

3062
02:21:09,739 --> 02:21:11,089
或四个单独的阵列。
or four separate arrays.

3063
02:21:11,090 --> 02:21:14,240
但是，按照合并排序的图形表示就足够了，
But it's suffices, per the graphical representation of merge sort,

3064
02:21:14,239 --> 02:21:16,102
只使用第二个数组。
to just use a second array.

3065
02:21:16,102 --> 02:21:18,019
现在，这似乎没什么大不了的。
Now, that might not seem like such a big deal.

3066
02:21:18,020 --> 02:21:21,710
但是隐式地，您需要两倍的空间。
But implicitly, you need twice as much space.

3067
02:21:21,709 --> 02:21:23,269
那可能是一件大事。
And that might be a big deal.

3068
02:21:23,270 --> 02:21:27,590
如果您要分类一百万个东西，现在需要两个数组，
If you've got a million things to sort, and you now need two arrays,

3069
02:21:27,590 --> 02:21:30,530
那就是您需要的200万块内存。
that's 2 million chunks of memory that you need.

3070
02:21:30,530 --> 02:21:32,052
也许那是站不住脚的。
And maybe that's not tenable.

3071
02:21:32,051 --> 02:21:34,009
因此，这里也要进行权衡。
So there, too, there's going to be a trade-off.

3072
02:21:34,010 --> 02:21:36,320
也许虽然速度较慢，但选择有点像气泡，也许
And maybe while slower, selection sort of bubble sort, maybe

3073
02:21:36,319 --> 02:21:38,819
更好，因为空间效率更高。
it's better because it's a little more efficient with space.

3074
02:21:38,819 --> 02:21:41,119
这将取决于您在乎什么
It's going to depend on what you care about

3075
02:21:41,120 --> 02:21:42,870
以及您要优化的内容。
and what you want to optimize for.

3076
02:21:42,870 --> 02:21:44,750
老实说，金钱有时是一个因素。
And honestly, money is sometimes a factor.

3077
02:21:44,750 --> 02:21:48,500
在现实世界中，编写稍微慢一点的代码也许更好
In the real world, maybe it's better to write slightly slower code

3078
02:21:48,500 --> 02:21:52,129
这样您就不必购买两倍的服务器或两倍的内存
so that you don't have to buy twice as many servers or twice as much memory

3079
02:21:52,129 --> 02:21:53,209
为您的计算机。
for your computer.

3080
02:21:53,209 --> 02:21:55,729
这取决于哪种资源更重要-
It depends there on what resource is more important--

3081
02:21:55,729 --> 02:22:00,769
您的时间，计算机的时间，您的钱包或其他资源
your time, the computer's time, your wallet, or some other resource

3082
02:22:00,770 --> 02:22:01,340
共。
altogether.

3083
02:22:01,340 --> 02:22:03,590
因此，我们将继续看到这些折衷方案。
So we'll continue to see these kinds of trade-offs.

3084
02:22:03,590 --> 02:22:07,500
但是，也许我们在这里总结时可以做的最令人震惊的事情
But perhaps the most mind blowing thing we can do as we wrap up here

3085
02:22:07,500 --> 02:22:12,919
分享了这些算法实际比较的一些可视化效果。
is share a few visualizations of how these algorithms actually compare.

3086
02:22:12,920 --> 02:22:17,900
最后一个行话就是这个最后的希腊符号theta。
And one last piece of jargon is this one final Greek symbol, theta.

3087
02:22:17,899 --> 02:22:21,919
事实证明，由于选择排序和合并排序，
It turns out that, thanks to selection sort and merge sort,

3088
02:22:21,920 --> 02:22:26,570
我们实际上可以在这里再加上一个艺术术语，即theta符号。
we can actually apply one more term of art here, this theta notation.

3089
02:22:26,569 --> 02:22:30,139
任何时候算法都有相同的上限
Anytime an algorithm has both the same upper bound

3090
02:22:30,139 --> 02:22:33,049
作为其下限运行时间，您实际上可以
as its lower bound running time, you can actually

3091
02:22:33,049 --> 02:22:37,979
仅用一句话描述它，而不是用theta表示法描述两个句子。
describe it in just one sentence instead of two in terms of theta notation.

3092
02:22:37,979 --> 02:22:41,374
因此，因为选择排序同时处于n平方和omega的大O中
So because selection sort was in both big O of n squared and omega

3093
02:22:41,375 --> 02:22:44,870
的n平方，您实际上可以说，啊，它在n平方的theta中。
of n squared, you can actually just say, ah, it's in theta of n squared.

3094
02:22:44,870 --> 02:22:49,010
在上限或下限中总是n平方。
It's always n squared either in the upper bound or in the lower bound.

3095
02:22:49,010 --> 02:22:50,210
合并排序也一样。
Same thing for merge sort.

3096
02:22:50,209 --> 02:22:52,309
它在n log n的theta中。
It's in theta of n log n.

3097
02:22:52,309 --> 02:22:57,859
我们不能将theta用于冒泡排序或二进制搜索或线性搜索，
We cannot use theta for bubble sort or for binary search or for linear search,

3098
02:22:57,860 --> 02:23:01,150
因为它们的上下限不同。
because they had different upper and lower bounds.

3099
02:23:01,149 --> 02:23:05,599
好吧，让我现在开始准备最后的演示，
Well, let me go ahead now and prepare a final demonstration,

3100
02:23:05,600 --> 02:23:08,090
这次使用一些随机输入。
this time using some random inputs.

3101
02:23:08,090 --> 02:23:11,750
因此，您将在此处看到一个视频，其中比较了选择排序，气泡排序
So you'll see here a video comparing selection sort, bubble sort,

3102
02:23:11,750 --> 02:23:13,759
并合并排序在一起。
and merge sort all together.

3103
02:23:13,760 --> 02:23:16,560
它们全部以随机数据开始。
All three of them start with random data.

3104
02:23:16,559 --> 02:23:18,829
但是，让我们看看它对算法意味着什么
But let's just see what it means for an algorithm

3105
02:23:18,829 --> 02:23:26,294
在最坏的情况下为n平方或在这种情况下为n log n。
to be an n squared in the worst case or in n log n in this case instead.

3106
02:23:26,295 --> 02:23:26,920
[音乐播放]
[MUSIC PLAYING]

3107
02:23:26,920 --> 02:23:29,295
选择排序在顶部，气泡排序在底部，
Selection sort's on the top, bubble sort's on the bottom,

3108
02:23:29,295 --> 02:23:30,490
合并排序在中间。
merge sort's in the middle.

3109
02:23:30,489 --> 02:23:35,351
而且您会相信，合并排序已经完成。
And would you believe it, merge sort is already done.

3110
02:23:35,352 --> 02:23:37,280
[音乐强度]
[MUSIC INTENSIFIES]

3111
02:23:37,280 --> 02:23:40,902
同时，我们可以听一些非常时髦的音乐，
And meanwhile, we have some very trendy music we can listen to,

3112
02:23:40,902 --> 02:23:42,610
真的只是在分散我们的注意力
which is really just there to distract us

3113
02:23:42,610 --> 02:23:47,060
实际上，实际上n平方有多慢。
from the fact at how slow n squared actually is in practice.

3114
02:23:47,059 --> 02:23:49,419
注意，这里没有很多酒吧。
And notice, there's not that many bars here.

3115
02:23:49,420 --> 02:23:51,310
大概有一百多个酒吧。
There's maybe like a hundred or so bars.

3116
02:23:51,309 --> 02:23:52,689
例如，n为100。
Like, n is 100.

3117
02:23:52,690 --> 02:23:53,882
那什至没有太大的价值。
That's not even a big value.

3118
02:23:53,881 --> 02:23:56,589
当我们谈论Twitter，Facebook，Google
When we're talking about the Twitters, the Facebooks, the Googles

3119
02:23:56,590 --> 02:23:59,080
在世界范围内，这些都是微不足道的尺寸。
of the world, these are trivial sizes.

3120
02:23:59,079 --> 02:24:03,219
但是，天哪，我们仍在等待选择排序和冒泡排序
And yet, my God, we're still waiting for selection sort and bubble sort

3121
02:24:03,219 --> 02:24:04,299
完成。
to finish.

3122
02:24:04,299 --> 02:24:08,109
因此，您可以在这里看到一点点运动确实很重要
And so you can see here that it really matters when you exercise a little bit

3123
02:24:08,110 --> 02:24:10,980
更聪明，并且您可以利用更高效的算法-
more cleverness, and you leverage a more efficient algorithm--

3124
02:24:10,979 --> 02:24:14,494
最后，选择排序完成，气泡排序仍在进行
and finally, selection sort is done, bubble sort still taking

3125
02:24:14,495 --> 02:24:15,370
在这里再多一点。
a little longer here.

3126
02:24:15,370 --> 02:24:16,810
这将取决于输入。
And this is going to depend on the input.

3127
02:24:16,809 --> 02:24:18,609
有时，您可能会感到幸运或不幸。
Sometimes you can get lucky or unlucky.

3128
02:24:18,610 --> 02:24:22,390
但我认为在这种情况下合并排序已获成功令人信服。
But I think it's convincing that merge sort has won in this case.

3129
02:24:22,389 --> 02:24:26,939
[音乐播放]
[MUSIC PLAYING]

