1
00:00:00,000 --> 00:00:04,490
[音乐响起--字幕精校中--By Persisan]
[MUSIC PLAYING]

2
00:00:49,398 --> 00:00:50,440
DAVID J MALAN：好的。
DAVID J MALAN: All right.

3
00:00:50,439 --> 00:00:53,559
这是 CS50， 哈佛大学的一门介绍
This is CS50, Harvard University's introduction

4
00:00:53,560 --> 00:00:55,930
计算机行业
to the intellectual enterprises of computer science

5
00:00:55,929 --> 00:00:57,609
和编程艺术的一门课程。
and the art of programming.

6
00:00:57,609 --> 00:01:01,839
通常我们都会在这个美丽的桑德斯剧场里
And ordinarily we would all be here on campus in this beautiful Sanders

7
00:01:01,840 --> 00:01:02,800
一起看戏。
Theater together.

8
00:01:02,799 --> 00:01:05,559
不过今年有点不同，
This, of course, is a little bit different this year,

9
00:01:05,560 --> 00:01:07,375
出于很多原因。
for more than one reason.

10
00:01:07,375 --> 00:01:11,109
我们却在哈佛大学的勒布戏剧中心。
But we're here instead in the Loeb Drama Center at Harvard University.

11
00:01:11,109 --> 00:01:14,349
感谢我们的朋友与美国剧目剧团的合作，
Thanks to our friends in collaboration with the American Repertory Theater,

12
00:01:14,349 --> 00:01:19,606
我们有了这个新的空间，甚至包括后面的道具店等设施，
we have this new space, including even such amenities as a prop shop in back,

13
00:01:19,606 --> 00:01:21,939
我们一直在与一个非常有才华的团队合作
where we've been working with an amazingly talented team

14
00:01:21,939 --> 00:01:25,299
一起在暑假期期间为本学期和CS50做准备。
over the course of the summer to prepare for this semester and CS50.

15
00:01:25,299 --> 00:01:29,539
我敢说我们将有一些新的表现方式。
And so I daresay we'll have some new and improved demonstrations along the way.

16
00:01:29,540 --> 00:01:32,920
我们要感谢美国剧目剧团的地主之谊。
So our thanks to our hosts, the American Repertory Theater.

17
00:01:32,920 --> 00:01:35,440
现在我们想唤起一些回忆，至少，
Now we wanted to evoke memories, at least,

18
00:01:35,439 --> 00:01:38,289
关于校园本身的一些图片，特别是
or some imagery of the campus itself, particularly

19
00:01:38,290 --> 00:01:41,300
对于那些本学期无法来这里上课的同学。
for the many of you who could not be here in person this semester.

20
00:01:41,299 --> 00:01:45,039
因此，我们进入了哈佛档案馆，在他们的藏品中
And so we went into the Harvard Archives, where among their collections

21
00:01:45,040 --> 00:01:49,330
有一幅水彩画，是由哈佛大学研究生
was this watercolor painting, painted by a Harvard graduate student

22
00:01:49,329 --> 00:01:52,869
在200年前（1794年）绘制的。
over 200 years ago in the year 1794.

23
00:01:52,870 --> 00:01:56,230
乔纳森·费舍尔（Jonathan Fisher）坐在现在的哈佛广场（Harvard Square）上，
Jonathan Fisher, who sat in what is now Harvard Square,

24
00:01:56,230 --> 00:01:59,950
眺望着哈佛校园最早的建筑。
looking in on some of the earliest buildings of Harvard's campus.

25
00:01:59,950 --> 00:02:03,700
多亏了科技，我们选择这幅相对较小的
And thanks to technology, we took what is a relatively small watercolor

26
00:02:03,700 --> 00:02:07,420
由这位研究生大约在 200 年前画的水彩画，
that this graduate student painted some 200 years ago,

27
00:02:07,420 --> 00:02:10,720
装饰在勒布戏剧中心（Loeb Drama Center）的舞台上。
and now adorns the stage here in the Loeb Drama Center.

28
00:02:10,719 --> 00:02:14,319
所以如果不熟悉的话，我们左手边就是霍尔顿教堂，
So if unfamiliar, we have Holden Chapel here at left,

29
00:02:14,319 --> 00:02:17,919
右边是 Hollis Hall ，是哈佛的本科宿舍之一
Hollis Hall to its right, which is one of the undergraduate dormitories

30
00:02:17,919 --> 00:02:20,919
Harvard Hall 是其中的一间教室
in Harvard Yard, Harvard Hall, which is one of the classroom

31
00:02:20,919 --> 00:02:24,069
然后是 Massachusetts Hall （马萨诸塞大厅），
buildings on campus, and then Massachusetts Hall,

32
00:02:24,069 --> 00:02:29,719
第一年的学生和哈佛校长都在此居住和工作。
where both first years and Harvard's president live and work respectively.

33
00:02:29,719 --> 00:02:31,649
欢迎来到 CS50。
So welcome, then, to CS50.

34
00:02:31,650 --> 00:02:35,800
话说不久之前，
And I can say that not quite as long ago,

35
00:02:35,800 --> 00:02:38,620
也可以说还是很久以前，大约20年前，
but, nonetheless, feels rather long ago, some 20 years ago,

36
00:02:38,620 --> 00:02:39,910
我也在上这个课。
did I take the same class.

37
00:02:39,909 --> 00:02:44,529
但是正如你所知，
But as you know, I myself had some trepidation

38
00:02:44,530 --> 00:02:47,710
在学习 CS50 时，在学习计算机科学时，我也有一些担心。
when it came to studying CS50, when it came to studying computer science.

39
00:02:47,710 --> 00:02:49,720
因为这是一个我不了解的领域。
Because it was a very unfamiliar field.

40
00:02:49,719 --> 00:02:53,649
我上大学时选择了一条让我觉得舒服的发展路线
I had followed a path when I got to college of sticking within my comfort

41
00:02:53,650 --> 00:02:56,080
我以为我会主修政治学
zone, studying government early on, thinking I would major

42
00:02:56,080 --> 00:02:57,430
或者专心于政治。
or concentrate in government.

43
00:02:57,430 --> 00:03:02,080
刚开始我很紧张，直到我鼓起勇气坐在那里，
And it wasn't until I got up the nerve to shop, that is, sit in

44
00:03:02,080 --> 00:03:06,730
坐在 CS50 的课堂上，我意识到实际上这门课很有趣。
on this class CS50, that I realized that homework can actually be fun.

45
00:03:06,729 --> 00:03:10,839
我发现计算机科学和CS50并不是关于编程本身的，
And I found that computer science and CS50 is not about programming per se,

46
00:03:10,840 --> 00:03:14,660
但无论是我们，还是去上这门课的同学，
even though that's how many of us perceive it in high school,

47
00:03:14,659 --> 00:03:17,074
在高中时都是这么认为的。
whether it's us or our classmates taking the class.

48
00:03:17,074 --> 00:03:18,699
但计算机科学其实是关于如何解决问题的艺术。
But it really is about problem solving.

49
00:03:18,699 --> 00:03:21,159
因此它不仅非常适用到
And as such, it's so very applicable not only

50
00:03:21,159 --> 00:03:23,289
计算机科学和工程领域，
to computer science and the engineering fields,

51
00:03:23,289 --> 00:03:27,889
也适合于艺术，人文科学，社会科学，科学及其他领域。
but really to the arts, humanities, social sciences, sciences, and beyond.

52
00:03:27,889 --> 00:03:30,159
因此，如果你也对参加 CS50 这样的课程，
And so if you're feeling a little uncomfortable

53
00:03:30,159 --> 00:03:32,499
感到有点不舒服，
with the idea of taking a class like CS50,

54
00:03:32,500 --> 00:03:36,910
要知道每年几乎有近三分之二参加 CS50 的学生
know that almost every year, nearly two thirds of the students who take CS50

55
00:03:36,909 --> 00:03:40,009
之前从没学过计算机科学课程。
have never taken a computer science course before.

56
00:03:40,009 --> 00:03:45,219
因此，如果你环顾四周，其实大部分同学
So if you look up, down, left, right, right now, odds are more than many

57
00:03:45,219 --> 00:03:49,719
跟你的情况一样。
of the classmates joining you here today are in a very similar position.

58
00:03:49,719 --> 00:03:52,269
你们可以彼此陪伴，一起学习。
You're indeed in very good company.

59
00:03:52,270 --> 00:03:56,683
在课程大纲中，我们强调 CS50 中最重要的一点，
And what's ultimately important in CS50 too, we emphasize, as in the syllabus,

60
00:03:56,682 --> 00:03:59,349
不是在过个过程中你跟别的同学比较
that what ultimately matters in this course is not so much where

61
00:03:59,349 --> 00:04:01,749
而是在结束之时
you end up relative to your classmates, but where you end

62
00:04:01,750 --> 00:04:04,359
跟你自己比较。
up relative to yourself when you began.

63
00:04:04,360 --> 00:04:07,242
确实，考虑到你当前所在的水平，也许
Indeed, taking into account where you currently are, perhaps

64
00:04:07,241 --> 00:04:08,949
你没有基础知识，
with no prior background, and considering

65
00:04:08,949 --> 00:04:11,589
你将在短短的三个月左右的时间内到达
where you will be in just three or so months

66
00:04:11,590 --> 00:04:14,510
最终让自己满意的标准。
is ultimately meant to be the measure of your own success.

67
00:04:14,509 --> 00:04:19,028
为此，我们就从一些过去的小玩意儿里，
And so toward that end, we'll start off this class programming

68
00:04:19,028 --> 00:04:20,889
开始这个课程。
a little something from yesteryear.

69
00:04:20,889 --> 00:04:23,349
这里有一张超级马里奥的图片，还有这些角色要
An image here of Super Mario Brothers and the pyramid

70
00:04:23,350 --> 00:04:24,910
跨过的金子塔砖块。
that the character has to ascend.

71
00:04:24,910 --> 00:04:28,780
我们将使用文本重新创建游戏的一部分，
We'll recreate a portion of this game, albeit using text--

72
00:04:28,779 --> 00:04:32,919
也就是所谓的 ASCII 艺术- 但我们将在课程的
otherwise known as ASCII art-- but we'll do that in just the course's second

73
00:04:32,920 --> 00:04:33,795
第二周完成。
or so week.

74
00:04:33,795 --> 00:04:35,920
这将是你编写的第一个程序。
So this will be among the first programs you write.

75
00:04:35,920 --> 00:04:39,070
然后快速前进，只是几个问题集或编程作业
And then fast forward just several problem sets or programming

76
00:04:39,069 --> 00:04:41,949
在几个星期之后，
assignments later, or several weeks later, too,

77
00:04:41,949 --> 00:04:44,949
你将建立一个在互联网上运行的应用程序，
and you'll be building what we call CS50 Finance, a web

78
00:04:44,949 --> 00:04:48,249
我们称之为 CS50 金融，
application of your very own that runs on the internet,

79
00:04:48,250 --> 00:04:52,250
从第三方服务中抓取近乎实时的股票报价，
pulling down nearly real-time stock quotes from a third party service,

80
00:04:52,250 --> 00:04:57,219
允许你的用户登录注册，以及买卖股票，
allowing your own users to log in and register to buy and sell stocks,

81
00:04:57,220 --> 00:04:59,260
或者说使用虚拟货币。
so to speak, using virtual currency.

82
00:04:59,259 --> 00:05:02,439
因此，在这几个月的课程中，
So over the course of the class's several months,

83
00:05:02,439 --> 00:05:05,334
你将真正地从在马里奥里建造一面金字塔墙
will you go, truly, from building a pyramid in Mario

84
00:05:05,334 --> 00:05:08,049
到构建自己的 Web 应用程序。
to building your very own web application and more,

85
00:05:08,050 --> 00:05:10,660
然后是本课程的最终经验
followed by the course's capstone experience, which

86
00:05:10,660 --> 00:05:13,450
这将是你的最终项目。
will be your very own final project.

87
00:05:13,449 --> 00:05:15,699
但是计算机科学到底是什么？
But what exactly is computer science?

88
00:05:15,699 --> 00:05:19,599
我们认为在第 0 周，即课程的第一周，我们要做的是
What we thought we would do in this week zero, the very first week of the class,

89
00:05:19,600 --> 00:05:23,200
考虑到底什么叫解决问题。
is consider exactly what it means to solve problems.

90
00:05:23,199 --> 00:05:26,079
要我说这就是计算机科学。
And let me propose that this is computer science.

91
00:05:26,079 --> 00:05:27,999
就是解决问题。
This is problem solving.

92
00:05:28,000 --> 00:05:30,370
你有一些输入，就是你关心的你想解决的问题
You have some input, which is the problem you care about

93
00:05:30,370 --> 00:05:33,020
你关心这个问题的解决方案，
that you want to solve, and you care about the solution to that problem,

94
00:05:33,019 --> 00:05:34,269
也就是所谓的输出。
which is the so-called output.

95
00:05:34,269 --> 00:05:37,659
在输入和输出之间是这个黑盒
And in between that input and output is this black box

96
00:05:37,660 --> 00:05:41,230
里面似乎有一种魔力，
of sorts, inside of which is the magic that happens,

97
00:05:41,230 --> 00:05:45,310
一种最终让你能够利用和强迫计算机
the magic that you'll eventually be able to harness and compel computers

98
00:05:45,310 --> 00:05:46,600
去为你解决问题的魔力。
to solve problems for you.

99
00:05:46,600 --> 00:05:50,800
最终，黑盒内部将是你编写的代码。
Inside of that black box, ultimately, is going to be the code that you write.

100
00:05:50,800 --> 00:05:53,380
但我们要开始这样做，我们都
But for us to begin doing that, we all kind of

101
00:05:53,379 --> 00:05:56,929
需要就如何表示这些输入和输出达成一致。
need to agree on how we're going to represent these inputs and outputs.

102
00:05:56,930 --> 00:05:59,755
我们所有人都必须说一种共同的语言。
We all kind of have to speak a common language, so to speak.

103
00:05:59,754 --> 00:06:02,629
可以这么说，我们需要就如何表示这些输入有统一的方法。
And so we need to agree how these inputs are going to be represented.

104
00:06:02,629 --> 00:06:05,049
那么，我们通常如何表示信息呢？
So how might we typically represent information?

105
00:06:05,050 --> 00:06:08,230
好吧，也许最简单的事就是在第一节课的时候
Well, maybe the simplest thing to do at the very first class, whether we're

106
00:06:08,230 --> 00:06:10,450
无论是在线上还是在现场
online or in person, is to take attendance

107
00:06:10,449 --> 00:06:13,519
都要进行考勤，统计一下人数。
or to count the number of people in the room.

108
00:06:13,519 --> 00:06:16,339
你可能会在手上做这种老派的风格，
And so you might do this old school style on your hands

109
00:06:16,339 --> 00:06:18,729
举起一根手指
so as to represent every person in a room

110
00:06:18,730 --> 00:06:21,100
代表房间里的一个人。
with just a finger raised on your hands.

111
00:06:21,100 --> 00:06:23,260
所以我们用手指
So how we might represent information boils down

112
00:06:23,259 --> 00:06:25,879
表示简单的数字信息。
to very simple digits on your hand.

113
00:06:25,879 --> 00:06:28,767
当然，仅用手不能指望你能数到很多数字。
Of course, you can't count very high with just this hand.

114
00:06:28,767 --> 00:06:31,059
实际上，我们正在做的事有一个很好的老派的形容词，
And there's actually a fancy word for what we're doing,

115
00:06:31,060 --> 00:06:35,020
那就是单数记法 ，一根手指代表一个人，
old school here, and that's unary notation-- uno, implying one,

116
00:06:35,019 --> 00:06:36,919
一根手指向上或向下。
or one finger being up or down.

117
00:06:36,920 --> 00:06:39,128
这样看来，你最多可以数五个人。
And so you can count, it would seem, as high as five.

118
00:06:39,127 --> 00:06:40,919
当然，如果我拿出第二手，
And of course, if I bring in a second hand,

119
00:06:40,920 --> 00:06:43,960
我可以数到十，然后事情就变难了。
I can go as high as 10, and then things get a little more difficult.

120
00:06:43,959 --> 00:06:45,939
但这是一个代表信息的系统
But it's a system for representing information

121
00:06:45,939 --> 00:06:49,329
当我们都是小孩的时候经常会使用它。
and it's fairly universal, certainly when we're all quite young.

122
00:06:49,329 --> 00:06:52,959
但是现在我们更倾向于使用更有用的系统。
But you and I tend to use a more useful system.

123
00:06:52,959 --> 00:06:55,869
不只是手上的数字，还有其他种类的数字。
Not just digits on the hand, but other sorts of digits.

124
00:06:55,870 --> 00:06:58,780
也就是你我都知道的十进制数字。
Namely, the decimal digits that you and I know.

125
00:06:58,779 --> 00:07:02,036
所以，这些数字在技术上更多地被称为基数 10 --
So the numbers that are otherwise more technically called base 10--

126
00:07:02,036 --> 00:07:04,119
这只是一种花哨的表述
and that's just a fancy way of describing the fact

127
00:07:04,120 --> 00:07:08,490
我们作为人类实际上通常会使用 10 位数字。
that there's 10 digits that you and I as humans really tend to use typically.

128
00:07:08,490 --> 00:07:10,990
当然，这些数字是从 0 到 9，
Those digits, of course, are zero through nine,

129
00:07:10,990 --> 00:07:14,710
利用这几个数字，我们可以摆出 0
and using these several digits, we can pose numbers like zero

130
00:07:14,709 --> 00:07:18,219
到 9 的数字，还有 10 和 11、12 这样的数字
through nine, but also 10 and 11 and 12, and as high up

131
00:07:18,220 --> 00:07:21,220
想多少有多少。
as we want to go by using multiple digits still.

132
00:07:21,220 --> 00:07:26,140
但是计算机与我们说的语言并不完全相同。
But computers don't really speak the same language as us.

133
00:07:26,139 --> 00:07:29,569
从某种意义上讲，它们比我们人类要简单得多，
They're, in some sense, much simpler than we humans,

134
00:07:29,569 --> 00:07:33,759
即使它们看起来是如此复杂，也如此之快。
even though they seem so complicated or so sophisticated and certainly so fast.

135
00:07:33,759 --> 00:07:36,429
归根结底，这些都是人造设备，
At the end of the day, these are all human-made devices,

136
00:07:36,430 --> 00:07:39,230
而且它们的核心相对简单。
and they're relatively simple at their core.

137
00:07:39,230 --> 00:07:41,770
实际上，即使你不太知道自己在说什么，
In fact, even if you don't quite know what you're saying,

138
00:07:41,769 --> 00:07:43,869
但你至少听说过这种情况，
but you've at least heard this to be the case,

139
00:07:43,870 --> 00:07:47,920
你知道计算机说的是什么语言吗？
what language do you understand computers to speak?

140
00:07:47,920 --> 00:07:52,120
如果不是我们的语言，那计算机会说什么语言，
What language do computers speak, if not the system that you and I use

141
00:07:52,120 --> 00:07:54,520
0 到 9 或十进制？
of zeros through nines or decimal?

142
00:07:54,519 --> 00:07:57,279
Brian，让我们看看谁能回答这个问题？
Brian, could we see who might answer this?

143
00:07:57,279 --> 00:08:00,339
据你所知，计算机使用什么语言系统？
What system do computers use, so far as you've heard,

144
00:08:00,339 --> 00:08:02,799
不论你之前是否参加过CS课。
whether or not you've taken a CS class before?

145
00:08:02,800 --> 00:08:04,305
Keith，我们可以先请你回答吗？
Keith, can we go to you first?

146
00:08:04,305 --> 00:08:04,930
听众：好的。
AUDIENCE: Yeah.

147
00:08:04,930 --> 00:08:06,263
计算机使用二进制。
The computers use binary.

148
00:08:06,262 --> 00:08:07,179
DAVID J MALAN：二进制。
DAVID J MALAN: Binary.

149
00:08:07,180 --> 00:08:08,638
你能详细说明一下吗？
And can you elaborate a little bit?

150
00:08:08,637 --> 00:08:10,089
你所说的二进制是什么意思？
What do you mean by binary?

151
00:08:10,089 --> 00:08:11,379
听众：是零和一。
AUDIENCE: It's zeros and ones.

152
00:08:11,379 --> 00:08:13,797
所以，就像，当我们使用 0 到 9 表示十进制的基数，
So, like, while we use zero through nine for base 10,

153
00:08:13,798 --> 00:08:15,340
他们使用 0 到 1 作为二进制的基数。
they use zero through one for base 2.

154
00:08:15,339 --> 00:08:16,547
DAVID J MALAN：好的，非常正确。
DAVID J MALAN: Yeah, exactly.

155
00:08:16,548 --> 00:08:19,630
因此，计算机使用所谓的二进制系统，表示两个。
So computers use the so-called binary system, bi implying two.

156
00:08:19,629 --> 00:08:23,139
实际上，正如 Keith 所指出的那样，它们仅使用 0 和 1，两个数字。
And they, indeed, only use, as Keith notes, zero and one, two digits.

157
00:08:23,139 --> 00:08:25,479
所以从一方面看，这实际上是令人鼓舞的，
So on the one hand, this is actually pretty encouraging,

158
00:08:25,480 --> 00:08:28,420
你想想看，如果我们只使用两个数字，
because, wow, this is actually a pretty simple system if we're only

159
00:08:28,420 --> 00:08:29,830
这实际上是一个非常简单的系统。
using two of these digits.

160
00:08:29,829 --> 00:08:33,369
但是，当然，如果你只有两个数，
But, of course, if you only have two digits,

161
00:08:33,370 --> 00:08:37,120
我们将如何表示 2 或 3 或 4
how are we going to represent the number two or three or four

162
00:08:37,120 --> 00:08:38,830
还是更大的数字？
or any much larger number?

163
00:08:38,830 --> 00:08:40,970
这看起来像是倒退了。
It would almost seem like a step backwards.

164
00:08:40,970 --> 00:08:41,980
但实际上不是。
But it isn't actually.

165
00:08:41,980 --> 00:08:44,710
而事实证明，这个所谓的系统，或者说以 2 为基数
And it turns out that this so-called system, or base 2--

166
00:08:44,710 --> 00:08:47,560
因为只有两个数字，
two because there's two digits in the vocabulary, otherwise known,

167
00:08:47,559 --> 00:08:48,999
正如 Keith 所说，二进制
as Keith says, as binary--

168
00:08:49,000 --> 00:08:52,600
仅使用 0 和 1，这里还有很多其他命名方式
uses just zeros and ones, and it turns out there's other nomenclature here

169
00:08:52,600 --> 00:08:53,500
我们先不管。
we can toss out.

170
00:08:53,500 --> 00:08:56,080
这些零和一被称为比特。
These zeros and ones are otherwise known as bits.

171
00:08:56,080 --> 00:09:00,070
实际上，比特仅来自两个数字，即二进制数字。
And bits actually derive from just two words, binary digits.

172
00:09:00,070 --> 00:09:02,595
二进制，意味着两种可能性，数字，
Binary, implying two possibilities, digits,

173
00:09:02,595 --> 00:09:03,970
只是屏幕上的符号。
just being symbols on the screen.

174
00:09:03,970 --> 00:09:05,845
因此二进制数字，也就是所谓的比特。
So binary digits, or otherwise known as bits.

175
00:09:05,845 --> 00:09:09,220
而计算机用这些叫做比特的东西来表示二进制。
And computers speak binary using these things called bits.

176
00:09:09,220 --> 00:09:11,350
但这意味着什么，为什么会这样呢？
But what does that mean and why is it the case?

177
00:09:11,350 --> 00:09:13,480
就像，他们为什么不在几十年前就发明计算机
Like, why didn't they invent computers decades ago

178
00:09:13,480 --> 00:09:15,580
只使用 0 到 9，而不是
that just use zero through nine, rather than

179
00:09:15,580 --> 00:09:19,330
想出一个全新的系统让我们去费劲思考，更不要说讨论了？
come up with a whole new system for us to think about, let alone talk about?

180
00:09:19,330 --> 00:09:22,480
那么，归根结底，计算机正在使用什么作为输入？
Well, at the end of the day, computers are using what as their input?

181
00:09:22,480 --> 00:09:24,100
其实只是电。
Really just electricity.

182
00:09:24,100 --> 00:09:28,030
也许我们所有人每天或每隔几天都会对我们的笔记本电脑、台式机或手机
Probably the only thing all of us do every day or every couple of days

183
00:09:28,029 --> 00:09:32,559
做的唯一一件事，就是确保它插着电源，
with our laptop or desktop or phone is either make sure it's still plugged in,

184
00:09:32,559 --> 00:09:34,779
或者给它插上电源，以便为它充电。
or to plug it in so as to charge it.

185
00:09:34,779 --> 00:09:36,759
因此，我们设备的唯一的物理输入
So the only physical input to our devices

186
00:09:36,759 --> 00:09:38,641
就是某种形式的电。
these days is electricity in some form.

187
00:09:38,642 --> 00:09:41,350
我们不必细说什么是电，
And we don't have to get into the nuances of what electricity is,

188
00:09:41,350 --> 00:09:45,610
但我认为它是关于电子流入设备，从而给它充电。
but I think it's about electrons flowing into the device so as to charge it.

189
00:09:45,610 --> 00:09:48,310
因此，对于我们来说，只要知道有一些物理上的输入到我们使用的电脑和手机
So it suffices for our purposes to know that there's

190
00:09:48,309 --> 00:09:51,789
这些设备就足够了。
some physical input to the device, these computers and phones that we use.

191
00:09:51,789 --> 00:09:52,819
就是这样。
But that's it.

192
00:09:52,820 --> 00:09:56,410
因此，如果我们利用这些电力，也许我们
And so if we harness this electricity, maybe we

193
00:09:56,409 --> 00:09:58,509
可以用它来表示信息。
can start to represent information with it.

194
00:09:58,509 --> 00:10:01,899
例如，这是一个灯泡，这是剧院里的旧鬼灯
For instance, here is a light bulb, this old ghost light in the theater here

195
00:10:01,899 --> 00:10:03,279
目前是关闭的。
that's currently off.

196
00:10:03,279 --> 00:10:05,319
但是它具有打开的能力。
But it has the ability to turn on.

197
00:10:05,320 --> 00:10:08,750
我们只需要插上电源或打开开关就可以。
We just need to plug it in or throw on a switch.

198
00:10:08,750 --> 00:10:11,470
如果是这样，
And if that's the case, what's really quite

199
00:10:11,470 --> 00:10:14,013
我们就使用这个灯来打个比方
compelling about the metaphor of using lights

200
00:10:14,013 --> 00:10:16,180
就是这个灯泡，现在是关闭的
is that right now, this light bulb is currently off,

201
00:10:16,179 --> 00:10:18,099
但只要我让电流流动
but as soon as I allow electricity to flow

202
00:10:18,100 --> 00:10:22,510
例如通过插上电源或打开开关，你看，亮了。
as by plugging it in or maybe throwing a switch, now it's, of course, on.

203
00:10:22,509 --> 00:10:25,569
如果我拔下电源插头或关上开关，灯就关了。
And if I unplug it or throw the switch again, it's off.

204
00:10:25,570 --> 00:10:28,150
或者，如果我重新插上，它就会打开。
Or if I plug it back in, it's on.

205
00:10:28,149 --> 00:10:30,999
而这个非常简单的想法的含义
And the implication of this very simple idea

206
00:10:31,000 --> 00:10:34,569
是我们可以使用一个物理设备，例如单个灯泡，
is that we can take a physical device, like a single light bulb,

207
00:10:34,570 --> 00:10:38,110
通过插上或拔下它，我们可以表示信息。
and by plugging it in or unplugging it, we can represent information.

208
00:10:38,110 --> 00:10:39,170
我刚才做了什么？
What did I just do?

209
00:10:39,169 --> 00:10:41,649
我来表示灯泡是开还是关，
I represented the light bulb being off or on,

210
00:10:41,649 --> 00:10:43,609
但我们也可以把关和开叫做其他东西。
but we can just call off and on something else.

211
00:10:43,610 --> 00:10:46,250
我们可以称它们为零和一。
We can call them zeros and ones.

212
00:10:46,250 --> 00:10:48,290
这确实是一个对我们发明计算机的启发
And so this really is the germ of an idea

213
00:10:48,289 --> 00:10:52,549
以及随之而来的二进制系统的使用。
that gave us computers, and with it, their use of the binary system.

214
00:10:52,549 --> 00:10:55,849
如果最终仅有的物理输入是电流，
If, at the end of the day, all they have is physical input as electricity,

215
00:10:55,850 --> 00:10:59,800
那就让我们使用电流来控制和跟踪信息。
well, let's just use that to harness and keep track of information.

216
00:10:59,799 --> 00:11:03,239
当我们想要表示 1 时，让我们给它一点电流，
Let's store a little bit of electricity when we want to represent a one,

217
00:11:03,240 --> 00:11:05,870
当我们想要表示一个 0
and let's let go of that electricity in some sense

218
00:11:05,870 --> 00:11:09,060
时就把电流关上。
when we want to represent a zero instead.

219
00:11:09,059 --> 00:11:12,019
因此，计算机的输入非常简单，
And so because the input to computers is so simple,

220
00:11:12,019 --> 00:11:15,619
我们仅仅使用 0 和 1。
thus gives us the zeros and ones that we now use.

221
00:11:15,620 --> 00:11:18,050
但是，我们似乎为自己制造了一个问题。
But we seem to have created a problem for ourselves.

222
00:11:18,049 --> 00:11:22,399
如果我们只有一个灯泡或一个开关，如果它不亮，
If we only have one light bulb or one switch, if it's off,

223
00:11:22,399 --> 00:11:25,759
它可能为 0 ，如果为开，则可能为 1，
it might be zero, if it's on, it might be a one,

224
00:11:25,759 --> 00:11:28,219
但是我怎么表示一个比 1 大的数字呢？
but how do I count higher than one?

225
00:11:28,220 --> 00:11:30,380
这个问题从根本上仍然存在。
That problem still fundamentally remains.

226
00:11:30,379 --> 00:11:32,849
好吧，我当然可以使用更多的灯泡。
Well, I could, of course, use more light bulbs.

227
00:11:32,850 --> 00:11:33,920
所以让我问一下这个问题。
So let me ask this.

228
00:11:33,919 --> 00:11:38,179
如果我们要使用三个灯泡，我们最多可以表示几？
If we were to use three light bulbs, how high could we count?

229
00:11:38,179 --> 00:11:42,739
因此，使用一个灯泡，我们可以从表示 0 到 1 两种可能性。
So with one light bulb, we can count from zero to one, two possibilities.

230
00:11:42,740 --> 00:11:45,170
但是使用三个灯泡，我们最多可以表示几？
But with three light bulbs, how high could we count?

231
00:11:45,169 --> 00:11:47,779
让我继续在线问这个问题。
Let me go ahead and ask this question here on the screen.

232
00:11:47,779 --> 00:11:52,729
很快你就会看到这个特殊的问题，
In just a moment you'll see on your side this particular question via which

233
00:11:52,730 --> 00:11:56,150
你可以在设备上做出回应。
you can respond on your device.

234
00:11:56,149 --> 00:11:59,819
三个灯泡最多可以表示几？
How high can you count with three light bulbs?

235
00:11:59,820 --> 00:12:05,130
我给你三个灯泡，而不是一个灯泡，每个灯泡都可以打开或关闭。
So instead of one, I give you three, each of which can be on or off.

236
00:12:05,129 --> 00:12:07,699
最多可以表示几呢？
How high can we, perhaps, count?

237
00:12:07,700 --> 00:12:11,010
你将在这个屏幕上看到答案。
So you'll see on the screen here the answers coming in.

238
00:12:11,009 --> 00:12:14,359
有很多人在思考，60％ 人以上回答是 8
We have a lot of folks thinking, 60-plus percent that it's

239
00:12:14,360 --> 00:12:16,523
8 是你可以表示的最大数字。
eight is the highest you can count.

240
00:12:16,523 --> 00:12:18,440
你们中的很多人都认为是 7，有些人
A lot of you think it's seven, and some of you

241
00:12:18,440 --> 00:12:20,960
也有人认为是 3 或者 2。
also think it might be three or two.

242
00:12:20,960 --> 00:12:23,790
这些答案都很有趣。
So that's actually an interesting range of answers.

243
00:12:23,789 --> 00:12:25,979
让我们看看实际可能是什么情况。
And let's see what might actually be the case.

244
00:12:25,980 --> 00:12:29,990
好吧，让我在这里减少到三个灯泡，关闭所有的
Well, let me cut back over to three actual light bulbs here, all of which

245
00:12:29,990 --> 00:12:30,680
灯泡。
are off.

246
00:12:30,679 --> 00:12:33,619
从最简单的开始，我认为，如果我们都打开这些灯泡，
And most naively, I think, if we were to turn these light bulbs on,

247
00:12:33,620 --> 00:12:36,680
如果它们当前代表零，显然，我可以将其打开
if they currently represent zero, obviously, I could turn one on

248
00:12:36,679 --> 00:12:37,759
我们可以认为它表示 1。
and we could call it one.

249
00:12:37,759 --> 00:12:41,989
然后我可以打开第二个，它表示 2，打开第三个，
Then I could turn the second one on and call it two, turn on the third one,

250
00:12:41,990 --> 00:12:44,963
现在三个都启用了，我们可以说现在表示 3。
and now with all three on, we could say now we're representing three.

251
00:12:44,962 --> 00:12:47,629
但这还不是最聪明的做法，如果我们最高
But we're not really being clever enough just yet, if we're only

252
00:12:47,629 --> 00:12:49,429
只是到 3 的话。
counting as high as three.

253
00:12:49,429 --> 00:12:52,339
因为在这个方法中，我只是从左到右打开它们。
Because I'm just turning them on, in this story, left to right.

254
00:12:52,340 --> 00:12:54,230
但是，如果我们更加进一步呢？
But what if we were a little more clever?

255
00:12:54,230 --> 00:12:57,740
也许我们将它们从右到左打开，或者也许我们对它们进行
Maybe we turn them on right to left, or maybe we kind of permuted them

256
00:12:57,740 --> 00:12:58,940
不同的方向的排列？
in different directions?

257
00:12:58,940 --> 00:13:01,790
也就是说，我们不仅考虑灯泡的个数
That is, we took into account not just how many bulbs are on

258
00:13:01,789 --> 00:13:06,349
或有多少根手指，而是
or how many fingers are in the air, but rather the pattern of on

259
00:13:06,350 --> 00:13:08,523
打开和关上的灯泡的排列模式。
and off light bulbs that we've created.

260
00:13:08,523 --> 00:13:09,690
那就让我们来数一下。
So let's just count this up.

261
00:13:09,690 --> 00:13:12,680
我们来有规律地打开一些灯泡，
So let me somewhat systematically turn some of these bulbs on here,

262
00:13:12,679 --> 00:13:13,999
尽管它们是虚拟的。
albeit virtually.

263
00:13:14,000 --> 00:13:18,147
现在可能表示 1 ，现在可能表示 2，现在可能表示 2。
Here might be one, here might be two, here might be three.

264
00:13:18,147 --> 00:13:19,980
但是那样这个事情就结束了。
But then we're kind of done with that story.

265
00:13:19,980 --> 00:13:21,570
那么我们如何才能做得更好呢？
So how might we do it a little better?

266
00:13:21,570 --> 00:13:23,060
好吧，让我们从 0 开始。
Well, let's start again at zero.

267
00:13:23,059 --> 00:13:24,529
这表示 1。
Here might be one.

268
00:13:24,529 --> 00:13:26,479
我们为什么不用这个表示 2 呢？
Why don't we call this two?

269
00:13:26,480 --> 00:13:28,670
为什么不用这个表示 3 呢？
Why don't we call this three?

270
00:13:28,669 --> 00:13:30,769
为什么不用这个表示 4 呢？
Why don't we call this four?

271
00:13:30,769 --> 00:13:35,179
这是 5，6 和 7。
Call this five, this six, and this seven.

272
00:13:35,179 --> 00:13:38,029
如果你现在还看不太懂这个模式，没关系，
Now, it's fine if you didn't quite see what pattern I was following,

273
00:13:38,029 --> 00:13:42,799
但请你相信我，这是一种独特的灯泡模式，
but take my word for it that that was a unique pattern of light bulbs,

274
00:13:42,799 --> 00:13:44,299
一共八次。
eight total times.

275
00:13:44,299 --> 00:13:47,494
我从关闭，关闭，关闭，然后打开，打开，打开。
I started at off, off, off, and I ended at on, on, on.

276
00:13:47,495 --> 00:13:49,370
但是一路下来，3 个灯泡，确实是 8。
But along the way, there were, indeed, eight.

277
00:13:49,370 --> 00:13:50,573
但是我最多能数多少呢？
But how high can I count?

278
00:13:50,572 --> 00:13:53,239
嗯，这取决于你要从哪个数字开始数，
Well, it kind of depends on what number you start counting from,

279
00:13:53,240 --> 00:13:57,560
就像我们到目前为止所做的那样，计算机科学家一直在做。
and just as we thus far have been doing, computer scientists do all the time.

280
00:13:57,559 --> 00:13:59,899
计算机科学家，以及计算机程序，
Computer scientists and, in turn, computer programs,

281
00:13:59,899 --> 00:14:03,019
通常从零开始计数，只是因为它有意义
typically start counting from zero, just because it makes sense

282
00:14:03,019 --> 00:14:05,899
因为当一切都关闭时，你最好将其称为 0。
because when everything is off, you might as well call that zero.

283
00:14:05,899 --> 00:14:09,799
因此，如果我们从零开始计数，那么就有八种可能的模式
So if we start counting at zero, and we have eight possible patterns

284
00:14:09,799 --> 00:14:12,319
我们只是从图片上看到了
that we just saw pictorially, well, that would

285
00:14:12,320 --> 00:14:14,330
让我们数到七。
allow us to count as high as seven.

286
00:14:14,330 --> 00:14:17,450
所以从零到七个，所以七是最大的
So from zero to seven, so seven is the highest

287
00:14:17,450 --> 00:14:19,320
我们可以用三个灯泡数。
we can count with three light bulbs.

288
00:14:19,320 --> 00:14:22,760
正确答案是 7 ，有36％
So those of you who propose that seven was the answer, 36% of you

289
00:14:22,759 --> 00:14:24,409
的回答是正确的。
were indeed correct.

290
00:14:24,409 --> 00:14:29,509
如果你假设我们从 1 开始算，那么 87% 的人回答 8 是对的，
57% of you who said eight are correct if you assume we start counting at one,

291
00:14:29,509 --> 00:14:30,359
很好。
and that's fine.

292
00:14:30,360 --> 00:14:33,388
但是至少在现在的计算机世界中，按照惯例，
But at least in the computing world now, we'll generally, by convention,

293
00:14:33,388 --> 00:14:34,430
从零开始计数。
start counting from zero.

294
00:14:34,429 --> 00:14:37,659
但是你说的很对，有八种这样的可能性。
But you are correct to say that there's eight such possibilities.

295
00:14:37,659 --> 00:14:39,409
好吧，这很好
All right, well, this is all fine and good

296
00:14:39,409 --> 00:14:41,459
用灯泡的模式来代表事物。
to represent things with patterns of light bulbs.

297
00:14:41,460 --> 00:14:44,270
但我们是如何从计算机
But how do we actually now get to the zeros and ones

298
00:14:44,269 --> 00:14:45,919
获取实际的零和一呢？
that a computer is actually using?

299
00:14:45,919 --> 00:14:48,649
计算机的内部到底是什么，
Because what's inside of a computer, at the end of the day,

300
00:14:48,649 --> 00:14:52,069
不是灯泡，而是非常小，微小的开关，
are not light bulbs but tiny, tiny little switches,

301
00:14:52,070 --> 00:14:57,320
数以百万计的小开关，它们可以是打开表示 1 ，关闭表示 0。
millions of little switches that can either be on, or one, or off, or zero.

302
00:14:57,320 --> 00:14:59,780
这些开关被称为晶体管。
Those switches happen to be called transistors.

303
00:14:59,779 --> 00:15:02,347
如今，计算机的确有数百万
And these days computers do have millions

304
00:15:02,347 --> 00:15:04,889
的晶体管可以以不同的模式开启和关闭。
of these things that can be on and off in different patterns.

305
00:15:04,889 --> 00:15:08,029
因此，如果你有能力打开和关闭所有这些开关，那么，
So if you have the ability to turn on and off all of these switches, well,

306
00:15:08,029 --> 00:15:13,999
在使用这些开关时，我们所有人都可以在表示形式上达成共识吗？
what can we all agree on representation when it comes to using those switches?

307
00:15:14,000 --> 00:15:16,250
我们将如何用它们代表信息？
How will we represent information with them?

308
00:15:16,250 --> 00:15:19,700
好吧，美妙的是，我们真的不需要很努力地去思考
Well, wonderfully, we don't really need to think very hard

309
00:15:19,700 --> 00:15:22,700
或者克服我们孩童般的舒适。
or go past our very comfortable roots as kids.

310
00:15:22,700 --> 00:15:25,320
如果我们暂时考虑的不只是零和一，
If we consider for a moment not just zero and one,

311
00:15:25,320 --> 00:15:27,320
而是整个十进制系统（从零到九）
but the whole decimal system, zero through nine,

312
00:15:27,320 --> 00:15:30,000
你们和我都从今天开始。
that you and I all started our day with today.

313
00:15:30,000 --> 00:15:31,310
这个系统是如何工作的？
How does that system work?

314
00:15:31,309 --> 00:15:34,339
嗯，屏幕上的数字是 123。
Well, here on the screen is 123.

315
00:15:34,340 --> 00:15:37,130
所以，你可能会认为是一百二十三，
So yes, you're probably thinking that's one hundred twenty three,

316
00:15:37,129 --> 00:15:38,179
但不完全是。
but not quite.

317
00:15:38,179 --> 00:15:40,279
我在屏幕上显示的只是一种符号的模式
All I've shown on the screen is a pattern

318
00:15:40,279 --> 00:15:43,009
一百二十三， 或者三个数字。
of symbols, 123, or three digits.

319
00:15:43,009 --> 00:15:45,816
而且我们所有人可能都只是本能地在说，
And all of us probably are instinctively just saying, obviously,

320
00:15:45,817 --> 00:15:47,150
这是一百二十三。
it's a hundred and twenty three.

321
00:15:47,149 --> 00:15:49,191
但是可能这么多年来你一直在想
But it's probably been years since you considered

322
00:15:49,192 --> 00:15:51,340
为什么是一百二十三。
why it is one hundred twenty three.

323
00:15:51,340 --> 00:15:55,180
好吧，让我们考虑一下这些数字或符号分别代表什么。
Well, let's consider what each of these digits or symbols represents.

324
00:15:55,179 --> 00:15:58,599
如果你跟我一样，是在长大后才知道最右边的数字是
If you're like me, you grew up learning that the rightmost digit is the ones

325
00:15:58,600 --> 00:16:03,230
个位，中间是十位，左边是百位。
place, the middle is the tens place, the left one is the hundreds place.

326
00:16:03,230 --> 00:16:06,250
那么，我们如何从这三个符号或数字123，
And so how do we get from these three symbols or digits,

327
00:16:06,250 --> 00:16:09,970
到我们所知道的数学概念的一百二十三呢？
123, to the mathematical idea we know as one hundred twenty three?

328
00:16:09,970 --> 00:16:14,860
好吧，我们所有人其实都在一瞬间计算了 100 乘以 1， 加上 10 乘以 2
Well, all of us instantaneously, these days, did 100 times 1 plus 10 times

329
00:16:14,860 --> 00:16:19,690
加上 1 乘以 3，就是 100 + 20 + 3，
2 plus 1 times 3, which, of course, is just 100 plus 20 plus 3,

330
00:16:19,690 --> 00:16:23,290
我们都知道结果是数学上的 123
or the mathematical value we all know as one hundred twenty three.

331
00:16:23,289 --> 00:16:26,379
所以有点循环论证的意思，但只是想提醒大家，
So a bit of a circular argument, but just to remind us

332
00:16:26,379 --> 00:16:30,279
我们是如何从 "123" 到一百二十三的。
how we got from 123 to one hundred twenty three.

333
00:16:30,279 --> 00:16:34,299
好吧，事实证明，在计算机世界中，系统
Well, it turns out that in the world of computers, the system

334
00:16:34,299 --> 00:16:38,239
使用的方法是完全相同的。
they use is exactly, fundamentally the same.

335
00:16:38,240 --> 00:16:41,680
唯一的区别是计算机只能访问零和一，
The only difference is that computers only have access to zeros and ones,

336
00:16:41,679 --> 00:16:43,149
不是零到九。
not zeros through nines.

337
00:16:43,149 --> 00:16:46,989
所以，如果我们现在抽象地考虑，只是在这里表示三个可能的数字，
So if we consider now in the abstract, just three possible digits

338
00:16:46,990 --> 00:16:51,610
我们先考虑一下，为什么这些列是代表
represented here, let's consider for a moment why those columns are places

339
00:16:51,610 --> 00:16:54,923
1、10、100，等等依此类推。
where one, 10, and 100, and so forth.

340
00:16:54,923 --> 00:16:56,090
好吧，为什么会这样呢？
Well, why was that the case?

341
00:16:56,090 --> 00:16:58,048
好吧，事实上，有一种模式
Well, there was a pattern, in fact, and it just

342
00:16:58,048 --> 00:16:59,900
与指数或幂有关。
has to do with exponents or powers.

343
00:16:59,899 --> 00:17:03,489
所以，最右边的一列，技术上，如果我们真的深入细节的话
So the rightmost column, technically, if we really get into the weeds,

344
00:17:03,490 --> 00:17:06,069
是 10 的零次方，如果你还记得的话，
is 10 to the zeroth power, which if you recall,

345
00:17:06,068 --> 00:17:09,409
等于 1，10 的一次方，等于10，
just means one, 10 to the first power, which is just 10,

346
00:17:09,410 --> 00:17:12,766
10 的 2 次方，即 10 的平方，等于100。
and 10 to the second power, or 10 squared, is 100.

347
00:17:12,766 --> 00:17:15,099
但是以这种方式表示好玩的地方
But what's interesting about representing it in this way

348
00:17:15,098 --> 00:17:18,338
是它跳出了 10 本身。
is that it jumps out that 10 is involved.

349
00:17:18,338 --> 00:17:24,229
有 10 个数字，从 0 到 9，所以这些列使用10的基数。
There's 10 digits, zero through nine, so the columns are using this base of 10.

350
00:17:24,230 --> 00:17:26,230
所以你现在也许可以比我更早地考虑到，
So you can perhaps now get even ahead of me

351
00:17:26,230 --> 00:17:29,380
如果在计算机使用的二进制系统中，
here by considering, well, if in the binary system that computers

352
00:17:29,380 --> 00:17:31,810
你只有两个数字，0 和 1，
use, you only have two digits, zeros and ones,

353
00:17:31,809 --> 00:17:35,989
那么唯一要改变的可能就是这些列的意义。
odds are the only thing that's going to change is the meaning of these columns.

354
00:17:35,990 --> 00:17:39,880
现在我们仍然这么替换，因为 2 的 0 次方是 1，
Now we have the ones place still, because 2 to the zero is one,

355
00:17:39,880 --> 00:17:43,278
2 的 1 次方，2 的 2 次方，依此类推。
but then we have 2 to the first, 2 to the second, and so forth.

356
00:17:43,278 --> 00:17:45,070
当然，如果我们只是进行数学运算，
And of course, if we just do out that math,

357
00:17:45,069 --> 00:17:47,499
在计算机使用的二进制世界中，
in the world of binary that computers use,

358
00:17:47,500 --> 00:17:52,400
我们有 1，2，4 等等。
we have the ones place, twos place, fours place, and so forth.

359
00:17:52,400 --> 00:17:53,980
现在我们继续。
And now we're good to go.

360
00:17:53,980 --> 00:17:57,340
尽管我们现在必须在不同的基数系统中思考，
Even though we have to now think in a different base system,

361
00:17:57,339 --> 00:17:59,199
但我们可以开始更正确地计数了。
now we can start counting more properly.

362
00:17:59,200 --> 00:18:01,840
现在我们可以摆脱灯泡的例子了
And now we can move away from the metaphor of light bulbs

363
00:18:01,839 --> 00:18:04,659
考虑一下，如果所有的灯泡都熄灭，
and consider that if all of those light bulbs are off,

364
00:18:04,660 --> 00:18:07,720
同样，我们将再次开始将这些东西视为零。
we're, again, just going to start thinking of those things as zeros.

365
00:18:07,720 --> 00:18:12,040
因此，这将是符号或数字的模式，二进制的形式为 000。
So that would be a pattern of symbols or digits that's 000 in binary.

366
00:18:12,039 --> 00:18:14,579
但是在我们人类的世界里，
But in our human world, the mental math you

367
00:18:14,579 --> 00:18:17,379
你可能会马上心算出来
would probably do now instantaneously after today

368
00:18:17,380 --> 00:18:22,030
好吧，那显然是 4*0 加上 2*0 加上 1*0，
would be, well, that's obviously 4 times 0 plus 2 times 0 plus 1 times 0,

369
00:18:22,029 --> 00:18:24,729
当然，结果是十进制的 0。
or, of course, zero in decimal.

370
00:18:24,730 --> 00:18:28,540
但是，计算机如何表示 1 ？
But how does a computer represent the number one, for instance?

371
00:18:28,539 --> 00:18:33,429
好吧，只是将最右边的位从 0 变成 1，
Well, it's just going to change that rightmost bit from a zero to a one,

372
00:18:33,430 --> 00:18:37,270
或者，比喻来说，它将打开并点亮该开关
or, more metaphorically, it's going to turn that switch on and illuminate

373
00:18:37,269 --> 00:18:40,059
就像我之前所做的那样，那个最右边的灯泡。
that rightmost light bulb just like I did earlier.

374
00:18:40,059 --> 00:18:41,559
我怎么表示 2？
How do I represent two?

375
00:18:41,559 --> 00:18:44,139
二进制是 010。
It's going to be 010 in binary.

376
00:18:44,140 --> 00:18:45,700
我怎么表示 3？
How do I represent three?

377
00:18:45,700 --> 00:18:47,270
这就是跟我们不一样的地方。
This is where we're about to differ.

378
00:18:47,269 --> 00:18:49,647
现在我要打开其中两个开关，
Now I'm putting on two of those switches,

379
00:18:49,647 --> 00:18:52,689
因为我需要在2和1的位置上有一些东西来给我，
because I need something in the twos place and the ones place to give me,

380
00:18:52,690 --> 00:18:54,340
从数学上讲，3。
mathematically, three.

381
00:18:54,339 --> 00:18:57,249
接下来，如果我们继续选择-
Next, if we go ahead and choose--

382
00:18:57,250 --> 00:19:00,220
数到 4，就是 100。
count up to four, that's going to be 100.

383
00:19:00,220 --> 00:19:02,950
如果我要数到 5，那就是 101
if I want to count up to five, that's going to be 101,

384
00:19:02,950 --> 00:19:10,840
6将是 110，最后，数字 7 将是 111。
six is going to be 110, and finally, the number seven is going to be 111.

385
00:19:10,839 --> 00:19:14,849
因此，似乎使用了三位，每个位可以为零或一，
So it would seem that using three bits, each of which can be a zero or one,

386
00:19:14,849 --> 00:19:17,979
是的，你可以用八种不同的方式来排列它们。
yes, you can permute them in eight different ways.

387
00:19:17,980 --> 00:19:20,950
第一位两种可能性乘以第二位的两种可能性乘以第三位的两种可能性，
Two possibilities for the first times two for the second times two

388
00:19:20,950 --> 00:19:22,360
到第三位就有 8 种情况。
for the third gives us eight.

389
00:19:22,359 --> 00:19:26,109
但按照这个数学和从零开始算的传统，
But as per this math and the intuition of starting counting from zero,

390
00:19:26,109 --> 00:19:30,559
我们最多只能数到 7。
we can only count up as high as seven in total.

391
00:19:30,559 --> 00:19:33,099
好吧，让我们继续，然后来个实例。
Well, let's go ahead and actually take this out for a spin.

392
00:19:33,099 --> 00:19:38,874
当我们不只是有，一个灯泡或三个灯泡时，
When we don't have just, say, let's say, one light bulb or three light bulbs,

393
00:19:38,875 --> 00:19:40,750
实际上，我们拥有
we have, actually, the fortune of having like

394
00:19:40,750 --> 00:19:42,350
一整个舞台的灯泡。
a whole stage worth of light bulbs.

395
00:19:42,349 --> 00:19:46,059
舞台上装饰着 64 个灯泡。
64 light bulbs adorn the stage here.

396
00:19:46,059 --> 00:19:47,049
你知道吗？
And you know what?

397
00:19:47,049 --> 00:19:51,169
Sumner，我们可以继续在这里在屏幕上放一个随机数吗？
Sumner, could we go ahead and put up a random number on the screen here?

398
00:19:51,170 --> 00:19:54,490
好吧，所以如果你从视角看这些灯泡，
All right, so if you can see these light bulbs from your perspective,

399
00:19:54,490 --> 00:19:57,640
我们有 8 个灯泡，还有一堆，
we have eight light bulbs plus another bunch of them,

400
00:19:57,640 --> 00:19:59,420
其他的都关闭了。
and all the others are off.

401
00:19:59,420 --> 00:20:01,660
因此，让我们继续问一个问题。
So let's go ahead and ask a question then.

402
00:20:01,660 --> 00:20:07,720
如果这些灯泡现在不仅仅是一个灯泡，或两个或三个，
If these light bulbs now represent not just one light bulb or two or three,

403
00:20:07,720 --> 00:20:10,750
而是多个-在这种情况下，至少有六个灯泡，
but several more-- in this case, at least six light bulbs,

404
00:20:10,750 --> 00:20:12,399
我们实际上得到了什么数？
what value do we actually get?

405
00:20:12,400 --> 00:20:15,260
好吧，让我继续在屏幕上提问，
Well, let me go ahead and put a question on the screen here,

406
00:20:15,259 --> 00:20:18,079
一会儿就把你们弹出来。
which should pop up on yours in just a moment.

407
00:20:18,079 --> 00:20:22,009
现在，你应该在看到了同样的问题。
And you should see now on your end this same question.

408
00:20:22,009 --> 00:20:26,259
用二进制表示，什么数字-
Put in binary terms, what number--

409
00:20:26,259 --> 00:20:33,789
二进制数 110010 表示十进制的什么数？
in decimal, does binary number 110010 represents?

410
00:20:33,789 --> 00:20:40,459
从左到右，二进制数 110010 代表十进制的什么数？
What decimal number does binary number 110010 represent, from left to right?

411
00:20:40,460 --> 00:20:42,710
我们得到了压倒性的回答。
So here we have an overwhelming response.

412
00:20:42,710 --> 00:20:45,300
50 是正确答案。
50 is indeed the correct answer.

413
00:20:45,299 --> 00:20:46,029
为什么呢？
Now why is that?

414
00:20:46,029 --> 00:20:48,449
好吧，如果我转到这里的物理灯泡，让我们
Well, if I go over to the physical light bulbs here, let's

415
00:20:48,450 --> 00:20:51,210
稍微考虑一下实际的情况。
just consider for a moment what the pattern actually is.

416
00:20:51,210 --> 00:20:58,110
这是 1，2，4，8，16、32，
This here is the ones place, the twos place, four, eight, 16, 32,

417
00:20:58,109 --> 00:20:59,109
而且我们可以继续数下去。
and we could keep going.

418
00:20:59,109 --> 00:21:01,317
但这无关紧要，因为它们全都是关闭的。
But it's not going to matter because they're all off.

419
00:21:01,317 --> 00:21:05,249
所以我们有 32 加 16 加 2
So we have 32 plus 16 plus 2, which indeed gives us

420
00:21:05,250 --> 00:21:07,770
得到我们都知道的十进制数字 50。
the number you and I know in decimal as 50.

421
00:21:07,769 --> 00:21:11,249
试想一下，如果我们可以用其他所有灯泡
And just imagine how high we could count with all of the other light bulbs

422
00:21:11,250 --> 00:21:12,699
可以数到多少
as well.

423
00:21:12,700 --> 00:21:13,230
好的。
All right.

424
00:21:13,230 --> 00:21:15,450
我们从电的故事开始。
So we started with the story with electricity.

425
00:21:15,450 --> 00:21:18,090
然后我们转到数字并表示信息，
We then moved on to numbers and representing things,

426
00:21:18,089 --> 00:21:19,949
十进制或二进制。
either in decimal or in binary.

427
00:21:19,950 --> 00:21:22,050
但是我们有点陷入困境，
But we've kind of painted ourselves into a corner,

428
00:21:22,049 --> 00:21:26,159
因为如果我们只有开关或例子中的
because if we only have at our disposal switches or the metaphorical light

429
00:21:26,160 --> 00:21:28,830
灯泡，我们可以认为是零和一，
bulbs, which we can think of as zeros and ones,

430
00:21:28,829 --> 00:21:32,279
看来计算机唯一能做的就是计算。
it would seem that the only things computers can do is compute.

431
00:21:32,279 --> 00:21:33,929
即，充当计算器。
That is, behave as calculators.

432
00:21:33,930 --> 00:21:37,590
实际上，从一开始，这就是计算机的设计宗旨，
And in fact, early on, that's exactly what computers were designed to do,

433
00:21:37,589 --> 00:21:41,219
确实促进了数学计算，否则本来就相当
was really facilitate mathematical calculations that were otherwise quite

434
00:21:41,220 --> 00:21:43,110
对人类而言是乏味或不可能的。
tedious or impossible for humans.

435
00:21:43,109 --> 00:21:45,389
但是，当然，你和我现在正在使用什么，
But, of course, what you and I are using right now,

436
00:21:45,390 --> 00:21:49,290
我们每天在手机，笔记本电脑和台式机上使用的东西更多
what we use every day on our phones and our laptops and desktops is much more

437
00:21:49,289 --> 00:21:50,139
复杂的。
sophisticated.

438
00:21:50,140 --> 00:21:53,940
因此，让我们考虑一台计算机如何不仅能代表数字，
So let's consider how could a computer represent not just numbers,

439
00:21:53,940 --> 00:21:56,700
但是字母。
but letters of the alphabet.

440
00:21:56,700 --> 00:21:58,620
布莱恩，我们可以请这个人吗？
Brian, could we call on someone for this one?

441
00:21:58,619 --> 00:22:00,809
如果你想举起虚拟牌，
If you'd like to raise your virtual hand,

442
00:22:00,809 --> 00:22:03,869
计算机如何去代表一个字母
how could a computer go about representing letters of an alphabet

443
00:22:03,869 --> 00:22:10,189
像英语一样，如果我们能使用的只是开关吗？
like English if, again, all we have at our disposal is switches?

444
00:22:10,190 --> 00:22:13,550
听众：我们可以分配从二进制中得到的数字
AUDIENCE: We can assign the numbers that we're getting from binary

445
00:22:13,549 --> 00:22:15,776
到特定的字母。
to specific letters of the alphabet.

446
00:22:15,777 --> 00:22:16,610
大卫·J·马兰（David J MALAN）：是的。
DAVID J MALAN: Yeah.

447
00:22:16,609 --> 00:22:20,046
我们可以将特定数字以二进制形式分配给字母。
We can assign the specific numbers in binary to letters of the alphabet.

448
00:22:20,047 --> 00:22:22,130
看来，这几乎是我们唯一的选择。
That's pretty much our only option, it would seem.

449
00:22:22,130 --> 00:22:26,060
如果我们只能对这些开关，电灯泡或钻头进行置换，
If we only have the ability to permute these switches or light bulbs or bits,

450
00:22:26,059 --> 00:22:29,742
好吧，我们所有人都必须同意如何以相同的方式表示字母。
well, we just all have to agree how to represent letters in the same way.

451
00:22:29,742 --> 00:22:32,659
现在，对于我们而言，最简单的方法可能是，你知道吗？
Now, maybe the simplest way for us to do this would be, you know what?

452
00:22:32,660 --> 00:22:36,230
我们都同意，大写字母A将成为第一位。
Let's just all agree that a capital A is going to be the number one.

453
00:22:36,230 --> 00:22:40,280
因此，你打开一个灯泡，或表示二进制数字1。
So you turn on one light bulb, or represent the binary number one.

454
00:22:40,279 --> 00:22:42,889
好吧，对于B，我们可以使用第二。
Well, how about for B, we could use the number two.

455
00:22:42,890 --> 00:22:45,950
对于C，我们可以使用数字三。
For C we could use the number three.

456
00:22:45,950 --> 00:22:47,510
D可以是4，依此类推。
D could be four, and so forth.

457
00:22:47,509 --> 00:22:51,929
我们都只需要同意用这种方式给字母编号。
We all just have to agree to number the letters in that way.

458
00:22:51,930 --> 00:22:54,240
但事实证明，人类确实做到了这一点，
But it turns out humans did exactly that,

459
00:22:54,240 --> 00:22:56,150
但与几年前有所不同。
but a little bit differently years ago.

460
00:22:56,150 --> 00:22:59,450
他们之所以做出决定，是因为我们暂时不会参与其中，
They decided for reasons that we won't get into just now,

461
00:22:59,450 --> 00:23:01,730
实际上，大写字母A实际上是
that, actually, the capital letter A is actually

462
00:23:01,730 --> 00:23:05,930
将由你和我知道的65十进制数表示。
going to be represented by the decimal number you and I know as 65.

463
00:23:05,930 --> 00:23:08,850
现在按位形式，看起来像这样。
Now in bitwise form, that's going to look like this.

464
00:23:08,849 --> 00:23:11,599
这就是计算机将要使用的位模式
So this is the pattern of bits that a computer would

465
00:23:11,599 --> 00:23:15,659
用来代表我们现在知道的十进制数字65，
use to represent the decimal number we now know as 65,

466
00:23:15,660 --> 00:23:18,980
现在计算机要做的只是注意什么
and now what the computer is going to do is just be mindful of what

467
00:23:18,980 --> 00:23:20,730
你正在使用的程序类型。
type of program you're using.

468
00:23:20,730 --> 00:23:24,380
所以是的，如果你使用的是计算器或使用Excel之类的工具
So yes, if you're using a calculator or maybe using something like Excel

469
00:23:24,380 --> 00:23:28,190
在运行软件的情况下，要计算数字，
to crunch numbers, well, in that context when running software,

470
00:23:28,190 --> 00:23:32,030
像是进行数值分析的计算器或电子表格程序，
like a calculator or a spreadsheet program doing numerical analysis,

471
00:23:32,029 --> 00:23:36,259
该程序将在计算机的硬件内部看到
the program is going to see inside of the computer's hardware

472
00:23:36,259 --> 00:23:40,489
代表十进制数字65的开关模式。
the pattern of switches that represents the decimal number 65.

473
00:23:40,490 --> 00:23:43,340
而且由于它是在计算器或电子表格的上下文中，
And because it's in the context of a calculator or spreadsheet, what

474
00:23:43,339 --> 00:23:47,749
你（人类）可能会在屏幕上看到字面上的十进制数字65。
you, the human, might see on the screen is literally the decimal number 65.

475
00:23:47,750 --> 00:23:50,873
但是，如果你和我正在使用短信或电子邮件或任何号码
But if you and I are using text messaging or email or any number

476
00:23:50,873 --> 00:23:52,790
我们正在交流的社交媒体应用程序
of social media apps where we're communicating

477
00:23:52,789 --> 00:23:56,149
不是数字形式，而是字母，例如英文字母，
not numerically but in letters, say, English letters,

478
00:23:56,150 --> 00:23:59,360
在这种情况下，你的计算机将足够智能
in that context your computer is going to be smart enough

479
00:23:59,359 --> 00:24:03,259
要知道，代表65的相同位模式
to know, well, that same pattern of bits that represents 65,

480
00:24:03,259 --> 00:24:07,189
在短信或电子邮件等中
in the context of a text message or in an email or the like

481
00:24:07,190 --> 00:24:11,208
实际上代表大写字母A。因此模式是相同的。
actually represents the capital letter A. So the pattern is the same.

482
00:24:11,208 --> 00:24:12,500
表示是相同的。
The representation is the same.

483
00:24:12,500 --> 00:24:14,270
但是上下文是不同的。
But the context is what differs.

484
00:24:14,269 --> 00:24:20,359
人类几年前想出的系统，将65映射到A，将66映射到B，
And the system that humans came up with years ago that maps 65 to A, 66 to B,

485
00:24:20,359 --> 00:24:23,569
67到C，称为ASCII，美国标准
67 to C, is called ASCII, the American Standard

486
00:24:23,569 --> 00:24:25,669
信息交换代码。
Code for Information Interchange.

487
00:24:25,670 --> 00:24:28,640
这只是意味着存在一个定义明确的映射，
And that just means that there is a well-defined mapping that a bunch

488
00:24:28,640 --> 00:24:33,650
几十年前的人类决定为了绘制字母表中的字母-
of humans decades ago decided on, in order to map letters of the alphabet--

489
00:24:33,650 --> 00:24:34,830
在这种情况下为英语
English in this case--

490
00:24:34,829 --> 00:24:36,649
到以65开头的数字。
to numbers starting with 65.

491
00:24:36,650 --> 00:24:39,950
对于标点符号，小写字母也有一个完整的映射，
And there's a whole mapping, too for punctuation, for lowercase letters,

492
00:24:39,950 --> 00:24:41,076
等等。
and the like.

493
00:24:41,076 --> 00:24:47,480
因此，假设你确实收到了一条包含以下内容的短信：
So given that, suppose that you did receive a text message containing

494
00:24:47,480 --> 00:24:52,250
一种位模式，或者实际上只是一个十进制数字序列
a pattern of bits, or, really, just a sequence of decimal numbers that

495
00:24:52,250 --> 00:24:53,719
碰巧是这个。
happened to be this.

496
00:24:53,720 --> 00:24:57,500
72、73、33。
72, 73, 33.

497
00:24:57,500 --> 00:25:02,929
假设你收到一条包含这些数字模式的短信。
Suppose that you received a text message containing these patterns of numbers.

498
00:25:02,930 --> 00:25:05,240
72、73、33。
72, 73, 33.

499
00:25:05,240 --> 00:25:07,860
你可能会收到什么消息？
What message might you have just received?

500
00:25:07,859 --> 00:25:10,519
让我继续，在这里拉起简短的图表
Let me go ahead and pull up the abbreviated chart here

501
00:25:10,519 --> 00:25:13,669
仔细考虑你收到的消息。
to consider exactly what message you've received.

502
00:25:13,670 --> 00:25:15,710
72、73、33。
72, 73, 33.

503
00:25:15,710 --> 00:25:19,400
萨姆纳，我们可以继续抛出同样的三个字母的单词吗？
And Sumner, could we go ahead and throw this same three-letter word

504
00:25:19,400 --> 00:25:21,710
在灯上？
on the lights?

505
00:25:21,710 --> 00:25:24,910
如果你想按位查看它，可以这么说，
If you'd like to see it in bitwise form, so to speak,

506
00:25:24,910 --> 00:25:29,870
现在它也将出现在这些灯泡上。
it will appear here on these light bulbs now as well.

507
00:25:29,869 --> 00:25:31,909
这代表什么模式？
What pattern does this represent?

508
00:25:31,910 --> 00:25:33,920
兰纳姆，我们可以去找你吗？
Lanham, can we go to you?

509
00:25:33,920 --> 00:25:36,563
听众：HI带有感叹号，对吗？
AUDIENCE: That would be HI with an exclamation point, correct?

510
00:25:36,563 --> 00:25:39,230
DAVID J MALAN：是的，确实如此，带有感叹号。
DAVID J MALAN: Yeah so it's indeed HI with an exclamation point.

511
00:25:39,230 --> 00:25:41,272
回想起来，现在可能很容易
And it's probably pretty easy now, in retrospect,

512
00:25:41,271 --> 00:25:45,229
可以理解，是的，72和73分别是H和I。
to glean that, yes, the 72 and the 73 were H and I respectively.

513
00:25:45,230 --> 00:25:49,070
但是Lanham也指出了这个图表中没有的感叹号，
But Lanham also noted the exclamation point, which isn't in this chart,

514
00:25:49,069 --> 00:25:51,529
但是对于每个点点，都有一个定义明确的映射
but per the dot dot dots, there is a well-defined mapping

515
00:25:51,529 --> 00:25:54,689
对于我们可能关心的所有字母。
for all of the letters of the alphabet that we might care about.

516
00:25:54,690 --> 00:25:57,260
因此，HI可能比其他方法更明显。
And so HI is perhaps more obvious than the other.

517
00:25:57,259 --> 00:25:59,097
那33，我们需要一个更大的图表。
That 33, we need a bigger chart.

518
00:25:59,097 --> 00:26:00,889
因此，如果你实际使用计算机
And so if you actually go on your computers

519
00:26:00,890 --> 00:26:04,905
现在到asciichart.com，asciichart.com，你将
now to asciichart.com, asciichart.com, you'll

520
00:26:04,904 --> 00:26:06,279
看到这样的东西。
see a little something like this.

521
00:26:06,279 --> 00:26:08,279
尽管你也可以只使用google ASCII进行搜索
Though you can also just google ASCII in general

522
00:26:08,279 --> 00:26:09,659
并获得相同图表的副本。
and get copies of the same chart.

523
00:26:09,660 --> 00:26:13,550
你会在这里看到H的确是72，我的确是73，
You'll see here that H is indeed 72, I is indeed 73,

524
00:26:13,549 --> 00:26:17,009
但是如果我们向左看，显然33是一个感叹号。
but if we look to the left, 33 is, apparently, an exclamation mark.

525
00:26:17,009 --> 00:26:19,759
而且，你只会知道查找或只是拥有
And you would only know that by having looked it up or just having

526
00:26:19,759 --> 00:26:20,717
提交给内存。
committed it to memory.

527
00:26:20,718 --> 00:26:23,630
但是你和我使用的计算机以及你和我使用的电话仅
But the computers you and I use and the phones you and I use just

528
00:26:23,630 --> 00:26:24,710
内在地知道这一点。
know this intrinsically.

529
00:26:24,710 --> 00:26:26,510
确实，这就是它们的编程方式。
That's, indeed, how they're programmed.

530
00:26:26,509 --> 00:26:29,869
但事实证明，我们也应该考虑
But it turns out, too, that we should consider

531
00:26:29,869 --> 00:26:32,419
我们现在使用多少个零和一个
just how many zeroes and ones we're using now

532
00:26:32,420 --> 00:26:35,660
分别代表72、73和33
to represent the 72, the 73, and the 33.

533
00:26:35,660 --> 00:26:38,840
因此，让我们最后一次查看二进制表示形式，
So let's look for one last time at the binary representation, which,

534
00:26:38,839 --> 00:26:42,389
根据灯泡，这里是这些位模式。
as per the light bulbs, are these patterns of bits here.

535
00:26:42,390 --> 00:26:45,410
因此，当你收到朋友发来的短信说HI！
So when you receive a text message from a friend saying HI!

536
00:26:45,410 --> 00:26:47,930
HI感叹号，总的来说，
H-I exclamation point, in all caps, you're

537
00:26:47,930 --> 00:26:51,470
从技术上讲，它接收比特模式，某种频率，
technically receiving a pattern of bits, some kind of frequency,

538
00:26:51,470 --> 00:26:54,920
如果是无线的，则表示这种位模式。
if it's wireless, that represents this pattern of bits.

539
00:26:54,920 --> 00:26:58,910
通常，这些天的计算机使用八位
And typically, computers these days use eight bits

540
00:26:58,910 --> 00:27:00,892
代表每个这些字符。
to represent each of those characters.

541
00:27:00,892 --> 00:27:02,600
ASCII首次出现时，通常
When ASCII first came out, they typically

542
00:27:02,599 --> 00:27:06,829
出于效率考虑，只使用了7个，因为当时的空间太昂贵了。
used seven for efficiency reasons, because space was expensive back then.

543
00:27:06,829 --> 00:27:09,469
但是在这里我们使用了八个，实际上，这就是现在
But here we used eight, and, indeed, that's now

544
00:27:09,470 --> 00:27:12,470
以八的倍数表示字符时的规范。
the norm when it comes to representing characters in multiples of eight.

545
00:27:12,470 --> 00:27:15,690
所以我们这里有八位，这里有八位，这里有八位，
So we have eight bits here, eight bits here, eight bits here,

546
00:27:15,690 --> 00:27:20,210
这意味着要收到消息HI！你正在发送或接收24位
which means to receive the message HI! you are sending or receiving 24 bits

547
00:27:20,210 --> 00:27:20,840
全部的。
total.

548
00:27:20,839 --> 00:27:23,299
坦白说，现在位不是一个非常有用的度量单位，
Now, frankly, bits are not a very useful unit of measure,

549
00:27:23,299 --> 00:27:24,799
通常是因为它们很小。
typically, because they're so small.

550
00:27:24,799 --> 00:27:26,299
只是零或一。
Just a zero or a one.

551
00:27:26,299 --> 00:27:29,329
但是这些八位模式中的每一个实际上
But each of these patterns of eight bits, actually

552
00:27:29,329 --> 00:27:32,539
如果可以的话，有一个词汇词，即字节。
have a vocabulary word, if you will, which is bytes.

553
00:27:32,539 --> 00:27:35,839
而且很可能，我们所有人都在某些情况下使用了这个术语，
And odds are, all of us have used this term in some context,

554
00:27:35,839 --> 00:27:39,179
但通常以兆字节甚至千兆字节为背景。
but generally in the context of megabytes or even gigabytes.

555
00:27:39,180 --> 00:27:41,870
确实，当你最近谈论文件的大小时，
Indeed when you talk about the sizes of your files these days,

556
00:27:41,869 --> 00:27:46,579
你是以某种形式的字节（百万字节或十亿字节）说话。
you're speaking in bytes in some form, either million or billion bytes.

557
00:27:46,579 --> 00:27:51,409
但是，这些字节中的每个字节都非常简单地由八个零和一的模式组成。
But each of those bytes, quite simply, is a pattern of eight zeros and ones.

558
00:27:51,410 --> 00:27:55,160
因此，实际上，如果我们可以使用多达64个灯泡，
So, in fact, if we have as many as 64 bulbs at our disposal,

559
00:27:55,160 --> 00:27:56,800
那是64除以8。
that's 64 divided by 8.

560
00:27:56,799 --> 00:27:57,799
那是八个字符。
That's eight characters.

561
00:27:57,799 --> 00:28:01,309
因此，似乎我们可以在此阶段进行拼写，即使是八个字母的单词-
So it would seem we could spell on this stage, even an eight-letter word--

562
00:28:01,309 --> 00:28:03,919
萨姆纳（Sumner），如果我们可以随机输入一个八个字母的单词，
if, Sumner, we could put up a random eight-letter word,

563
00:28:03,920 --> 00:28:05,720
我们现在要跟上
that we'll keep up now--

564
00:28:05,720 --> 00:28:09,230
你现在可以从左向右拼写吗？
can you now spell from left to right, your left

565
00:28:09,230 --> 00:28:14,780
在你的右边，是一个八个字母的单词，使用的是ASCII码系统。
to your right, an eight-letter word using the system known as ASCII.

566
00:28:14,779 --> 00:28:17,119
但是，当然，我们在这里有些偏见，
But, of course, we're being a little bit biased here,

567
00:28:17,119 --> 00:28:20,779
因为ASCII是美国信息交换标准代码。
as ASCII is the American Standard Code for Information Interchange.

568
00:28:20,779 --> 00:28:24,319
当然，在典型的美国英语键盘上，肯定会有更多的字符，
And on a typical US English keyboard, there's more characters, certainly,

569
00:28:24,319 --> 00:28:27,409
而不是大写字母，例如A到H和I。
than uppercase letters, like A through H and I.

570
00:28:27,410 --> 00:28:30,860
还有一些标点符号和一些数字，但也有很多
There's also some punctuation and some numbers, but there's also quite a bit

571
00:28:30,859 --> 00:28:32,069
也失踪了。
missing as well.

572
00:28:32,069 --> 00:28:34,909
你们在世界上其他任何地方的人，
And any of you who are elsewhere in the world, odds are,

573
00:28:34,910 --> 00:28:41,210
会发现使用这样的键盘特别容易造成限制或沮丧。
would find using a keyboard like this especially limiting or frustrating.

574
00:28:41,210 --> 00:28:41,840
这是为什么？
Why is that?

575
00:28:41,839 --> 00:28:44,439
ASCII似乎缺少了什么？
What seems to be missing from ASCII?

576
00:28:44,440 --> 00:28:46,415
ASCII似乎缺少了什么？
What seems to be missing from ASCII?

577
00:28:46,414 --> 00:28:49,669
好吧，让我在这里问另一个问题。
Well, let me ask this one other question here.

578
00:28:49,670 --> 00:28:56,150
如果我们确实使用ASCII，因此我们给自己八位或一个字节，
If we do use ASCII, and we therefore give ourselves eight bits or one byte,

579
00:28:56,150 --> 00:29:03,620
我们实际上可能会显示多少个不同的字符
how many different characters could we potentially actually display, actually

580
00:29:03,619 --> 00:29:04,159
代表？
represent?

581
00:29:04,160 --> 00:29:06,350
因此，在屏幕上，你现在应该会看到此问题。
So on your screen, you should see this question now.

582
00:29:06,349 --> 00:29:09,929
你可以用8位表示多少个符号？
How many symbols can you represent with eight bits?

583
00:29:09,930 --> 00:29:14,660
你可以用8位表示多少个符号？
How many symbols can you represent with eight bits?

584
00:29:14,660 --> 00:29:17,480
最终，这实际上说明了
And this speaks to, really, at the end of the day, how

585
00:29:17,480 --> 00:29:20,180
许多字母加上标点符号，
many letters of the alphabet plus punctuation,

586
00:29:20,180 --> 00:29:23,930
加上大写和小写字母，计算机可以支持ASCII还是真的支持？
plus uppercase and lowercase, can ASCII, or really, can computers support?

587
00:29:23,930 --> 00:29:28,080
好吧，似乎有72％的人认为答案是256。
Well, it looks like 72% or so of you think that the answer is 256.

588
00:29:28,079 --> 00:29:32,269
确实可以代表256种可能性。
And it is indeed the case that you can represent 256 possibilities.

589
00:29:32,269 --> 00:29:32,779
为什么？
Why?

590
00:29:32,779 --> 00:29:34,154
你实际上可以进行数学计算。
You can actually do out the math.

591
00:29:34,154 --> 00:29:37,459
如果你有八位，每位可以是零或一，
If you've got eight bits, each of which can be a zero or a one,

592
00:29:37,460 --> 00:29:39,720
这意味着你有两种可能性，
that means you have two possibilities for the first,

593
00:29:39,720 --> 00:29:43,280
第二次乘以两次，两次乘以两次。
times two possibilities for the second, times two times two times two.

594
00:29:43,279 --> 00:29:46,649
恰好是2到八分之一，即256。
That happens to be 2 to the eighth, or 256.

595
00:29:46,650 --> 00:29:48,560
如果那不是立即显而易见的话，那很好
It's fine if that's not immediately obvious,

596
00:29:48,559 --> 00:29:52,309
但是如果你确实有8位，而每位可以是两个值之一，
but if you do have eight bits, each of which can be one of two values,

597
00:29:52,309 --> 00:29:55,649
你可以想出256种可能性。
you can come up with 256 possibilities.

598
00:29:55,650 --> 00:29:59,510
在这种情况下，那些听到提示说答案为255的人，
Those of you who chimed in to say that the answer is 255 in this case,

599
00:29:59,509 --> 00:30:02,959
是错的，只是因为现在我们在谈论总数
are wrong, only because now we're talking about the total number

600
00:30:02,960 --> 00:30:05,270
模式，实际上是256。
of patterns, which is indeed 256.

601
00:30:05,269 --> 00:30:10,009
但是我们可以用八位或八个灯泡表示的最大值
But the highest value we could represent with eight bits or eight light bulbs,

602
00:30:10,009 --> 00:30:13,197
看来确实是255。
it would seem to be, indeed, 255.

603
00:30:13,198 --> 00:30:15,990
那是因为我们可以置换所有不同的模式。
And that's because of all of the different patterns we can permute.

604
00:30:15,990 --> 00:30:18,590
但是，现在让我向观众们提一个问题。
But let me open the question to the audience now.

605
00:30:18,589 --> 00:30:21,589
为什么美式英语键盘会特别受限制，
Why might a US English keyboard be especially limiting,

606
00:30:21,589 --> 00:30:26,329
反过来，为什么ASCII真的不太合适
and in turn, why is ASCII really not quite appropriate

607
00:30:26,329 --> 00:30:29,059
在表达人类语言时，
when it comes to representing human language,

608
00:30:29,059 --> 00:30:33,109
即使这是几年前开始的计算机？
even though this is what computers began with years ago?

609
00:30:33,109 --> 00:30:35,944
ASCII缺少什么？
What is missing from ASCII?

610
00:30:35,944 --> 00:30:41,419
为什么总共256种可能性不够？
Why might 256 total possibilities not be sufficient?

611
00:30:41,420 --> 00:30:42,440
凯文，我们可以去找你吗？
Kevin, can we go to you?

612
00:30:42,440 --> 00:30:43,700
听众：好的。
AUDIENCE: Sure.

613
00:30:43,700 --> 00:30:47,310
我的意思是，一方面，我没有其他语言的很多口音。
I mean, for one thing, missing a lot of the accents in other languages.

614
00:30:47,309 --> 00:30:49,309
但是，如果你只考虑亚洲语言，
But if you just consider, like, Asian languages,

615
00:30:49,309 --> 00:30:51,441
超过256个字符。
there are a lot more than 256 characters.

616
00:30:51,442 --> 00:30:52,400
大卫·J·马兰（David J MALAN）：好的。
DAVID J MALAN: Exactly.

617
00:30:52,400 --> 00:30:55,370
所以我们不仅缺少重音符号
So not only are we missing accented characters

618
00:30:55,369 --> 00:30:57,229
你可能需要某些语言的版本，
that you might need in some languages, we're

619
00:30:57,230 --> 00:30:59,960
还缺少亚洲语言中可能需要的字符，
also missing the characters that you might need in Asian languages,

620
00:30:59,960 --> 00:31:01,543
像阿拉伯语之类的语言。
in languages like Arabic and the like.

621
00:31:01,542 --> 00:31:05,629
我们人类可以使用更多的方式以印刷形式进行交流
There are way more symbols that we humans use to communicate in print

622
00:31:05,630 --> 00:31:08,565
和电子方式超过256。
and electronically than 256.

623
00:31:08,565 --> 00:31:10,940
英文，我们可以轻松安装此键盘，
English, we can get away with fitting into this keyboard,

624
00:31:10,940 --> 00:31:13,280
但是一旦我们介绍了类似这些字符的东西，
but not once we introduce things like these characters,

625
00:31:13,279 --> 00:31:15,359
更不用说其他符号了。
let alone other symbols as well.

626
00:31:15,359 --> 00:31:18,709
事实证明，这些天来我们人类还有其他要说的话
And it turns out there's other things we humans like to say these days

627
00:31:18,710 --> 00:31:23,390
并使用流行的字符来表达，即
and express using characters that have come into vogue, which is, namely,

628
00:31:23,390 --> 00:31:24,020
这些东西。
these things.

629
00:31:24,019 --> 00:31:26,509
可能是今天某个时候
Odds are, probably sometime today you have

630
00:31:26,509 --> 00:31:30,229
在此处发送或接收这些东西之一，也称为表情符号。
sent or received one of these things here, otherwise known as an emoji.

631
00:31:30,230 --> 00:31:33,890
现在，即使这些表情符号看起来像图片，它们也看起来像图像-
Now, even though these emojis look like pictures, they look like images--

632
00:31:33,890 --> 00:31:37,760
从技术上讲，它们是在计算机中实现的方式
and they are, technically-- the way they're implemented in computers

633
00:31:37,759 --> 00:31:40,189
实际上是零和一的模式。
is actually as patterns of zeros and ones.

634
00:31:40,190 --> 00:31:44,570
这些实际上只是字母（表情符号字母）中的字符。
These are actually just characters in an alphabet, the emoji alphabet.

635
00:31:44,569 --> 00:31:47,029
也就是说存在一些零和一的模式
Which is to say there's some pattern of zeros and ones

636
00:31:47,029 --> 00:31:50,629
代表这些面孔中的每一个面孔，以及许多其他表情符号
that represents each one of these faces, and the many other emojis that

637
00:31:50,630 --> 00:31:51,860
时下存在。
nowadays exist.

638
00:31:51,859 --> 00:31:55,639
这是因为多年来，世界已经从ASCII过渡，
And this is because the world has transitioned over the years from ASCII,

639
00:31:55,640 --> 00:31:57,950
它只使用了七个，在某种意义上，
which only used seven, and in some sense,

640
00:31:57,950 --> 00:32:01,250
总共八位代表所有可能的字符，
eight bits total to represent all possible characters,

641
00:32:01,250 --> 00:32:07,099
使用8个或16个或24个甚至32个。
to using either eight or 16 or 24 or even 32 .

642
00:32:07,099 --> 00:32:11,339
如今，有一个名为Unicode的系统，人类已经出现了
Bits nowadays there's a system called Unicode, which humans have come up

643
00:32:11,339 --> 00:32:17,549
不仅支持英语，还支持所有人类语言，
with that support not only English, but also all of the human languages,

644
00:32:17,549 --> 00:32:24,569
是理想的目标，无论是印刷形式还是电子形式都是目标。
is the aspirational goal, both written in print or electronically is the goal.

645
00:32:24,569 --> 00:32:28,239
除此之外，这就是说我们可以代表这样的事情。
And in addition to that, this is to say we can represent things like this.

646
00:32:28,240 --> 00:32:30,810
因此，这就是充满喜悦的眼泪的面孔。
So this is the so-called face with tears of joy.

647
00:32:30,809 --> 00:32:32,939
从去年开始，满脸欢乐的眼泪，
And this face of tears of joy, as of last year,

648
00:32:32,940 --> 00:32:37,240
是通过短信，电子邮件发送的最受欢迎的表情符号，
was the most popular emoji sent via text messages, emails,

649
00:32:37,240 --> 00:32:38,720
社交媒体等。
social media, and the like.

650
00:32:38,720 --> 00:32:40,170
但是到最后，你所收到的一切
But at the end of the day, all you're receiving

651
00:32:40,170 --> 00:32:41,500
就像键盘上的键一样。
is, like, a key on a keyboard.

652
00:32:41,500 --> 00:32:44,319
因此，实际上，你不会知道它。
So, in fact, you wouldn't know it to look at it.

653
00:32:44,319 --> 00:32:48,749
但实际上，代表此面孔的十进制数字
But in fact, the decimal number representing this face

654
00:32:48,750 --> 00:32:52,980
含着喜悦的眼泪恰好是128,514。
with tears of joy happens to be 128,514.

655
00:32:52,980 --> 00:32:56,220
因此，就凯文而言，不仅要代表某些人类语言，
So to Kevin's point, to represent not only certain human languages,

656
00:32:56,220 --> 00:33:00,910
但肯定这些表情符号，我们需要超过256个字符
but certainly these emojis, we need way more than 256 characters

657
00:33:00,910 --> 00:33:05,010
因此我们不仅可以使用8位，还可以使用16或24或32。
so we can use not just eight bits, but 16 or 24 or 32.

658
00:33:05,009 --> 00:33:06,954
现在有很多可能性。
That's a huge amount of possibilities now.

659
00:33:06,954 --> 00:33:09,329
实际上，现在，要真正从这些事情中获得乐趣，
In fact, now, to really take the fun out of these things,

660
00:33:09,329 --> 00:33:12,599
如果你带着喜悦的眼泪收到或发送这张脸，
if you receive that face with tears of joy or send it,

661
00:33:12,599 --> 00:33:16,701
从技术上讲，你只是发送一种看起来像这样的位模式。
you're technically just sending a pattern of bits that looks like this.

662
00:33:16,701 --> 00:33:18,659
这就是引擎盖下所有的一切，
That's all that's going on underneath the hood,

663
00:33:18,660 --> 00:33:20,300
每次你使用这些东西时。
every time you use these things.

664
00:33:20,299 --> 00:33:20,799
好的。
All right.

665
00:33:20,799 --> 00:33:22,619
因此，我们再次开始用电。
So we started again with electricity.

666
00:33:22,619 --> 00:33:24,401
然后，我们代表数字。
We then represented numbers.

667
00:33:24,402 --> 00:33:26,610
现在我们可以代表字母，甚至
Now we have the ability to represent letters and even

668
00:33:26,609 --> 00:33:28,469
表情符号形式的情绪。
emotions in the form of emojis.

669
00:33:28,470 --> 00:33:30,397
那里还有什么？
What else is there out there?

670
00:33:30,396 --> 00:33:33,479
好吧，表情符号本身，当然，至少我们已经看过了，
Well, the emojis themselves, of course, at least the ones we've looked at,

671
00:33:33,480 --> 00:33:35,652
本质上是图画。
are pictorial in nature.

672
00:33:35,652 --> 00:33:37,860
这就引出了一个问题，一台计算机如何
And so that invites the question, how does a computer

673
00:33:37,859 --> 00:33:39,209
代表颜色之类的东西？
represent things like color?

674
00:33:39,210 --> 00:33:42,150
就像，那张充满欢乐的眼泪的脸上充满了黄色。
Like, that face with tears of joy had a lot of yellow in it.

675
00:33:42,150 --> 00:33:46,140
那么，黄色或任何颜色如何在计算机中表示出来呢？
So how is yellow or any color, for that matter, represented in a computer?

676
00:33:46,140 --> 00:33:48,180
好吧，让我再次问听众。
Well, let me ask the audience again.

677
00:33:48,180 --> 00:33:52,800
如果你拥有的全部是零，零和一，
If all you have at your disposal is bits, zeros and ones,

678
00:33:52,799 --> 00:33:55,799
正如人类需要同意如何表现颜色一样，
and we just as humans need to agree how to represent colors,

679
00:33:55,799 --> 00:33:57,509
一种可能是什么？
what might be one possibility?

680
00:33:57,509 --> 00:33:59,439
不一定是答案。
It doesn't need to be the answer.

681
00:33:59,440 --> 00:34:03,360
但是，如果你是第一次设计，你的本能是什么？
But what might your own instinct be if designing this for the first time

682
00:34:03,359 --> 00:34:05,009
你自己？
yourself?

683
00:34:05,009 --> 00:34:09,979
现在计算机怎么能代表颜色？
How might a computer represent colors now?

684
00:34:09,980 --> 00:34:12,110
亚斯敏，你怎么看？
Yasmin, what do you think?

685
00:34:12,110 --> 00:34:14,989
听众：你希望成员使用不同的颜色和形状
AUDIENCE: You would like members to different colors and shapes

686
00:34:14,989 --> 00:34:16,602
并做同样的系统。
and just do the same system.

687
00:34:16,601 --> 00:34:17,809
DAVID J MALAN：好的，是的。
DAVID J MALAN: Yeah, exactly.

688
00:34:17,809 --> 00:34:18,559
完美的直觉。
Perfect instincts.

689
00:34:18,559 --> 00:34:21,019
你只需将数字分配给不同的颜色，
You would just assign numbers to the different colors,

690
00:34:21,019 --> 00:34:24,676
我们都只需要就该映射的实际含义达成共识。
and we all just have to agree on what that mapping is actually going to be.

691
00:34:24,677 --> 00:34:26,760
事实证明，有不同的方法可以做到这一点。
So it turns out there's different ways to do this.

692
00:34:26,760 --> 00:34:30,530
而且，如果你中的任何人具有艺术性，并以数字方式使用Photoshop或类似工具，
And if any of you are artistic and use Photoshop or the like digitally,

693
00:34:30,530 --> 00:34:34,010
你可能熟悉RGB，红色，绿色，蓝色等首字母缩写词。
you're probably familiar with acronyms like RGB, red, green, blue.

694
00:34:34,010 --> 00:34:36,199
但是还有其他首字母缩写词和其他方式
But there are other acronyms and other ways

695
00:34:36,199 --> 00:34:39,590
实施Yasmin的想法，我们以某种方式将其映射
to implement Yasmin's idea where we just somehow map

696
00:34:39,590 --> 00:34:41,780
零和一为实际颜色。
zeros and ones to actual colors.

697
00:34:41,780 --> 00:34:45,120
好吧，RGB恰好代表红色，绿色和蓝色。
Well, RGB just happens to represent red, green, and blue.

698
00:34:45,119 --> 00:34:48,319
这是人类几年前想出的一个系统，说，你知道吗？
And this is a system humans came up with years ago that says, you know what?

699
00:34:48,320 --> 00:34:50,510
我们实际上可以得到彩虹的每种颜色
We can actually get every color of the rainbow

700
00:34:50,510 --> 00:34:55,370
基本上是将一些红色，绿色和蓝色的光混合在一起。
by mixing together some amount of red and green and blue light, essentially.

701
00:34:55,369 --> 00:34:58,729
因此，这引发了一个问题，好吧，我们如何表示红色的数量，
So that just invites the question, well, how do we represent the amount of red,

702
00:34:58,730 --> 00:35:00,980
我们如何表示绿色的数量，以及我们如何
how do we represent the amount of green, and how do we

703
00:35:00,980 --> 00:35:02,720
代表蓝色的数量？
represent the amount of blue?

704
00:35:02,719 --> 00:35:05,759
正如Yasmin所说，我们还有一些可用的工具。
And we have, as Yasmin says, bits at our disposal.

705
00:35:05,760 --> 00:35:07,470
因此，我们只需要决定如何执行此操作即可。
So we just have to decide how to do this.

706
00:35:07,469 --> 00:35:12,319
因此，假设我们收到了一种位模式，即72、73、33，
So suppose we receive a pattern of bits, that 72, 73, 33 again,

707
00:35:12,320 --> 00:35:13,940
但是这次不是电子邮件。
but this time it's not an email.

708
00:35:13,940 --> 00:35:15,320
它不在短信中。
It's not in a text message.

709
00:35:15,320 --> 00:35:19,020
这是在Photoshop中打开的文件的上下文中。
It's in the context of a file that I've opened in Photoshop.

710
00:35:19,019 --> 00:35:21,649
好像我打开了一张照片，有人
So it's as though I've opened up a photograph that someone

711
00:35:21,650 --> 00:35:26,030
发送给我，我想进行一些编辑，我看到这种数字模式，
sent me and I want to do some editing and I see this pattern of numbers,

712
00:35:26,030 --> 00:35:27,170
或位。
or, in turn, bits.

713
00:35:27,170 --> 00:35:29,420
好吧，在这种情况下代表什么？
Well, what is that representing in this case?

714
00:35:29,420 --> 00:35:32,300
在电子邮件或短信中，它仍然是HI！
In the context of an email or a text message, it's still HI!

715
00:35:32,300 --> 00:35:34,670
但是在Photoshop或Instagram的背景下
But in the context of Photoshop or Instagram

716
00:35:34,670 --> 00:35:37,190
或任何围绕图像的内容，
or anything that is oriented around images,

717
00:35:37,190 --> 00:35:40,730
它实际上将代表一定数量的红色，一定数量的绿色，
it's actually going to represent some amount of red, some amount of green,

718
00:35:40,730 --> 00:35:41,870
一些蓝色。
some amount of blue.

719
00:35:41,869 --> 00:35:45,229
正如我们之前发现的，总数
And as we discovered earlier, the total number

720
00:35:45,230 --> 00:35:49,340
你可以用8位表示的可能性恰好是256。
of possibilities you can represent with eight bits happens to be 256.

721
00:35:49,340 --> 00:35:54,200
如果我们从零开始计数，则可以代表的最大值是255。
The highest value you can represent is 255 if we start counting from zero.

722
00:35:54,199 --> 00:35:56,659
所以这就是说这三个数字
So this is to say that each of these three numbers

723
00:35:56,659 --> 00:35:59,339
是介于0到255之间的数字。
is a number between zero and 255.

724
00:35:59,340 --> 00:36:04,640
所以72感觉像是中等数量的红色，73感觉像是中等数量的绿色，33
So 72 feels like a medium amount of red, 73 is like a medium amount of green, 33

725
00:36:04,639 --> 00:36:06,089
有点蓝。
is a little bit of blue.

726
00:36:06,090 --> 00:36:10,610
如果将这三种颜色组合起来，则八位加八
And if you combine those three amounts of color, eight bits plus eight

727
00:36:10,610 --> 00:36:13,460
位加8位，总共使用24位，
bits plus eight bits, using 24 bits total,

728
00:36:13,460 --> 00:36:16,880
用前三分之一表示红色，后三分之一表示绿色，
using the first third to represent redness, the second third greenness,

729
00:36:16,880 --> 00:36:20,540
结果是三分之一到三度发蓝，
and the third third blueness, you get, it turns out,

730
00:36:20,539 --> 00:36:24,539
像这样的一个点，一个黄色的点。
a dot that looks like this, a yellow dot.

731
00:36:24,539 --> 00:36:27,799
因此，当表情符号显示在屏幕上时，
And so, indeed, that emoji, when it's being displayed on the screen,

732
00:36:27,800 --> 00:36:30,380
是计算机解释的结果-
is the result of the computer interpreting--

733
00:36:30,380 --> 00:36:35,120
128,514的值是知道的，哦，这就是表情符号
the 128,514 value is knowing oh, that's the emoji

734
00:36:35,119 --> 00:36:36,769
带着喜悦的眼泪。
with the face of tears of joy.

735
00:36:36,769 --> 00:36:39,469
但是当涉及到在屏幕上显示信息时，
But when it comes to displaying the information on your screen,

736
00:36:39,469 --> 00:36:42,859
现在你的计算机将使用不同的位模式
now your computer is going to be using different patterns of bits

737
00:36:42,860 --> 00:36:45,428
控制屏幕上点的颜色。
to control the colors of the dots on the screen.

738
00:36:45,427 --> 00:36:46,969
这个词你可能已经知道了。
And this term you might already know.

739
00:36:46,969 --> 00:36:50,239
这些天，你和我在计算机屏幕甚至电视上看到的圆点
The dots you and I see on our computer screens or even TVs these days

740
00:36:50,239 --> 00:36:51,229
被称为像素。
are called pixels.

741
00:36:51,230 --> 00:36:55,250
它们是代表一些颜色的微小小方块
They're tiny little squares that represent some color

742
00:36:55,250 --> 00:36:56,600
例如这里的黄色。
such as this yellow one here.

743
00:36:56,599 --> 00:36:58,859
你实际上可以在某些情况下看到它们。
And you can actually see them in some contexts.

744
00:36:58,860 --> 00:37:02,930
如果我继续前进，用喜悦的眼泪将同一张脸抬起并放大一点，
If I go ahead and pull up the same face with tears of joy and zoom in a bit,

745
00:37:02,929 --> 00:37:05,419
再放大一点，实际上再放大一点，
zoom in a bit more, and really zoom in a bit more,

746
00:37:05,420 --> 00:37:07,857
现在你实际上可以看到我们所谓的像素化。
now you can actually see what we call pixelation.

747
00:37:07,856 --> 00:37:10,189
很有可能，你已经在Facebook，Instagram，
And odds are, you have seen this on Facebook, Instagram,

748
00:37:10,190 --> 00:37:13,790
无论你在什么地方调整尺寸或编辑不太合适的照片
wherever you might be resizing or editing photos that don't quite

749
00:37:13,789 --> 00:37:15,209
有足够的分辨率。
have enough resolution.

750
00:37:15,210 --> 00:37:18,740
图像的分辨率就是那里的像素或点数
The resolution of an image is just how many pixels or dots there

751
00:37:18,739 --> 00:37:20,999
是水平和垂直的。
are horizontally and vertically.

752
00:37:21,000 --> 00:37:25,379
因此，如果你真正放大图像，最终将看到这些像素。
So if you really zoom in on an image, you'll eventually see those pixels.

753
00:37:25,380 --> 00:37:29,510
这就是说，即使在这张放大的笑脸中，
And this is to say that even in this zoomed-in happy face,

754
00:37:29,510 --> 00:37:32,090
有大量的黄点和一大堆
there's a huge number of yellow dots and a whole bunch

755
00:37:32,090 --> 00:37:34,880
黑色，灰色和棕褐色的点也是如此
of black and gray and brownish dots as well

756
00:37:34,880 --> 00:37:38,210
构成了这个非常彩色的图像。
that compose this very colorful image.

757
00:37:38,210 --> 00:37:41,450
这样一来，你就可以看到它们，现在每个点都可以看到，
And so you can see them in that case, and every one of those dots now,

758
00:37:41,449 --> 00:37:47,069
我声称一个像素正在使用24位或3个字节。
a pixel, is using, I claim, like 24 bits or three bytes.

759
00:37:47,070 --> 00:37:51,320
现在，你可以想象，可能有数百个点
Now, you can imagine, there's probably what, hundreds, maybe thousands of dots

760
00:37:51,320 --> 00:37:54,740
在该图像中，如果我们缩小并再次查看所有图像。
in that image if we zoom out and look at all of them again.

761
00:37:54,739 --> 00:37:58,139
因此，如果这些点或像素中的每一个都是三个字节，
So if every one of those dots or pixels is three bytes,

762
00:37:58,139 --> 00:38:00,889
这就是为什么我和你拍照的原因
this is why the photographs you and I take

763
00:38:00,889 --> 00:38:03,049
以及你和我从互联网上下载的图像
and the images you and I download from the internet

764
00:38:03,050 --> 00:38:06,590
通常通常不以字节为单位来度量，而是以千字节为单位，
are typically measured not even in bytes, per se, but in kilobytes,

765
00:38:06,590 --> 00:38:09,830
成千上万个字节，或者兆字节上百万个字节，
for thousands of bytes, or megabytes for millions of bytes,

766
00:38:09,829 --> 00:38:14,119
或者如果是视频文件，则可能会更大，数十亿或千兆字节。
or if it's a video file, it might get even bigger, billions, or gigabytes.

767
00:38:14,119 --> 00:38:17,329
但这就是引擎盖下发生的全部事情。
But that's all that is happening underneath the hood.

768
00:38:17,329 --> 00:38:20,239
我们只是以这种方式表示信息。
We're just representing information in this way.

769
00:38:20,239 --> 00:38:22,039
好吧，现在让我问一个后续问题。
Well, let me ask a follow up question now.

770
00:38:22,039 --> 00:38:26,359
如果我们现在有了Yasmin，代表了颜色，
If we've now, thanks to Yasmin, represented colors,

771
00:38:26,360 --> 00:38:30,680
进而是图像，因为所有图像都是一个像素网格。
and in turn, images, because all an image is is a grid of pixels.

772
00:38:30,679 --> 00:38:32,959
你采用Yasmin提出的相同原则，
You take the same principle Yasmin proposed,

773
00:38:32,960 --> 00:38:36,710
你代表一个点的每种颜色，并且有一堆点
where you represent each color of a dot and you have a whole bunch of dots that

774
00:38:36,710 --> 00:38:41,750
给我们提供图像，你如何建议计算机代表视频文件？
gives us images, how would you propose computers represent video files?

775
00:38:41,750 --> 00:38:44,629
同样，即使你不知道答案，怎么办
Again, even if you don't know the answer, how might

776
00:38:44,630 --> 00:38:50,030
一台计算机现在仅使用位来表示视频文件
a computer represent video files now using, again, only bits

777
00:38:50,030 --> 00:38:52,630
在他们的处置？
at their disposal?

778
00:38:52,630 --> 00:38:55,030
谁会喜欢这个？
Who might like to field this one?

779
00:38:55,030 --> 00:38:59,110
计算机如何代表视频？
How might a computer represent a video?

780
00:38:59,110 --> 00:39:01,240
贾斯汀，你怎么看？
Justin, what do you think?

781
00:39:01,239 --> 00:39:04,801
听众：我-也许只是在迅速改变自己的口感？
AUDIENCE: I-- maybe just, like, rapidly changing the bites?

782
00:39:04,802 --> 00:39:06,760
DAVID J MALAN：只是在迅速改变话题。
DAVID J MALAN: Just rapidly changing the bites.

783
00:39:06,760 --> 00:39:08,680
我听说-你能详细说明一下吗？
I hear-- can you elaborate a little bit?

784
00:39:08,679 --> 00:39:11,349
改变口语是什么意思？
What do you mean by changing the bites?

785
00:39:11,349 --> 00:39:17,581
听众：就像快速改变单个像素的RGB一样，
AUDIENCE: Like rapidly changing the RGB of individual pixels--

786
00:39:17,581 --> 00:39:18,539
大卫·J·马兰（David J MALAN）：好的。
DAVID J MALAN: Exactly.

787
00:39:18,539 --> 00:39:22,679
听众：-匹配那秒钟的图像
AUDIENCE: --to match the image of that second

788
00:39:22,679 --> 00:39:24,569
视频或视频的一部分。
of the video or portion of the video.

789
00:39:24,570 --> 00:39:25,060
DAVID J MALAN：完美。
DAVID J MALAN: Perfect.

790
00:39:25,059 --> 00:39:27,519
因此，如果你考虑使用像手机这样的矩形屏幕，
So if you think about, like, the rectangular screen that is your phone,

791
00:39:27,519 --> 00:39:29,909
或笔记本电脑或台式机显示器（如果你只是
or your laptop, or your desktop monitor, if you just

792
00:39:29,909 --> 00:39:33,419
每秒更改一次这些点的颜色
keep changing the colors of those dots once per second

793
00:39:33,420 --> 00:39:35,460
或每秒一整堆的时间，我们将
or a whole bunch of times per second, we'll

794
00:39:35,460 --> 00:39:39,690
感觉到屏幕上确实有运动，所以是视频。
get the illusion that there's actually motion on the screen, ergo video.

795
00:39:39,690 --> 00:39:43,950
所以说真的，从某种意义上讲，视频只是一堆图像，
So really, a video, in some sense, it's just a whole bunch of images,

796
00:39:43,949 --> 00:39:47,749
达到Yasmin的定义，可以非常迅速地在屏幕上飞行。
to Yasmin's definition, flying across the screen really quickly.

797
00:39:47,750 --> 00:39:49,679
这样你就可以看到这种甚至古老的学校风格。
And so you can see this even old school style.

798
00:39:49,679 --> 00:39:52,169
例如，让我继续并在屏幕上打开
For instance, let me go ahead and open up on my screen

799
00:39:52,170 --> 00:39:54,940
代表翻书的简短视频。
a short video that represents a flipbook.

800
00:39:54,940 --> 00:39:57,690
因此，你可能在小时候就已经成为其中之一，或者你可能是你的老师
So you might have made one of these as a kid or maybe your teacher

801
00:39:57,690 --> 00:40:00,510
或至少在某个地方亲眼看到了它们。
did or you saw them, at least, in person somewhere.

802
00:40:00,510 --> 00:40:04,380
如果要拿一大堆纸和钉书钉
Where if you take a whole bunch of pieces of paper and staple

803
00:40:04,380 --> 00:40:08,190
或以某种方式将它们剪裁在一起，绘制大量图片，所有这些
or clip them together in some way, draw a whole lot of pictures, all of which

804
00:40:08,190 --> 00:40:11,650
在每一页上相似但略有不同，
are similar but slightly different on each page,

805
00:40:11,650 --> 00:40:14,910
你可以创建动画，或者实际上是视频。
you can create an animation, or, really, a video.

806
00:40:14,909 --> 00:40:17,449
这就是纯电子世界中的所有视频。
And this is all a video is in a purely electronic world.

807
00:40:17,449 --> 00:40:19,199
即使恰好实现了
Even though this happens to be implemented

808
00:40:19,199 --> 00:40:22,199
在纸上，计算机世界会发生什么
in paper, what happens in the computer world

809
00:40:22,199 --> 00:40:24,329
确实只是整个图像序列
is indeed just a whole sequence of images

810
00:40:24,329 --> 00:40:26,829
以一定的速度飞过屏幕。
flying across the screen at some rate.

811
00:40:26,829 --> 00:40:30,796
这就是实际上为我们提供了你我今天所知道的视频文件的原因。
And that's what actually gives us the video files that you and I know today.

812
00:40:30,797 --> 00:40:32,880
而且还有更多的兔子洞我们可以下去。
And there's even more rabbit holes we can go down.

813
00:40:32,880 --> 00:40:34,860
例如，你将如何表现音乐？
For instance, how might you represent music?

814
00:40:34,860 --> 00:40:37,350
好吧，音乐可以用不同的方式表现出来。
Well, music, could be represented, gosh, in different ways.

815
00:40:37,349 --> 00:40:39,469
例如，如果你弹钢琴，
Like, if you play the piano, for instance, you

816
00:40:39,469 --> 00:40:41,552
可能知道有些音符，例如A到G。
might know that there are notes, like A through G.

817
00:40:41,552 --> 00:40:43,739
但是也有尖锐的东西和平坦的东西等等。
But there's also sharps and flats and so forth.

818
00:40:43,739 --> 00:40:44,489
但是你知道吗？
But you know what?

819
00:40:44,489 --> 00:40:48,509
也许我们只需要一个数字来表示每个可能的注释。
Maybe we just need a number to represent each of those possible notes.

820
00:40:48,510 --> 00:40:51,660
也许我们也可以使用其他数字，
And maybe also we could use another number,

821
00:40:51,659 --> 00:40:55,019
就像图像使用多个数字来表示点一样，
just like images use multiple numbers to represent dots,

822
00:40:55,019 --> 00:40:57,779
我们可以用数字来代表歌曲中的音符，
we could use a number to represent the notes in a song,

823
00:40:57,780 --> 00:41:01,560
而且还有一个数字代表该音符的持续时间。
but also another number to represent the duration of that note.

824
00:41:01,559 --> 00:41:05,146
你应该听到该音符多少秒，毫秒或节拍。
How many seconds or milliseconds or beats should you hear that note for.

825
00:41:05,146 --> 00:41:07,229
因此，你也可以提出其他公式，
So you could come up with other formulations, too,

826
00:41:07,230 --> 00:41:11,250
但实际上，音乐可以在计算机世界中量化
but music, really, can be quantized in the world of computers

827
00:41:11,250 --> 00:41:13,330
只是一小部分信息。
into just small pieces of information.

828
00:41:13,329 --> 00:41:16,109
只要你我同意如何代表它，
And so long as you and I agree on how to represent it,

829
00:41:16,110 --> 00:41:17,640
这些都是这样的。
that's how these things all work.

830
00:41:17,639 --> 00:41:23,399
如果你曾经想知道为什么会有JPEG，PNG，GIF和Word
And if you've ever wondered why there are JPEGs and PNGs and GIFs and Word

831
00:41:23,400 --> 00:41:27,750
文档和Excel文件以及所有这些不同的文件格式或文件
documents and Excel files and all of these different file formats or file

832
00:41:27,750 --> 00:41:32,639
计算机上的扩展名，这些文件扩展名或格式仅
extensions on computers, those file extensions or formats just

833
00:41:32,639 --> 00:41:35,249
代表一大堆人同意
represent a whole bunch of humans agreeing

834
00:41:35,250 --> 00:41:38,430
如何在文件中存储零和一的模式
how to store patterns of zeros and ones in a file

835
00:41:38,429 --> 00:41:43,529
这样，当这些零和一被加载到计算机中进行显示时
so that when those zeros and ones are loaded into a computer for display

836
00:41:43,530 --> 00:41:47,460
或为了解释，它知道这些模式代表什么。
or for interpretation, it knows what those patterns represent.

837
00:41:47,460 --> 00:41:49,572
图像的表示方式略有不同，
Images are represented slightly differently,

838
00:41:49,572 --> 00:41:51,780
声音和视频的表示方式略有不同，
sound and video are represented slightly differently,

839
00:41:51,780 --> 00:41:54,820
但是一天结束时都是零和一。
but it's all zeros and ones at the end of the day.

840
00:41:54,820 --> 00:41:59,400
这就是说，只要我们都同意，最好是在世界范围内，
So this is all to say, so long as we all agree, ideally around the world,

841
00:41:59,400 --> 00:42:03,180
如何表示信息，现在我们可以表示问题的输入
how to represent information, now we can represent inputs to problems

842
00:42:03,179 --> 00:42:05,789
并希望解决问题并获得产出。
and hopefully solve problems and get outputs.

843
00:42:05,789 --> 00:42:09,959
因此，所有这些问题仍然存在于解决问题的过程中，或者实际上是在计算机科学领域，
So all that remains in problem solving, or really, computer science broadly,

844
00:42:09,960 --> 00:42:14,950
就是要看这个黑匣子的内部，并考虑如何进行输入，
is to look inside of this black box and to consider how you take inputs,

845
00:42:14,949 --> 00:42:18,809
无论是数字，字母，图像，视频，声音，
whether it's numbers, letters, images, video, sound,

846
00:42:18,809 --> 00:42:21,929
并将其转换为实际的解决方案。
and convert them into actual solutions.

847
00:42:21,929 --> 00:42:24,419
所以在这个黑匣子的内部，我们通常会
And so inside of this black box is what we would typically

848
00:42:24,420 --> 00:42:26,100
描述为算法。
describe as algorithms.

849
00:42:26,099 --> 00:42:30,249
算法是解决问题的分步说明。
Algorithms are step by step instructions for solving problems.

850
00:42:30,250 --> 00:42:32,010
他们甚至不必参与计算机。
They don't even have to involve computers.

851
00:42:32,010 --> 00:42:36,630
我们人类只需遵循别人的指令就可以执行算法。
We humans can execute algorithms just by following someone else's instructions.

852
00:42:36,630 --> 00:42:40,350
如果你曾经按照食谱制作食谱，
If you've ever prepared something from a cookbook, following a recipe,

853
00:42:40,349 --> 00:42:43,169
你正在逐步执行算法。
you are executing an algorithm step by step.

854
00:42:43,170 --> 00:42:46,170
但是不像很多食谱或者不像很多
But unlike a lot of recipes or unlike a lot

855
00:42:46,170 --> 00:42:48,880
人类相互之间的指示，
of instructions that we humans give to each other,

856
00:42:48,880 --> 00:42:51,330
计算机中没有歧义的余地。
there's no room for ambiguity in computers.

857
00:42:51,329 --> 00:42:54,359
由机器实施的计算机算法，
Computers' algorithms, when implemented by machines,

858
00:42:54,360 --> 00:42:56,910
他们不仅必须正确，所以
they really have to be not only correct so

859
00:42:56,909 --> 00:42:59,069
得到你所关心的正确输出，
that you get the right outputs that you care about,

860
00:42:59,070 --> 00:43:01,170
但它们也需要精确。
but they also need to be precise.

861
00:43:01,170 --> 00:43:04,590
你需要如此精确，因为与我们人类不同的是，
You need to be ever so precise, because unlike we humans who can kind of like

862
00:43:04,590 --> 00:43:06,990
在两行之间阅读，是的，我明白了你的意思，
read between the lines and, yeah, I get what you mean,

863
00:43:06,989 --> 00:43:09,069
电脑将带你从字面上看。
computers are going to take you literally.

864
00:43:09,070 --> 00:43:13,320
因此，在对计算机进行编程（即翻译算法）时，
And so when programming a computer, that is, translating an algorithm,

865
00:43:13,320 --> 00:43:16,290
逐步说明，将其翻译成计算机可以理解的某种语言，
step by step instructions, into some language the computer understands,

866
00:43:16,289 --> 00:43:20,909
你有责任确保计算机不会误解你的意思
the onus is on you to make sure that the computer cannot misinterpret what you

867
00:43:20,909 --> 00:43:21,459
想。
want.

868
00:43:21,460 --> 00:43:23,170
因此，让我们考虑一种这样的算法。
So let's consider one such algorithm.

869
00:43:23,170 --> 00:43:26,190
因此，在我们所有的手机（无论是iOS还是Android或类似设备）上，
So on all of our phones, whether iOS or Android or the like,

870
00:43:26,190 --> 00:43:28,217
你有一些联系人应用程序。
you have some contacts application.

871
00:43:28,217 --> 00:43:31,050
该联系人应用程序可能存储了你所有的朋友
And that contacts application's probably storing all of your friends

872
00:43:31,050 --> 00:43:33,810
以及家人和同事，可能是按字母顺序。
and family members and colleagues, probably alphabetically.

873
00:43:33,809 --> 00:43:36,449
也许是名字，也许是姓氏，或者
Maybe by first name, maybe by last name, or however

874
00:43:36,449 --> 00:43:37,979
你已经整理好了该设备。
you've organized that device.

875
00:43:37,980 --> 00:43:40,590
好吧，这种情况的旧版本
Well, the old school version of this happens

876
00:43:40,590 --> 00:43:44,170
变成纸质的，看起来像这样的东西，一部电话
to be in paper form, which looks a little something like this, a phone

877
00:43:44,170 --> 00:43:44,670
书。
book.

878
00:43:44,670 --> 00:43:48,280
在一本老学校电话簿中确实是完全一样的主意。
And inside of an old school phone book really is that exact same idea.

879
00:43:48,280 --> 00:43:49,060
它更大。
It's much larger.

880
00:43:49,059 --> 00:43:51,019
它的印刷更多。
It's much more much more printed.

881
00:43:51,019 --> 00:43:52,019
但这是同一回事。
But it's the same thing.

882
00:43:52,019 --> 00:43:54,811
典型的电话簿中有一堆名字和电话号码，
There's a whole bunch of names and numbers in a typical phone book,

883
00:43:54,811 --> 00:43:59,279
就像你自己的Android手机或iOS一样，按字母顺序排序
sorted alphabetically just like your own Android phone or iOS

884
00:43:59,280 --> 00:44:00,697
手机也可以。
phone might be as well.

885
00:44:00,697 --> 00:44:02,280
因此，假设我们要解决一个问题。
So suppose we want to solve a problem.

886
00:44:02,280 --> 00:44:05,340
这个问题的输入不仅是电话簿，还有
And the input to that problem is not only this phone book, but also

887
00:44:05,340 --> 00:44:07,710
查找号码的人的名字。
the name of someone to look up the number for.

888
00:44:07,710 --> 00:44:08,980
因此，例如我自己的名字。
So my own name, for instance.

889
00:44:08,980 --> 00:44:12,660
如果我想查找我的电话号码，或者你愿意，可以打开这本书
If I want to look up my phone number, or you do, you might open up this book

890
00:44:12,659 --> 00:44:14,709
然后开始寻找戴维（David），
and start looking for David, for instance,

891
00:44:14,710 --> 00:44:16,770
如果我们假设它是按名字排序的。
if we assume that it's sorted by first name.

892
00:44:16,769 --> 00:44:20,019
我在第一页上没有看到David，所以我继续第二页。
I don't see David on the first page, so I move on to the second.

893
00:44:20,019 --> 00:44:22,389
我在那儿看不到自己，所以我继续前进到第三位。
I don't see myself there, so I move on to the third.

894
00:44:22,389 --> 00:44:25,119
我在那儿看不到自己，所以我继续前进到第四名。
I don't see myself there so I move on to the fourth.

895
00:44:25,119 --> 00:44:29,349
依此类推，一次一页，寻找我的名字，然后，
And so forth, one page at a time, looking for my name and, in turn,

896
00:44:29,349 --> 00:44:30,679
我的号码。
my number.

897
00:44:30,679 --> 00:44:34,119
好吧，如果正确性很重要-让我先问这个问题。
Well, if correctness is important-- let me ask that question first.

898
00:44:34,119 --> 00:44:37,059
是这种算法，一步一步地翻页，
Is this algorithm, turning the pages, step by step,

899
00:44:37,059 --> 00:44:40,729
寻找大卫正确吗？
looking for David correct?

900
00:44:40,730 --> 00:44:41,480
你怎么认为？
What do you think?

901
00:44:41,480 --> 00:44:45,680
在Zoom中，你应该在参与者下方看到一些图标
Within Zoom, you should see some icons under the participants

902
00:44:45,679 --> 00:44:47,819
标有“是”和“否”的窗口。
window labeled yes and no.

903
00:44:47,820 --> 00:44:53,480
如果你想继续进行虚拟投票，是或否，
If you'd like to go ahead and vote virtually, yes or no,

904
00:44:53,480 --> 00:44:55,670
这个算法正确吗？
is this algorithm correct?

905
00:44:55,670 --> 00:44:59,390
一次一页，寻找自己。
One page at a time, looking for myself.

906
00:44:59,389 --> 00:45:01,369
没关系，这是黄页的事实，
Never mind the fact that this is yellow pages,

907
00:45:01,369 --> 00:45:03,979
所以我不会在电话簿中的任何地方，
and so I'm not going to be anywhere in the phone book,

908
00:45:03,980 --> 00:45:07,830
但实际上，我们将假定它也包含人类。
but indeed, we'll assume it contains humans as well.

909
00:45:07,829 --> 00:45:08,479
好的。
All right.

910
00:45:08,480 --> 00:45:13,430
所以看起来算法确实是正确的，
So it looks like the algorithm is indeed correct,

911
00:45:13,429 --> 00:45:15,559
但是它非常缓慢。
but it's terribly, terribly slow.

912
00:45:15,559 --> 00:45:18,169
没关系，因为我们的想法之一
And that's OK, because one of the ideas we're

913
00:45:18,170 --> 00:45:21,590
在CS50中考虑，然后在计算机科学中考虑，
going to consider in CS50 and in turn, computer science,

914
00:45:21,590 --> 00:45:25,040
不仅是算法的正确性，而且是效率。
is not only the correctness of an algorithm, but also the efficiency.

915
00:45:25,039 --> 00:45:27,319
算法设计得如何？
How well designed is the algorithm?

916
00:45:27,320 --> 00:45:28,070
这是对的。
This is correct.

917
00:45:28,070 --> 00:45:31,040
这是令人难以置信的，令人难以置信的乏味和缓慢的。
It's just incredibly, incredibly tedious and slow.

918
00:45:31,039 --> 00:45:32,034
但是我会发现自己。
But I will find myself.

919
00:45:32,034 --> 00:45:33,409
但是，当然，我们可以做得更好。
But, of course, we can do better.

920
00:45:33,409 --> 00:45:37,189
而不是一次只找自己一页，我为什么不做一页，
Instead of looking for myself one page at a time, why don't I do one page,

921
00:45:37,190 --> 00:45:40,790
我来做两个，四个，六个，八个，十个
let me do two, four, six, eight, 10.

922
00:45:40,789 --> 00:45:42,259
听起来更快，也更快。
It sounds faster and it is faster.

923
00:45:42,260 --> 00:45:45,320
我正在翻遍电话簿以查找自己的速度快一倍。
I'm going twice as fast through the phone book looking for myself.

924
00:45:45,320 --> 00:45:46,640
这个算法正确吗？
Is this algorithm correct?

925
00:45:46,639 --> 00:45:48,709
这次让我去听众。
Let me go to someone in the audience this time.

926
00:45:48,710 --> 00:45:52,550
这是一次一次在两个页面上搜索某人姓名的算法吗
Is this algorithm of searching for someone's name two pages at a time

927
00:45:52,550 --> 00:45:53,300
正确的？
correct?

928
00:45:53,300 --> 00:45:55,070
因为我声称这样更有效。
Because I claim it's more efficient.

929
00:45:55,070 --> 00:45:59,630
我声称它的设计更好，因为我能以两倍快的速度解决问题。
I claim it's better designed because I'll solve the problem twice as fast.

930
00:45:59,630 --> 00:46:00,800
阿内卡，你怎么看？
Aneka, what do you think?

931
00:46:00,800 --> 00:46:03,373
听众：否，因为你可能会跳过页面上的名字。
AUDIENCE: No, because you might skip your name on a page.

932
00:46:03,373 --> 00:46:05,540
DAVID J MALAN：是的，我可能会在页面上跳过我的名字。
DAVID J MALAN: Yeah, I might skip my name on a page.

933
00:46:05,539 --> 00:46:07,289
让我问一个后续问题。
And let me ask a follow up question.

934
00:46:07,289 --> 00:46:07,929
我可以解决这个问题吗？
Can I fix this?

935
00:46:07,929 --> 00:46:09,679
我是否必须放弃整个算法
Do I have to throw out the whole algorithm

936
00:46:09,679 --> 00:46:11,779
还是我们至少可以解决这个问题，你认为吗？
or can we at least fix this problem, do you think?

937
00:46:11,780 --> 00:46:15,285
观众：我认为无论你翻到哪一页，都会有帮助，
AUDIENCE: I think whatever page you flip to, it would help to see,

938
00:46:15,284 --> 00:46:17,659
例如，那里有什么名字，也许看看你的名字会不会
like, what name is there and maybe see if your name would

939
00:46:17,659 --> 00:46:18,889
之前或之后
come before or after.

940
00:46:18,889 --> 00:46:19,339
DAVID J MALAN：好的。
DAVID J MALAN: Nice.

941
00:46:19,340 --> 00:46:20,850
所以这是正确的直觉。
So that's exactly the right intuition.

942
00:46:20,849 --> 00:46:23,724
我认为我们不必完全放弃加速的想法
I don't think we have to completely sacrifice the idea of speeding up

943
00:46:23,724 --> 00:46:25,679
这种算法的移动速度是以前的两倍。
this algorithm by moving twice as fast.

944
00:46:25,679 --> 00:46:29,569
但是，正如你所提议的那样，如果我走得太远，也许我会进入E部分，
But as you propose, if I go too far-- maybe I get to the E section,

945
00:46:29,570 --> 00:46:30,920
太迟了一个字母-
which is one letter too late--

946
00:46:30,920 --> 00:46:33,110
我应该至少翻回一页。
I should at least double back one page.

947
00:46:33,110 --> 00:46:35,210
因为我可能会倒霉，也许是大卫
Because I could get unlucky, and maybe David

948
00:46:35,210 --> 00:46:37,863
有点夹在两页之间，这时
is kind of sandwiched in between two pages, at which point

949
00:46:37,862 --> 00:46:41,029
我可能飞过去，走到电话簿的结尾，说，不，没有大卫，
I might fly by, get to the end of the phone book, say, no, there's no David,

950
00:46:41,030 --> 00:46:43,910
而且我不幸的是有50％的概率。
and I just got unlucky with 50% probability.

951
00:46:43,909 --> 00:46:47,359
但是，正如你所提议的，我至少可以恢复并有条件地进行
But as you propose, I can at least recover and sort of conditionally

952
00:46:47,360 --> 00:46:50,270
问自己，等一下，也许我只是错过了，然后再回头。
ask myself, wait a minute, maybe I just missed it, and double back.

953
00:46:50,269 --> 00:46:52,829
这样我可以整体上提高速度，
So I can get the overall speed improvement,

954
00:46:52,829 --> 00:46:55,699
但是至少可以解决这种错误或错误。
but then at least fix that kind of mistake or bug.

955
00:46:55,699 --> 00:46:57,919
错误，是我们在编程中的一个术语，一个错误
And bug, a term of our-- in programming, a bug

956
00:46:57,920 --> 00:47:00,080
仅仅是程序中的一个错误，或者更多
is just a mistake in a program, or a mistake, more

957
00:47:00,079 --> 00:47:01,204
通常，在算法中。
generally, in an algorithm.

958
00:47:01,204 --> 00:47:03,121
但老实说，我们谁也不会这样做。
But honestly, none of us are going to do that.

959
00:47:03,121 --> 00:47:05,599
当我们实际去搜索电话簿中的某人时，
When we actually go to search for someone in a phone book,

960
00:47:05,599 --> 00:47:09,289
就像我们的手机一样，它们通常不会从顶部开始
just like our phones do, they typically don't start at the top

961
00:47:09,289 --> 00:47:10,429
并转到底部。
and go to the bottom.

962
00:47:10,429 --> 00:47:13,159
而且计算机可以更直观地完成你可能要做的事情。
And computers do exactly what you might do more intuitively.

963
00:47:13,159 --> 00:47:14,929
他们大概会走到中间。
They'll probably go roughly to the middle.

964
00:47:14,929 --> 00:47:16,639
如果你知道的话，也许他们会向左倾斜一点
Maybe they'll skew a little to the left, if you know

965
00:47:16,639 --> 00:47:18,229
D朝向字母的开头。
D is toward the start of an alphabet.

966
00:47:18,230 --> 00:47:21,980
但是，不，我很随意地向中间开放，我处于M部分。
But, no I open to the middle sort of sloppily, and I'm in the M section.

967
00:47:21,980 --> 00:47:25,130
那么，当我进入M部分时，该怎么办？
So what do I know when I'm in the M section about this problem?

968
00:47:25,130 --> 00:47:26,990
让我再请一个人。
Let me call on one more person.

969
00:47:26,989 --> 00:47:28,159
我在M部分。
I'm in the M section.

970
00:47:28,159 --> 00:47:31,969
作为解决此问题的输入，你现在将如何做一个人？
What would you do as a human now, taking this as input to solve this problem?

971
00:47:31,969 --> 00:47:39,529
我当然知道电话簿中我的名字的位置？
What do I know about the location, of course, of my name in the phone book?

972
00:47:39,530 --> 00:47:43,040
我可以在这里做出什么决定？
What decision can I make here?

973
00:47:43,039 --> 00:47:44,559
我可以做出什么决定？
What decision can I make?

974
00:47:44,559 --> 00:47:45,559
凯尔，你怎么看？
Kyle, what do you think?

975
00:47:45,559 --> 00:47:46,184
听众：是的。
AUDIENCE: Yeah.

976
00:47:46,184 --> 00:47:49,369
因此，从M开始，你肯定不会知道你的名字。
So from the M onwards, you know that your name won't be there for sure.

977
00:47:49,369 --> 00:47:51,379
DAVID J MALAN：是的，所以我的名字不会出现在M部分。
DAVID J MALAN: Yeah, so my name is not going to be in the M section.

978
00:47:51,380 --> 00:47:53,780
但是，由于电话簿的字母顺序，我至少知道，
But thanks to the alphabetization of the phone book, I at least know,

979
00:47:53,780 --> 00:47:54,650
你知道吗？
you know what?

980
00:47:54,650 --> 00:47:57,170
我可以解决这个问题
I can take a huge bite out of this problem

981
00:47:57,170 --> 00:48:01,043
从隐喻和字面意义上将问题分解成两半，
and tear the problem in half, both metaphorically and also literally,

982
00:48:01,043 --> 00:48:02,210
如果是电话簿。
in the case of a phone book.

983
00:48:02,210 --> 00:48:05,540
我实际上可以解决一半的问题。
And I can literally throw half of the problem away.

984
00:48:05,539 --> 00:48:08,689
因此，如果我从这本电话簿中的第一千页开始
And so if I started with something like 1,000 pages in this phone book

985
00:48:08,690 --> 00:48:12,050
或手机中的1,000个联系人，只需转到中间，
or 1,000 contacts in my phone, just by going to the middle,

986
00:48:12,050 --> 00:48:14,990
粗略地看一下左右，我可以决定，
roughly, and taking a look to the left and the right, I can decide,

987
00:48:14,989 --> 00:48:18,329
正如你所注意到的，它不在我要查找的页面上。
as you note, well, it's not on the page I'm looking for.

988
00:48:18,329 --> 00:48:20,479
但是我可以决定它在左边还是右边。
But I can decide it's to the left or to the right.

989
00:48:20,480 --> 00:48:24,110
我知道D在M之前出现。所以现在我可以向左走。
I know D comes before M. And so now I can go to the left.

990
00:48:24,110 --> 00:48:26,210
你知道这里有趣的是，我
And you know what's interesting here, is that I

991
00:48:26,210 --> 00:48:28,057
可以使用完全相同的算法。
can use that exact same algorithm.

992
00:48:28,056 --> 00:48:29,639
我没有任何不同的想法。
I don't have to think any differently.

993
00:48:29,639 --> 00:48:33,529
我可以应用相同的逻辑，打开电话的这半部分，预定
I can apply the same logic, open to the middle of this half of the phone, book

994
00:48:33,530 --> 00:48:35,450
现在我看到我在“ G”部分。
and now I see I'm in the G section.

995
00:48:35,449 --> 00:48:37,069
所以我还是有点太过分了。
So I'm still a little too far.

996
00:48:37,070 --> 00:48:40,880
但是，我可以将一半的问题解决掉，把它扔下来
But again, I can tear half the problem away, throw it down

997
00:48:40,880 --> 00:48:45,050
现在我已经从1000页增加到500页再增加到250页。
and now I've gone from, like 1,000 pages to 500 pages to 250 pages.

998
00:48:45,050 --> 00:48:49,040
如果再次执行此操作，我可能会发现自己，哦，我现在进入了C部分。
If I do this again, I might find myself, oh, I made it to the C section now.

999
00:48:49,039 --> 00:48:52,369
我可以再把问题撕成两半，丢掉剩下的一半，
I can tear the problem in half again, throw the left half away,

1000
00:48:52,369 --> 00:48:54,919
现在只有125页。
and now I'm down to just 125 pages.

1001
00:48:54,920 --> 00:48:56,840
现在，仍然很多，但我的天哪。
Now, that's still a lot, but my god.

1002
00:48:56,840 --> 00:49:00,020
我已经从1,000升至500到250升至125。
I've gone from 1,000 to 500 to 250 to 125.

1003
00:49:00,019 --> 00:49:05,149
那比从1,000到999到998快得多，
That is way faster than going from 1,000 to 999 to 998,

1004
00:49:05,150 --> 00:49:11,300
甚至比从1,000到998到996到994还要快。
and it's even faster than going from 1,000 to 998 to 996 to 994.

1005
00:49:11,300 --> 00:49:15,030
这两种算法都将花费我更长的时间。
Both of those algorithms are going to take me much longer as well.

1006
00:49:15,030 --> 00:49:17,840
我们有Brian制作的这种可视化效果，非常棒，
We have this visualization made by Brian, wonderfully,

1007
00:49:17,840 --> 00:49:23,870
描绘了1,024页的电话簿，一次翻一页。
that depicts 1,024 page phone book with one page being flipped at a time.

1008
00:49:23,869 --> 00:49:26,664
现在我们降到了996，995。
And now we're down to 996, 995.

1009
00:49:26,664 --> 00:49:28,789
我的意思是，老实说，这还不是很有启发性的。
I mean, honestly, this isn't all that enlightening.

1010
00:49:28,789 --> 00:49:31,969
在电话簿中找到David或任何名字将需要永远
It's going to take forever to find David or any name in a phone book

1011
00:49:31,969 --> 00:49:35,059
当以这种算法开始时。
when starting at that kind of pace with that algorithm.

1012
00:49:35,059 --> 00:49:37,069
但是，如果我更聪明些怎么办
But what if, instead, I'm a little smarter

1013
00:49:37,070 --> 00:49:38,450
我会更直观些吗？
and I'm a little more intuitive?

1014
00:49:38,449 --> 00:49:40,969
我利用了你和我可能拥有的直觉
And I harness the intuition that probably you had and I

1015
00:49:40,969 --> 00:49:44,389
再次从1,024页开始，这次
start with 1,024 pages again, and this time

1016
00:49:44,389 --> 00:49:48,619
一次分而治之，将问题一分为二吗？
divide and conquer, half at a time, splitting the problem in half?

1017
00:49:48,619 --> 00:49:51,899
将电话簿撕成两半，我只剩下一页。
Tearing the phone book in half, I get down to just one page.

1018
00:49:51,900 --> 00:49:55,610
如果我们实际进行数学计算，如果你的页面起始于1000多个页面，
And if we actually do out the math, if you start at like 1,000-plus pages,

1019
00:49:55,610 --> 00:50:01,070
下来，我只花了10滴电话簿的眼泪就可以掉下来
it will only take me 10 total tears of that phone book in order to get down

1020
00:50:01,070 --> 00:50:05,690
我的电话号码是949-468-2750。
to my number, 949-468-2750.

1021
00:50:05,690 --> 00:50:10,010
因此，这只是说第三种算法不仅正确，而且
So that just is to say that the third algorithm is not only correct, just

1022
00:50:10,010 --> 00:50:14,600
因为第一个肯定是，第二个可能是该错误修复，
as the first one definitely was and the second one could be with that bug fix,

1023
00:50:14,599 --> 00:50:16,609
但它的设计也更好。
but it's also much better designed.

1024
00:50:16,610 --> 00:50:17,670
效率更高。
It's much more efficient.

1025
00:50:17,670 --> 00:50:20,040
因此，我们也可以在图形上看到这一点。
And so we can see this a little graphically as well.

1026
00:50:20,039 --> 00:50:23,199
让我继续前进，不提出任何数值分析或其他任何建议
Let me go ahead and propose not a numerical analysis or anything

1027
00:50:23,199 --> 00:50:23,699
像那样。
like that.

1028
00:50:23,699 --> 00:50:26,549
但是只是一些像这样的视觉效果。
But just something that's a little visual like this.

1029
00:50:26,550 --> 00:50:28,640
所以如果我有一个x轴代表
So if I have an x-axis here that represents

1030
00:50:28,639 --> 00:50:32,299
从横向上看问题的大小，电话簿中的页数，
horizontally the size of the problem, the number of pages in a phone book,

1031
00:50:32,300 --> 00:50:36,030
垂直于y轴表示解决问题所需的时间。
and vertically on the y-axis, the amount of time required to solve a problem.

1032
00:50:36,030 --> 00:50:38,840
如果我们只是将它们绘制成图表，这些算法的外观如何？
What co these algorithms look like, if we just kind of chart them?

1033
00:50:38,840 --> 00:50:42,410
好吧，第一个算法（这里用红色表示）只是一条直线。
Well, the first algorithm, depicted here in red, it's just a straight line.

1034
00:50:42,409 --> 00:50:45,709
这是一个1的斜率，因为这是一对一的
It's a slope of one because there is this one to one

1035
00:50:45,710 --> 00:50:48,560
页数和时间之间的关系
relationship between number of pages and the amount of time

1036
00:50:48,559 --> 00:50:49,669
我需要解决它。
it takes me to solve it.

1037
00:50:49,670 --> 00:50:52,730
对于该电话簿的每个新页面，也许年复一年，
For every new page of that phone book, maybe year after year,

1038
00:50:52,730 --> 00:50:54,710
如果电话簿增长，它将带我
if the phone book grows, it's going to take me

1039
00:50:54,710 --> 00:50:57,560
进一步寻找自己或其他任何人，
one more step to look for myself or anyone else,

1040
00:50:57,559 --> 00:50:59,119
可能在该电话簿中。
potentially, in that phone book.

1041
00:50:59,119 --> 00:51:02,059
除非我很幸运，而且他们早在电话簿中，但是还有一个
Unless I get lucky and they're early in the phone book, but one more

1042
00:51:02,059 --> 00:51:04,459
翻页意味着再翻一页。
page means one more page turn.

1043
00:51:04,460 --> 00:51:06,980
第二种算法实际上更好。
The second algorithm is actually better.

1044
00:51:06,980 --> 00:51:08,580
仍然是一条直线。
It's still a straight line.

1045
00:51:08,579 --> 00:51:11,539
因此，它仍然是线性关系。
So it's still a linear relationship.

1046
00:51:11,539 --> 00:51:15,019
但是，电话簿中的每两页又使我迈出了一步。
But for every two pages in the phone book it takes me one more step.

1047
00:51:15,019 --> 00:51:16,399
两页，一圈。
Two pages, one turn.

1048
00:51:16,400 --> 00:51:17,750
两页，一圈。
Two pages, one turn.

1049
00:51:17,750 --> 00:51:20,040
因此，它绝对比第一种算法好。
So it's strictly better than the first algorithm.

1050
00:51:20,039 --> 00:51:20,539
为什么？
Why?

1051
00:51:20,539 --> 00:51:22,956
好吧，如果我们考虑到这一点-如果问题的严重性是
Well, if we consider this-- if the size of the problem is,

1052
00:51:22,956 --> 00:51:24,239
例如，也许在这里。
maybe, here, for instance.

1053
00:51:24,239 --> 00:51:26,419
因此，如果我们假设出于讨论目的，也许
So if we assume, for the sake of discussion, maybe

1054
00:51:26,420 --> 00:51:29,780
电话簿中有许多用虚线表示的页面。
the phone book has this many pages depicted with this dotted line.

1055
00:51:29,780 --> 00:51:32,540
好了，第二个算法要花多少时间
Well, how much time is it going to take the second algorithm

1056
00:51:32,539 --> 00:51:34,552
在电话簿中找人？
to find someone in that phone book?

1057
00:51:34,552 --> 00:51:36,469
这将花费大量时间，对吗？
It's going to take this amount of time, right?

1058
00:51:36,469 --> 00:51:37,909
那两条线相交的地方。
Where those two lines intersect.

1059
00:51:37,909 --> 00:51:40,849
不过，如果你使用的是第一种算法，则一次浏览一页，
If you're using the first algorithm, though, going one page at a time,

1060
00:51:40,849 --> 00:51:45,209
实际上，这将花费很多时间，这实际上是原来的两倍。
it's actually going to take this much time, which is literally twice as much.

1061
00:51:45,210 --> 00:51:47,820
因此，它们都是正确的，假设我们根据需要加倍返回
So they're both correct, assuming we double back as needed

1062
00:51:47,820 --> 00:51:50,030
如果我走了一个名字太远了。
if I go too far past a name.

1063
00:51:50,030 --> 00:51:52,400
但是，两者在本质上是相同的。
But both of those are sort of fundamentally the same.

1064
00:51:52,400 --> 00:51:54,400
它们是相同的形状，老实说，它们都
They're the same shape, and, honestly, they both

1065
00:51:54,400 --> 00:51:56,990
说话和行动起来很慢。
felt slow to say and to act out.

1066
00:51:56,989 --> 00:51:59,209
第三种算法，如果我们将其绘制成图形，
The third algorithm, if we were to graph it,

1067
00:51:59,210 --> 00:52:01,700
有根本不同的关系
has a fundamentally different relationship

1068
00:52:01,699 --> 00:52:05,479
在问题的大小和解决问题所需的时间之间。
between the size of the problem and the time required to solve the problem.

1069
00:52:05,480 --> 00:52:07,953
这条线应该向上，向上，向上，向上
The line goes up, up, up, up, as it should,

1070
00:52:07,952 --> 00:52:11,119
因为存在的页面越多，解决该问题所需的时间就越多，
because the more pages there are, the more time it's going to take to solve,

1071
00:52:11,119 --> 00:52:14,359
但请注意它上升的速度要慢得多。
but notice how much more slowly it goes up.

1072
00:52:14,360 --> 00:52:18,320
随着问题的严重，这件事几乎没有开始增加
This thing barely starts to rise as the size of the problem

1073
00:52:18,320 --> 00:52:19,880
变得越来越大。
gets bigger and bigger and bigger.

1074
00:52:19,880 --> 00:52:21,618
凭直觉为什么会这样呢？
And why is that, intuitively?

1075
00:52:21,617 --> 00:52:24,409
好吧，这里的功能强大的是，假设明年有电话簿，
Well, here, what's powerful is, suppose that phone book, next year,

1076
00:52:24,409 --> 00:52:26,629
无论出于何种原因，其大小都会增加一倍。
for whatever reason, doubled in size.

1077
00:52:26,630 --> 00:52:29,930
也许剑桥和马萨诸塞州的奥尔斯顿合并为一个
Maybe Cambridge and Allston, Massachusetts merged together into one

1078
00:52:29,929 --> 00:52:33,529
大型电话簿，所以现在有2,000多个页面。
big phone book, so there's 2,000-some-odd pages now instead.

1079
00:52:33,530 --> 00:52:35,660
明年还需要多少步骤
How many more steps would it take next year

1080
00:52:35,659 --> 00:52:37,969
在该电话簿中搜索某人？
to search for someone in that phone book?

1081
00:52:37,969 --> 00:52:38,769
一。
One.

1082
00:52:38,769 --> 00:52:39,919
更进一步。
One more step.

1083
00:52:39,920 --> 00:52:42,920
因此，如果你沿着这条绿线向此处看，
And so if you look way out here along this green line,

1084
00:52:42,920 --> 00:52:45,050
将电话簿的大小加倍
doubling the size of the phone book, the line

1085
00:52:45,050 --> 00:52:48,170
本身只会上升一点点，因为没什么大不了的。
itself is only going to rise ever so slightly because no big deal.

1086
00:52:48,170 --> 00:52:52,410
使用第三种算法，你可以从问题中解脱出来。
With that third algorithm you're taking much bigger bites out of the problem.

1087
00:52:52,409 --> 00:52:56,119
因此，这也说明了什么计算机科学和编程
And so this, too, speaks to what computer science and what programming

1088
00:52:56,119 --> 00:52:57,109
最终喜欢。
are ultimately like.

1089
00:52:57,110 --> 00:52:59,765
利用你进入课堂的想法
Harnessing ideas that you come into the class with

1090
00:52:59,764 --> 00:53:01,639
并可能会在你的日常生活中使用，
and that you might use in your everyday life,

1091
00:53:01,639 --> 00:53:05,719
但你不必思考如何表达问题
but you don't necessarily think about how you might represent problems

1092
00:53:05,719 --> 00:53:10,249
使用这些算法，以及如何将其转换为计算机语言。
using those algorithms and how you might translate them to computer speak.

1093
00:53:10,250 --> 00:53:13,036
实际上，我们将开始考虑算法的一种方式
And indeed, one way we'll start to think about algorithms

1094
00:53:13,036 --> 00:53:15,619
不仅是它们的正确性，还在于它们的设计水平。
is not only their correctness, but how well designed they are.

1095
00:53:15,619 --> 00:53:17,539
因此，例如在这里，我故意
And so for instance here, I've deliberately

1096
00:53:17,539 --> 00:53:21,799
将这三行标记为n，n标记为2，n标记对数为2。
labeled these three lines n, n over 2, and log base 2 over n.

1097
00:53:21,800 --> 00:53:25,250
这只是意味着如果我们将n用作数字-那么计算机科学家倾向于
That just means that if we use n as number-- so computer scientists tend

1098
00:53:25,250 --> 00:53:30,139
使用n作为变量，就像数学家可能会说x或y或z，
to use n as a variable, much like a mathematician might say x or y or z,

1099
00:53:30,139 --> 00:53:31,219
n为数字。
n for number.

1100
00:53:31,219 --> 00:53:34,602
所以第一条红线是运行时间，
And so the first red line is the running time,

1101
00:53:34,603 --> 00:53:36,770
解决问题可能要采取的步骤数
the number of steps it might take to solve a problem

1102
00:53:36,769 --> 00:53:38,149
在最坏的情况下，可能是n。
might be, in the worst case, n.

1103
00:53:38,150 --> 00:53:41,368
如果电话簿中有n页，也许我正在寻找某人的方式
If there's n pages in the phone book, maybe I'm looking for someone way

1104
00:53:41,367 --> 00:53:43,159
在电话簿的末尾
at the end of the phone book and it's going

1105
00:53:43,159 --> 00:53:45,104
带我全部n步找到它们。
to take me all n steps to find them.

1106
00:53:45,105 --> 00:53:47,480
第二种算法将采取一半的步骤。
The second algorithm is going to take half as many steps.

1107
00:53:47,480 --> 00:53:50,720
所以我们将其表示为n除以2，因为如果
So we express that as n divided by 2, because if we're

1108
00:53:50,719 --> 00:53:54,019
一次做两页，我们将到达电话簿的结尾-
doing two pages at a time we'll get to the end of the phone book--

1109
00:53:54,019 --> 00:53:57,199
例如，如果我们正在寻找名字以Z开头的人，
if we're looking for someone whose name starts with Z, for instance--

1110
00:53:57,199 --> 00:53:58,519
快一倍。
twice as fast.

1111
00:53:58,519 --> 00:54:01,489
但是第三种算法，如果你对数学有些生疏，
But the third algorithm, if you're a little rusty on the mathematics,

1112
00:54:01,489 --> 00:54:04,729
以2为底的对数表示。
is represented as a logarithm with a base of 2.

1113
00:54:04,730 --> 00:54:08,540
这只是表示该图，绿线
And this just means that this graph, the green line

1114
00:54:08,539 --> 00:54:14,839
描述每次通过需要多少时间来解决问题，
describes how much time it takes to solve a problem when on each pass,

1115
00:54:14,840 --> 00:54:19,220
在每一步中，你都将问题（在这种情况下）除以一半。
on each step, you are dividing the problem, in this case, by half.

1116
00:54:19,219 --> 00:54:22,739
其他两种算法可以解决这一问题。
The other two algorithms are taking one or two bites out of the problem.

1117
00:54:22,739 --> 00:54:27,539
第三种算法一次处理了整个问题的一半。
The third algorithm was taking half of the whole problem at a time.

1118
00:54:27,539 --> 00:54:29,849
这就是使它变得更加强大的原因。
And that's what made it all the more powerful.

1119
00:54:29,849 --> 00:54:32,239
所以说到现在的编程，我们需要
So when it comes to programming now, we need

1120
00:54:32,239 --> 00:54:35,119
将这些称为算法的东西翻译成代码。
to translate these things called algorithms to code.

1121
00:54:35,119 --> 00:54:36,919
或者，在这种情况下，我们称其为伪代码。
Or, in this case, let's call it pseudocode.

1122
00:54:36,920 --> 00:54:40,160
稍后，我们将专注于一种实际的编程语言，
And in just a bit, we'll focus on an actual programming language,

1123
00:54:40,159 --> 00:54:41,329
尽管是图形的。
albeit a graphical one.

1124
00:54:41,329 --> 00:54:44,349
但是现在，我们只考虑一些构造或排序
But for now let's just consider some of the constructs or sort

1125
00:54:44,349 --> 00:54:46,849
基本的想法将很有用
of fundamental ideas that are going to be useful to leverage

1126
00:54:46,849 --> 00:54:48,679
在这堂课上
here on out in this class.

1127
00:54:48,679 --> 00:54:51,439
因此，让我提出我实际上只是口头上所做的事情
So let me propose that what I really just did verbally

1128
00:54:51,440 --> 00:54:55,580
可以翻译成伪代码，就像实现的算法一样
can be translated into pseudocode, which is like an algorithm implemented

1129
00:54:55,579 --> 00:54:58,167
用英语，或你所说的口语或书面语言。
in English, or whatever your spoken or written language is.

1130
00:54:58,168 --> 00:54:59,960
但关键是它必须正确，
But the key is that it's got to be correct,

1131
00:54:59,960 --> 00:55:03,410
理想情况下最好是准确无误。
and ideally it had better be precise so that there's no ambiguity.

1132
00:55:03,409 --> 00:55:05,149
第一步确实是我所做的。
Step one was, indeed, what I did.

1133
00:55:05,150 --> 00:55:06,260
拿起电话簿。
Pick up phone book.

1134
00:55:06,260 --> 00:55:08,810
第二步，打开电话簿的中间。
Step two, open to middle of phone book.

1135
00:55:08,809 --> 00:55:10,579
第三步，看页面。
Step three, look at page.

1136
00:55:10,579 --> 00:55:11,779
确实，我做到了。
And indeed I did that.

1137
00:55:11,780 --> 00:55:14,000
现在事情变得有趣了。
And now things got interesting.

1138
00:55:14,000 --> 00:55:15,739
第四步，如果有人-
Step four, if person--

1139
00:55:15,739 --> 00:55:19,429
在我的情况下，David –在页面上，我想做什么？
David, in my case-- is on the page, what do I want to do?

1140
00:55:19,429 --> 00:55:21,289
好吧，我可能应该打电话给那个人。
Well, I should probably call that person.

1141
00:55:21,289 --> 00:55:22,279
问题已经解决了。
The problem is solved.

1142
00:55:22,280 --> 00:55:24,620
我已经得到了我的输出，那个人的号码。
I've gotten my output, the person's number.

1143
00:55:24,619 --> 00:55:27,799
但是还有另一种可能性，如果此人不在页面上
But there's another possibility, not if the person's on the page

1144
00:55:27,800 --> 00:55:29,930
但是，如果此人早于本书，
but, rather if the person is earlier in the book--

1145
00:55:29,929 --> 00:55:31,554
那就是刚才发生的事情。
and that is what happened a moment ago.

1146
00:55:31,554 --> 00:55:34,819
如果我最后选择了M，但我正在寻找David，那就在左边，
If I ended up on M, but I'm looking for David, that's to the left,

1147
00:55:34,820 --> 00:55:36,890
那我该怎么办？
I should then do what?

1148
00:55:36,889 --> 00:55:39,829
打开到书的左半部分的中间。
Open to the middle of the left half of the book.

1149
00:55:39,829 --> 00:55:41,082
这确实是我所做的。
And that's indeed what I did.

1150
00:55:41,083 --> 00:55:43,250
而且我无意间把问题解决了一半。
And I sort of gratuitously tore the problem in half.

1151
00:55:43,250 --> 00:55:47,809
但是从算法上讲，我只是看了下本书的左半部分。
But algorithmically, I just looked at the left half of the book next.

1152
00:55:47,809 --> 00:55:48,559
我下一步该怎么办？
What do I do next?

1153
00:55:48,559 --> 00:55:50,267
好吧，真的，这就是我要说的重点
Well, really, that's the point at which I

1154
00:55:50,268 --> 00:55:53,120
提出该算法现在一次又一次地可重复，
proposed that the algorithm is now just repeatable, again and again,

1155
00:55:53,119 --> 00:55:54,859
所以我们要说回到第三行。
and so we'll say go back to line three.

1156
00:55:54,860 --> 00:55:55,460
为什么？
Why?

1157
00:55:55,460 --> 00:55:58,125
好吧，从第三行开始，我有一个算法
Well, starting at line three, I have an algorithm

1158
00:55:58,125 --> 00:55:59,750
查找电话簿中的某人。
for looking up someone in a phone book.

1159
00:55:59,750 --> 00:56:02,728
碰巧的是，现在的电话簿只有原来的一半。
It just so happens the phone book now is half as large.

1160
00:56:02,728 --> 00:56:03,770
但是还有另一种情况。
But there's another case.

1161
00:56:03,769 --> 00:56:05,436
如果此人后来在书中怎么办？
What if the person is later in the book?

1162
00:56:05,436 --> 00:56:07,699
我不是在寻找以D开头的David，
I wasn't searching for David, which starts with D,

1163
00:56:07,699 --> 00:56:10,639
但是别人的名字都在字母表的末尾。
but someone else's name that's toward the end of the alphabet.

1164
00:56:10,639 --> 00:56:13,697
好吧，那么如果那个人在书的后面，那么同样的想法。
Well, then if that person is later in the book, same idea.

1165
00:56:13,697 --> 00:56:15,739
打开到书的右半部分的中间，
Open to the middle of the right half of the book,

1166
00:56:15,739 --> 00:56:18,349
然后再次返回到第三步。
and then again, go back to step three.

1167
00:56:18,349 --> 00:56:20,899
但最后，还有第四种可能性。
But lastly, there's a fourth possibility.

1168
00:56:20,900 --> 00:56:22,160
还有第四种可能性。
There's a fourth possibility.

1169
00:56:22,159 --> 00:56:24,949
该人在电话簿中，还是在左侧
Either the person's in the phone book, or they're to the left

1170
00:56:24,949 --> 00:56:29,819
或者它们在右边，或者坦率地说，它们根本不在那儿。
or they're to the right, or, frankly, they are just not there at all.

1171
00:56:29,820 --> 00:56:32,480
最后一点，尽管有些微妙，却非常重要。
And this last point, though somewhat subtle, is so important.

1172
00:56:32,480 --> 00:56:34,520
在Mac，PC上，我们所有人都有可能发生。
Odds are all of us on our Macs, PCs.

1173
00:56:34,519 --> 00:56:38,909
甚至手机，都曾经历过如此令人沮丧的经历
Maybe even phones, have had that very frustrating experience where

1174
00:56:38,909 --> 00:56:43,129
你的计算机挂起，却出现了愚蠢的旋转沙滩球或沙漏，
your computer hangs, you get the stupid spinning beachball or hourglass,

1175
00:56:43,130 --> 00:56:46,430
东西冻结或只是重新启动，你知道，出了点问题
the thing freezes or just reboots, you know, something goes wrong

1176
00:56:46,429 --> 00:56:48,049
这有点莫名其妙。
and it's sort of inexplicable.

1177
00:56:48,050 --> 00:56:50,270
你可能会认为这是你的错，但实际上是
And you might think it's your fault, but really it's

1178
00:56:50,269 --> 00:56:54,199
通常是程序员的过错，谁编写了你所需要的软件
usually the programmer's fault who wrote the software that you're

1179
00:56:54,199 --> 00:56:56,609
在你的计算机或设备上使用。
using on your computer or your device.

1180
00:56:56,610 --> 00:56:57,260
为什么？
Why?

1181
00:56:57,260 --> 00:57:00,960
不管出于何种原因，那个程序员经常
Very often, that programmer, for whatever reason,

1182
00:57:00,960 --> 00:57:03,935
没想到可能的情况。
did not anticipate a possible scenario.

1183
00:57:03,934 --> 00:57:05,809
在这种情况下，有四种情况，但是你
In this case, there's four scenarios, but you

1184
00:57:05,809 --> 00:57:09,229
可以想像有点忘记了事实，哦，也许大卫的
could imagine kind of forgetting the fact that, oh, well maybe David's

1185
00:57:09,230 --> 00:57:11,000
甚至在这本电话簿中也没有。
not even in this phone book.

1186
00:57:11,000 --> 00:57:12,719
但是你最好处理这种情况。
But you'd better handle that scenario.

1187
00:57:12,719 --> 00:57:14,929
当你的计算机死机或挂起时
And when you have a computer that freezes or hangs

1188
00:57:14,929 --> 00:57:17,119
或重新启动或出现问题，
or reboots or just something goes awry, that

1189
00:57:17,119 --> 00:57:20,269
通常只是因为人类没有
is quite often quite simply because a human did not

1190
00:57:20,269 --> 00:57:23,279
某些可能情况的代码。
code for some possible scenario.

1191
00:57:23,280 --> 00:57:25,610
那么我们的基本结构是什么
So what are the fundamental constructs we've

1192
00:57:25,610 --> 00:57:28,430
在这里看到我们将继续在课堂上看到吗？
seen here that we're going to continue seeing in class?

1193
00:57:28,429 --> 00:57:32,029
好吧，现在以黄色突出显示的实际上是一些动词或动作
Well, highlighted in yellow now are really some verbs or actions

1194
00:57:32,030 --> 00:57:33,870
我们用那本电话簿练习过的。
that we exercised with that phone book.

1195
00:57:33,869 --> 00:57:36,559
通常，这些在称为函数的编程中。
These are, in general, in programming called functions.

1196
00:57:36,559 --> 00:57:39,129
功能是动作或动词。
A function is an action or a verb.

1197
00:57:39,130 --> 00:57:41,820
这是使计算机执行某项操作的声明。
It's a statement that gets the computer to do something.

1198
00:57:41,820 --> 00:57:45,725
接下来要突出显示的是我们称为条件或分支的内容。
Next highlighted here are what we'll call conditions or branches.

1199
00:57:45,724 --> 00:57:47,849
这些是道路上众所周知的分叉。
These are sort of the proverbial forks in the road.

1200
00:57:47,849 --> 00:57:50,889
你既可以执行此操作，也可以执行此操作，也可以执行此操作。
You could either do this or this or maybe this other thing.

1201
00:57:50,889 --> 00:57:53,729
你可以做出一个决定，也可以做出两个，三个或四个决定，
And you can have one decision to make or two or three or four,

1202
00:57:53,730 --> 00:57:55,800
但是，从逻辑上讲，许多条件都是有意义的。
however many conditions make sense logically.

1203
00:57:55,800 --> 00:57:57,210
我们称这些条件。
We'll call those conditions.

1204
00:57:57,210 --> 00:58:00,790
但是，你如何决定走哪条路呢？
But how do you decide which fork in the road to take?

1205
00:58:00,789 --> 00:58:03,029
是否要执行此操作，该操作或其他操作？
Whether to do this or that or this other thing?

1206
00:58:03,030 --> 00:58:06,030
为此，我们需要一种称为布尔表达式的东西。
For that we need something called Boolean expressions.

1207
00:58:06,030 --> 00:58:09,150
一个布尔表达式，这只是一个问题
A Boolean expression it's just a question

1208
00:58:09,150 --> 00:58:14,700
其答案是“是”或“否”，或者是或否，或者坦率地说是“ 1”或“ 0”。
whose answer is yes or no, or true or false, or, frankly, one or zero.

1209
00:58:14,699 --> 00:58:16,989
所有这些对于我们的目的而言都是等效的。
All of those would be equivalent for our purposes.

1210
00:58:16,989 --> 00:58:18,269
所以页面上的人。
So person on page.

1211
00:58:18,269 --> 00:58:19,589
这是一个是或否的问题。
That's a yes or no question.

1212
00:58:19,590 --> 00:58:20,730
书中较早的人？
Person earlier in book?

1213
00:58:20,730 --> 00:58:21,690
这也是一个问题。
That too is a question.

1214
00:58:21,690 --> 00:58:24,280
书中后面的人也是第三个问题。
Person later in book is a third question as well.

1215
00:58:24,280 --> 00:58:28,860
因此，如果你可以想像是-否的答案，是非题，一个零答案，
So if you can imagine a yes-no answer, a true-false answer, a one-zero answer,

1216
00:58:28,860 --> 00:58:31,708
这就是给我们提供这些被称为布尔表达式的东西的原因。
that is what gives us these things called Boolean expressions.

1217
00:58:31,708 --> 00:58:33,750
最后，这些是黄色的东西。
And then lastly, in yellow here are these things.

1218
00:58:33,750 --> 00:58:35,489
回到第三行。
Go back to line three.

1219
00:58:35,489 --> 00:58:38,489
这将引发我们称为循环或循环的事情，
This will induce what we'll call a loop or a cycle,

1220
00:58:38,489 --> 00:58:42,231
这仅仅是程序的构造或算法的原理，
which is just a programming construct or principle of an algorithm that

1221
00:58:42,231 --> 00:58:44,189
让你一次又一次地做某事，所以你
gets you to do something again and again so you

1222
00:58:44,190 --> 00:58:46,620
不必编写100行算法。
don't have to write 100-line algorithm.

1223
00:58:46,619 --> 00:58:51,629
你可以编写一个13行算法，然后一次又一次地重用其中的一部分。
You can write a 13-line algorithm and reuse parts of it again and again.

1224
00:58:51,630 --> 00:58:55,890
因此，我们现在开始，我们将从外观上开始CS50
And so we'll begin now, and we'll begin CS50 with a look

1225
00:58:55,889 --> 00:58:59,399
使用一种实际的编程语言，你可能最近使用过一种
at an actual programming language, one that you might have used recently

1226
00:58:59,400 --> 00:59:03,120
还是年纪较小的孩子（称为Scratch），它是一种图形化编程
or as younger kids, known as Scratch, which is a graphical programming

1227
00:59:03,119 --> 00:59:07,859
虽然你们中的一些人可能很熟悉的语言，
language which, while it might be very familiar to some of you,

1228
00:59:07,860 --> 00:59:10,770
它实际上代表了许多编程基础知识
it actually represents a lot of these programming fundamentals

1229
00:59:10,769 --> 00:59:13,979
我们将在一周内将其用作过渡的基础
that we'll use as this ground for transitioning in just one week

1230
00:59:13,980 --> 00:59:16,440
到更传统，更古老的学校语言
to a more traditional more old school language,

1231
00:59:16,440 --> 00:59:19,260
称为C，完全基于文本和键盘。
known as C, which is entirely text and keyboard-based.

1232
00:59:19,260 --> 00:59:21,720
但是我们会在CS50中看到的所有语言中都可以看到，
But we'll see in all of the languages we look at in CS50,

1233
00:59:21,719 --> 00:59:25,229
这些东西称为函数和条件，布尔表达式
these things called functions and conditions, Boolean expressions

1234
00:59:25,230 --> 00:59:27,300
和循环，今天，在片刻中，我们将
and loops, and today, in just a moment, we'll

1235
00:59:27,300 --> 00:59:31,230
还可以看到我们描述为变量的其他一些功能，与x，y，
also see some other features that we describe as variables, not unlike x, y,

1236
00:59:31,230 --> 00:59:35,350
和z在数学，线程上，这似乎允许计算机执行操作，
and z in math, threads, which allow a computer to do, it would seem,

1237
00:59:35,349 --> 00:59:40,269
同时具有多个功能，事件和其他功能。
multiple things at once, events, and yet other features as well.

1238
00:59:40,269 --> 00:59:46,349
因此，从这里开始，我们从伪代码过渡到实际代码。
And so from here, we transition from pseudocode to actual code.

1239
00:59:46,349 --> 00:59:49,094
而你在屏幕上看到的是一个示例
And what you see on the screen here is an example

1240
00:59:49,094 --> 00:59:51,719
一种称为C的语言，我们将在其中花费大量时间
of a language called C, where we'll spend a good amount of time

1241
00:59:51,719 --> 00:59:52,302
本学期。
this semester.

1242
00:59:52,302 --> 00:59:54,809
这是较老的学校基于文本，基于键盘的语言
This is the older school text-based, keyboard-based language

1243
00:59:54,809 --> 00:59:56,129
我之前提到的。
to which I referred earlier.

1244
00:59:56,130 --> 00:59:58,050
但是这种语言有点神秘。
But this language is a bit cryptic.

1245
00:59:58,050 --> 01:00:01,650
当然，乍一看，你可能会想知道为什么其中存在井号，
And certainly at first glance, you might wonder why is the hash symbol there,

1246
01:00:01,650 --> 01:00:05,220
尖括号，括号，花括号，分号，
the angled brackets, the parentheses, the curly braces, the semicolon,

1247
01:00:05,219 --> 01:00:10,019
引号，我的意思是，我的天哪，屏幕上的内容有太多语法
the quotes, I mean, my god, there is so much syntax to what is on the screen

1248
01:00:10,019 --> 01:00:10,589
现在。
now.

1249
01:00:10,590 --> 01:00:12,690
你可能会猜到该程序的作用。
And you can probably guess what this program does.

1250
01:00:12,690 --> 01:00:14,315
让我快点到观众面前。
Let me just go quickly to the audience.

1251
01:00:14,315 --> 01:00:17,310
这个程序可能会做什么，即使你从未尝试过，
What, anyone, does this program probably do, even if you've never

1252
01:00:17,309 --> 01:00:19,469
编程过电脑吗？
programmed a computer before?

1253
01:00:19,469 --> 01:00:21,551
听众：它只是打印出你好，逗号，世界。
AUDIENCE: It just prints out hello, comma, world.

1254
01:00:21,552 --> 01:00:22,510
大卫·J·马兰（David J MALAN）：好的。
DAVID J MALAN: Exactly.

1255
01:00:22,510 --> 01:00:23,820
它只是打印你好，世界。
It just prints hello, world.

1256
01:00:23,820 --> 01:00:26,850
我的上帝，就像，看看所有的语法和所有的击键
And my god, like, look at all of the syntax and all of the keystrokes

1257
01:00:26,849 --> 01:00:29,559
我们只需要键入命令计算机即可。
we had to type just to command the computer to do that.

1258
01:00:29,559 --> 01:00:31,887
相比之下，今天是Scratch。
And so by contrast today is Scratch.

1259
01:00:31,887 --> 01:00:34,679
今天，我们将允许我们自己研究更多
We'll allow ourselves for just today to look at something much more

1260
01:00:34,679 --> 01:00:39,209
友好的，更加图形化的，这将使我们能够探索这些想法
friendly, much more graphical, that will allow us to explore these very ideas

1261
01:00:39,210 --> 01:00:42,810
并为更复杂，更传统的舞台打下基础
and set the stage for more sophisticated, more traditional

1262
01:00:42,809 --> 01:00:45,647
下周及以后的语言，但在上下文中
languages next week and beyond, but in the context

1263
01:00:45,648 --> 01:00:48,690
我们不必担心括号，分号，花括号，
where we don't have to worry about parentheses, semicolons, curly braces,

1264
01:00:48,690 --> 01:00:51,520
以及这些键在键盘上的位置。
and where even these keys are on the keyboard.

1265
01:00:51,519 --> 01:00:53,552
因此，请允许我向你介绍Scratch，
So allow me to introduce you, then, to Scratch,

1266
01:00:53,552 --> 01:00:55,469
由我们的一些朋友开发的
developed by some of our friends down the road

1267
01:00:55,469 --> 01:00:58,019
在麻省理工学院媒体实验室的剑桥。
here in Cambridge at MIT's Media Lab.

1268
01:00:58,019 --> 01:01:02,489
如果你想在scratch.mit.edu上玩，可以在这里在家玩。
You can play along at home here on out if you would like at scratch.mit.edu.

1269
01:01:02,489 --> 01:01:05,759
它是基于Web的，但也有一个脱机版本
It's web-based, but there's also an offline version

1270
01:01:05,760 --> 01:01:07,770
如果你往往没有最好的互联网。
if you tend not to have the best of internet.

1271
01:01:07,769 --> 01:01:10,169
但是用户界面通常看起来像这样。
But the user interface would typically look like this.

1272
01:01:10,170 --> 01:01:11,190
快速浏览。
And a quick tour.

1273
01:01:11,190 --> 01:01:15,390
因此，当你创建时，在草稿.mit.edu上
So here on scratch.mit.edu, when you go to create

1274
01:01:15,389 --> 01:01:20,399
通过界面上的按钮创建一个项目，你将首先看到Scratch，
a project via the button on the interface, you'll see first Scratch,

1275
01:01:20,400 --> 01:01:22,920
节目的同名人物，这只猫
the namesake of the program, this cat who

1276
01:01:22,920 --> 01:01:25,630
生活在这个可以移动的矩形小世界中，
lives in this little rectangular world in which you can move up,

1277
01:01:25,630 --> 01:01:26,505
向下，向左或向右。
down, left, or right.

1278
01:01:26,505 --> 01:01:29,310
但是猫可以被转换成任意数量的其他字符，
But the cat can be transformed into any number of other characters,

1279
01:01:29,309 --> 01:01:32,849
或我们称之为精灵的视觉表示。
or what we'll call sprites, visual representations thereof.

1280
01:01:32,849 --> 01:01:37,229
现在，这里的左侧是Scratch附带的所有构建块。
On the left here, now, are all of the building blocks that come with Scratch.

1281
01:01:37,230 --> 01:01:39,780
所有可用的编程结构
All of the programming constructs available to you

1282
01:01:39,780 --> 01:01:41,310
以拼图的形式。
in the form of puzzle pieces.

1283
01:01:41,309 --> 01:01:43,476
你会注意到，它们是根据
And you'll notice that they're categorized according

1284
01:01:43,476 --> 01:01:46,649
颜色和描述，还有一大堆拼图
to color and description and there's a whole bunch of puzzle pieces

1285
01:01:46,650 --> 01:01:48,120
而不是说他们做什么。
that rather say what they do.

1286
01:01:48,119 --> 01:01:52,079
今天的目标是不要陷入所有这些难题的杂草中
And today the goal is not to go into the weeds of all of these various puzzle

1287
01:01:52,079 --> 01:01:55,979
碎片，但强调一些可能的基本概念。
pieces, but to highlight some of the fundamental ideas that are possible.

1288
01:01:55,980 --> 01:01:58,695
我们将在此处通过屏幕中间探索这些想法。
And we'll explore those ideas via the middle of the screen here.

1289
01:01:58,695 --> 01:02:01,320
稍后，我们将能够开始拖放
We'll be able, in just a moment, to start dragging and dropping

1290
01:02:01,320 --> 01:02:04,110
这些拼图碎片放到更大的屏幕上
these puzzle pieces onto this larger screen

1291
01:02:04,110 --> 01:02:09,450
并将它们互锁在一起，如果这样做合乎逻辑。
and interlock them together, if it makes logical sense to do so.

1292
01:02:09,449 --> 01:02:11,789
最后，对于最复杂的程序，
Finally, for the most sophisticated programs,

1293
01:02:11,789 --> 01:02:14,699
我们实际上可以创建更多的角色或精灵
we can actually create yet more characters or sprites

1294
01:02:14,699 --> 01:02:18,579
并且实际上在屏幕上也有很多互动。
and actually have a lot of interactions on the screen as well.

1295
01:02:18,579 --> 01:02:21,629
但是，让我们继续前进，很快地举一个例子。
But let's go ahead and dive in with just an example quite quickly.

1296
01:02:21,630 --> 01:02:27,630
我要在屏幕上继续前进，确实要转到scratch.mit.edu。
I'm going to go ahead on my screen and go, indeed, to scratch.mit.edu.

1297
01:02:27,630 --> 01:02:30,430
也欢迎你在家中一起玩。
And you're welcome to play along at home as well.

1298
01:02:30,429 --> 01:02:33,899
我将单击“创建”以完全进入该界面。
And I'm going to click Create in order to get into exactly that interface.

1299
01:02:33,900 --> 01:02:37,140
除非你愿意，否则无需一开始就建立帐户。
You do not need to make an account from the get go unless you would like.

1300
01:02:37,139 --> 01:02:39,449
让我继续并开始创建程序。
And let me go ahead and start creating a program.

1301
01:02:39,449 --> 01:02:42,299
曾经是绝杀而编写的第一个程序，
The very first program that was once written, by lore,

1302
01:02:42,300 --> 01:02:46,170
简直就是Iris提出的“ Hello World”计划，
was quite simply what Iris proposed as "Hello World," a program that

1303
01:02:46,170 --> 01:02:47,850
在屏幕上打个招呼，世界。
prints on the screen hello, world.

1304
01:02:47,849 --> 01:02:48,999
好吧，我们该怎么做？
Well, how can we do that?

1305
01:02:49,000 --> 01:02:51,359
好吧，我可能很快就能做到
Well, I can probably do this quite quickly

1306
01:02:51,360 --> 01:02:53,698
因为我之前使用过界面，但是目标
because I've used the interface before, but the goal

1307
01:02:53,697 --> 01:02:55,739
如果你以前从未使用过此功能，
for you at hand if you've never used this before,

1308
01:02:55,739 --> 01:02:58,859
带着课程的第一个问题集或编程作业，真的
with the course's first problem set or programming assignment, really

1309
01:02:58,860 --> 01:03:01,740
只是让你的手变脏并探索和戳戳。
is just to get your hands dirty and explore and poke around.

1310
01:03:01,739 --> 01:03:05,789
很有可能，你正在寻找的想法最终会弹出。
And odds are, the ideas you are looking for, you'll find eventually pop out.

1311
01:03:05,789 --> 01:03:08,729
我要尝试的第一个是这里。
And the first one I'm going to try out is this one here.

1312
01:03:08,730 --> 01:03:12,030
这个拼图块是黄色或橙色的一点。
This puzzle piece that's a little yellow or orange in color.

1313
01:03:12,030 --> 01:03:16,200
它在“事件”类别中，单击绿色标记时将调用它。
It's in the Events category, and it's called when green flag clicked.

1314
01:03:16,199 --> 01:03:19,439
这很有趣，因为如果我在这里进入Scratch的舞台，
This is of interest, because if I go to Scratch's stage over here,

1315
01:03:19,440 --> 01:03:24,810
你会在左上角看到一个绿色标志，表示已通过，
you'll see at top left there's a green flag that's going to signify go,

1316
01:03:24,809 --> 01:03:27,629
还有一个红色的停止标志，表示停止。
and a red stop sign that's going to signify stop.

1317
01:03:27,630 --> 01:03:31,170
因此，如果我希望在单击该绿色标志时发生某些事情，
So if I want something to happen when I click that green flag,

1318
01:03:31,170 --> 01:03:33,520
我将从这个拼图开始。
I'm going to start with this puzzle piece here.

1319
01:03:33,519 --> 01:03:35,851
现在，我将进入“外观”类别。
Now I'm going to go over into the Looks category.

1320
01:03:35,851 --> 01:03:38,309
在“外观”类别中，有一大堆街区。
And in the Looks category, there's a whole bunch of blocks.

1321
01:03:38,309 --> 01:03:39,934
但是我们将在这里保持简单。
But we're going to keep it simple here.

1322
01:03:39,934 --> 01:03:44,669
我将继续讲Iris所说的规范，你好，逗号，
I'm going to go ahead and just say the canonical, as Iris noted, hello, comma,

1323
01:03:44,670 --> 01:03:45,390
世界。
world.

1324
01:03:45,389 --> 01:03:46,836
我将缩小。
I'll zoom back out.

1325
01:03:46,836 --> 01:03:49,919
我将移至此处的Scratch，然后单击绿色标志。
I'll move over to Scratch here, and I'm going to click now the green flag.

1326
01:03:49,920 --> 01:03:52,150
瞧，你好，世界。
And voila, hello, world.

1327
01:03:52,150 --> 01:03:55,410
这就是我的-也许很快，你的第一个程序，
So that is my-- and perhaps, soon, your-- very first program,

1328
01:03:55,409 --> 01:03:57,479
以这种语言使用Scratch。
using in this language Scratch.

1329
01:03:57,480 --> 01:03:59,880
但是，这当然不是很有趣。
But, of course, this isn't terribly interesting.

1330
01:03:59,880 --> 01:04:01,723
可能是第一次令人满足。
Might be gratifying for the very first time.

1331
01:04:01,722 --> 01:04:04,139
但这不是你想一次又一次地玩的东西。
But it's not something you'd want to play again and again.

1332
01:04:04,139 --> 01:04:06,151
但是我们可以使这件事更具互动性
But we can make this thing much more interactive

1333
01:04:06,152 --> 01:04:08,110
我们可以开始对这些构建基块进行分层
and we can start to layer these building blocks

1334
01:04:08,110 --> 01:04:10,980
并有一种类似于搜索电话簿的算法，
and have an algorithm more like searching that phone book,

1335
01:04:10,980 --> 01:04:12,460
有多个步骤。
that has multiple steps.

1336
01:04:12,460 --> 01:04:14,380
因此，让我继续并停止该程序。
So let me go ahead and stop that program.

1337
01:04:14,380 --> 01:04:16,320
让我来探索一下。
And let me explore a little bit instead.

1338
01:04:16,320 --> 01:04:19,860
这次，让我进入“感测”这个蓝色类别。
Let me go under Sensing this time, this blue category.

1339
01:04:19,860 --> 01:04:21,540
而且你将在这里看到此街区。
And you'll see this block here.

1340
01:04:21,539 --> 01:04:23,939
问你叫什么名字，然后等待。
Ask what's your name, and wait.

1341
01:04:23,940 --> 01:04:26,570
但是请注意，你的名字叫这个白色的椭圆形，
But notice that what's your name is in this white oval,

1342
01:04:26,570 --> 01:04:29,320
这意味着如果我想要，我可以更改问题所在，
and that implies that I can change what the question is if I want,

1343
01:04:29,320 --> 01:04:31,120
但我现在对这个问题还可以。
but I'm fine with that question for now.

1344
01:04:31,119 --> 01:04:34,619
让我继续，首先摆脱这些障碍，
And let me go ahead and first get rid of these blocks,

1345
01:04:34,619 --> 01:04:39,719
并在单击绿旗时给自己，这一次是在“传感”下
and give myself when green flag clicked, and this time start under Sensing

1346
01:04:39,719 --> 01:04:41,699
询问你叫什么名字，然后等待。
with ask what's your name and wait.

1347
01:04:41,699 --> 01:04:43,859
但是请注意，这是一个特殊的块。
But notice that this is kind of a special block.

1348
01:04:43,860 --> 01:04:46,920
它带有第二个块，即所谓的变量。
It comes with a second block, a so-called variable.

1349
01:04:46,920 --> 01:04:50,070
事实证明，这道谜题字面意思是
It turns out that this ask puzzle piece is literally

1350
01:04:50,070 --> 01:04:52,950
会问玩这个游戏的人一个问题，
going to ask the human who's playing this game a question,

1351
01:04:52,949 --> 01:04:57,149
并将该问题的答案存储在一个变量中，如图所示
and it's going to store the answer to that question in a variable, depicted

1352
01:04:57,150 --> 01:04:59,370
这里称为这个蓝色的椭圆形，称为答案。
here as this blue oval, called answer.

1353
01:04:59,369 --> 01:05:02,279
就像数学中一样，x，ay或z也是如此。
Just like in math, an x, a y, or a z.

1354
01:05:02,280 --> 01:05:03,970
那我该怎么办。
So what could I do with that.

1355
01:05:03,969 --> 01:05:05,729
好吧，让我再次进入外观。
Well, let me again go to Looks.

1356
01:05:05,730 --> 01:05:09,480
让我去打个招呼，但是这次，你知道吗？
Let me go to say hello, but this time, you know what?

1357
01:05:09,480 --> 01:05:13,410
让我继续打个招呼，逗号，然后-好吧，
Let me go ahead and say hello, comma, and then-- all right,

1358
01:05:13,409 --> 01:05:15,489
让我再说一遍。
let me give myself a second say block.

1359
01:05:15,489 --> 01:05:16,989
但我不想再打个招呼。
But I don't want to say hello again.

1360
01:05:16,989 --> 01:05:18,459
所以我要删除它。
So I'm going to delete that.

1361
01:05:18,460 --> 01:05:22,200
但是，我将回到“感测”，然后拖放答案。
But I'm going to go back to Sensing and I'm going to drag and drop answer.

1362
01:05:22,199 --> 01:05:24,989
现在看起来太大了，但是请注意，如果我接近它，
Now it looks a little too big, but notice if I get close to it,

1363
01:05:24,989 --> 01:05:26,999
有点磁性地想要连接。
it sort of magnetically wants to connect.

1364
01:05:27,000 --> 01:05:30,490
确实，Scratch会为我填补难题。
And indeed, Scratch will grow to fill the puzzle piece for me.

1365
01:05:30,489 --> 01:05:34,849
现在看来，我有一个用Scratch编写的程序，
So now I have a program, it would seem, a program written in Scratch,

1366
01:05:34,849 --> 01:05:38,099
一块用Scratch编写的软件，当绿色标志是
a piece of software written in Scratch that's going to, when the green flag is

1367
01:05:38,099 --> 01:05:41,099
单击，询问你的名字，然后等待-这就是我们的功能-
clicked, ask what's your name, and wait-- that's our function--

1368
01:05:41,099 --> 01:05:42,059
问好 -
say hello--

1369
01:05:42,059 --> 01:05:43,934
那是另一个功能-然后
that's another function-- and then it's going

1370
01:05:43,934 --> 01:05:45,839
无论人类输入什么，都可以说出答案。
to say answer, whatever the human typed in.

1371
01:05:45,840 --> 01:05:48,990
好吧，让我在这里转到Scratch的世界，然后单击绿色标志。
Well, let me go over to Scratch's world here and click the green flag.

1372
01:05:48,989 --> 01:05:50,939
注意猫在问我你叫什么名字。
Notice the cat is asking me what's your name.

1373
01:05:50,940 --> 01:05:53,550
我输入David并输入。
I type in David and enter.

1374
01:05:53,550 --> 01:05:55,040
嗯
Huh.

1375
01:05:55,039 --> 01:05:55,842
我只见大卫。
I only see David.

1376
01:05:55,842 --> 01:05:57,259
好吧，也许我做错了。
Well, maybe I did something wrong.

1377
01:05:57,260 --> 01:05:58,052
让我再做一次。
Let me do it again.

1378
01:05:58,052 --> 01:06:00,720
绿旗大卫（David）进入。
Green flag, D-A-V-I-D, enter.

1379
01:06:00,719 --> 01:06:02,369
唔。
Hmm.

1380
01:06:02,369 --> 01:06:04,289
这是怎么回事？
What's going on?

1381
01:06:04,289 --> 01:06:08,429
这似乎是一个错误，因为我很确定自己具有三个功能，
This seems to be a bug, because I'm pretty sure I have three functions,

1382
01:06:08,429 --> 01:06:10,679
问，说和说。
ask, say, and say.

1383
01:06:10,679 --> 01:06:13,679
但是我觉得我错过了第二条指令。
But I feel like I'm missing the second instruction.

1384
01:06:13,679 --> 01:06:17,879
对我犯了什么错误有任何想法吗？
Any thoughts on what bug I have made?

1385
01:06:17,880 --> 01:06:19,185
有什么解释呢？
What might explain this?

1386
01:06:22,030 --> 01:06:23,860
娜塔莉，是吗？
Natalie, is it?

1387
01:06:23,860 --> 01:06:26,957
听众：所以你用相同的功能替换了输出。
AUDIENCE: So you replaced the output with the same function.

1388
01:06:26,956 --> 01:06:27,789
大卫·J·马兰（David J MALAN）：是的。
DAVID J MALAN: Yeah.

1389
01:06:27,789 --> 01:06:29,664
我用相同的功能替换了输出。
I replaced the output with the same function.

1390
01:06:29,664 --> 01:06:33,069
老实说，即使我们使用的是一个非常简单的程序，Scratch，
And honestly, even though we're using a fairly simple program, Scratch,

1391
01:06:33,070 --> 01:06:34,900
我的Mac实际上非常快。
my Mac is actually pretty fast.

1392
01:06:34,900 --> 01:06:37,600
而且你的PC或Mac或手机都非常快。
And your PC or your Mac or your phone is pretty fast.

1393
01:06:37,599 --> 01:06:42,129
而且正如娜塔莉（Natalie）所说，即使Scratch在打招呼和回答，
And even though Scratch is saying hello and saying answer, as Natalie notes,

1394
01:06:42,130 --> 01:06:46,030
答案有点让人难以置信，因为我没有停下来。
the answer is sort of overwhelming to say, because I didn't so much as pause.

1395
01:06:46,030 --> 01:06:48,220
所以我可以进去找一个街区
So I could go in and find a block-- there's

1396
01:06:48,219 --> 01:06:50,949
一个等待块，可以让我插入一个任意的暂停。
a wait block that could allow me to insert an arbitrary pause.

1397
01:06:50,949 --> 01:06:52,789
但是我真的希望这是一口气。
But I really want this to be one breath.

1398
01:06:52,789 --> 01:06:55,449
我希望马上打个招呼，逗号，大卫。
I want it to be hello, comma, David, all at once.

1399
01:06:55,449 --> 01:06:56,539
那我该怎么办呢？
So how can I do that?

1400
01:06:56,539 --> 01:06:58,027
好吧，让我进入“操作”下。
Well, let me go under Operations.

1401
01:06:58,027 --> 01:07:00,819
事实证明，这里有一堆与数学相关的东西，
And it turns out there's a whole bunch of math-related things here,

1402
01:07:00,820 --> 01:07:04,930
而且这里还有一些与英语或语言相关的东西。
but also some English or language-related things down here.

1403
01:07:04,929 --> 01:07:06,134
加入苹果香蕉。
Join apple banana.

1404
01:07:06,135 --> 01:07:08,260
现在，这与苹果和香蕉无关。
Now this has nothing to do with apples and bananas.

1405
01:07:08,260 --> 01:07:10,885
这些只是占位符，但是这里有这个难题
Those are just placeholders, but there's this puzzle piece here

1406
01:07:10,885 --> 01:07:12,160
我可以拖放。
that I can drag and drop.

1407
01:07:12,159 --> 01:07:12,909
你知道吗？
And you know what?

1408
01:07:12,909 --> 01:07:14,076
让我继续执行此操作。
Let me go ahead and do this.

1409
01:07:14,077 --> 01:07:19,870
让我替换第一个输入要说的内容，然后让我加入问候逗号，然后
Let me replace the first input to say, and let me join hello comma, and then

1410
01:07:19,869 --> 01:07:22,101
不是香蕉，而是让我拖延答案-
not banana, but let me drag the answer--

1411
01:07:22,101 --> 01:07:23,559
并注意该位置会下降。
and notice that will drop in place.

1412
01:07:23,559 --> 01:07:24,879
让我把另一个方块扔掉。
Let me throw this other block away.

1413
01:07:24,880 --> 01:07:27,755
要删除内容，你只需将它们拖到左侧并放开即可。
To delete things, you can just drag them over to the left and let go.

1414
01:07:27,755 --> 01:07:31,300
现在请注意，我有一个程序正在询问你的名字
And now notice that I have a program that's asking what's your name

1415
01:07:31,300 --> 01:07:35,110
然后我要说说加入问候和回答的结果。
and then I'm going to say the result of joining hello and answer.

1416
01:07:35,110 --> 01:07:37,972
让我继续，并在停止旧版本后立即播放。
And let me go ahead and play this now, after stopping the old one.

1417
01:07:37,972 --> 01:07:38,680
你叫什么名字？
What's your name?

1418
01:07:38,679 --> 01:07:41,229
我输入David，输入，然后瞧。
I type in David, enter, and voila.

1419
01:07:41,230 --> 01:07:44,710
正如娜塔莉（Natalie）所说，现在它并没有绊倒自己，
As Natalie notes, now it's not tripping over itself,

1420
01:07:44,710 --> 01:07:46,270
破坏以前的存在。
clobbering what was previously there.

1421
01:07:46,269 --> 01:07:48,069
现在，我一口气得到了这一切。
Now I'm getting it all in one breath.

1422
01:07:48,070 --> 01:07:50,320
现在该程序变得更加有趣了，
Now the program is getting a little more interesting,

1423
01:07:50,320 --> 01:07:52,880
但是这种范式与以前没有什么不同。
but the paradigm is no different from before.

1424
01:07:52,880 --> 01:07:56,230
实际上，让我提出我们刚刚完成的所有工作
In fact, let me propose that everything we've just done

1425
01:07:56,230 --> 01:08:00,340
完全适合什么的整个心理模型
is fitting perfectly into this whole mental model of what

1426
01:08:00,340 --> 01:08:03,140
它意味着解决问题以及计算机科学本身是什么。
it means to solve problems and what computer science itself is.

1427
01:08:03,139 --> 01:08:06,669
因此，例如，如果这是要解决的问题
So for instance, if this is the problem to be solved

1428
01:08:06,670 --> 01:08:10,070
我有输入和输出是我的目标，还有两者之间的算法，
and I've got inputs and outputs are my goal and an algorithm in between,

1429
01:08:10,070 --> 01:08:12,580
让我们考虑一下Scratch如何适应这种心理模型。
let's consider how Scratch even fits into this mental model.

1430
01:08:12,579 --> 01:08:15,579
我刚才输入的第一个程序的输入
My input to the very first program that we wrote a moment ago

1431
01:08:15,579 --> 01:08:18,219
从字面上打招呼，它的椭圆形世界。
was literally hello, world in its own oval.

1432
01:08:18,220 --> 01:08:23,680
该算法在Scratch中被实现为一个称为say的函数。
The algorithm was implemented as a function in Scratch called say.

1433
01:08:23,680 --> 01:08:25,569
因此，有一个算法，分步说明，
So an algorithm, step by step instructions,

1434
01:08:25,569 --> 01:08:28,630
函数是计算机对算法的实现。
a function is the computer's implementation of an algorithm.

1435
01:08:28,630 --> 01:08:30,399
在这种情况下，称为say的功能。
In this case, a function called say.

1436
01:08:30,399 --> 01:08:33,010
当然，输出的是猫在打招呼，世界。
The output, of course, was the cat saying hello, world.

1437
01:08:33,010 --> 01:08:37,300
但是，纳塔莉（Natalie）发表讲话后，事情变得更加有趣了。
But things got more interesting just now after Natalie's remark, whereby when I

1438
01:08:37,300 --> 01:08:41,170
介绍一些类似的问题，问你叫什么名字，然后等待，
introduce something like ask what's your name and then wait,

1439
01:08:41,170 --> 01:08:43,460
注意这次在模型中发生了什么。
notice what happens this time in the model.

1440
01:08:43,460 --> 01:08:46,420
现在问题的输入是你的名字-
Now the input to the problem is what's your name--

1441
01:08:46,420 --> 01:08:49,630
那是默认情况下出现的字符串，我可以更改它，但是没有。
that's the string that comes by default, and I could change it but I didn't.

1442
01:08:49,630 --> 01:08:52,330
现在将其输入到ask块中。
That's being fed now into the ask block.

1443
01:08:52,329 --> 01:08:55,599
问块的生活目的是养猫
And the ask block's purpose in life is to get the cat

1444
01:08:55,600 --> 01:08:58,359
给我一个这样的答案
to give me an answer like this.

1445
01:08:58,359 --> 01:09:02,080
现在，这个答案很有趣，因为我现在可以加入它
Now, that answer is interesting because I can now join it

1446
01:09:02,079 --> 01:09:04,579
以单词hello作为前缀。
in with the word hello as a prefix.

1447
01:09:04,579 --> 01:09:06,999
因此，此块很有趣，因为注意，输入，
So this block is interesting because notice, the input,

1448
01:09:07,000 --> 01:09:10,930
“说”方块的白色椭圆形实际上还有另一个拼图块，然后
the white oval to the say block actually has another puzzle piece and then

1449
01:09:10,930 --> 01:09:12,760
在它上面还有两个拼图。
two more puzzle pieces on top of it.

1450
01:09:12,760 --> 01:09:16,090
这里很酷的是，在对函数进行编程时，
And what's cool here is that when programming functions,

1451
01:09:16,090 --> 01:09:20,529
你可以使一个功能的输出成为另一功能的输入。
you can have the outputs of one function become the input to another function.

1452
01:09:20,529 --> 01:09:22,660
因此，这里的流程非常简单。
And so the flow here is quite simply this.

1453
01:09:22,659 --> 01:09:26,559
现在我有两个输入到函数，两个都是你好，我写的，
Now I have two inputs to the function, both hello, which I wrote,

1454
01:09:26,560 --> 01:09:30,010
和答案，这是来自Ask块的。
and answer, which came from the ask block.

1455
01:09:30,010 --> 01:09:34,359
现在有问题的算法是我刚刚使用的联接函数。
The algorithm in question now is the join function, which I just used.

1456
01:09:34,359 --> 01:09:37,540
希望它的输出会打招呼，逗号，大卫。
And its output is hopefully going to be hello, comma, David.

1457
01:09:37,539 --> 01:09:40,959
但我不想在屏幕上看到一个白色的椭圆形，问好，逗号，大卫。
But I don't want to see a white oval on the screen saying hello, comma, David.

1458
01:09:40,960 --> 01:09:43,359
我要猫打招呼，逗号，大卫。
I want the cat to say hello, comma, David.

1459
01:09:43,359 --> 01:09:46,120
因此，让我继续，只专注于输出。
So let me go ahead and focus only on the output.

1460
01:09:46,119 --> 01:09:50,409
使它成为最终功能的输入，也就是块，
Make it become the input to a final function, which is that say block,

1461
01:09:50,409 --> 01:09:54,169
瞧，现在猫说了我想要的。
and voila, now the cat says what I want it to.

1462
01:09:54,170 --> 01:09:58,570
再说一遍，即使你开始筑巢，也要放置这些拼图
So again, even as you start to nest, that is, place these puzzle pieces

1463
01:09:58,569 --> 01:10:02,169
一个在另一个之上，我们要做的就是传递输入
one on top of the other, all we're doing is passing in inputs

1464
01:10:02,170 --> 01:10:03,040
并获得输出。
and getting outputs.

1465
01:10:03,039 --> 01:10:06,039
对这些输出进行处理，然后使它们成为输入，依此类推。
Doing something with those outputs and making them inputs, and so forth.

1466
01:10:06,039 --> 01:10:10,029
最终，这实际上就是编程意味着什么。
That really is the paradigm, ultimately, of what it means to program.

1467
01:10:10,029 --> 01:10:12,189
但是我们可以使猫做更多有趣的事情。
But we can make the cat do more interesting things.

1468
01:10:12,189 --> 01:10:14,147
只是为了从中获得一点乐趣，
And just to have a little bit of fun with this,

1469
01:10:14,148 --> 01:10:16,360
让我继续深入此底部图标
let me go ahead and dig in to this bottom icon

1470
01:10:16,359 --> 01:10:17,739
在屏幕的左下方。
at the bottom left of the screen.

1471
01:10:17,739 --> 01:10:20,529
Scratch具有这些所谓的扩展程序，你可以在其中真正地
Scratch has these so-called extensions, where you can really

1472
01:10:20,529 --> 01:10:22,459
使其做得更好。
make it do fancier things as well.

1473
01:10:22,460 --> 01:10:25,030
让我转到右上角的“文本到语音”。
And let me go to Text to Speech at the top right.

1474
01:10:25,029 --> 01:10:27,099
所以这是使用基于云的服务-
So this is using a cloud-based service--

1475
01:10:27,100 --> 01:10:29,260
这是一些基于互联网的服务-
that is some internet-based service--

1476
01:10:29,260 --> 01:10:32,860
这将发送我在互联网上输入的单词。
that's going to send the words that I type out on the internet.

1477
01:10:32,859 --> 01:10:37,029
互联网，那里的一些服务器，将以口头表达来回应
The internet, some server there, is going to respond with a verbalization

1478
01:10:37,029 --> 01:10:39,066
现在我刚刚输入的内容。
now of what it is I just typed.

1479
01:10:39,067 --> 01:10:40,400
因此，让我继续尝试。
So let me go ahead and try this.

1480
01:10:40,399 --> 01:10:42,609
让我摆脱紫色语音功能
Let me get rid of the purple say function

1481
01:10:42,609 --> 01:10:45,549
并替换为该语音块。
and replace it with this speak block.

1482
01:10:45,550 --> 01:10:48,190
让我继续并拖入拼图
And let me go ahead and drag in the join puzzle piece

1483
01:10:48,189 --> 01:10:49,899
在这里-请注意，它将不断增长，
here-- notice it's going to grow to fill,

1484
01:10:49,899 --> 01:10:51,859
而且我将不再使用它。
and I'm not going to use this one anymore.

1485
01:10:51,859 --> 01:10:54,639
这次我要点击“停止”，然后继续
This time I'm going to hit Stop and I'm going to go ahead

1486
01:10:54,640 --> 01:10:56,800
然后再次点击播放，然后输入我的名字。
and hit Play once more and type in my name.

1487
01:10:56,800 --> 01:10:57,780
和 -
And--

1488
01:10:57,779 --> 01:10:59,529
计算机：（女性机器人）你好，大卫。
COMPUTER: (FEMININE ROBOTIC) Hello, David.

1489
01:10:59,529 --> 01:11:01,529
DAVID J MALAN：好的，不是很自然的猫声音，
DAVID J MALAN: OK, not a very natural cat sound,

1490
01:11:01,529 --> 01:11:03,559
但请注意，我们可以设置不同的声音。
but notice we can set the voice differently.

1491
01:11:03,560 --> 01:11:05,350
因此请注意，我可以拖动此拼图。
So notice I can drag this puzzle piece.

1492
01:11:05,350 --> 01:11:07,690
你甚至可以将砖块挤压在其他砖块内。
And you can even squeeze blocks inside of others.

1493
01:11:07,689 --> 01:11:09,489
请注意，它可以随心所欲。
Notice that it can go wherever you want.

1494
01:11:09,489 --> 01:11:10,869
我将其放在此处的最高位置。
I'll put it at the very top here.

1495
01:11:10,869 --> 01:11:12,952
所以我可以把它放在几个不同的地方。
So I could put it in a couple of different places.

1496
01:11:12,953 --> 01:11:15,220
现在，默认声音是女低音。
Right now the default voice is alto.

1497
01:11:15,220 --> 01:11:16,840
吱吱声听起来合适。
Squeak sounds appropriate.

1498
01:11:16,840 --> 01:11:18,790
让我们尝试一下。
Let's try that.

1499
01:11:18,789 --> 01:11:20,586
键入我的名字，大卫。
Typing in my name, David.

1500
01:11:20,587 --> 01:11:22,170
计算机：（高音调）你好，大卫。
COMPUTER: (HIGH PITCHED) Hello, David.

1501
01:11:22,170 --> 01:11:22,530
DAVID J MALAN：好的。
DAVID J MALAN: All right.

1502
01:11:22,529 --> 01:11:23,609
还是不太像猫。
Still not very catlike.

1503
01:11:23,609 --> 01:11:27,719
具有讽刺意味的是，有一种小猫的声音，如果我改成小猫的话，
Ironically, there is a kitten voice, which if I change it to kitten,

1504
01:11:27,720 --> 01:11:29,520
我们现在将听到此消息。
we'll now hear this.

1505
01:11:29,520 --> 01:11:31,482
输入我的名字并输入。
Type in my name and enter.

1506
01:11:31,481 --> 01:11:32,939
计算机：（高音调）喵喵。
COMPUTER: (HIGH PITCHED) Meow meow.

1507
01:11:32,939 --> 01:11:35,249
DAVID J MALAN：好的，那时候我键入的内容并不重要。
DAVID J MALAN: OK, so it doesn't really matter at that point what I type in.

1508
01:11:35,250 --> 01:11:36,750
但是现在，这太神奇了。
But now this is amazing.

1509
01:11:36,750 --> 01:11:39,569
就像，我们已经从仅仅打个招呼，世界到打招呼，
Like, we've gone from just saying hello, world to hello,

1510
01:11:39,569 --> 01:11:41,219
大卫，这是动态变化的。
David, which is dynamically changing.

1511
01:11:41,220 --> 01:11:42,600
显然，如果你输入姓名，
If you were to type your name, obviously,

1512
01:11:42,600 --> 01:11:43,950
它会说你的名字。
it would say your name instead.

1513
01:11:43,949 --> 01:11:47,579
现在，由于有了云，也就是说，互联网上的服务器，
And now, thanks to the cloud, that is, servers on the internet,

1514
01:11:47,579 --> 01:11:51,089
我们会自动转换人类刚刚拥有的文本
we're converting automatically text that the human has just

1515
01:11:51,090 --> 01:11:53,190
提供到声音文件中-
provided into a sound file--

1516
01:11:53,189 --> 01:11:55,739
注释和持续时间，以及所有这些-
notes and durations and all of that--

1517
01:11:55,739 --> 01:11:57,699
变成我的计算机现在可以播放的内容。
into something my computer can now play.

1518
01:11:57,699 --> 01:12:00,449
好吧，让我们实际使这只猫听起来更像只猫。
Well, let's actually make this cat sound a little more like a cat.

1519
01:12:00,449 --> 01:12:02,241
让我继续前进，摆脱那些障碍
Let me go ahead and get rid of those blocks

1520
01:12:02,242 --> 01:12:07,080
在这里，让我现在从声音类别中讲一下自己，
here, and let me go and give myself now from the sound category,

1521
01:12:07,079 --> 01:12:07,709
这个怎么样？
how about this?

1522
01:12:07,710 --> 01:12:09,840
播放声音直到完成。
Play sound meow until done.

1523
01:12:09,840 --> 01:12:11,370
现在，这是一个简单的程序。
Now, this is a simple program.

1524
01:12:11,369 --> 01:12:14,549
单击绿色标志时，播放声音直到完成。
When the green flag is clicked, play sound meow until done.

1525
01:12:14,550 --> 01:12:15,130
开始了。
Here we go.

1526
01:12:15,130 --> 01:12:16,588
我要继续玩Play。
I'm going to go ahead and hit Play.

1527
01:12:16,587 --> 01:12:17,899
[喵]
[MEOW]

1528
01:12:17,899 --> 01:12:19,159
好吧，就是这样。
All right, that's it.

1529
01:12:19,159 --> 01:12:21,676
如果我想再次听到猫的叫声，我必须再做一次。
If I want to hear the cat meow again, I got to do it again.

1530
01:12:21,676 --> 01:12:22,839
[喵]
[MEOW]

1531
01:12:22,840 --> 01:12:23,637
太棒了。
OK, that's great.

1532
01:12:23,636 --> 01:12:26,094
只需单击一下，我就可以使自己好一阵子
I could kind of amuse myself for a while by just clicking--

1533
01:12:26,095 --> 01:12:26,595
[喵]
[MEOW]

1534
01:12:26,595 --> 01:12:27,170
-播放，但是-
--play, but--

1535
01:12:27,170 --> 01:12:27,670
[喵]
[MEOW]

1536
01:12:27,670 --> 01:12:29,170
-当然，我们可以做得更好。
--surely we can do better than this.

1537
01:12:29,170 --> 01:12:30,360
你可以想象-
You can imagine this--

1538
01:12:30,359 --> 01:12:31,119
[喵]
[MEOW]

1539
01:12:31,119 --> 01:12:32,539
-很快变得乏味。
--getting tedious quickly.

1540
01:12:32,539 --> 01:12:35,396
那么我怎样才能让猫一次又一次地这样做呢？
So how might I get the cat to do this again and again?

1541
01:12:35,396 --> 01:12:36,229
好吧，你知道吗？
Well, you know what?

1542
01:12:36,229 --> 01:12:39,399
让我继续前进，让我稍微抓住其中的一些。
Let me go ahead and let me just kind of grab a few of these.

1543
01:12:39,399 --> 01:12:41,877
喵，喵，喵，三遍。
Meow, meow, meow, three times.

1544
01:12:41,877 --> 01:12:44,169
因此，现在我不必再按两次按钮了。
So now that's two fewer times I have to hit the button.

1545
01:12:44,170 --> 01:12:46,250
[快速播放3次]
[MEOWING THREE TIMES RAPIDLY]

1546
01:12:46,250 --> 01:12:46,750
好的。
All right.

1547
01:12:46,750 --> 01:12:48,399
看起来好像不是最快乐的猫。
It doesn't seem like the happiest cat.

1548
01:12:48,399 --> 01:12:53,109
因此，让我实际去控制中心，让我再给他第二个休息时间。
So let me actually go to Control and let me give him a second break in between.

1549
01:12:53,109 --> 01:12:55,209
在这里等一会儿。
Wait one second in between here.

1550
01:12:55,210 --> 01:12:56,260
现在让我再来一次。
Now let me do it again.

1551
01:12:56,260 --> 01:12:59,560
[放映三遍]
[MEOWING THREE TIMES]

1552
01:12:59,560 --> 01:13:01,960
好吧，猫要快乐一些。
OK, slightly happier cat.

1553
01:13:01,960 --> 01:13:03,900
但这现在看起来有点混乱。
But this seems a little messy now.

1554
01:13:03,899 --> 01:13:05,079
这是对的。
This is correct.

1555
01:13:05,079 --> 01:13:06,279
叫三声。
It is meowing three times.

1556
01:13:06,279 --> 01:13:07,769
但是，让我去听众。
But let me go to the audience.

1557
01:13:07,770 --> 01:13:09,080
现在让我们考虑设计。
Let's now consider design.

1558
01:13:09,079 --> 01:13:11,829
回想一下，我们在电话簿的上下文中考虑了设计。
Recall that we considered design in the context of the phone book.

1559
01:13:11,829 --> 01:13:15,819
第三种算法设计得更好，因为它更快，
The third algorithm was better designed in that it was faster,

1560
01:13:15,819 --> 01:13:18,939
它效率更高，但是还有另一个要素
it was more efficient, but there's another element

1561
01:13:18,939 --> 01:13:23,139
设计，那就是如果可能的话，你不应该重复自己。
to design, which is that you shouldn't repeat yourself if possible.

1562
01:13:23,140 --> 01:13:25,668
所以你们那些以前编程的人
So those of you who have programmed before

1563
01:13:25,667 --> 01:13:27,459
可能知道这里的解决方案可能是什么。
might know what the solution here might be.

1564
01:13:27,460 --> 01:13:31,840
好吧，事实证明，回到第三行，我们称之为循环。
Well, it turns out that go back to line three, we call a loop.

1565
01:13:31,840 --> 01:13:34,060
事实证明，Scratch支持这些称为循环的事情。
Turns out Scratch supports these things called loops.

1566
01:13:34,060 --> 01:13:36,185
而且，实际上，这里有人盯着我。
And, in fact, there's one staring at me right here.

1567
01:13:36,185 --> 01:13:39,100
如果我向左放大，请注意在控制块下方，
If I zoom in on the left, notice that under the control blocks,

1568
01:13:39,100 --> 01:13:41,053
这些橙色方块有一个重复方块。
these orange blocks there's a repeat block.

1569
01:13:41,052 --> 01:13:43,719
即使默认情况下它为10，我敢打赌我们也可以更改它。
And even though it says 10 by default, I bet we can change that.

1570
01:13:43,720 --> 01:13:45,430
因此，让我将其拖到此处。
So let me drag that over here.

1571
01:13:45,430 --> 01:13:49,210
让我丢掉很多这种多余的东西，这些副本粘贴。
Let me throw away a lot of this redundancy, this copy paste.

1572
01:13:49,210 --> 01:13:52,480
让我将这些拼图碎片移动到重复块中，
Let me move these puzzle pieces inside of the repeat block,

1573
01:13:52,479 --> 01:13:54,069
而且它也会增长以适合他们。
and it, too, will grow to fit them.

1574
01:13:54,069 --> 01:13:55,089
没问题
Not a problem.

1575
01:13:55,090 --> 01:13:56,980
让我将重复次数更改为三个。
Let me change the repeat to three.

1576
01:13:56,979 --> 01:13:59,079
现在让我重新连接一切。
And now let me reconnect everything.

1577
01:13:59,079 --> 01:14:01,089
现在，该程序更加严格了。
And now the program is just tighter.

1578
01:14:01,090 --> 01:14:04,690
它使用更少的拼图块或更少的代码行，
It's using fewer puzzle pieces, or fewer lines of code,

1579
01:14:04,689 --> 01:14:07,609
如果你愿意的话，只需更少的步骤即可达到相同的结果。
fewer steps, if you will, to achieve the same result.

1580
01:14:07,609 --> 01:14:09,477
所以现在如果我单击绿色标记-
So now if I click the green flag--

1581
01:14:09,478 --> 01:14:13,230
[放映三遍]
[MEOWING THREE TIMES]

1582
01:14:13,229 --> 01:14:14,122
-它仍在工作。
--it's still working.

1583
01:14:14,122 --> 01:14:16,539
因此，你可以想象将其更改为所需的任何数字。
So you could imagine changing this to any number you want.

1584
01:14:16,539 --> 01:14:19,019
甚至有一个永远的障碍，我们可以永远做到，
There's even a forever block, where we could do it forever,

1585
01:14:19,020 --> 01:14:21,000
如果这只猫将永远这样做。
if the cat's going to do this in perpetuity.

1586
01:14:21,000 --> 01:14:22,590
但这是一个更好的程序。
But it's a better program now.

1587
01:14:22,590 --> 01:14:26,280
现在设计更好，因为如果我想更改时间量
Now it is better designed, because if I want to change the amount of time

1588
01:14:26,279 --> 01:14:28,619
猫在等我还是要换
the cat is waiting or if I want to change

1589
01:14:28,619 --> 01:14:30,779
猫叫的总次数，我
the total number of times the cat meows, I

1590
01:14:30,779 --> 01:14:34,889
可以在一处而不是一两个或三个地方更改这些详细信息，
can change those details in one place, not in one or two or three,

1591
01:14:34,890 --> 01:14:37,950
就像通过复制和粘贴相同的拼图一样。
as by copying and pasting those same puzzle pieces.

1592
01:14:37,949 --> 01:14:39,486
好吧，那永远的循环呢？
Well, what about that forever loop?

1593
01:14:39,487 --> 01:14:41,320
如果你确实想永远做某事怎么办？
What if you do want to do something forever?

1594
01:14:41,319 --> 01:14:42,329
我想怎么办？
What might I want to do?

1595
01:14:42,329 --> 01:14:44,009
好吧，让我们起床并动起来。
Well, let's get the cat up and moving.

1596
01:14:44,010 --> 01:14:46,410
现在让我进入运动类别。
Let me go under the motion category now.

1597
01:14:46,409 --> 01:14:49,799
让我指向鼠标指针。
Let me go to point towards mouse pointer.

1598
01:14:49,800 --> 01:14:51,240
因此，让我放大一下。
So let me zoom in on this.

1599
01:14:51,239 --> 01:14:54,509
每当猫指向鼠标指针时，
And every time the cat points toward the mouse pointer,

1600
01:14:54,510 --> 01:14:56,260
让他迈出一步。
let's have him take one step.

1601
01:14:56,260 --> 01:14:58,540
因此，我将采取一些步骤，
So I'm going to grab the move some number of steps,

1602
01:14:58,539 --> 01:15:00,269
我将把10改成1。
and I'm going to change the 10 to a one.

1603
01:15:00,270 --> 01:15:01,860
现在我要打Play。
And now I'm going to hit Play.

1604
01:15:01,859 --> 01:15:04,349
现在我们有了第一个程序，猫在哪里
And now we have our first program where the cat is

1605
01:15:04,350 --> 01:15:07,075
对我的Mac光标的响应。
kind of responding to my Mac's cursor.

1606
01:15:07,074 --> 01:15:09,699
我可以四处移动，有点傻瓜，
And I can move it around, and I can kind of get a little goofy,

1607
01:15:09,699 --> 01:15:11,339
但是从字面上带走了我。
but it's taking me literally.

1608
01:15:11,340 --> 01:15:15,068
它指向鼠标光标，然后向前移动了一步。
It's pointing at the mouse cursor and it's then moving one step.

1609
01:15:15,068 --> 01:15:16,360
现在，我可以使其移动更快。
Now, I can make it move faster.

1610
01:15:16,359 --> 01:15:17,699
让我停一秒。
Let me stop this for a second.

1611
01:15:17,699 --> 01:15:21,479
如果我一次不走一步，而是一次走两步怎么办？
What if I move not one step at a time, but two steps at a time?

1612
01:15:21,479 --> 01:15:24,329
而且我们会看到，猫现在移动得更快了。
And we'll see that now the cat is moving a little faster.

1613
01:15:24,329 --> 01:15:25,559
不太快。
Not quite super fast.

1614
01:15:25,560 --> 01:15:28,420
让我们一次执行20个步骤，看看会发生什么。
Let's do 20 steps at a time and see what happens.

1615
01:15:28,420 --> 01:15:30,450
这确实是动画的本质。
And this is really the essence of animation.

1616
01:15:30,449 --> 01:15:33,749
你调整的步数或更改数量越多
The more you adjust the number of steps or the number of changes happening

1617
01:15:33,750 --> 01:15:36,149
每秒或每单位时间的像素数，
to those pixels per second or per unit of time,

1618
01:15:36,149 --> 01:15:38,579
在屏幕上视觉上会发生更多的事情。
the more that's going to happen visually on the screen.

1619
01:15:38,579 --> 01:15:41,946
好吧，仅仅跟随我们还能做些什么？
Well, what more can we do from just following?

1620
01:15:41,947 --> 01:15:42,780
好吧，你知道吗？
Well, you know what?

1621
01:15:42,779 --> 01:15:45,539
如果我现在有能力让猫跟着我，
If I have the ability now to have the cat follow me,

1622
01:15:45,539 --> 01:15:47,449
让我一起尝试其他东西。
let me try something else altogether.

1623
01:15:47,449 --> 01:15:49,567
让我继续，打开另一个扩展。
Let me go ahead and open up another extension.

1624
01:15:49,568 --> 01:15:51,360
让我进入钢笔工具
Let me go into the Pen tool, which is going

1625
01:15:51,359 --> 01:15:55,619
现在让我在屏幕上用铅笔或钢笔绘图。
to allow me now to draw with, like, a pencil or pen on the screen.

1626
01:15:55,619 --> 01:16:00,319
我想让猫继续跟着我走，
And let me go ahead and still have the cat follow me, I think--

1627
01:16:00,319 --> 01:16:01,319
其实，你知道吗？
actually, you know what?

1628
01:16:01,319 --> 01:16:02,279
让我们改变这个。
Let's change this.

1629
01:16:02,279 --> 01:16:04,229
让他去我现在的位置。
Let's just have him go to where I am.

1630
01:16:04,229 --> 01:16:06,959
因此，还有另一个方块表示转到随机位置。
So there's another block that says go to random position.

1631
01:16:06,960 --> 01:16:07,930
我不要
I don't want that.

1632
01:16:07,930 --> 01:16:10,200
所以我将通过小三角菜单来更改它
So I'm going to change it by the little triangle menu

1633
01:16:10,199 --> 01:16:11,819
在这里，转到鼠标指针。
here, to go to the mouse pointer.

1634
01:16:11,819 --> 01:16:15,269
所以现在，永远，猫只会去到鼠标指针所在的位置。
So now, forever, the cat's just going to go to where the mouse pointer is.

1635
01:16:15,270 --> 01:16:18,210
它不会滑行或缓慢或快速地滑行。
It's not going to glide or do it slowly or quickly.

1636
01:16:18,210 --> 01:16:20,550
它只会移至光标所在的位置。
It's just going to go to wherever the cursor is.

1637
01:16:20,550 --> 01:16:23,970
现在，让我现在转到下面的这个新的Pen类别。
And let me go now to this new Pen category down below.

1638
01:16:23,970 --> 01:16:25,565
我该怎么办呢？
And how might I do this?

1639
01:16:25,564 --> 01:16:26,439
你知道我想要什么？
You know what I want?

1640
01:16:26,439 --> 01:16:28,469
我希望这只猫能为我画画。
I want this cat to be able to draw for me.

1641
01:16:28,470 --> 01:16:31,080
当我上下左右移动光标时，
When I move the cursor up, down, left, right, I

1642
01:16:31,079 --> 01:16:33,779
想要在屏幕上实际用墨水画些东西。
want to actually draw something with ink on the screen.

1643
01:16:33,779 --> 01:16:37,589
但是我只想在笔落下时画些东西。
But I only want to draw something when the pen is down.

1644
01:16:37,590 --> 01:16:41,520
请注意左侧，我刚刚介绍的两个拼图中的两个
Notice on the left that two of the two puzzle pieces I just introduced over

1645
01:16:41,520 --> 01:16:45,240
左边是笔向下和笔向上。
here at left are pen down and pen up.

1646
01:16:45,239 --> 01:16:48,089
但是这里缺少一些逻辑。
But there's a piece of missing logic here.

1647
01:16:48,090 --> 01:16:53,550
让我问听众，我们将如何改进该计划
Let me ask the audience how might we go about enhancing this program

1648
01:16:53,550 --> 01:16:58,500
这样猫不仅会跟随我的光标，而且还会在屏幕上画画？
so not only does the cat follow my cursor, but I also draw on the screen?

1649
01:16:58,500 --> 01:17:02,879
尼古拉斯，你会提出什么样的解决方案？
Nicholas, what kinds of solutions would you propose?

1650
01:17:02,880 --> 01:17:07,257
观众：所以你可以做一个if陈述-
AUDIENCE: So what you could do is take an if statement--

1651
01:17:07,256 --> 01:17:09,839
这样你就可以控制何时打开笔或何时向下笔，
so you can control when the pen is up or when the pen is down,

1652
01:17:09,840 --> 01:17:12,630
取决于你的某些情况。
depending on some condition that you have.

1653
01:17:12,630 --> 01:17:15,420
就像，我知道很多事情，都是通过单击鼠标来绘制的，
Like, I know a lot of things, you draw with the mouse click,

1654
01:17:15,420 --> 01:17:18,850
如果鼠标处于打开状态，则可以说笔处于关闭状态。
if the mouse is on, then you can say the pen is down.

1655
01:17:18,850 --> 01:17:21,720
而且，当没有单击鼠标时，笔就起来了。
And when the mouse click is not on, your pen is up.

1656
01:17:21,720 --> 01:17:24,330
然后，尽管它永远跟随着它
And then while it follows it forever it also

1657
01:17:24,329 --> 01:17:26,699
可以查看你的鼠标单击是打开还是关闭。
senses to see if your mouse click is on or off.

1658
01:17:26,699 --> 01:17:27,696
我真的不知道
I don't really know.

1659
01:17:27,697 --> 01:17:29,280
DAVID J MALAN：不，你确实知道。
DAVID J MALAN: No, you really do know.

1660
01:17:29,279 --> 01:17:30,449
那真是太完美了。
That was, like, perfect.

1661
01:17:30,449 --> 01:17:32,819
因为你本着永远拥有的原则
Because you took this principle of having the forever

1662
01:17:32,819 --> 01:17:35,579
不仅阻止了鼠标指针，而且你建议
block not only go to the mouse pointer, but you proposed

1663
01:17:35,579 --> 01:17:37,589
根据条件提出问题。
asking a question by a condition.

1664
01:17:37,590 --> 01:17:39,450
因此，让我实际上处于控制之下
So let me actually go under Control, where

1665
01:17:39,449 --> 01:17:44,069
我碰巧知道这个拼图是，并且注意到类似于我们的电话簿
I happen to know this puzzle piece is, and notice similar to our phone book

1666
01:17:44,069 --> 01:17:48,419
伪代码，我在这里说过，如果还有，如果还有，
pseudocode, where I said if else, if else, if else, well,

1667
01:17:48,420 --> 01:17:52,340
我认为，正如你所建议的，这里只有两个问题。
here there's only two questions, I think, as you're proposing.

1668
01:17:52,340 --> 01:17:55,210
鼠标按钮是向下还是向上？
Is the mouse button down or up?

1669
01:17:55,210 --> 01:17:57,700
因此，我认为我们可以通过其他方式摆脱困境。
So I think we can get away with just an if else.

1670
01:17:57,699 --> 01:18:01,199
因此，让我继续并将其拖到鼠标指针下方。
So let me go ahead and drag this below the go to mouse pointer.

1671
01:18:01,199 --> 01:18:04,299
然后注意中间的这种梯形形状
And then notice this little trapezoid-like shape in the middle

1672
01:18:04,300 --> 01:18:04,800
这里。
here.

1673
01:18:04,800 --> 01:18:07,570
让我在这里去传感。
Let me go to Sensing here.

1674
01:18:07,569 --> 01:18:09,989
请注意，如果我向下滚动，是的。
And notice if I scroll down-- yep, there it is.

1675
01:18:09,989 --> 01:18:11,519
在左边，注意到这个了吗？
On the left, notice this one?

1676
01:18:11,520 --> 01:18:13,200
鼠标按下，问号？
Mouse down, question mark?

1677
01:18:13,199 --> 01:18:15,089
这些是我们的布尔表达式。
These are our Boolean expressions.

1678
01:18:15,090 --> 01:18:18,052
让我将该布尔表达式拖动到类似的形状中。
Let me drag that Boolean expression into that similar shape.

1679
01:18:18,051 --> 01:18:19,259
它会不断增长以适应它。
It's going to grow to fit it.

1680
01:18:19,260 --> 01:18:20,510
然后我想怎么办？
And then what do I want to do?

1681
01:18:20,510 --> 01:18:24,020
如果鼠标按下，我想我想把笔放下。
If the mouse is down, I think I want to put the pen down.

1682
01:18:24,020 --> 01:18:28,950
否则，如果鼠标隐含地抬起，让我继续进行操作，然后将笔抬起
Else, if the mouse is implicitly up, let me go ahead and put the pen up

1683
01:18:28,949 --> 01:18:29,819
像这样。
like this.

1684
01:18:29,819 --> 01:18:31,289
好吧，让我继续全屏显示
Well, let me go ahead and full screen this, just

1685
01:18:31,289 --> 01:18:32,539
这样我们可以看到更好的效果。
so we can see a little better.

1686
01:18:32,539 --> 01:18:33,449
让我点击播放。
Let me hit Play.

1687
01:18:33,449 --> 01:18:35,819
现在，这只猫正按照我的承诺跟着我走。
And now the cat is following me, as promised.

1688
01:18:35,819 --> 01:18:37,229
但这现在是一只绘图猫。
But this is now a drawing cat.

1689
01:18:37,229 --> 01:18:44,469
如果我单击鼠标按钮，我会说类似的话，草书很差，
If I click the mouse button, I can say something like, very poorly in cursive,

1690
01:18:44,470 --> 01:18:45,580
你好。
Hello.

1691
01:18:45,579 --> 01:18:46,149
有点。
Sort of.

1692
01:18:46,149 --> 01:18:47,919
自从我做草书以来已经有很长时间了。
Been a long time since I've done cursive.

1693
01:18:47,920 --> 01:18:50,050
因此，我们现在让猫实际上在画些东西。
So we now have the cat actually drawing something.

1694
01:18:50,050 --> 01:18:52,270
老实说，这是只猫在画，这有点荒谬。
And honestly, it's a little ridiculous that it's a cat drawing.

1695
01:18:52,270 --> 01:18:53,050
但是你知道吗？
But you know what?

1696
01:18:53,050 --> 01:18:54,520
Scratch有这些服装。
Scratch has these costumes.

1697
01:18:54,520 --> 01:18:57,880
我们可以在这里左上角，即使Scratch带有两只猫
We could go at top left here, and even though Scratch comes with two cat

1698
01:18:57,880 --> 01:19:01,060
服饰，我们可以将其更改为笔或记号笔，或者实际上是任何东西
costumes, we could change it to be a pen or a marker or, really, anything

1699
01:19:01,060 --> 01:19:01,710
我们想要。
we want.

1700
01:19:01,710 --> 01:19:03,460
因为归根结底，这个精灵
Because at the end of the day, this sprite

1701
01:19:03,460 --> 01:19:05,920
实际上只是屏幕上的一个字符
is really just a character on the screen that

1702
01:19:05,920 --> 01:19:08,662
可以采用我们可能想要的任何形式。
can take any form that we might want.

1703
01:19:08,662 --> 01:19:10,120
好吧，我们如何才能进一步做到这一点？
Well, how can we take this further?

1704
01:19:10,119 --> 01:19:13,059
我喜欢这种条件和循环的介绍，
I like this introduction of conditions and loops,

1705
01:19:13,060 --> 01:19:15,620
但是我们可以在这里介绍其他一些原则。
but there's some other principles we can introduce here.

1706
01:19:15,619 --> 01:19:19,329
让我继续在这里开始一个新程序。
Let me go ahead and start a new program here altogether.

1707
01:19:19,329 --> 01:19:21,699
让我们看看我们是否无法开始计数
And let's see if we can't start counting up

1708
01:19:21,699 --> 01:19:23,629
并开始跟踪信息。
and start keeping track of information.

1709
01:19:23,630 --> 01:19:25,390
所以这次，让我们开始吧。
So for this time, let's do this.

1710
01:19:25,390 --> 01:19:29,033
单击绿色标志后，这次让我们进入变量
When the green flag is clicked, this time let's go under variables

1711
01:19:29,033 --> 01:19:30,700
让我们给自己一个新的变量。
and let's give ourselves a new variable.

1712
01:19:30,699 --> 01:19:33,819
从头开始，你可以创建拼图块，这是一个变量，
Scratch lets you create puzzle pieces, this one being a variable,

1713
01:19:33,819 --> 01:19:35,829
我将其称为计数器。
and I'm going to call this a counter.

1714
01:19:35,829 --> 01:19:38,649
只是一些要不断增加的东西。
Just something that's going to keep count from one on up.

1715
01:19:38,649 --> 01:19:42,159
现在，这给了我一些自定义的拼图
Now this has given me some custom puzzle pieces over here

1716
01:19:42,159 --> 01:19:45,279
称为计数器，然后是默认的我的变量，该变量已经存在。
called counter, and then the default my variable, which was there already.

1717
01:19:45,279 --> 01:19:46,862
我将继续执行此操作。
And I'm going to go ahead and do this.

1718
01:19:46,863 --> 01:19:49,960
我将计数器初始设置为1。
I'm going to set the counter initially equal to one.

1719
01:19:49,960 --> 01:19:51,790
然后我将永远做某事。
And then I'm going to do something forever.

1720
01:19:51,789 --> 01:19:53,559
让我抓住那些永远的障碍之一。
Let me grab one of those forever blocks.

1721
01:19:53,560 --> 01:19:55,820
我希望这只猫永远做下去。
And I want the cat now to do this forever.

1722
01:19:55,819 --> 01:20:00,159
我希望它只说当前的数量。
I want it to just say whatever the current count is.

1723
01:20:00,159 --> 01:20:02,199
所以我不想两秒钟打招呼。
So I don't want it to say hello for two seconds.

1724
01:20:02,199 --> 01:20:05,619
我想说一秒。
I want it to say something for one second, let's say.

1725
01:20:05,619 --> 01:20:07,879
因此，我将回到变量。
So I'm going to go back to variables.

1726
01:20:07,880 --> 01:20:11,980
我要抓住我创建的这个新的圆形计数器
And I'm going to grab this new circular shape, counter, that I created

1727
01:20:11,979 --> 01:20:13,364
并将其拖到那里。
and drag it right there.

1728
01:20:13,364 --> 01:20:15,239
因此，你可以从上到下逐字阅读。
So you can read this literally top to bottom.

1729
01:20:15,239 --> 01:20:18,889
所以数到一，然后等一会儿。
So counter to one, then forever say the counter for one second.

1730
01:20:18,890 --> 01:20:22,990
但是如果我们不希望猫一次又一次地说相同的数字，
But if we don't want the cat to say the same number again and again and again,

1731
01:20:22,989 --> 01:20:26,259
让我们继续前进，将计数器换一。
let's go ahead and change the counter by one.

1732
01:20:26,260 --> 01:20:29,080
这将隐式地将其添加到计数器中。
And that's implicitly going to add one to the counter.

1733
01:20:29,079 --> 01:20:31,989
现在，如果我继续点击播放，我们会看到一只猫
Now if I go ahead and hit Play, we see a cat

1734
01:20:31,989 --> 01:20:34,337
从一数到二到三，
that's counting from one to two to three,

1735
01:20:34,337 --> 01:20:36,879
理想情况下，它会一直计数到无穷大。
and it's going to count up, ideally, all the way to infinity.

1736
01:20:36,880 --> 01:20:39,010
现在不同了，我们有这个功能
The difference being now, we have this feature

1737
01:20:39,010 --> 01:20:41,800
实际使用一个变量，一个保持不变的变量
of actually using a variable, a variable that's keeping

1738
01:20:41,800 --> 01:20:44,290
跟踪一些信息。
track of some amount of information.

1739
01:20:44,289 --> 01:20:47,079
在这种情况下，数量会不断更新，
In this case, the number that's constantly being updated,

1740
01:20:47,079 --> 01:20:49,489
屏幕将一次又一次地重绘。
and the screen is being redrawn again and again.

1741
01:20:49,489 --> 01:20:51,489
好吧，现在让我继续，然后开始打开
Well, now let me go ahead and just start opening

1742
01:20:51,489 --> 01:20:53,679
我事先写的一些程序
a few programs that I wrote in advance, just

1743
01:20:53,680 --> 01:20:55,480
这样我们就可以浏览其中的一些。
so that we can get a tour of some of those.

1744
01:20:55,479 --> 01:20:58,996
我有一个名为Bounce的程序，它的工作原理如下。
I've got this program called Bounce that works a little something like this.

1745
01:20:58,997 --> 01:21:00,580
这也是编程的一部分。
And this, too, is part of programming.

1746
01:21:00,579 --> 01:21:03,416
不仅要编写自己的代码，还要阅读自己的代码。
Not only writing your own code, but reading your own code.

1747
01:21:03,417 --> 01:21:06,250
让我继续放大我已经创建的内容，
And let me go ahead and zoom in on this, which I've already created,

1748
01:21:06,250 --> 01:21:08,169
并考虑它的意思。
and consider what it says.

1749
01:21:08,170 --> 01:21:09,965
第一组，旋转样式，左，右。
First set, rotation style, left, right.

1750
01:21:09,965 --> 01:21:13,090
这只是一个修复，否则将是猫不小心遇到的错误
This is just a fix what would otherwise be a bug where the cat accidentally

1751
01:21:13,090 --> 01:21:14,110
最终倒挂。
ends up upside down.

1752
01:21:14,109 --> 01:21:15,661
但是，让我对此挥手。
But let me wave my hand at that.

1753
01:21:15,662 --> 01:21:16,870
这是有趣的部分。
This is the interesting part.

1754
01:21:16,869 --> 01:21:19,669
猫永远走了10步。
Forever have the cat moved 10 steps.

1755
01:21:19,670 --> 01:21:25,490
然后，如果它接触到边缘，则旋转180度。
And then if it's touching the edge, then turn around 180 degrees.

1756
01:21:25,489 --> 01:21:27,939
现在，我们可以重新介绍动画的概念。
So now we can reintroduce the idea of animation.

1757
01:21:27,939 --> 01:21:30,669
但这不是由我（人类）用光标驱动的。
But not that's driven by me, the human, with my cursor.

1758
01:21:30,670 --> 01:21:35,890
我现在可以制作游戏，互动艺术品或其他任何东西
I can now make a game, and interactive piece of art, or anything

1759
01:21:35,890 --> 01:21:37,540
现在这只猫是自我驱动的。
now where the cat is self-driven.

1760
01:21:37,539 --> 01:21:40,389
因为当我点击“立即播放”时，请注意
Because when I hit Play now, notice that it's

1761
01:21:40,390 --> 01:21:42,620
来回移动。
moving back and forth, back and forth.

1762
01:21:42,619 --> 01:21:45,249
如果它触碰到边缘和答案
And if it is touching the edge and the answer

1763
01:21:45,250 --> 01:21:50,740
这个布尔问题的答案实际上是“是”或“是”或“一个”
to that Boolean question is, actually, yes or true or one,

1764
01:21:50,739 --> 01:21:53,779
然后它将旋转180度。
then it's going to turn 180 degrees.

1765
01:21:53,779 --> 01:21:56,036
诚然，这看起来有点愚蠢。
But this looks kind of stupid, admittedly.

1766
01:21:56,037 --> 01:21:58,370
你知道，一只猫，是的，正在从屏幕上跳下来，
You know, one, the cat, yes, is bouncing off the screen,

1767
01:21:58,369 --> 01:21:59,529
这可能有点不现实。
which is maybe a little unrealistic.

1768
01:21:59,529 --> 01:22:01,029
但是他并没有真正走路。
But he's not really walking.

1769
01:22:01,029 --> 01:22:02,359
他在滑行。
He's gliding.

1770
01:22:02,359 --> 01:22:04,149
但这是关于动画的事情。
But this is the thing about animation.

1771
01:22:04,149 --> 01:22:07,119
就像我们在录像之前提到的那样，在一天结束时，
Just as we noted before that videos, at the end of the day,

1772
01:22:07,119 --> 01:22:10,856
实际上只是图像在屏幕上飞舞
are really just images flying across the screen--

1773
01:22:10,856 --> 01:22:11,439
你知道吗？
you know what?

1774
01:22:11,439 --> 01:22:15,219
我敢打赌，就像真实的视频中一样，我们可以创造自己的运动错觉，
I bet we can create our own illusion of movement, just like in a real video,

1775
01:22:15,220 --> 01:22:18,850
不仅穿着一种服装，一只猫的脚像这样。
by taking not just one costume, the cat with his feet like this.

1776
01:22:18,850 --> 01:22:22,630
如果我们给自己第二套服装，那几乎是一样的怎么办
What if we gave ourselves a second costume, where it's almost the same

1777
01:22:22,630 --> 01:22:24,760
但他的脚的位置略有不同？
but his feet are slightly differently positioned?

1778
01:22:24,760 --> 01:22:27,970
就像我们之前看过的纸质活页簿一样。
Just like the paper based flipbook that we looked at earlier.

1779
01:22:27,970 --> 01:22:28,720
你知道吗？
And you know what?

1780
01:22:28,720 --> 01:22:32,440
我敢打赌，如果我在这两种服装之间切换，
I bet if I toggle between these two costumes,

1781
01:22:32,439 --> 01:22:34,929
一次又一次地改变猫的状况，
changing the condition of the cat again and again,

1782
01:22:34,930 --> 01:22:38,360
我敢打赌，我们可以制造出实际运动的错觉。
I bet we can create the illusion of actual movement.

1783
01:22:38,359 --> 01:22:41,079
这就是我们在另一个弹跳示例中所拥有的。
And that's what we have here in this other bounce example.

1784
01:22:41,079 --> 01:22:44,529
在另一个弹跳示例中，我们现在正在移动猫
In this other bounce example, we have the cat now moving

1785
01:22:44,529 --> 01:22:48,009
不仅来回，而且注意这个紫色的拼图。
not only back and forth, but notice this purple puzzle piece.

1786
01:22:48,010 --> 01:22:52,210
从边缘弹起或考虑从边缘弹起后，
After it bounces off the edge, or considers bouncing off the edge,

1787
01:22:52,210 --> 01:22:55,630
它不断地改变其服装到下一个，到下一个，
it constantly changes its costume to the next one, to the next one,

1788
01:22:55,630 --> 01:22:58,670
到下一个，基本上是两者之间的交替
to the next one, essentially alternating between the two.

1789
01:22:58,670 --> 01:23:01,000
所以现在还不是很完美。
So now it's not quite perfect.

1790
01:23:01,000 --> 01:23:02,919
就像，我们称之为非常低的帧速率。
Like, it has what we call very low frame rate.

1791
01:23:02,920 --> 01:23:05,530
这就像在网上观看非常糟糕的GIF动画一样
This is like watching a really bad animated GIF online

1792
01:23:05,529 --> 01:23:08,679
它只有两个不同的框架。
that only has two different frames in it.

1793
01:23:08,680 --> 01:23:11,230
但看起来更像是他在走路，少得多
But it looks more like he's walking and much less

1794
01:23:11,229 --> 01:23:14,469
就像他在屏幕上来回滑动。
like he's gliding back and forth on the screen.

1795
01:23:14,470 --> 01:23:16,510
因此，我们实际上也可以从中获得一些乐趣。
So we can actually have some fun with this, too.

1796
01:23:16,510 --> 01:23:18,112
刮擦声。
Scratch support sounds.

1797
01:23:18,112 --> 01:23:20,320
因此，例如，这是我们之前听到的喵。
So, for instance, here's the meow we've heard before.

1798
01:23:20,319 --> 01:23:21,159
[喵]
[MEOW]

1799
01:23:21,159 --> 01:23:24,909
不过，如果我单击此处的小加号图标，则可以记录自己的内容。
I can record my own, though, if I click this little plus icon down here.

1800
01:23:24,909 --> 01:23:28,059
单击记录，并允许Scratch访问我的麦克风。
Click Record, and allow Scratch to access my microphone.

1801
01:23:28,060 --> 01:23:29,690
单击确定几次。
Click OK a couple of times.

1802
01:23:29,689 --> 01:23:30,189
开始了。
Here we go.

1803
01:23:30,189 --> 01:23:32,139
让我录制自己的声音。
Let me record my own voice.

1804
01:23:32,140 --> 01:23:33,140
哎哟。
Ouch.

1805
01:23:33,140 --> 01:23:33,640
好的。
All right.

1806
01:23:33,640 --> 01:23:36,432
那就是Ouch这个词的模样，至少在我发音的时候。
That's what the word Ouch looks like, at least when I pronounce it.

1807
01:23:36,431 --> 01:23:38,619
我可以在这里剪掉开头。
I can trim off the beginning here.

1808
01:23:38,619 --> 01:23:39,759
让我保存一下。
Let me save that.

1809
01:23:39,760 --> 01:23:42,000
我要给这张唱片起个名字，哦，
I'm going to give this recording a name, Ouch,

1810
01:23:42,000 --> 01:23:43,951
现在让我回到我的代码。
and now let me go back to my code.

1811
01:23:43,952 --> 01:23:45,660
在挡声板下，你知道吗？
And under the sound block, you know what?

1812
01:23:45,659 --> 01:23:48,539
让我继续说。
Let me go ahead and say this.

1813
01:23:48,539 --> 01:23:52,329
如果我触摸边缘，不仅要旋转180度。
If I'm touching the edge, not only do I want to turn 180 degrees.

1814
01:23:52,329 --> 01:23:56,469
现在，我可以使它更具趣味性。
Now I can kind of make this a little more playful.

1815
01:23:56,470 --> 01:23:57,790
电脑：哎呀。
COMPUTER: Ouch.

1816
01:23:57,789 --> 01:23:59,079
哎哟。
Ouch.

1817
01:23:59,079 --> 01:23:59,589
哎哟。
Ouch.

1818
01:23:59,590 --> 01:23:59,860
DAVID J MALAN：好的。
DAVID J MALAN: All right.

1819
01:23:59,859 --> 01:24:02,692
仍然不是很像猫，但同样，我们只是分层而已。
Still not very catlike, but again, we're just layering and layering.

1820
01:24:02,693 --> 01:24:05,655
这些方案的真正意义在于
And the takeaway here really is, as these programs

1821
01:24:05,654 --> 01:24:08,779
变得越来越复杂，在编写代码时目标永远不应该是
get more and more complicated, the goal should never be, when writing code,

1822
01:24:08,779 --> 01:24:10,539
无论是以Scratch还是C还是最终
whether it's in Scratch or C or eventually

1823
01:24:10,539 --> 01:24:13,209
此类或其他类别的Python，请尝试并开始尝试
Python in this class or others, to just start and try

1824
01:24:13,210 --> 01:24:14,920
实现你的整个愿景。
to implement your entire vision.

1825
01:24:14,920 --> 01:24:17,920
请注意，我从头开始编写的所有这些程序中，
Notice with every one of these programs that I wrote from scratch,

1826
01:24:17,920 --> 01:24:22,180
无双关语，我从小处开始，添加一两个或三个难题
no pun intended, did I start small and add one or two or three puzzle

1827
01:24:22,180 --> 01:24:25,810
从简单的东西发展到更复杂的东西。
pieces, building up from something simple to something more complex.

1828
01:24:25,810 --> 01:24:26,560
你知道吗？
And you know what?

1829
01:24:26,560 --> 01:24:30,130
我敢打赌，如果我们综合其中的一些想法，我们也可以做其他事情。
I bet if we synthesize some of these ideas, we can do yet other things too.

1830
01:24:30,130 --> 01:24:33,370
这是另一个例子，可能涉及抚摸猫。
Here's another example that involves, perhaps, petting a cat.

1831
01:24:33,369 --> 01:24:35,379
让我继续看一下该程序的内部。
Let me go ahead and see inside this program.

1832
01:24:35,380 --> 01:24:40,090
这个比较简单，但是目前还没有做任何事情。
This one's relatively simple, but it's not doing anything just yet.

1833
01:24:40,090 --> 01:24:41,710
我已经打了绿旗。
I already hit the green flag.

1834
01:24:41,710 --> 01:24:45,190
让我放大代码，也许你现在可以阅读我自己的代码
Let me Zoom in on the code, and you can, perhaps, now read my own code

1835
01:24:45,189 --> 01:24:46,659
我事先写的
that I wrote in advance.

1836
01:24:46,659 --> 01:24:50,649
猫永远在问这个问题，如果碰到鼠标指针则
The cat is forever asking the question, if touching mouse pointer then

1837
01:24:50,649 --> 01:24:52,649
播放声音直到完成。
play that sound meow until done.

1838
01:24:52,649 --> 01:24:55,149
好吧，即使程序正在运行，
Well, it would seem that even though the program is running,

1839
01:24:55,149 --> 01:24:56,349
它什么也没做。
it's not doing anything.

1840
01:24:56,350 --> 01:24:56,980
但它是。
But it is.

1841
01:24:56,979 --> 01:24:59,059
它正在等待某些事情发生。
It's waiting for something to happen.

1842
01:24:59,060 --> 01:25:01,780
所以让我将光标移到猫上，就像-
So let me move my cursor over the cat like--

1843
01:25:01,779 --> 01:25:03,159
[喵]
[MEOW]

1844
01:25:03,159 --> 01:25:04,079
- 这。
--this.

1845
01:25:04,079 --> 01:25:05,919
[喵]
[MEOW]

1846
01:25:05,920 --> 01:25:08,890
这样看来，如果我把它放在那儿，他会继续喵喵叫。
So it would seem, and if I leave it on there, he'll keep meowing.

1847
01:25:08,890 --> 01:25:11,590
这有点像是在抚摸猫的程序。
And it's kind of like a program that's petting a cat.

1848
01:25:11,590 --> 01:25:13,660
所以你可以想象现在有条件
And so you can imagine now having conditions

1849
01:25:13,659 --> 01:25:16,269
在使用布尔表达式确定的循环内部
inside of loops that are using Boolean expressions to decide

1850
01:25:16,270 --> 01:25:18,550
正是你想要做的事。
exactly what you want something to do.

1851
01:25:18,550 --> 01:25:22,460
更强大的是，即使使用Scratch之类的语言，我们也可以做到这一点。
And even more powerfully, even in a language like Scratch can we do this.

1852
01:25:22,460 --> 01:25:26,530
让我在这里打开有一个非常独特的树皮的海狮。
Let me open up the sea lion here, who has a very distinct bark.

1853
01:25:26,529 --> 01:25:30,279
但是他现在在演示具有多个脚本的程序。
But he's demonstrative now of a program that has multiple scripts.

1854
01:25:30,279 --> 01:25:33,729
因此，在这个Scratch项目中，我们不仅是一个程序，而且是两个。
So inside of this Scratch project now, we're not just one program but two.

1855
01:25:33,729 --> 01:25:36,681
请注意，这两者都在单击绿色标志时开始。
Notice both of which start when a green flag is clicked.

1856
01:25:36,681 --> 01:25:38,389
让我将它们都放在屏幕上。
And let me put them both onto the screen.

1857
01:25:38,390 --> 01:25:39,290
而且看起来更长。
And it looks longer.

1858
01:25:39,289 --> 01:25:41,929
但这仅仅是因为拼图不断增长，以适应彼此。
But that's just because the puzzle pieces are growing to fit each other.

1859
01:25:41,930 --> 01:25:43,360
让我们继续前进，点击“播放”。
Let's go ahead and hit Play on this.

1860
01:25:43,359 --> 01:25:43,859
玩
Play

1861
01:25:43,859 --> 01:25:47,039
[海狮吠叫]
[SEA LION BARKING]

1862
01:25:47,039 --> 01:25:51,419
注意，大约每秒钟，海狮都在吠叫。
Notice that every second or so, the sea lion is barking.

1863
01:25:51,420 --> 01:25:53,490
坦白说，这很快就令人讨厌。
And frankly, this gets annoying quickly.

1864
01:25:53,489 --> 01:25:54,839
但是我怎样才能阻止它呢？
But how can I stop it?

1865
01:25:54,840 --> 01:25:58,230
好吧，让我继续前进，在它仍然吠叫的时候在左边看。
Well, let me go ahead and look over here on the left while it's still barking.

1866
01:25:58,229 --> 01:26:01,829
请注意，海狮永远在问一个问题。
Notice the sea lion is forever asking a question.

1867
01:26:01,829 --> 01:26:07,089
如果静音等于假，则开始发出海狮的声音，请打个招呼两秒钟。
If muted equals false, start sounds sea lion, think hi hi hi for two seconds.

1868
01:26:07,090 --> 01:26:07,980
那么什么是静音的？
So what is muted?

1869
01:26:07,979 --> 01:26:09,779
好吧，回想起来，它的形状代表了
Well, the shape of it, recall, represents

1870
01:26:09,779 --> 01:26:13,869
一个变量，例如x或y或z，它只是保留信息的一种方式。
a variable, like x or y or z, which is just some way of retaining information.

1871
01:26:13,869 --> 01:26:17,879
所以这就像说，静音变量的值是否为false？
So this is like saying, is the value of the muted variable false?

1872
01:26:17,880 --> 01:26:22,590
如果是这样，你应该吠叫，因为如果它被错误静音，或者没有被静音，
If so, you should bark, because if it's false muted, if it's not muted,

1873
01:26:22,590 --> 01:26:24,480
继续播放海狮声。
go ahead and play the sea lion sound.

1874
01:26:24,479 --> 01:26:27,899
但是，我的上帝，让我们-在这里的右边，注意到还有另一个程序。
But my god, lets-- on the right here, notice there's another program.

1875
01:26:27,899 --> 01:26:31,049
单击绿色标志时，请永远提出问题。
When the green flag is clicked, forever ask the question.

1876
01:26:31,050 --> 01:26:34,980
如果按下空格键，则如果静音为true，
If the spacebar is pressed, then if muted is true,

1877
01:26:34,979 --> 01:26:38,559
将静音设置为false，否则将静音设置为true。
set muted to false, else set muted to true.

1878
01:26:38,560 --> 01:26:42,240
因此，右侧的程序将更改静音的值
So the program on the right is going to change the value of muted

1879
01:26:42,239 --> 01:26:44,269
从假到真或从真到假。
from false to true or true to false.

1880
01:26:44,270 --> 01:26:45,780
因为，天哪。
Because, my god.

1881
01:26:45,779 --> 01:26:47,324
我打了空格键
I've hit the space bar--

1882
01:26:47,324 --> 01:26:48,539
[海狮吠叫]
[SEA LION BARKING]

1883
01:26:48,539 --> 01:26:52,159
现在结束了。
And now it's over.

1884
01:26:52,159 --> 01:26:54,379
该程序仍在运行，但不再运行
The program is still running, but it's no longer

1885
01:26:54,380 --> 01:26:58,397
播放，因为静音现在为true而不是false。
playing because muted is now true and not false.

1886
01:26:58,396 --> 01:26:59,479
好吧，我们还能做什么？
Well, what else can we do?

1887
01:26:59,479 --> 01:27:01,639
事情很快就会变得很漂亮。
Things can get pretty fancy pretty quickly.

1888
01:27:01,640 --> 01:27:04,220
让我继续在这里创建另一个程序。
Let me go ahead and create one other program here.

1889
01:27:04,220 --> 01:27:06,770
我将继续进行，仅需两个方块即可完成。
And I'll go ahead and do one with just two blocks.

1890
01:27:06,770 --> 01:27:10,820
这个-让我再次进入扩展，这次是视频感测，
This one-- let me go into the extensions again, video sensing this time,

1891
01:27:10,819 --> 01:27:13,939
并注意有不同类型的启动程序的方法。
and notice there's different types of ways to start programs.

1892
01:27:13,939 --> 01:27:17,059
单击绿色标志时，并非每个程序都必须启动。
Not every program has to start when you click the green flag.

1893
01:27:17,060 --> 01:27:19,490
这里有一个类似的形状，但是这个是绿色的，
There's a similar shape here, but this one in green, that

1894
01:27:19,489 --> 01:27:21,289
表示视频运动大于10时。
says when video motion is greater than 10.

1895
01:27:21,289 --> 01:27:23,029
好像有10％的屏幕在移动。
Like 10% of the screen is moving.

1896
01:27:23,029 --> 01:27:25,009
让我将其增加到50％。
Let me increase that to 50%.

1897
01:27:25,010 --> 01:27:26,810
让我继续执行此操作。
And let me go ahead and do this.

1898
01:27:26,810 --> 01:27:30,050
让我继续前进，找到声音拼图。
Let me go ahead and find the sound puzzle piece.

1899
01:27:30,050 --> 01:27:31,850
播放声音直到完成。
Play sound meow until done.

1900
01:27:31,850 --> 01:27:34,520
所以现在我有一个两个程序块的程序。
So now I have a two block program.

1901
01:27:34,520 --> 01:27:38,780
当视频运动大于50时，播放声音直到结束。
When video motion is more than 50, play sound meow until done.

1902
01:27:38,779 --> 01:27:39,487
让我缩小。
Let me zoom out.

1903
01:27:39,488 --> 01:27:41,780
你会注意到我实际上在这里。
And you'll notice that I'm actually in the screen here.

1904
01:27:41,779 --> 01:27:43,639
让我离开舞台。
Let me move off stage.

1905
01:27:43,640 --> 01:27:47,040
现在什么都没有发生。
And now nothing is happening.

1906
01:27:47,039 --> 01:27:49,054
不过，让我去抚摸猫。
Let me go and pet the cat, though.

1907
01:27:49,055 --> 01:27:51,180
[喵]
[MEOW]

1908
01:27:51,180 --> 01:27:52,385
让我再做一次。
Let me do it again.

1909
01:27:52,385 --> 01:27:53,570
[喵]
[MEOW]

1910
01:27:53,569 --> 01:27:54,299
然后再次。
And again.

1911
01:27:54,300 --> 01:27:55,970
因此，它使用的是我计算机的摄像头-
So it's using my computer's camera--

1912
01:27:55,970 --> 01:27:56,510
[喵]
[MEOW]

1913
01:27:56,510 --> 01:28:00,408
-检测运动，然后执行该特定程序。
--detecting motion, and then executing that particular program.

1914
01:28:00,408 --> 01:28:02,450
同样，仅凭这些简单的构建块，
So again, with just these simple building blocks,

1915
01:28:02,449 --> 01:28:04,879
我们可以使越来越多的有趣事情发生吗？
can we get more and more interesting things to happen.

1916
01:28:04,880 --> 01:28:05,630
你知道吗？
And you know what?

1917
01:28:05,630 --> 01:28:07,310
我们甚至可以有多个精灵。
We can even have multiple sprites.

1918
01:28:07,310 --> 01:28:09,410
让我继续，打开一个老派游戏
Let me go ahead and open up an old school game

1919
01:28:09,409 --> 01:28:11,269
你可能在游泳池里玩过的游戏，
that you might have played in, like, a swimming pool, perhaps,

1920
01:28:11,270 --> 01:28:14,330
长大后，一个人大喊马可，另一个人大喊大叫
growing up, where one person yells out Marco and the other people

1921
01:28:14,329 --> 01:28:16,099
应该大吼大叫Polo。
are supposed to yell out Polo.

1922
01:28:16,100 --> 01:28:19,010
注意这里我们有一个带有两个精灵的程序。
Notice here we have a program with two sprites.

1923
01:28:19,010 --> 01:28:21,680
所以有两个木偶，一个橙色的木偶和一个蓝色的木偶。
So two puppets, an orange puppet and a blue puppet.

1924
01:28:21,680 --> 01:28:24,390
第一次在底部，
And down here at the bottom, for the very first time,

1925
01:28:24,390 --> 01:28:27,440
我们有两种不同的精灵编写程序的能力。
We have two different sprites' abilities to write programs.

1926
01:28:27,439 --> 01:28:29,609
所以现在选择了橙色木偶，
So right now the orange puppet is selected,

1927
01:28:29,609 --> 01:28:31,669
这意味着该程序位于左上角，
which means the program at top left here,

1928
01:28:31,670 --> 01:28:34,072
在这里，属于橙色木偶。
up here, belongs to the orange puppet.

1929
01:28:34,072 --> 01:28:35,780
而且橙色p已经被编程
And the orange puppet has been programmed

1930
01:28:35,779 --> 01:28:39,439
永远说，如果按下键盘的空格键，
to say forever, if the keyboard's space key is pressed,

1931
01:28:39,439 --> 01:28:41,239
然后说Marco两秒钟。
then say Marco for two seconds.

1932
01:28:41,239 --> 01:28:42,649
然后是新功能。
And then here's the new feature.

1933
01:28:42,649 --> 01:28:46,039
编程中有一种方法可以像进行一次程序交谈
There's a way in programming to have, like, one program talk

1934
01:28:46,039 --> 01:28:49,069
与另一个，或者在这种情况下，一个精灵与另一个交谈。
to another, or in this case, one sprite talk to another.

1935
01:28:49,069 --> 01:28:52,439
传递一种你在屏幕上看不到的秘密消息。
Sort of passing a secret message that you don't see on the screen.

1936
01:28:52,439 --> 01:28:54,409
但是一个程序可以听到另一个程序的声音。
But one program can hear from another.

1937
01:28:54,409 --> 01:28:56,539
这就是所谓的广播事件。
And that's called broadcasting an event.

1938
01:28:56,539 --> 01:28:58,429
这就是橙色木偶在做什么。
And that's what the orange puppet is doing.

1939
01:28:58,430 --> 01:29:00,627
如果我在这里单击蓝色木偶的图标，
If I click on the blue puppet's icon here,

1940
01:29:00,627 --> 01:29:02,210
他根本不会做太多事情。
he's not going to do very much at all.

1941
01:29:02,210 --> 01:29:05,010
但是，当单击绿色标志时，不执行任何操作，
But instead of doing anything when the green flag is clicked,

1942
01:29:05,010 --> 01:29:07,700
而不是在摄像机看到运动时做些什么，
instead of doing something when the camera sees motion,

1943
01:29:07,699 --> 01:29:14,089
相反，当他收到事件时，他要说Polo两秒钟。
he instead is going to, when he receives the event, say Polo for two seconds.

1944
01:29:14,090 --> 01:29:17,690
因此，在这种情况下，如果我立即点击“播放”，则什么也不会发生。
And so in this case, if I hit Play now, nothing happens yet.

1945
01:29:17,689 --> 01:29:23,299
但是当我按下空格键时，橙色表示马可，蓝色表示波罗。
But when I do hit the spacebar, orange says Marco, blue says Polo.

1946
01:29:23,300 --> 01:29:25,550
但是它们是独立编写的。
But they are written independently.

1947
01:29:25,550 --> 01:29:28,250
我已经为橙色编写了一个程序，为蓝色编写了一个程序，
I've written one program for orange, one program for blue,

1948
01:29:28,250 --> 01:29:30,439
他们正在以某种方式进行交流。
and they're somehow communicating.

1949
01:29:30,439 --> 01:29:32,539
说到交流，甚至还有
And speaking of communicating, there's even

1950
01:29:32,539 --> 01:29:36,229
这些天，借助互联网和云，你可以做更多的事情。
more things you can do these days thanks to the internet and the cloud.

1951
01:29:36,229 --> 01:29:40,129
让我继续，在这里打开另一个新画布。
Let me go ahead and open up one other new canvas here.

1952
01:29:40,130 --> 01:29:42,710
单击绿标时，很快给自己一个提示。
Very quickly give myself a when green flag clicked.

1953
01:29:42,710 --> 01:29:45,950
我先问同样的问题，问你叫什么名字
Let me go ahead and ask that same question before, ask what's your name

1954
01:29:45,949 --> 01:29:46,489
等一下
and wait.

1955
01:29:46,489 --> 01:29:48,709
但是现在让我进入这些扩展并让
But now let me go into these extensions and let

1956
01:29:48,710 --> 01:29:50,990
我找到了翻译扩展名，也就是
me find the translate extension, which is, again,

1957
01:29:50,989 --> 01:29:54,619
要使用云发送我在互联网上输入的任何内容
going to use the cloud to send whatever I type in out on the internet

1958
01:29:54,619 --> 01:29:57,839
然后返回响应，然后在此处在屏幕上说出来。
and get back a response, and then say it on the screen here.

1959
01:29:57,840 --> 01:30:01,680
因此，让我继续在屏幕上说些什么，例如打个招呼。
So let me go ahead and say something on the screen, like say hello.

1960
01:30:01,680 --> 01:30:02,930
但是我不想打招呼。
But I don't want to say hello.

1961
01:30:02,930 --> 01:30:05,360
我想回到“翻译”类别，
I want to go back to the Translate category,

1962
01:30:05,359 --> 01:30:07,356
我想继续翻译-
and I want to go ahead and translate--

1963
01:30:07,356 --> 01:30:07,939
你知道吗？
you know what?

1964
01:30:07,939 --> 01:30:08,779
我喜欢这个街区。
I like this block.

1965
01:30:08,779 --> 01:30:11,249
将某物翻译成另一种语言。
Translate something to another language.

1966
01:30:11,250 --> 01:30:14,390
但是，让我再次获得其中一个连接块，然后让我继续
But let me get one of those join blocks again, and let me go ahead

1967
01:30:14,390 --> 01:30:19,200
并输入单词hello，然后输入此人键入的姓名。
and join the word hello and then the name that the person has typed in.

1968
01:30:19,199 --> 01:30:21,689
为此，我再次需要答案块。
So to get that, I need the answer block again.

1969
01:30:21,689 --> 01:30:24,479
因此，我只是重新创建了较早版本的某些块。
So I'm just recreating some of our blocks from earlier.

1970
01:30:24,479 --> 01:30:26,779
并注意，在我刚刚这样做之前。
And notice, before I just did this.

1971
01:30:26,779 --> 01:30:31,399
我说了加入问候和回答的结果，尽管上次是逗号。
I said the result of joining hello and answer, albeit with a comma last time.

1972
01:30:31,399 --> 01:30:32,879
但是现在让我们开始吧。
But now let's do this.

1973
01:30:32,880 --> 01:30:37,370
让我接受join的输出，使其成为要翻译的输入。
Let me take the output of join, make it the input to translate.

1974
01:30:37,369 --> 01:30:39,589
让我在这里翻译成阿拉伯语。
Let me translate, say, to Arabic here.

1975
01:30:39,590 --> 01:30:41,700
让我拖放到say块中。
Let me drag and drop into the say block.

1976
01:30:41,699 --> 01:30:46,099
所以现在我们有两个输入要加入，连接的输出要去
So now we have two inputs going into join, join's output going

1977
01:30:46,100 --> 01:30:50,570
转化为翻译的输入，然后转化为翻译的输出。
into the input of translate, and the output of translate going into say.

1978
01:30:50,569 --> 01:30:55,399
但最终结果是，我将输入我的名字David并按Enter。
But the net result is going to be I'll type in my name David and hit Enter.

1979
01:30:55,399 --> 01:30:57,559
你好，大卫，现在是阿拉伯语。
Hello, David, now in Arabic.

1980
01:30:57,560 --> 01:31:00,920
全部归功于这些功能，条件和循环的原理，
All thanks to these principles of functions, conditions, and loops,

1981
01:31:00,920 --> 01:31:03,770
现在甚至加入了互联网。
and now even adding in the internet.

1982
01:31:03,770 --> 01:31:07,190
现在让我们考虑一下，最后再玩几局游戏。
Now let's consider finally, before we play a final couple of games.

1983
01:31:07,189 --> 01:31:10,339
总而言之，有一种方法甚至可以改善
In conclusion, there's a way to even improve

1984
01:31:10,340 --> 01:31:12,270
我们所做的很多事情的设计。
the design of a lot of what we've done.

1985
01:31:12,270 --> 01:31:16,610
实际上，让我回想一下刚才我们听到的那一声叫喊声。
In fact, let me go back just a moment to where we left off with that meowing.

1986
01:31:16,609 --> 01:31:19,369
在我们其中一个讨人喜欢的例子中，
And in one of our meowing examples, we had

1987
01:31:19,369 --> 01:31:22,489
看起来像这样的代码，我重复了三遍，
code that looked like this, where I repeated three times,

1988
01:31:22,489 --> 01:31:26,719
回想起来，我一次又一次地播放声音。
recall, and I played the sound meow again and again and again.

1989
01:31:26,720 --> 01:31:29,070
我当时认为这是更好的设计。
And I argued at the time that this was better designed.

1990
01:31:29,069 --> 01:31:29,569
为什么？
Why?

1991
01:31:29,569 --> 01:31:32,369
因为我不只是再次拖放同一块拼图
Because I didn't just drag and drop the same puzzle piece again

1992
01:31:32,369 --> 01:31:33,259
一遍又一遍。
and again and again.

1993
01:31:33,260 --> 01:31:36,560
我用了一个重复块，我丢掉了所有的冗余，
I used a repeat block, I threw away all of the redundancy,

1994
01:31:36,560 --> 01:31:38,150
而且我可以说一直很简单。
and I've arguably kept it simple.

1995
01:31:38,149 --> 01:31:40,789
我使用了一些更好的想法，但是代码更简单
I'm using some fancier ideas, but the code is simpler

1996
01:31:40,789 --> 01:31:42,859
而且现在拼图的数量更少了。
and it's fewer puzzle pieces now.

1997
01:31:42,859 --> 01:31:45,139
但事实证明，机会错失了
But it turns out that there's a missed opportunity

1998
01:31:45,140 --> 01:31:47,840
在这里应用计算机科学的另一个原理，
here to apply another principle of computer science,

1999
01:31:47,840 --> 01:31:50,750
这就是我们通常所说的抽象。
and this is what we would generally describe as abstraction.

2000
01:31:50,750 --> 01:31:53,299
抽象是解决问题的绝妙方法
Abstraction is this amazing problem solving

2001
01:31:53,300 --> 01:31:55,460
实际上只是一种奇特的表达方式
technique that's really just a fancy way of saying

2002
01:31:55,460 --> 01:31:59,150
让我们采用一个非常复杂的想法，或者一个稍微复杂的想法
let's take a very complicated idea, or a slightly complicated idea

2003
01:31:59,149 --> 01:32:04,669
并以某种方式简化它，我们都同意你可以实施它
and simplify it in such a way that we all agree that you can implement it

2004
01:32:04,670 --> 01:32:10,040
复杂的方式，但让我们现在规定一下
the complicated way, but let's now just stipulate

2005
01:32:10,039 --> 01:32:14,429
我们将在一个更简单的层面上考虑它。
that we're going to think about it as on a more simple level.

2006
01:32:14,430 --> 01:32:17,510
因此，让我继续看这个相同的程序。
So let me go over to this same program.

2007
01:32:17,510 --> 01:32:18,260
你知道吗？
And you know what?

2008
01:32:18,260 --> 01:32:22,250
奇怪的是，Scratch没想到会有喵叫声。
Scratch, curiously, did not anticipate having a meow block.

2009
01:32:22,250 --> 01:32:27,349
例如，有一个发言权区和一个思考区，但没有喵叫区。
Like, there is a say block and there's a think block, but there's no meow block.

2010
01:32:27,350 --> 01:32:31,100
这似乎适合于内置了猫的程序。
And that seems appropriate for a program where it comes with a cat built in.

2011
01:32:31,100 --> 01:32:32,030
因此，我们可以做到这一点。
So we can do this.

2012
01:32:32,029 --> 01:32:35,339
正如你可以创建自己的变量一样，请注意此处的左下方，
Just as you can create your own variables, notice at bottom left here,

2013
01:32:35,340 --> 01:32:38,610
你可以使用此粉红色类别创建自己的积木。
you can create your own blocks with this pink category.

2014
01:32:38,609 --> 01:32:40,429
如果我去这里，我将成为一个障碍
And if I go here, I'm going to make a block

2015
01:32:40,430 --> 01:32:42,440
我将这个叫作“喵喵”。
and I'm going to call this block meow.

2016
01:32:42,439 --> 01:32:45,839
很简单，我将单击“确定”。
And quite simply, I'm going to click OK.

2017
01:32:45,840 --> 01:32:49,160
现在注意，我得到了这个新玩具，上面写着喵。
Now notice I get this new puzzle piece that says define meow.

2018
01:32:49,159 --> 01:32:51,589
并且已经准备好将其他部分连接到它。
And it's ready to have other pieces connected to it.

2019
01:32:51,590 --> 01:32:53,130
我要如何定义喵？
How am I going to define meow?

2020
01:32:53,130 --> 01:32:56,005
我将继续将其拖到此处，因为我已经
I'm just going to go ahead and drag this over here, because I already

2021
01:32:56,005 --> 01:32:57,200
实施喵之前。
implemented meow before.

2022
01:32:57,199 --> 01:32:59,959
现在，请注意我左侧的内容。
And now, notice what I have on the left hand side.

2023
01:32:59,960 --> 01:33:03,230
因为我刚刚制作了这个自定义积木或拼图，
Because I've just made this custom block or puzzle piece,

2024
01:33:03,229 --> 01:33:07,369
我现在有一个名为喵的粉红色小块，就像Scratch附带的那样。
I now have a pink piece called meow, just as though it came with Scratch.

2025
01:33:07,369 --> 01:33:10,639
现在，令人着迷的是，我可以思考一下
And now what's compelling about this is that I can sort of think

2026
01:33:10,640 --> 01:33:12,350
视而不见，无所适从。
of this as out of sight, out of mind.

2027
01:33:12,350 --> 01:33:14,190
谁在乎喵的实现方式？
Who cares how meow is implemented?

2028
01:33:14,189 --> 01:33:16,039
我们知道我们早些时候实现了它。
We know we implemented it earlier.

2029
01:33:16,039 --> 01:33:19,379
现在让我们规定我们可以认为它的存在是理所当然的。
Let's now just stipulate that we can take for granted it exists.

2030
01:33:19,380 --> 01:33:23,210
而且，如果我现在放大新程序，那么从某种意义上讲它现在更具可读性。
And if I zoom in now on the new program, now it's more readable in some sense.

2031
01:33:23,210 --> 01:33:24,290
有点短。
It's a little shorter.

2032
01:33:24,289 --> 01:33:26,059
它的拼图块更少了。
It has a fewer puzzle piece.

2033
01:33:26,060 --> 01:33:29,210
但这也更具有自我描述性。
But it also is more self-descriptive.

2034
01:33:29,210 --> 01:33:30,202
我可以阅读我的代码。
I can read my code.

2035
01:33:30,202 --> 01:33:31,910
我可以看一下这段代码，然后说，好的，
I can look at this code and say, OK, it's

2036
01:33:31,909 --> 01:33:34,849
显然要重复三声喵叫声。
obviously going to repeat three times a meow block.

2037
01:33:34,850 --> 01:33:36,310
但是，让我们玩。
But let's play that.

2038
01:33:36,310 --> 01:33:36,810
[喵]
[MEOW]

2039
01:33:36,810 --> 01:33:38,460
没什么两样
It's no different.

2040
01:33:38,460 --> 01:33:38,960
[喵]
[MEOW]

2041
01:33:38,960 --> 01:33:40,384
二。
Two.

2042
01:33:40,384 --> 01:33:41,330
[喵]
[MEOW]

2043
01:33:41,329 --> 01:33:44,239
但是我敢打赌，我们可以进一步简化这一步骤，
But I bet we can simplify this one step further and make

2044
01:33:44,239 --> 01:33:45,649
它更加灵活。
it a little more flexible.

2045
01:33:45,649 --> 01:33:49,519
让我继续前进，然后在喵自定义块上单击鼠标右键或按住Control键单击。
Let me go ahead and right click or control click on the meow custom block.

2046
01:33:49,520 --> 01:33:53,270
让我在这里实际添加一个我们称为n的输入。
And let me actually add an input here that we'll call n.

2047
01:33:53,270 --> 01:33:55,850
让我添加一个带有时间的标签。
And let me just add a label that says times.

2048
01:33:55,850 --> 01:33:57,510
让我继续，然后单击“确定”。
And let me go ahead and click OK.

2049
01:33:57,510 --> 01:33:59,677
并请注意，我的拼图现在看起来有所不同。
And notice that my puzzle piece now looks different.

2050
01:33:59,676 --> 01:34:02,059
看起来更像是MIT的一些输入块
It looks more like some of MIT's blocks that take input

2051
01:34:02,060 --> 01:34:03,390
这些小小的白色椭圆形。
with these little white ovals.

2052
01:34:03,390 --> 01:34:06,350
而且，实际上，现在注意我能做什么。
And, in fact, now notice what I can do.

2053
01:34:06,350 --> 01:34:11,330
正如Scratch对我来说，我可以更改喵的定义，
I can change the definition of meow, as Scratch already has for me,

2054
01:34:11,329 --> 01:34:13,559
这样我现在可以在内部做更多的事情。
such that I can now do more inside.

2055
01:34:13,560 --> 01:34:15,930
让我实际上断开所有这些东西。
Let me actually disconnect all of this stuff.

2056
01:34:15,930 --> 01:34:20,040
让我将重复块移至喵本身的定义。
Let me move the repeat block to the definition of meow itself.

2057
01:34:20,039 --> 01:34:23,449
让我继续播放声音，然后在该重复块中等待，
Let me go ahead and play the sound and wait inside of that repeat block,

2058
01:34:23,449 --> 01:34:26,119
但请注意最后的这个小圆圈。
but notice this little circle around the end.

2059
01:34:26,119 --> 01:34:29,269
现在让我重复任意次数。
Let me just repeat an arbitrary number of times now.

2060
01:34:29,270 --> 01:34:32,430
我不必担心对3个或10个或其他任何东西进行硬编码。
I don't have to worry about hard coding three or 10 or anything else.

2061
01:34:32,430 --> 01:34:36,500
而现在，在你的视线范围之内，你无需再为此担心。
And now, out of sight, out of mind, don't have to worry about that anymore.

2062
01:34:36,500 --> 01:34:40,549
现在让我们简化一下这个越来越复杂的程序
Let's now just whittle down that increasingly complicated program

2063
01:34:40,550 --> 01:34:43,730
我们之前写的，实际上只有两个拼图。
that we wrote earlier into, really, just two puzzle pieces.

2064
01:34:43,729 --> 01:34:47,519
单击绿色标志时，肯定会发出三声喵叫。
When the green flag is clicked, meow, sure, three times.

2065
01:34:47,520 --> 01:34:50,720
我不必再知道或不在乎喵是如何实现的。
I don't have to know or care any more how meow is implemented.

2066
01:34:50,720 --> 01:34:54,590
我只需要知道有人为我做了，无论是麻省理工学院还是也许
I just need to know that someone did it for me, whether MIT or maybe

2067
01:34:54,590 --> 01:34:56,360
我自己，几分钟前。
myself, minutes ago.

2068
01:34:56,359 --> 01:34:57,834
我将再次点击播放。
I'll click play again.

2069
01:34:57,835 --> 01:34:59,655
[放映三遍]
[MEOWING THREE TIMES]

2070
01:34:59,654 --> 01:35:03,039
二三
Two, and three.

2071
01:35:03,039 --> 01:35:05,919
因此，现在我们有了抽象的实现。
And so now we have an implementation of abstraction.

2072
01:35:05,920 --> 01:35:09,190
采取一个有点复杂的想法，例如让猫咪喵喵叫，
Taking a somewhat complicated idea, like getting a cat to meow,

2073
01:35:09,189 --> 01:35:11,679
不用担心所谓的实施细节，
not worrying about the so-called implementation details,

2074
01:35:11,680 --> 01:35:15,160
并定义一个叫做喵的拼图或功能。
and just defining a puzzle piece or function called meow.

2075
01:35:15,159 --> 01:35:17,379
好吧，现在让我们一起考虑所有这些
Well, now let's take all of this together

2076
01:35:17,380 --> 01:35:21,910
并查看你过去的一些前任作品的一些创作。
and see some of the creations of some of your predecessors in past terms.

2077
01:35:21,909 --> 01:35:26,229
举例来说，这是几年前一位同学的故事
Here, for instance, is a sort of story that one of your classmates years ago

2078
01:35:26,229 --> 01:35:28,712
涉及姜饼故事。
made involving a gingerbread tale.

2079
01:35:28,712 --> 01:35:30,879
让我继续进行全屏播放，然后单击“播放”。
Let me go ahead and full screen this and click Play.

2080
01:35:30,880 --> 01:35:31,505
[音乐播放]
[MUSIC PLAYING]

2081
01:35:31,505 --> 01:35:35,200
现在你将看到我们已经有多个精灵，每个精灵
And you'll see now that we have multiple sprites already, each of which

2082
01:35:35,199 --> 01:35:37,829
有不同的服装，有人问我一个问题。
have different costumes, and I'm being asked a question.

2083
01:35:37,829 --> 01:35:38,829
你想要一个苹果吗？
Would you like an apple?

2084
01:35:38,829 --> 01:35:39,399
是还是不是。
Yes or no.

2085
01:35:39,399 --> 01:35:40,779
所以我不再被问到我的名字了。
So I'm no longer being asked my name.

2086
01:35:40,779 --> 01:35:42,099
我被问到任意问题。
I'm being asked arbitrary questions.

2087
01:35:42,100 --> 01:35:42,470
当然。
Sure.

2088
01:35:42,470 --> 01:35:43,887
我继续吃一个苹果。
Let me go ahead and have an apple.

2089
01:35:43,886 --> 01:35:45,459
我输入是，然后按Enter。
I type in yes and hit Enter.

2090
01:35:45,460 --> 01:35:46,450
注意运动。
Notice the movement.

2091
01:35:46,449 --> 01:35:48,429
我们以前看过运动。
We've seen movement before.

2092
01:35:48,430 --> 01:35:50,170
[刺耳的声音]
[CHOMPING SOUNDS]

2093
01:35:50,170 --> 01:35:50,950
[音乐播放]
[MUSIC PLAYING]

2094
01:35:50,949 --> 01:35:54,099
好的，不幸的是，这是在这个故事中做出的错误决定。
OK, unfortunately, that was the wrong decision to make in this story.

2095
01:35:54,100 --> 01:35:55,090
这样就可以了
So that's OK.

2096
01:35:55,090 --> 01:35:56,290
让我们重新开始。
Let's start it again.

2097
01:35:56,289 --> 01:35:57,279
红色停车标志。
Red stop sign.

2098
01:35:57,279 --> 01:35:57,969
[音乐播放]
[MUSIC PLAYING]

2099
01:35:57,970 --> 01:35:58,757
绿旗。
Green flag.

2100
01:35:58,756 --> 01:36:00,339
你好亲爱的，你想要一个苹果吗？
Hello dearie, would you like an apple?

2101
01:36:00,340 --> 01:36:02,440
不，让我们从这一课中学到东西。
No, let's learn from that lesson.

2102
01:36:02,439 --> 01:36:04,269
蛋糕听起来好多了。
Cupcake sounds much better.

2103
01:36:04,270 --> 01:36:05,680
这次我输入是。
I'll type yes this time.

2104
01:36:05,680 --> 01:36:07,270
再次注意该动议。
Notice, again, the motion.

2105
01:36:07,270 --> 01:36:09,370
所以那里有一些动画。
So there's some animation there.

2106
01:36:09,369 --> 01:36:11,409
它正在触碰另一个精灵。
It's touching the other sprite.

2107
01:36:11,409 --> 01:36:12,909
那也是不幸的。
That, too, was unfortunate.

2108
01:36:12,909 --> 01:36:16,599
让我们最后一次尝试这种艺术。
Let's try one last time with this art.

2109
01:36:16,600 --> 01:36:18,470
现在我们有一个苹果，没有。
And now we have an apple, no.

2110
01:36:18,470 --> 01:36:19,210
吸取了教训。
Learned a lesson.

2111
01:36:19,210 --> 01:36:19,960
蛋糕，不。
Cupcake, no.

2112
01:36:19,960 --> 01:36:21,040
吸取了教训。
Learned a lesson.

2113
01:36:21,039 --> 01:36:24,287
好的，现在让我们看看该循环会发生什么。
OK, now let's see what happens with that loop.

2114
01:36:24,287 --> 01:36:25,751
[咯咯地笑]
[CACKLING]

2115
01:36:25,752 --> 01:36:29,170
[尖叫]
[SCREAMING]

2116
01:36:29,170 --> 01:36:31,270
[刺耳的声音]
[CHOMPING SOUNDS]

2117
01:36:31,270 --> 01:36:32,650
好，惊喜结束。
OK, surprise ending.

2118
01:36:32,649 --> 01:36:35,679
但这就是说，通过采用这些循环构建块，
But this is all to say that by taking these building blocks of loops,

2119
01:36:35,680 --> 01:36:37,420
条件和功能，你可以开始制造东西吗
conditions, and functions, can you start to make things

2120
01:36:37,420 --> 01:36:38,770
更具互动性。
that are a little more interactive.

2121
01:36:38,770 --> 01:36:41,380
实际上，我本人几年前就做过-第一件事
In fact, I myself did something years ago-- the very first thing

2122
01:36:41,380 --> 01:36:44,213
我自己在Scratch中写的实际上是我在读研究生时
I myself wrote in Scratch was actually when I was in graduate school

2123
01:36:44,212 --> 01:36:47,629
并交叉注册了麻省理工学院的一门课程，教授
and cross-registered for a class at MIT, the professor for which

2124
01:36:47,630 --> 01:36:50,830
是Scratch本身的作者和创始人。
was the author of and the originator of Scratch itself.

2125
01:36:50,829 --> 01:36:53,469
让我继续全屏讨论并提出建议
And let me go ahead and full screen this and propose

2126
01:36:53,470 --> 01:36:58,030
我当时如何考虑解决当今的一个相当大的问题。
how I thought about solving, now, a fairly large problem back in the day.

2127
01:36:58,029 --> 01:37:00,669
尽量将掉落的垃圾拖入罐中。
Drag as much falling trash into the can as you can.

2128
01:37:00,670 --> 01:37:01,840
那么现在发生了什么呢？
So what's happening now?

2129
01:37:01,840 --> 01:37:03,958
屏幕上掉了一块垃圾。
A piece of trash is falling on the screen.

2130
01:37:03,957 --> 01:37:06,249
你会看到它从上到下移动，
You'll see that it's moving from the top to the bottom,

2131
01:37:06,250 --> 01:37:08,040
我们已经看到了这样的动画。
and we've seen animations like that.

2132
01:37:08,039 --> 01:37:08,679
但是请注意这一点。
But watch this.

2133
01:37:08,680 --> 01:37:11,800
我打赌使用条件和永远循环，
I bet using a condition and a forever loop,

2134
01:37:11,800 --> 01:37:14,600
我们可以使它成为可能。
we can make it possible to pick this up.

2135
01:37:14,600 --> 01:37:18,010
请注意，现在垃圾就像猫一样跟随着我的光标。
Notice now the trash is following my cursor, just like the cat was.

2136
01:37:18,010 --> 01:37:21,550
并请注意，如果碰触到其他垃圾桶可能会造成污染，
And notice if touching this other trash can sprite,

2137
01:37:21,550 --> 01:37:24,760
也许我们甚至可以让Oscar脱颖而出。
maybe we can even get Oscar to pop out of the can.

2138
01:37:24,760 --> 01:37:27,700
然后，他开始计算我的分数，从而使用一个变量，
And he, then, starts counting up my score, thereby using a variable,

2139
01:37:27,699 --> 01:37:30,399
实际上，随着更多的精灵或更多的垃圾掉落，
and indeed, as more sprites or more trash falls,

2140
01:37:30,399 --> 01:37:32,612
我可以继续以这种方式玩游戏。
I can continue to play a game in this way.

2141
01:37:32,613 --> 01:37:35,530
但是在这里，即使事情开始变得更快，
But here, too, even though things are starting to happen more quickly,

2142
01:37:35,529 --> 01:37:38,279
屏幕上还有更多，歌曲在后台播放，
there's more on the screen, the song is playing in the background,

2143
01:37:38,279 --> 01:37:40,719
所有这些都简化为基本的构建基块。
it all reduces to basic building blocks.

2144
01:37:40,720 --> 01:37:42,040
我不能强调太多。
And I can't emphasize enough.

2145
01:37:42,039 --> 01:37:44,379
当我几年前写第一个程序时，
When I wrote that first program years ago,

2146
01:37:44,380 --> 01:37:46,390
我没有实现你刚刚看到的内容。
I did not implement what you just saw.

2147
01:37:46,390 --> 01:37:49,240
我想我做的第一件事就是我在Google周围搜索
I think the very first thing I did was I googled around

2148
01:37:49,239 --> 01:37:52,514
并找到了芝麻街的路灯，然后将其放在屏幕上。
and found Sesame Street's street lamp and I put that on the screen.

2149
01:37:52,515 --> 01:37:53,890
那是第一个版本。
And that was sort of version one.

2150
01:37:53,890 --> 01:37:56,170
它什么也没做，但是看起来像我想要的。
It didn't do anything, but it looked like what I want.

2151
01:37:56,170 --> 01:37:57,880
然后我添加了垃圾桶。
Then I added the trash can.

2152
01:37:57,880 --> 01:38:02,200
然后，我想我编写了一个垃圾桶或一个精灵来掉落的程序。
Then I think I programmed one piece of trash or one sprite to fall.

2153
01:38:02,199 --> 01:38:04,569
所以我把猫变成了一块垃圾，然后
So I changed the cat to a piece of trash and then

2154
01:38:04,569 --> 01:38:07,009
我从上到下制作了动画。
I had it animate from top to bottom.

2155
01:38:07,010 --> 01:38:10,420
然后是第四或第五版，然后我添加了一个永久循环
Then version four or five, I then added a forever loop

2156
01:38:10,420 --> 01:38:13,330
以及检查鼠标按钮是否按下的条件，
and a condition that checks if the mouse button is down,

2157
01:38:13,329 --> 01:38:16,179
如果是这样，我可以跟随鼠标指针。
and if so, I have it follow the mouse pointer.

2158
01:38:16,180 --> 01:38:19,330
所以我遇到了一个大问题，并将其一点一点分解
So I took a big problem and broke it down bit by bit

2159
01:38:19,329 --> 01:38:21,139
分成更小的步骤。
into much smaller steps.

2160
01:38:21,140 --> 01:38:25,363
这与CS50自己的安德鲁·贝瑞（Andrew Berry）几年前采取的方法相同，
And this was the same approach that CS50's own Andrew Berry took years ago,

2161
01:38:25,363 --> 01:38:26,530
我们的一位教学研究员。
one of our teaching fellows.

2162
01:38:26,529 --> 01:38:30,039
我教CS50的第一年，创建了他自己的第一个Scratch
The very first year I taught CS50, created his very own first Scratch

2163
01:38:30,039 --> 01:38:33,399
我认为我今天会离开我们的项目。
project that I thought I'd leave us with here today.

2164
01:38:33,399 --> 01:38:36,099
这是他称为“下雨人”的程序。
This is a program that he called Raining Men.

2165
01:38:36,100 --> 01:38:38,200
它的音调可能很熟悉，我会
It might have a familiar tune, and I would

2166
01:38:38,199 --> 01:38:41,529
建议你在观看时考虑
propose that you consider, when watching this,

2167
01:38:41,529 --> 01:38:46,779
今天我们最后的Scratch程序，Andrew进行编程的方式
our final Scratch program today, how it is that Andrew went about programming

2168
01:38:46,779 --> 01:38:48,369
你所看到的一切。
everything that you see.

2169
01:38:48,369 --> 01:38:51,529
现在，安德鲁（Andrew）进入了现实世界，不再追求计算机科学，
Now Andrew went off into the real world and didn't pursue computer science,

2170
01:38:51,529 --> 01:38:52,029
本身。
per se.

2171
01:38:52,029 --> 01:38:55,419
他现在实际上是克利夫兰布朗队的总经理，
He's actually now the general manager for the Cleveland Browns,

2172
01:38:55,420 --> 01:38:57,010
这是一支美式橄榄球队。
which is an American football team.

2173
01:38:57,010 --> 01:39:00,760
但这也说明了你的基础是什么
But this, too, speaks to just what kind of foundation you

2174
01:39:00,760 --> 01:39:03,862
可以形成，而不论你打算的专业是什么，你可能的专业，
can form, irrespective of your intended major, your possible major,

2175
01:39:03,862 --> 01:39:06,820
毕竟，考虑到我们将要重点关注的许多想法
considering, after all, that a lot of the ideas we're going to focus on

2176
01:39:06,819 --> 01:39:09,159
这节课的最终目的是解决问题，
in this class are ultimately about problem solving,

2177
01:39:09,159 --> 01:39:11,709
编程只是交易的一种工具。
programming being just one tool for the trade.

2178
01:39:11,710 --> 01:39:13,870
而且的确，即使在体育界，
And, indeed, even within the world of sports,

2179
01:39:13,869 --> 01:39:17,349
如今在算法，分析等方面有很多机会，
are there so many opportunities nowadays for algorithms, for analysis,

2180
01:39:17,350 --> 01:39:21,190
进行视频模拟，以及安德鲁的许多世界
for video simulations thereof, and so many of Andrew's worlds

2181
01:39:21,189 --> 01:39:24,429
并且你的世界将不可避免地开始发生碰撞
and your worlds will invariably start to collide

2182
01:39:24,430 --> 01:39:26,410
当你开始构建自己的工具包时
as you begin to build up your own toolkit

2183
01:39:26,409 --> 01:39:28,369
和你自己的理解。
and your own understanding thereof.

2184
01:39:28,369 --> 01:39:31,539
因此，总而言之，我们将看看这个Andrews程序。
So in conclusion, we'll take a look at this, Andrews program.

2185
01:39:31,539 --> 01:39:37,363
同时，这是CS50，现在正在下雨。
In the meantime, this was CS50, and now it's raining men.

2186
01:39:37,363 --> 01:39:40,345
[音乐-“这是要训练的人”
[MUSIC - "IT'S RAINING MEN]

2187
01:40:05,195 --> 01:40:06,186
电脑：嗨。
COMPUTER: Hi.

2188
01:40:06,186 --> 01:40:06,686
你好。
Hi.

2189
01:40:06,686 --> 01:40:08,177
我们是你的天气女孩。
We're your weather girls.

2190
01:40:08,177 --> 01:40:09,171
嗯。
Uh huh.

2191
01:40:09,171 --> 01:40:11,656
并且我们有消息要给你。
And have we got news for you.

2192
01:40:11,657 --> 01:40:12,651
你最好听。
You better listen.

2193
01:40:12,650 --> 01:40:18,117
准备好所有孤单的女孩，把那些雨伞留在家中。
Get ready, all you lonely girls, and leave those umbrellas at home.

2194
01:40:18,118 --> 01:40:19,112
好的。
All right.

2195
01:40:19,112 --> 01:40:24,576
（正在唱歌）湿度在上升，气压计正在变低。
(SINGING) Humidity's rising, barometer's getting low.

2196
01:40:24,576 --> 01:40:25,076
哦。
Oh.

2197
01:40:25,076 --> 01:40:26,070
哦哦
Uh oh.

2198
01:40:26,069 --> 01:40:28,279
根据所有消息来源-
According to all sources--

2199
01:40:28,279 --> 01:40:29,749
现在有什么来源？
What sources now?

2200
01:40:29,750 --> 01:40:32,689
这条街是去的地方。
The street's the place to go.

2201
01:40:32,689 --> 01:40:40,039
“是因为今晚第一次，大约是十点半，
'Cause tonight for the first time, at just about half past 10,

2202
01:40:40,039 --> 01:40:47,879
这是历史上第一次要下雨的人！
for the first time in history it's gonna start raining men!

2203
01:40:47,880 --> 01:40:54,340
正在下雨的人，哈利路亚，正在下雨的人-
It's raining men, hallelujah, it's raining men--

2204
01:40:54,340 --> 01:40:58,890
[音乐播放]
[MUSIC PLAYING]

