1
00:00:00,000 --> 00:00:02,479
[音乐响起--字幕精校中--By Persisan]
[MUSIC PLAYING]

2
00:00:49,021 --> 00:00:49,979
戴维·马兰：好的。
DAVID MALAN: All right.

3
00:00:49,979 --> 00:00:52,859
这是CS50，这是第五周。
This CS50 and this is week five.

4
00:00:52,859 --> 00:00:56,639
回想一下，在第四周的上周，我们引入了一些新的构建基块，
Recall that last week in week four, we introduced a few new building blocks,

5
00:00:56,640 --> 00:00:58,920
即指针和非常详细的讲话
namely pointers and spoke in great detail

6
00:00:58,920 --> 00:01:01,230
关于如何现在可以操纵计算机的内存
about how you can now manipulate a computer's memory

7
00:01:01,229 --> 00:01:04,119
并开始用它做较低层次的事情。
and begin to do things at a lower level with it.

8
00:01:04,120 --> 00:01:06,690
好吧，今天，我们将使用这些基本构建块
Well today, we'll sort of use those basic building blocks

9
00:01:06,689 --> 00:01:10,289
开始在计算机内存中创建称为数据结构的事物。
to start creating things called data structures in the computer's memory.

10
00:01:10,290 --> 00:01:12,330
事实证明，一旦您具备了这种能力
It turns out that once you have this ability

11
00:01:12,329 --> 00:01:15,119
引用计算机内存中的不同位置，
to refer to different locations in the computer's memory,

12
00:01:15,120 --> 00:01:18,390
您可以将自己的自定义形状拼接在一起，
you can stitch together your own custom shapes,

13
00:01:18,390 --> 00:01:20,910
您自己的自定义数据结构，即所谓的数据结构。
your own custom data structures, as they're called.

14
00:01:20,909 --> 00:01:23,519
实际上，我们将通过回滚来开始
And indeed, we'll start doing that by rolling back

15
00:01:23,519 --> 00:01:27,149
在第二周我们第一次看到数据结构的那一刻。
for just a moment to where we first saw a data structure in week two.

16
00:01:27,150 --> 00:01:30,837
所以回想一下第二周，那是我们玩C的第二周，
So recall in week two which was our second week of playing with C,

17
00:01:30,837 --> 00:01:32,670
我们向您介绍了数组的概念。
we introduced you to the notion of an array.

18
00:01:32,670 --> 00:01:35,160
数组只是连续的内存序列
And an array is just a contiguous sequence of memory

19
00:01:35,159 --> 00:01:38,279
您可以在其中背靠背存储一大堆整数，
in which you can store a whole bunch of integers back to back to back,

20
00:01:38,280 --> 00:01:40,980
或整串字符背靠背。
or maybe a whole bunch of chars back to back to back.

21
00:01:40,980 --> 00:01:45,280
这些数组可能已通过图形方式表示。
And those arrays might have been represented pictorially like this.

22
00:01:45,280 --> 00:01:46,890
因此，这将是大小为3的数组。
So this would be an array of size 3.

23
00:01:46,890 --> 00:01:49,560
并假设这确实是一个整数数组。
And suppose that this were an array indeed of integers.

24
00:01:49,560 --> 00:01:52,650
我们里面可能有一，二，三。
We might have one, two, three inside of it.

25
00:01:52,650 --> 00:01:57,100
但是现在就假设-这是我们将开始遇到问题的地方，
But suppose now-- and here's where we'll start to bump up against a problem,

26
00:01:57,099 --> 00:01:58,619
而且今天也解决了一个问题。
but also solve a problem today.

27
00:01:58,620 --> 00:02:01,260
假设您要向该数组添加另一个数字，
Suppose that you want to add another number to this array,

28
00:02:01,260 --> 00:02:05,100
但是您只有预见性才能创建大小为3的数组。
but you've only had the forethought to create an array of size 3.

29
00:02:05,099 --> 00:02:09,654
C语言中的数组存在一个难点，就是它们实际上并不容易调整大小。
The catch with arrays in C is that they're not really easily resizable.

30
00:02:09,655 --> 00:02:12,780
同样，你们都知道您必须预先决定阵列的大小
Again, you all know that you have to decide in advance how big the array is

31
00:02:12,780 --> 00:02:13,630
将。
going to be.

32
00:02:13,629 --> 00:02:16,199
因此，如果您以后改变主意或您的程序
So if you change your mind later or your program's

33
00:02:16,199 --> 00:02:19,259
运行足够长的时间，您需要在其中存储更多值，
running long enough where you need to store more values in it,

34
00:02:19,259 --> 00:02:20,549
你陷入困境。
you're in a bind.

35
00:02:20,550 --> 00:02:24,300
直观上来说，如果您想将数字4插入此数组，
Like intuitively, if you wanted to insert the number 4 into this array,

36
00:02:24,300 --> 00:02:27,990
您最好将其放在数组末尾的此处
you would ideally just plop it right here at the end of the array

37
00:02:27,990 --> 00:02:30,660
并继续您的业务。
and continue about your business.

38
00:02:30,659 --> 00:02:36,119
但是数组带来的问题是那块内存不是-
But the catch with an array is that that chunk of memory is not--

39
00:02:36,120 --> 00:02:37,500
它不存在于真空中。
it doesn't exist in a vacuum.

40
00:02:37,500 --> 00:02:40,500
回想一下，如果我们缩小并查看您计算机的所有内存，
Recall if we zoom out and look at all of your computer's memory,

41
00:02:40,500 --> 00:02:43,169
这个字节，这个字节和其他所有字节
this byte, this byte and a whole bunch of other bytes

42
00:02:43,169 --> 00:02:46,019
可能很好地被其他变量使用
might very well be in use by other variables

43
00:02:46,020 --> 00:02:47,610
或程序的其他方面。
or other aspects of your program.

44
00:02:47,610 --> 00:02:49,710
因此，例如，为了讨论起见，
So for instance for the sake of discussion,

45
00:02:49,710 --> 00:02:53,880
假设所讨论的程序具有一个大小为3的数组，其中包含
suppose that the program in question has one array of size 3 containing

46
00:02:53,879 --> 00:02:55,409
整数1、2、3
the integers 1, 2 3.

47
00:02:55,409 --> 00:02:59,519
然后假设您的同一程序在代码中的某个位置有一个字符串
And then suppose that your same program has a string somewhere in the code

48
00:02:59,520 --> 00:03:02,670
您已经写过并且该字符串正在存储您好，世界。
that you've written and that string is storing hello, world.

49
00:03:02,669 --> 00:03:05,969
恰好在内存中这个数组的旁边，
Well next to this array in memory just by chance,

50
00:03:05,969 --> 00:03:13,379
可能是HELLO逗号空间WORLD反斜杠0。
may very well be an H-E-L-L-O comma space W-O-R-L-D backslash 0.

51
00:03:13,379 --> 00:03:15,659
可以这么说，那里可能有空闲的内存。
And there might be free memory, so to speak.

52
00:03:15,659 --> 00:03:19,072
您可以使用的内存充满了垃圾值，垃圾也不错。
Memory you could use that's filled with garbage values and garbage isn't bad.

53
00:03:19,073 --> 00:03:20,490
这只是意味着您不知道。
It just means that you don't know.

54
00:03:20,490 --> 00:03:23,710
您并不真正在乎什么价值或曾经存在过什么价值。
You don't really care what values are or were there.

55
00:03:23,710 --> 00:03:25,740
因此，可以说有自由空间。
So there is free space, so to speak.

56
00:03:25,740 --> 00:03:28,560
这些奥斯卡都代表了有效的自由空间
Each of these Oscars represents effectively free space

57
00:03:28,560 --> 00:03:30,030
那里有一些垃圾价值。
with some garbage value there.

58
00:03:30,030 --> 00:03:32,940
也许是过去执行过的遗留物。
Remnants, maybe, of some execution past.

59
00:03:32,939 --> 00:03:36,329
但是这里的问题是你没有空间
But the problem here is that you don't have room

60
00:03:36,330 --> 00:03:40,380
将这四个正确放置在您可能想要放置的位置。
to plop this four right where you might want to put it.

61
00:03:40,379 --> 00:03:41,669
那么解决方案是什么呢？
So what's the solution?

62
00:03:41,669 --> 00:03:44,189
如果我们有一个大小为3的数组，其中包含三个整数，
If we have this array of size 3 containing three integers--

63
00:03:44,189 --> 00:03:50,069
1，2 3--但是它被涂在一个角落里，地狱等
1, 2 3-- but it's been painted into a corner whereby H-E-L-L and so forth are

64
00:03:50,069 --> 00:03:54,179
已经就在它旁边，我们不能只把四个放在那里
already immediately next to it, we can't just put the four there without

65
00:03:54,180 --> 00:03:57,640
牺牲H。那真的感觉不像是一个解决方案。
sacrificing the H. And that doesn't really feel like a solution.

66
00:03:57,639 --> 00:04:01,349
那么，关于如何解决这个问题的任何想法？
So any thoughts on how we can solve this problem?

67
00:04:01,349 --> 00:04:02,969
我们完全没有运气吗？
Are we completely out of luck?

68
00:04:02,969 --> 00:04:08,309
在这样的情况下，您可以不只将数字添加到数组中吗？
Can you just not add a number to an array in a situation like this?

69
00:04:08,310 --> 00:04:10,780
还是有可能想到的解决方案？
Or is there a solution perhaps that comes to mind?

70
00:04:10,780 --> 00:04:14,760
即使您以前从未编程过，即使在屏幕上-
Even if you've never programmed before, if on the screen there--

71
00:04:14,759 --> 00:04:15,779
土地的位置。
the lay of the land.

72
00:04:15,780 --> 00:04:17,579
圣地亚哥，你怎么看？
Santiago, what do you think?

73
00:04:17,579 --> 00:04:21,060
听众：我会说也许你可以
AUDIENCE: I would say that maybe you could

74
00:04:21,060 --> 00:04:26,050
复制原始数组中的元素并创建一个新数组，
copy the elements in the original array and create a new array,

75
00:04:26,050 --> 00:04:29,640
但这是一个大一号或一个大一号的元素。
but that's one size bigger or one element bigger.

76
00:04:29,639 --> 00:04:31,229
然后，添加该新元素。
And then, add that new element.

77
00:04:31,230 --> 00:04:31,980
戴维·马兰：是的。
DAVID MALAN: Yeah.

78
00:04:31,980 --> 00:04:33,120
这真是直觉。
That's really good intuition.

79
00:04:33,120 --> 00:04:34,950
毕竟，屏幕上有所有这些奥斯卡奖
After all, there's all these Oscars on the screen

80
00:04:34,949 --> 00:04:37,049
现在，它再次表示垃圾值。
right now, which again represent garbage values.

81
00:04:37,050 --> 00:04:38,490
或依次释放可用空间。
Or in turn, free space.

82
00:04:38,490 --> 00:04:40,680
所以我可以在这里放1、2、3、4。
So I could put 1, 2, 3, 4 up here.

83
00:04:40,680 --> 00:04:42,780
我可以在这里放1、2、3、4。
I could put 1, 2, 3, 4 over here.

84
00:04:42,779 --> 00:04:44,639
我可以在这里放下1、2、3、4。
I could put 1, 2, 3, 4 down here.

85
00:04:44,639 --> 00:04:48,089
所以我们有一定的灵活性，但圣地亚哥是完全正确的。
So we some flexibility, but Santiago is exactly right.

86
00:04:48,089 --> 00:04:51,449
凭直觉，我们真正需要做的就是只集中精力
Intuitively, all we really need to do is let's focus only

87
00:04:51,449 --> 00:04:54,119
在四个可用位置上。
on four of the available spots.

88
00:04:54,120 --> 00:04:56,910
大小为4的新数组（如果可以），最初
A new array of size four, if you will, which initially

89
00:04:56,910 --> 00:04:58,290
具有这四个垃圾值。
has these four garbage values.

90
00:04:58,290 --> 00:04:59,280
但是没关系。
But that's OK.

91
00:04:59,279 --> 00:05:01,949
正如圣地亚哥也指出的那样，现在就足够了
Because as Santiago also notes, it suffices now

92
00:05:01,949 --> 00:05:03,419
只是复制旧的阵列-
to just copy the old array--

93
00:05:03,420 --> 00:05:06,840
1、2、3--进入新数组。
1, 2, 3-- into the new array.

94
00:05:06,839 --> 00:05:10,859
哎呀，也许我们现在甚至可以释放原始阵列中的内存，
And heck, maybe we can now even free the memory from the original array,

95
00:05:10,860 --> 00:05:12,870
就像我们使用malloc一样。
much like we could if we used malloc.

96
00:05:12,870 --> 00:05:15,870
当然，那只剩下我们一个大小的数组
And that leaves us then, of course, with just an array of size

97
00:05:15,870 --> 00:05:17,430
具有第四个垃圾值的4。
4 with that fourth garbage value.

98
00:05:17,430 --> 00:05:21,923
但是现在，我们确实有足够的空间，例如数字4本身。
But now, we do have room for, like the number 4 itself.

99
00:05:21,923 --> 00:05:24,840
因此，似乎有解决该问题的方法
So it would seem that there is a solution to this problem that doesn't

100
00:05:24,839 --> 00:05:26,489
违反数组的定义。
violate the definition of an array.

101
00:05:26,490 --> 00:05:29,220
同样，数组的唯一定义确实
Again, the only definition of an array really

102
00:05:29,220 --> 00:05:31,320
是内存必须是连续的。
is that the memory must be contiguous.

103
00:05:31,319 --> 00:05:34,619
您不能只将4放入计算机内存中的任何位置。
You can't just plop the 4 anywhere in the computer's memory.

104
00:05:34,620 --> 00:05:37,710
它必须在您现有的内存之后变为
It has to become right after your existing memory

105
00:05:37,709 --> 00:05:39,659
如果整个事情，整个结构，
if this whole thing, this whole structure,

106
00:05:39,660 --> 00:05:42,630
确实仍将是一个数组。
is indeed going to still be an array.

107
00:05:42,629 --> 00:05:47,529
但是我担心这可能会花费我们一些时间。
But I worry that might have cost us a bit of time.

108
00:05:47,529 --> 00:05:50,199
实际上，让我继续在此处打开屏幕
And in fact, let me go ahead and open up on the screen here

109
00:05:50,199 --> 00:05:54,669
片刻之内，欢迎大家提出一个问题。
in just a moment a question that you're all welcome to buzz in for.

110
00:05:54,670 --> 00:06:00,220
插入数组的运行时间是多少？
What would be the running time of inserting into an array?

111
00:06:00,220 --> 00:06:03,220
让我继续在这里透露民意调查问题。
Let me go ahead and reveal the poll question here.

112
00:06:03,220 --> 00:06:05,050
随意转到通常的URL。
Feel free to go to the usual URL.

113
00:06:05,050 --> 00:06:08,080
如果您不介意照常复制和粘贴，请选择Brian。
Which Brian, if you wouldn't mind copying and pasting as usual.

114
00:06:08,079 --> 00:06:13,449
您认为插入数组的运行时间如何？
What do you think the running time is of inserting into an array?

115
00:06:13,449 --> 00:06:15,399
插入数组。
Inserting into an array.

116
00:06:15,399 --> 00:06:19,302
回想过去，我们在搜索方面讨论了数组。
Recall in the past, we talked about arrays in terms of searching.

117
00:06:19,302 --> 00:06:21,219
但是今天，这是我们第一次真正
But today, this is the first time we're really

118
00:06:21,220 --> 00:06:22,660
谈论插入其中。
talking about inserting into them.

119
00:06:22,660 --> 00:06:27,280
如果我们看看结果，您中的80％
And if we take a look at the results coming in, it looks like 80% of you

120
00:06:27,279 --> 00:06:30,579
感觉到它是线性时间，n的大O，因此
feel that it's linear time, big O of n, whereby

121
00:06:30,579 --> 00:06:34,179
可能需要多达n个步骤才能实际插入到数组中。
it might take as many as n steps to actually insert into an array.

122
00:06:34,180 --> 00:06:36,130
5％的人建议n log n。
5% of you propose n log n.

123
00:06:36,129 --> 00:06:37,689
你们的7％，n平方。
7% of you, n squared.

124
00:06:37,689 --> 00:06:40,826
然后，其他值也分别为2％和5％。
And then, 2% and 5% respectively for the other values as well.

125
00:06:40,826 --> 00:06:42,909
所以这是一种有趣的混合，因为当
So this is kind of an interesting mix because when

126
00:06:42,910 --> 00:06:46,150
我们过去讨论过数组，也谈到过搜索，
we talked about arrays in the past and we talked about searching,

127
00:06:46,149 --> 00:06:49,329
回想一下，我们通常获得log n的大O。
recall that we typically achieve big O of log n.

128
00:06:49,329 --> 00:06:50,379
这非常好。
That's really good.

129
00:06:50,379 --> 00:06:53,559
不幸的是如果我们要与圣地亚哥建议
Unfortunately if we have to do with Santiago proposed

130
00:06:53,560 --> 00:06:58,540
并实际上将所有元素从旧数组复制到新数组中，
and actually copy all of the elements from the old array into the new array,

131
00:06:58,540 --> 00:07:03,490
这将花我们多达n步，因为我们有
it's going to take us as many as n steps because we have

132
00:07:03,490 --> 00:07:05,800
复制每个原始元素-
to copy each of the original elements--

133
00:07:05,800 --> 00:07:10,670
1、2、3到新数组中，其大小将为n加1。
1, 2, 3-- over into the new array, which is going to be of size n plus 1.

134
00:07:10,670 --> 00:07:13,690
因此，总共约为n个步骤。
So it's on the order of n steps in total.

135
00:07:13,689 --> 00:07:16,869
因此，插入数组的运行时间
So the running time then of inserting into an array, in terms

136
00:07:16,870 --> 00:07:19,780
至少是一个上限，实际上将是n的大O
of an upper bound at least, is going to be indeed big O of n

137
00:07:19,779 --> 00:07:23,559
因为您可能已经复制了所有这些元素。
because you've got a copy potentially all of those elements over.

138
00:07:23,560 --> 00:07:27,880
但是也许，如果我们考虑降低
But perhaps, we might feel differently if we consider a lower

139
00:07:27,879 --> 00:07:30,399
限制插入的运行时间。
bound on the running time of insert.

140
00:07:30,399 --> 00:07:35,289
当涉及到数组时，insert的下限可能是多少？
What might the lower bound of insert be when it comes to an array?

141
00:07:35,290 --> 00:07:38,140
同样，我们可以在这里使用omega表示法。
Again, omega notation is what we can use here.

142
00:07:38,139 --> 00:07:40,509
在最佳情况下，可能需要执行几个步骤
How many steps maybe in the best case might it

143
00:07:40,509 --> 00:07:42,519
带我将值插入数组吗？
take me to insert a value into an array?

144
00:07:42,519 --> 00:07:44,434
我们不会对此进行民意调查。
We won't do a poll for this one.

145
00:07:44,435 --> 00:07:46,810
布莱恩，为什么我们不继续呼吁这一点。
Brian, why don't we go ahead and call on a hand for this.

146
00:07:46,810 --> 00:07:49,240
插入运行时间的下限是多少？
What's a lower bound on the running time of insert?

147
00:07:49,240 --> 00:07:50,240
瑞安，你怎么看？
Ryan, what do you think?

148
00:07:50,240 --> 00:07:52,073
听众：最好的情况是
AUDIENCE: Well, the best case scenario would

149
00:07:52,072 --> 00:07:54,269
如果数组中只有一个元素。
be if there's only one element in the array.

150
00:07:54,269 --> 00:07:56,859
所以你只有一个，或者只是
So you would just have a one or it would just

151
00:07:56,860 --> 00:07:58,633
是数组中的一个元素。
be one element right into the array.

152
00:07:58,632 --> 00:08:00,549
大卫·马兰（David MALAN）：是的，如果您有一个阵列，
DAVID MALAN: Yeah, so if you've got an array--

153
00:08:00,550 --> 00:08:02,980
我要强调的是，这已经是空的-
and let me emphasize that's already empty--

154
00:08:02,980 --> 00:08:06,400
这样，您就可以为新元素留出空间。
whereby you have room for the new element, then indeed.

155
00:08:06,399 --> 00:08:09,459
只要您需要，欧米茄1恒定的时间就是您所需要的
Omega of 1, constant time, is all you need so long as you

156
00:08:09,459 --> 00:08:11,349
在数组中有可用空间。
have space available in the array.

157
00:08:11,350 --> 00:08:13,270
数组有多大无关紧要。
And it doesn't matter how large the array is.

158
00:08:13,269 --> 00:08:16,909
也许是4号，但您只输入了一个数字。
Maybe it's a size 4, but you've only put one number in it.

159
00:08:16,910 --> 00:08:20,110
可以，因为您可以立即将新号码放到位。
That's OK because you can immediately put the new number in place.

160
00:08:20,110 --> 00:08:22,130
回想一下，数组支持随机访问。
Recall that array support random access.

161
00:08:22,129 --> 00:08:24,129
您可以使用方括号表示法
You can use the square bracket notation and just

162
00:08:24,129 --> 00:08:28,279
仅一步之遥即可在所谓的恒定时间内跳到任意位置。
jump to any location in so-called constant time in just one step.

163
00:08:28,279 --> 00:08:32,408
因此，如果您的阵列足够大且未满，则可以。
So if your array is of sufficient size and it's not full, then yes.

164
00:08:32,408 --> 00:08:34,689
插入数组的下限
The lower bound on the insertion into an array

165
00:08:34,690 --> 00:08:37,630
将是恒定的时间，Ω为1。
is going to be constant time, omega of 1.

166
00:08:37,629 --> 00:08:39,939
但正如我们在圣地亚哥的情况中所见，
But as we saw in Santiago's situation whereby

167
00:08:39,940 --> 00:08:42,250
你有一个已经充满了元素的数组
you have an array that's already filled with elements

168
00:08:42,250 --> 00:08:44,810
并且您想添加另一个，在这种情况下，
and you want to add another, well in that case,

169
00:08:44,809 --> 00:08:47,739
那么上限确实将是n的大O
then upper bound is indeed going to be big O of n

170
00:08:47,740 --> 00:08:51,370
因为您必须做额外的工作来将值复制到
because you have to do the additional labor of copying the values over

171
00:08:51,370 --> 00:08:52,315
从一个到另一个。
from one to the other.

172
00:08:52,315 --> 00:08:54,940
现在，您之前已经编程过，也许您已经使用过Java。
Now those of you have programmed before, maybe you've use Java.

173
00:08:54,940 --> 00:08:56,900
您可能对短语向量很熟悉。
You might be familiar with the phrase vector.

174
00:08:56,899 --> 00:09:00,999
向量就像可以调整大小，可以增长和收缩的数组。
A vector is like an array that can be resized, can grow and shrink.

175
00:09:01,000 --> 00:09:05,530
那不是C中的数组。C中的数组只是连续的内存块
That's not what arrays in C. Arrays in C are just contiguous blocks of memory

176
00:09:05,529 --> 00:09:07,099
值背对背。
with values back to back to back.

177
00:09:07,100 --> 00:09:10,330
但是，一旦您决定了它们的大小，就可以了。
But once you decide on their size, that is it.

178
00:09:10,330 --> 00:09:12,700
您将不得不调整它的大小，本质上是您自己。
You're going to have to resize it, essentially yourself.

179
00:09:12,700 --> 00:09:16,280
他们不会为您自动成长。
They're not going to automatically grow for you.

180
00:09:16,279 --> 00:09:19,959
因此，数组是数据中的第一个，而且实际上是最简单的
So an array was the first and really the simplest of the data

181
00:09:19,960 --> 00:09:21,130
我们将看到的结构。
structures we'll see.

182
00:09:21,129 --> 00:09:23,499
但这还不如什么强大
But it's also not nearly as powerful as what

183
00:09:23,500 --> 00:09:25,870
现在我们可以访问计算机的内存了。
we can do now that we have access to a computers memory.

184
00:09:25,870 --> 00:09:28,328
今天，我们将开始利用这些称为
Today, we're going to start to leverage these things called

185
00:09:28,327 --> 00:09:31,996
指针，即我们可以用来引用内存中位置的地址。
pointers, the addresses via which we can refer to locations in memory.

186
00:09:31,996 --> 00:09:35,079
我们将开始将一些更高级的数据结构结合在一起-
And we're going to start to stitch together some fancier data structures--

187
00:09:35,080 --> 00:09:37,030
首先，在某种意义上是一维的。
first, one dimensional in some sense.

188
00:09:37,029 --> 00:09:41,529
然后，从某种意义上讲是二维的-通过使用一些非常基本的构建块。
Then, two dimensional in some sense-- by using some very basic building blocks.

189
00:09:41,529 --> 00:09:44,979
回顾过去几周的这三段语法。
Recall these three pieces of syntax from the past weeks.

190
00:09:44,980 --> 00:09:48,250
结构，回想是这种机制，C语言中的这个关键字，
Struct, recall, is this mechanism, this keyword in C,

191
00:09:48,250 --> 00:09:51,189
借此我们可以在内存中定义自己的结构。
whereby we can define our own structures in memory.

192
00:09:51,190 --> 00:09:55,780
我们为一个人看到了一个，其中一个人可能既有名字又有数字
We saw one for a person whereby a person might have both a name and a number

193
00:09:55,779 --> 00:09:57,609
在电话簿之类的东西中。
in something like a phone book.

194
00:09:57,610 --> 00:10:00,850
您已经看到了点运算符。
And you've seen the dot operator The dot operator was

195
00:10:00,850 --> 00:10:05,020
我们如何进入这种结构并获得点名称或点编号。
how we go inside of such a structure and get at dot name or dot number.

196
00:10:05,019 --> 00:10:07,569
结构内部的特定变量。
The specific variables inside of the struct.

197
00:10:07,570 --> 00:10:11,020
然后上周，回想一下，我们看到了明星运营商
And then last week, recall we saw the star operator

198
00:10:11,019 --> 00:10:14,409
因此，解引用运算符，通俗地表示
whereby the dereference operator, which colloquially means

199
00:10:14,409 --> 00:10:16,999
转到这个特定的地址。
go to this particular address.

200
00:10:17,000 --> 00:10:19,939
因此，仅通过使用这三种成分就可以
So just by using these three ingredients are

201
00:10:19,940 --> 00:10:22,690
我们现在将能够建立自己的自定义数据结构
we going to be able to now build up our own custom data structures

202
00:10:22,690 --> 00:10:26,062
甚至比阵列更出色，最终可以帮助我们解决问题
that are even fancier than arrays and can ultimately help us solve problems

203
00:10:26,062 --> 00:10:26,770
更有效率。
more efficiently.

204
00:10:26,769 --> 00:10:30,609
实际上，这是C语言编程中的一种常见技术
And in fact, this is such a common technique in programming in C

205
00:10:30,610 --> 00:10:33,790
点和星这两个运算符，
that these two operators, the dot and the star,

206
00:10:33,789 --> 00:10:38,229
通常被组合成一个故意看起来像箭头的箭头。
are often combined into one that intentionally looks like an arrow.

207
00:10:38,230 --> 00:10:41,500
因此，我们将在短时间内看到其用法。
So we'll see its usage in just a little bit.

208
00:10:41,500 --> 00:10:45,189
因此，从语法上讲，今天几乎是构建基块
So syntactically today, it's pretty much building blocks

209
00:10:45,190 --> 00:10:48,170
过去，但我们现在将以新方式使用这些构建基块
past but we're going to use these building blocks now in new ways

210
00:10:48,169 --> 00:10:50,779
开始以不同的方式解决问题。
to start solving problems differently.

211
00:10:50,779 --> 00:10:54,619
首先，我们将通过称为链接列表的方式进行此操作。
And we'll first do this by way of something called linked lists.

212
00:10:54,620 --> 00:11:00,110
因此，例如，一个链表将是一个可以解决以下问题的数据结构：
So for instance, a linked list is going to be a data structure that solves

213
00:11:00,110 --> 00:11:01,940
数组的一些问题。
some of the problems with an array.

214
00:11:01,940 --> 00:11:03,740
那可以说是什么问题呢？
And what's a problem arguably?

215
00:11:03,740 --> 00:11:07,117
好吧，如果将n个步骤中的大O插入到数组中，
Well if it takes big O of n steps to insert into an array,

216
00:11:07,116 --> 00:11:08,449
坦白说，这很烦人。
frankly that's kind of annoying.

217
00:11:08,450 --> 00:11:09,710
那有点贵。
That's kind of expensive.

218
00:11:09,710 --> 00:11:13,273
因为随着时间的流逝，如果您要编写一个包含大量数据的大型程序，
Because over time if you're writing a really big program with lots of data--

219
00:11:13,273 --> 00:11:16,190
您是世界上的Google，世界上的Twitter-很好
you're the Googles of the world, the Twitters of the world-- it's fine

220
00:11:16,190 --> 00:11:18,710
如果您想将所有数据存储在一个大数组中
if you want to store all of your data in a big array

221
00:11:18,710 --> 00:11:20,640
为了有效的搜索。
for the sake of efficient searching.

222
00:11:20,639 --> 00:11:23,869
如果我们使用类似二进制的搜索方式，那回想起来是log n的大O
Which recall, was big O of log n if we use something like binary search

223
00:11:23,870 --> 00:11:25,280
并保持一切排序。
and keep everything sorted.

224
00:11:25,279 --> 00:11:27,739
但是，如果每次您
But it's going to be pretty painful if every time you

225
00:11:27,740 --> 00:11:32,432
想要向该阵列添加另一条推文，或向该阵列添加其他网页。
want to add another tweet to the array, or some other web page to the array.

226
00:11:32,432 --> 00:11:34,640
根据您要解决的问题，
Depending on what the problem is that you're solving,

227
00:11:34,639 --> 00:11:36,431
正如圣地亚哥指出的那样，您可能会
you might potentially-- as Santiago notes--

228
00:11:36,432 --> 00:11:40,400
必须复制原始较小数组的所有内容
have to copy all of the contents of your original smaller array

229
00:11:40,399 --> 00:11:45,659
添加到更大的新数组中，只是添加更多推文或更多网页等。
into a new bigger array just to add more tweets or more web pages or the like.

230
00:11:45,659 --> 00:11:47,989
因此，链表将是一个数据结构，
So a linked list is going to be a data structure that's

231
00:11:47,990 --> 00:11:52,700
更动态，从而您可以扩大和缩小数据
more dynamic, whereby you can grow and shrink the data

232
00:11:52,700 --> 00:11:56,210
结构，而无需触及所有原始数据
structure without having to touch all of the original data

233
00:11:56,210 --> 00:11:58,820
并将其从旧位置移动到新位置。
and move it from old location to new.

234
00:11:58,820 --> 00:12:01,073
那么这看起来像什么呢？
So what might this look like?

235
00:12:01,072 --> 00:12:02,989
好吧，让我们再次考虑一下我们的计算机内存
Well let's consider again our computers memory

236
00:12:02,990 --> 00:12:05,615
并建议我要再次存储这些相同的值。
and let's propose that I want to store those same values again.

237
00:12:05,615 --> 00:12:08,180
就像第一名-只是为了讨论，
So like the number one-- and just for the sake of discussion,

238
00:12:08,179 --> 00:12:12,619
假设它在我计算机的内存中，地址为0x123。
suppose that it's in my computer's memory at address 0x123.

239
00:12:12,620 --> 00:12:14,660
0x只是表示它是一个十六进制数。
0x just means it's a hexadecimal number.

240
00:12:14,659 --> 00:12:16,429
1-2-3-是完全任意的。
1-2-3- is completely arbitrary.

241
00:12:16,429 --> 00:12:18,449
我只是为了讨论而编造的。
I made it up just for the sake of discussion.

242
00:12:18,450 --> 00:12:21,020
所以让我规定那就是数字1发生的地方
So let me stipulate that that's where the number 1 happens

243
00:12:21,019 --> 00:12:24,289
在这个新解决方案中存储在计算机的内存中
to be in the computer's memory in this new solution

244
00:12:24,289 --> 00:12:26,394
存储大量数据的问题。
to the problem of storing lots of data.

245
00:12:26,394 --> 00:12:27,769
假设我要存储2号。
Suppose I want to store number 2.

246
00:12:27,769 --> 00:12:30,229
也许是在地址0x456。
Maybe it's at address 0x456.

247
00:12:30,230 --> 00:12:32,340
然后，假设我要存储数字3。
And then, suppose I want to store number 3.

248
00:12:32,340 --> 00:12:36,260
假设它位于地址0x789。
Suppose it's at address 0x789.

249
00:12:36,259 --> 00:12:40,009
因此，请注意，这些数字分散了
So notice deliberately, these numbers are spread out

250
00:12:40,009 --> 00:12:41,179
在计算机的内存中。
in the computer's memory.

251
00:12:41,179 --> 00:12:44,329
因为毕竟，我们在不久前就遇到了数组问题
Because after all, the problem we ran into a moment ago with arrays

252
00:12:44,330 --> 00:12:48,080
是您可能拥有来自其他部分的问候，世界或其他价值
is that you might have hello, world or other values from other parts

253
00:12:48,080 --> 00:12:50,340
您的程序的方式。
of your program in the way.

254
00:12:50,340 --> 00:12:52,310
所以，如果我提议，如果你想
So if I'm proposing instead that if you want

255
00:12:52,309 --> 00:12:55,849
存储一个，然后两个，然后三个，就可以了。
to store one, and then two, and then three, that's fine.

256
00:12:55,850 --> 00:12:58,640
将它们放到您想要的任何地方，而无需
Plop them anywhere you want and you don't

257
00:12:58,639 --> 00:13:02,519
不得不担心在哪里已经存在价值。
have to worry about where there is already existing values.

258
00:13:02,519 --> 00:13:06,021
相反，您可以将这些值放在有空间的地方。
Instead, you can just put these values where there is room.

259
00:13:06,022 --> 00:13:09,230
但是，问题在于，如果您只是开始处理诸如一，二之类的值，
The problem, though, is that if you just start plopping values like one, two,

260
00:13:09,230 --> 00:13:11,630
您想要在计算机内存中的任意三个位置，
three anywhere you want in the computer's memory,

261
00:13:11,629 --> 00:13:15,049
您不能再轻易地找到这些值了，对吧？
you can no longer very easily find those values, right?

262
00:13:15,049 --> 00:13:17,629
您可能知道一个人在哪里，但是不再
You might know where one is, but it no longer

263
00:13:17,629 --> 00:13:21,949
只需在右侧寻找一个位置即可找到下一个值
suffices to just look one location to the right to find the next value

264
00:13:21,950 --> 00:13:25,790
或加两个，然后找到下一个值。
or add two find the next value after that.

265
00:13:25,789 --> 00:13:28,099
在数组中，所有内容都是连续的。
In an array, everything is contiguous.

266
00:13:28,100 --> 00:13:30,450
但是如果我们改为开始处理计算机的内存
But if we instead start to treat the computer's memory

267
00:13:30,450 --> 00:13:33,980
就像一个画布，我们可以在任何地方绘制数字
as just a canvas where we can just draw numbers anywhere

268
00:13:33,980 --> 00:13:37,370
我们想要，那很好，只要我们能以某种方式
we want, that's fine so long as we can somehow

269
00:13:37,370 --> 00:13:39,830
帮助自己从第一，第二，
help ourselves get from the first, to the second,

270
00:13:39,830 --> 00:13:43,310
到第三，不管其他所有东西是什么
to the third irrespective of all the other stuff that's

271
00:13:43,309 --> 00:13:45,329
弄乱了计算机的内存。
cluttering up the computer's memory.

272
00:13:45,330 --> 00:13:48,980
所以事实上，让我建议我们可以通过窃取来做到这一点
So in fact, let me propose that we do this by maybe stealing

273
00:13:48,980 --> 00:13:51,590
电脑上还有更多空间。
a bit more space from the computer.

274
00:13:51,590 --> 00:13:55,710
因此，与其使用足够的内存来存储一，二和三，
So rather than use just enough memory to store one, two, and three,

275
00:13:55,710 --> 00:13:59,060
让我存储两倍的信息。
let me store twice as much information.

276
00:13:59,059 --> 00:14:02,629
除了我真正关心的每个数字-一，二，三，
In addition to every number that I actually care about-- one, two, three,

277
00:14:02,629 --> 00:14:03,559
我的数据
my data--

278
00:14:03,559 --> 00:14:05,417
我可以存储一些元数据，可以这么说。
let me store a little metadata, so to speak.

279
00:14:05,418 --> 00:14:07,460
我根本不关心的价值观
The values that I don't fundamentally care about,

280
00:14:07,460 --> 00:14:10,970
但这将有助于我跟踪实际数据。
but that are going to help me keep track of my actual data.

281
00:14:10,970 --> 00:14:13,650
让我在这里的方框中提出这个建议，
And let me propose that in this box here,

282
00:14:13,649 --> 00:14:16,354
我从字面上存储值0x456。
I literally store the value 0x456.

283
00:14:16,355 --> 00:14:18,980
同样，它以十六进制编写，但这只是数字。
Again, it's written in hexadecimal, but that's just the number.

284
00:14:18,980 --> 00:14:21,350
那是内存中其他地方的地址。
That's the address of somewhere else in memory.

285
00:14:21,350 --> 00:14:24,530
在此框中，让我建议存储0x789。
In this box, let me propose that I store 0x789.

286
00:14:24,529 --> 00:14:31,069
在此框中，让我任意说0x0，它全都是零位。
And in this box, let me arbitrarily say 0x0, which is just all zero bits.

287
00:14:31,070 --> 00:14:32,810
现在为什么要这样做？
Now why have I done this?

288
00:14:32,809 --> 00:14:35,719
即使您从未见过这种结构，
Even if you've never seen this structure that's

289
00:14:35,720 --> 00:14:38,210
演变成所谓的链表，
evolving to be what's called a linked list,

290
00:14:38,210 --> 00:14:40,670
为什么我刚刚完成了自己的工作？
why have I just done what I've done?

291
00:14:40,669 --> 00:14:43,279
除了分别存储一，二和三之外，
In addition to storing one, two, and three respectively,

292
00:14:43,279 --> 00:14:49,699
我现在还存储0x456和额外的内存块以及0x789
I'm also now storing 0x456 and an additional chunk of memory and 0x789

293
00:14:49,700 --> 00:14:51,410
和一个额外的内存块。
and an additional chunk of memory.

294
00:14:51,409 --> 00:14:52,759
但为什么？
But why?

295
00:14:52,759 --> 00:14:53,719
苏菲亚。
Sofia.

296
00:14:53,720 --> 00:14:57,380
听众：这样我们就知道第一个元素与第二个元素有何关系
AUDIENCE: So that we know how the first element relates to the second

297
00:14:57,379 --> 00:14:58,691
或它们如何链接在一起。
or how they're linked together.

298
00:14:58,692 --> 00:14:59,900
戴维·马兰（David MALAN）：的确-
DAVID MALAN: That's exactly--

299
00:14:59,899 --> 00:15:01,129
听众：-在第一和第二之间。
AUDIENCE: --between the first and second.

300
00:15:01,129 --> 00:15:01,879
戴维·马兰：是的。
DAVID MALAN: Yeah.

301
00:15:01,879 --> 00:15:05,539
所以现在，我使用的空间实际上是每个数据的两倍。
So now, I'm using essentially twice as much space to store each piece of data.

302
00:15:05,539 --> 00:15:07,549
一，二和三。
One, two, and three respectively.

303
00:15:07,549 --> 00:15:10,279
但是在第二块空间中，我现在
But in the second chunk of space, I'm now

304
00:15:10,279 --> 00:15:16,409
在我现在将其视为列表的事物中存储指向下一个元素的指针。
storing a pointer to the next element in the thing I'll now think of as a list.

305
00:15:16,409 --> 00:15:19,969
所以这是0x456，因为第二个
So this is 0x456 because the number two, which

306
00:15:19,970 --> 00:15:24,650
是我关心的列表中的下一个数字，位于0x456。
is the next number in the list I care about, lives at 0x456.

307
00:15:24,649 --> 00:15:28,639
这个数字是0x789，因为我关心的是下一个数字
This number is 0x789 because the next number after that I care about

308
00:15:28,639 --> 00:15:31,309
位于地址0x789。
is at address 0x789.

309
00:15:31,309 --> 00:15:33,649
所以这只是离开的一种有用方法
So it's just a helpful way now of leaving

310
00:15:33,649 --> 00:15:37,099
我自己的面包屑，这样我就可以把一个，两个，三个放在任何地方
myself breadcrumbs so that I can plop the one, the two, the three anywhere

311
00:15:37,100 --> 00:15:40,550
只要有可用空间，我都希望在计算机的内存中
I want in the computer's memory wherever there's available space

312
00:15:40,549 --> 00:15:44,719
并仍然想出如何从一个到达另一个的方法。
and still figure out how to get from one to the other to the other.

313
00:15:44,720 --> 00:15:47,400
实际上，我们之前已经看过其中一些语法。
And we've actually seen some of this syntax before.

314
00:15:47,399 --> 00:15:53,679
事实证明，0x0全为零，这只是技术上的问题-
It turns out that 0x0, which is all zero bits, that's just the technical--

315
00:15:53,679 --> 00:15:56,079
这就是我们称为null的数值等效项。
that's the numeric equivalent of what we've called null.

316
00:15:56,080 --> 00:16:00,850
上周介绍的NULL是一个特殊符号，表示
N-U-L-L, which we introduced last week, is a special symbol indicating that

317
00:16:00,850 --> 00:16:03,910
内存出现问题或空间不足。
something has gone wrong with memory or you're out of space.

318
00:16:03,909 --> 00:16:06,069
有点没有地址。
It's sort of the absence of an address.

319
00:16:06,070 --> 00:16:09,850
C保证如果您使用0x0，AKA为null，
C guarantees that if you use 0x0, AKA null,

320
00:16:09,850 --> 00:16:13,240
那只是表明那里没有任何有用的地址。
that just indicates the absence of any useful address there.

321
00:16:13,240 --> 00:16:13,990
但是你知道吗？
But you know what?

322
00:16:13,990 --> 00:16:16,630
就像上周一样，这已经进入了杂草丛生。
Again like last week, this is of getting way into the weeds.

323
00:16:16,629 --> 00:16:19,689
我不太在乎0x123456789。
I don't really care about 0x123456789.

324
00:16:19,690 --> 00:16:23,680
因此，让我们将其抽象一下，然后开始真正地考虑一下
So let's just kind of abstract this away and start thinking about this really

325
00:16:23,679 --> 00:16:26,949
作为以某种方式链接在一起的数字的列表。
as a list of numbers that are somehow linked together.

326
00:16:26,950 --> 00:16:31,210
引擎盖下的链接是通过地址实现的，
Underneath the hood, the links are implemented by way of addresses,

327
00:16:31,210 --> 00:16:36,280
或指针，例如0x123456789的那些低级数字。
or pointers, those low level numbers like 0x123456789.

328
00:16:36,279 --> 00:16:39,039
但是从图片上来说，我们只要开始就足够了
But pictorially, it suffices for us to just start

329
00:16:39,039 --> 00:16:44,169
考虑到此数据结构（以下称为链表），
thinking of this data structure, hereafter known as a linked list,

330
00:16:44,169 --> 00:16:47,589
作为节点的集合，可以说-
as being a collection of nodes, so to speak--

331
00:16:47,590 --> 00:16:50,830
NODE-通过指针连接。
N-O-D-E-- that are connected via pointers.

332
00:16:50,830 --> 00:16:52,710
因此，节点只是一门通用的计算机科学
So a node is just a generic computer science

333
00:16:52,710 --> 00:16:54,460
指某种结构的术语
term that refers to some kind of structure

334
00:16:54,460 --> 00:16:56,230
存放您关心的东西。
that store stuff you care about.

335
00:16:56,230 --> 00:17:00,260
我在这里关心的是一个数字和一个指向另一个这样的结构的指针。
What I care about here is a number and a pointer to another such structure.

336
00:17:00,259 --> 00:17:05,679
所以这是一个链表，每个矩形代表一个节点。
So this is a linked list and each of these rectangles represents a node.

337
00:17:05,680 --> 00:17:08,740
在代码中，我们将最终实现这些节点
And in code, we'll implement those nodes ultimately

338
00:17:08,740 --> 00:17:12,069
通过C中的那个东西称为struct。
by way of that thing in C called a struct.

339
00:17:12,068 --> 00:17:14,588
但让我停在这里先看看是否有
But let me pause here to see first if there

340
00:17:14,588 --> 00:17:18,729
对我们建立的结构有任何疑问。
are any questions about the structure we have built up.

341
00:17:18,730 --> 00:17:22,180
有关此问题的任何问题都称为链接列表
Any questions about this thing called a linked list

342
00:17:22,180 --> 00:17:24,530
在某些代码中看到它之前？
before we see it in some code?

343
00:17:24,529 --> 00:17:25,029
布莱恩？
Brian?

344
00:17:25,029 --> 00:17:27,009
布莱恩：是的，聊天中出现了一个问题，
BRIAN: Yeah, a question came in in the chat asking,

345
00:17:27,009 --> 00:17:30,176
这不是浪费内存，我们现在正在使用所有这些单元格
isn't this kind of a waste of memory that we're now using all of these cells

346
00:17:30,176 --> 00:17:31,389
存储地址呢？
to store addresses too?

347
00:17:31,390 --> 00:17:33,310
大卫·马兰（David MALAN）：是的，非常好的观察。
DAVID MALAN: Yeah, really good observation.

348
00:17:33,309 --> 00:17:35,392
难道这不是在浪费记忆吗？
Isn't this kind of a waste of memory in that we're

349
00:17:35,393 --> 00:17:37,150
另外存储所有这些地址
storing all of these addresses in addition

350
00:17:37,150 --> 00:17:39,710
到我们关心的数字1、2、3？
to the numbers 1, 2, 3 that we care about?

351
00:17:39,710 --> 00:17:42,375
是的，事实上，这正是我们要付出的代价，
Yes, and in fact, that is exactly the price we are paying,

352
00:17:42,375 --> 00:17:43,750
这将是主题。
and this is going to be thematic.

353
00:17:43,750 --> 00:17:46,270
这个星期，上周以及此后的每个星期，
This week, last week and really every week thereafter,

354
00:17:46,269 --> 00:17:50,169
每当我们解决CS和编程方面的问题时，
any time we solve a problem in CS and programming in particular,

355
00:17:50,170 --> 00:17:52,268
总会有一些付出的代价。
there's always going to be some price paid.

356
00:17:52,268 --> 00:17:54,310
会有一些成本，实际上，有
There's going to be some cost and really, there's

357
00:17:54,309 --> 00:17:55,609
会有所取舍。
going to be some trade-off.

358
00:17:55,609 --> 00:18:00,399
因此，如果片刻之前插入到数组中是不可接受的
So if a moment ago, it was unacceptable that inserting into an array

359
00:18:00,400 --> 00:18:04,570
在n的大O中，因为人，这将需要很多步骤来复制所有
is in big O of n because man, that's going to take so many steps to copy all

360
00:18:04,569 --> 00:18:07,419
从旧数组到新数组的值，
of the values from the old array into the new array,

361
00:18:07,420 --> 00:18:10,300
如果由于性能原因您不可接受
if that is unacceptable to you for performance reasons

362
00:18:10,299 --> 00:18:13,869
或您正在解决的问题是什么，都很好。
or whatever the problem is that you're solving, well, that's fine.

363
00:18:13,869 --> 00:18:17,409
您可以解决该问题，现在有了更多的动力
You can solve that problem and now have much more dynamism

364
00:18:17,410 --> 00:18:19,900
借此您可以将数字放入内存中的任何位置
whereby you can plop your numbers anywhere in memory

365
00:18:19,900 --> 00:18:24,190
无需将现有数字移动到其他任何地方，从而节省了
without having to move the existing numbers anywhere else, thereby saving

366
00:18:24,190 --> 00:18:27,948
自己的时间，但是您要付出的代价确实是更多的空间。
yourself time, but the price you're going to pay indeed is more space.

367
00:18:27,948 --> 00:18:29,740
所以在那一点上，这取决于什么
So at that point, it kind of depends what's

368
00:18:29,740 --> 00:18:31,540
对您而言更重要的是计算机的时间，
more important to you, the computer's time,

369
00:18:31,539 --> 00:18:35,979
您的人的时间，或者空间或空间成本，更多的内存
your human time, or maybe the space or the cost of the space, the more memory

370
00:18:35,980 --> 00:18:38,577
您可能真的需要为该计算机购买。
that you might really need to literally buy for that computer.

371
00:18:38,576 --> 00:18:39,909
所以这将是主题。
So this is going to be thematic.

372
00:18:39,910 --> 00:18:44,590
实际上，在编程中，时空之间的这种折衷是无所不在的。
This trade-off between space and time is omnipresent, really, in programming.

373
00:18:44,589 --> 00:18:47,779
好吧，让我们考虑如何将其立即转换为实际代码。
Well, let's consider how we might translate this now into actual code.

374
00:18:47,779 --> 00:18:51,009
回想一下，当我们上次在C中看到结构时，
Recall that when we last saw structs in C,

375
00:18:51,009 --> 00:18:55,389
我们做了这样的事情来定义一个人有两个相关联的东西
we did something like this to define a person as having two things associated

376
00:18:55,390 --> 00:18:56,980
和他们一起，一个名字和一个数字。
with them, a name and a number.

377
00:18:56,980 --> 00:18:59,650
所以今天，我们不在乎人，名字和数字。
So today, we don't care about persons and names and numbers.

378
00:18:59,650 --> 00:19:01,780
我们关心这些事情，我们将开始调用节点，
We care about these things we're going to start calling nodes,

379
00:19:01,779 --> 00:19:03,446
所以让我继续前进。
so let me go ahead and rewind from that.

380
00:19:03,446 --> 00:19:08,439
擦除它，让我们说这个结构中的每个节点，
Erase that and let's instead say that every node in this structure,

381
00:19:08,440 --> 00:19:10,840
也将人重命名为节点
renaming person as well to node, is going

382
00:19:10,839 --> 00:19:15,429
有一个数字，在我们这里是整数
to have a number, which will be an int in our case here,

383
00:19:15,430 --> 00:19:18,670
我为其他价值留出了空间，因为我们最终
and I've left room for one other value because we ultimately

384
00:19:18,670 --> 00:19:21,255
需要能够存储第二条数据。
need to be able to store that second piece of data.

385
00:19:21,255 --> 00:19:23,380
第二部分数据将是一个指针。
That second piece of data is going to be a pointer.

386
00:19:23,380 --> 00:19:26,860
这将是某物的地址，但是怎么可能
It's going to be an address of something, but how might

387
00:19:26,859 --> 00:19:29,199
我表达这个吗？
I express this?

388
00:19:29,200 --> 00:19:31,270
这将不太明显
This is going to be a little less obvious

389
00:19:31,269 --> 00:19:34,899
但是我们上周为指针打下了基础。
but we laid the foundation last week with pointers.

390
00:19:34,900 --> 00:19:39,220
我怎么能形容这种结构
How could I describe this structure as having

391
00:19:39,220 --> 00:19:42,750
指向另一个这样的结构的指针？
a pointer to another such structure?

392
00:19:42,750 --> 00:19:45,879
关于所使用语法的口头思考，
Any thoughts on verbally the syntax to use,

393
00:19:45,880 --> 00:19:51,010
甚至即使您不确定确切的咒语，确切的符号
or even if you're not sure of exactly the incantation, exactly what symbols

394
00:19:51,009 --> 00:19:56,349
我们应该用来表达和寻址到另一个这样的节点吗？
we should use to express and address to another such node?

395
00:19:56,349 --> 00:19:59,596
布莱恩：有人建议我们使用节点*作为指向节点的指针。
BRIAN: Someone is suggesting we use a node * as a pointer to a node.

396
00:19:59,596 --> 00:20:00,429
DAVID MALAN：节点*？
DAVID MALAN: Node *?

397
00:20:00,430 --> 00:20:00,930
好的。
All right.

398
00:20:00,930 --> 00:20:02,740
所以*我绝对记得上周
So * I definitely remember from last week,

399
00:20:02,740 --> 00:20:06,310
表示如果您有int *，则为int的地址。
indicating that if you have int *, this is the address of an int.

400
00:20:06,309 --> 00:20:08,709
如果您有char *，则这是char的地址。
If you have char *, this is the address of a char.

401
00:20:08,710 --> 00:20:12,130
因此，如果所有这些箭头确实只是代表节点的地址，
So if all of these arrows really just represent addresses of nodes,

402
00:20:12,130 --> 00:20:14,200
有理由认为语法可能是
it stands to reason that syntax is probably

403
00:20:14,200 --> 00:20:16,660
将类似于节点*。
going to be something akin to node *.

404
00:20:16,660 --> 00:20:18,940
现在，我可以将其命名为任何所需的指针。
Now I can call this pointer anything I want.

405
00:20:18,940 --> 00:20:20,322
按照惯例，我将其称为“下一步”。
By convention, I'll call it next.

406
00:20:20,321 --> 00:20:22,029
因为从字面上看，它的人生目的是
Because literally, its purpose in life is

407
00:20:22,029 --> 00:20:24,939
指向数据结构中的下一个节点。
to point to the next node in the data structure.

408
00:20:24,940 --> 00:20:29,140
这将是我将建议的int被叫号码的补充
And that's going to be in addition to the int called number that I'll propose

409
00:20:29,140 --> 00:20:32,120
描述了该单个数据结构的顶部。
describes the top of that individual data structure.

410
00:20:32,119 --> 00:20:34,929
但是，C语言中存在一个细微的问题。
But there's a subtle problem here in C. Recall

411
00:20:34,930 --> 00:20:38,680
在C语言中，这是一种简单的语言，
that in C, it's kind of a simplistic language, complicated

412
00:20:38,680 --> 00:20:42,550
尽管它似乎经常出现，但它什么都不懂
though it might often seem, in that it doesn't understand anything

413
00:20:42,549 --> 00:20:44,479
它从未见过。
that it hasn't seen before.

414
00:20:44,480 --> 00:20:47,620
因此，目前，请注意
So at the moment, notice that the very first time

415
00:20:47,619 --> 00:20:50,649
到目前为止，我已经提到过节点
I have mentioned node up until now was on the very

416
00:20:50,650 --> 00:20:53,200
此代码段的最后一行。
last line of this snippet of code.

417
00:20:53,200 --> 00:20:56,530
问题在于，本质上是typedef的工作方式，
The problem is that by nature of how typedef works,

418
00:20:56,529 --> 00:20:59,259
所谓的节点实际上并没有
the thing called a node does not actually

419
00:20:59,259 --> 00:21:02,979
一直存在，直到编译器完成读取最后一行代码为止
exist until the compiler is done reading that last line of code

420
00:21:02,980 --> 00:21:06,070
和分号，也就是说，实际上
and the semicolon, which is to say that it would actually

421
00:21:06,069 --> 00:21:10,239
使用或引用不正确，请取消引用
be incorrect to use or refer to quote, unquote

422
00:21:10,240 --> 00:21:12,310
该结构内部的“节点”。
"node" inside of this structure.

423
00:21:12,309 --> 00:21:14,859
因为从字面上看，根据typedef的工作原理的定义，
Because literally, by definition of how typedef works,

424
00:21:14,859 --> 00:21:19,269
直到最后一行代码和分号为止，节点才存在
a node does not exist until, again, that last line of code and the semicolon

425
00:21:19,269 --> 00:21:19,904
被执行。
are executed.

426
00:21:19,904 --> 00:21:21,279
值得庆幸的是，有一种解决方法。
Thankfully, there's a workaround.

427
00:21:21,279 --> 00:21:22,659
看起来有点奇怪。
It's a little weird to look at.

428
00:21:22,660 --> 00:21:24,445
但是您可以在C语言中执行此操作。
But what you can do in C is this.

429
00:21:24,444 --> 00:21:29,207
实际上，您实际上可以在关键字struct之后添加一个附加词。
You can actually add an additional word after, literally, the keyword struct.

430
00:21:29,208 --> 00:21:30,250
我们将使其保持简单。
And we'll keep it simple.

431
00:21:30,250 --> 00:21:33,208
我们将使用完全相同的词，尽管从技术上讲这不是必需的。
We'll use the exact same word, though technically that's not necessary.

432
00:21:33,208 --> 00:21:37,160
现在，我将更改结构的内部以替代此说法。
And now, I'm going to change the inside of the structure to say this instead.

433
00:21:37,160 --> 00:21:38,740
因此感觉有些冗长。
So it feels a little verbose.

434
00:21:38,740 --> 00:21:40,510
而且感觉有点复制粘贴。
And it feels a little bit of copy paste.

435
00:21:40,509 --> 00:21:44,979
但这是在C中完成的方式。Typedef结构节点本质上是
But this is the way it is done in C. Typedef struct node is essentially

436
00:21:44,980 --> 00:21:47,200
暗示，与原型在精神上相似
a hint, similar in spirit to the prototypes

437
00:21:47,200 --> 00:21:50,680
我们已经讨论过有关为编译器提供线索的函数，
we've talked about for functions that gives the compiler a clue that,

438
00:21:50,680 --> 00:21:54,310
好了，一个叫做struct节点的东西将会存在。
OK, something called a struct node is going to exist.

439
00:21:54,309 --> 00:21:56,829
然后，您可以在该数据结构中使用它
You can then use it inside of that data structure

440
00:21:56,829 --> 00:21:59,762
并将其称为struct node *。
and refer to it as struct node *.

441
00:21:59,762 --> 00:22:01,179
这周比较令人满口。
It's more of a mouthful this week.

442
00:22:01,180 --> 00:22:02,847
我们还没有看到像这样的多个单词。
We've not seen multiple words like this.

443
00:22:02,846 --> 00:22:06,129
但这类似于char *或int *，就像上周一样。
But it's similar to char * or int *, like last week.

444
00:22:06,130 --> 00:22:08,140
接下来，我将随意拨打该电话。
And I'm going to call that arbitrarily next.

445
00:22:08,140 --> 00:22:12,550
在这里，与过去的人一样，发生了同样的事情。
And down here, the same thing happens as in the past with persons.

446
00:22:12,549 --> 00:22:15,129
通过在代码的最后一行调用此节点，可以
By calling this node at the very last line of the code, that

447
00:22:15,130 --> 00:22:16,600
只是告诉编译器，您知道吗？
just tells the compiler, you know what?

448
00:22:16,599 --> 00:22:19,279
您不必在各处都将其称为struct节点。
You don't have to refer to it as struct node all over the place.

449
00:22:19,279 --> 00:22:21,309
您可以仅将此事物节点称为。
You can just call this thing node.

450
00:22:21,309 --> 00:22:25,389
因此，在这种情况下，它有点冗长。
So it's a little verbose in this case.

451
00:22:25,390 --> 00:22:29,470
但是，所有这些工作都是在计算机中为我创建的，
But all this is done is create for me, in the computer,

452
00:22:29,470 --> 00:22:33,490
我们以图片形式描绘的节点定义
the definition of a node as we have depicted it pictorially

453
00:22:33,490 --> 00:22:36,430
那个矩形。
with that rectangle.

454
00:22:36,430 --> 00:22:40,490
好吧，现在我们如何将其转换为更有用的代码，而不是
All right, so how can we now translate this into more useful code, not

455
00:22:40,490 --> 00:22:42,490
只是定义这些结构是什么，但是如何
just defining what these structures are, but how

456
00:22:42,490 --> 00:22:44,470
我们如何开始建立链表？
do we begin building up linked lists?

457
00:22:44,470 --> 00:22:48,460
好吧，让我建议一个链接列表实际上仅从一个指针开始。
Well, let me propose that a linked list really begins with just a pointer.

458
00:22:48,460 --> 00:22:51,880
实际上，这里有了剧院的道具店，
And in fact, here we have, thanks to the theatre's prop shop,

459
00:22:51,880 --> 00:22:54,370
如果可以的话，只是一个空指针。
just kind of a null pointer, if you will.

460
00:22:54,369 --> 00:22:56,709
我将这个变量称为“列表”。
I'm going to call this variable "list."

461
00:22:56,710 --> 00:22:58,460
和列表目前什么都没有指向。
And list is currently pointing to nothing.

462
00:22:58,460 --> 00:23:01,585
我们将要说的箭头只是指向地板，这意味着它为空。
The arrow, we'll say, is just pointing at the floor, which means it's null.

463
00:23:01,585 --> 00:23:03,610
它实际上并没有指向任何有用的东西。
It's not actually pointing at anything useful.

464
00:23:03,609 --> 00:23:06,159
假设我现在想开始分配链接
Suppose I now want to start to begin to allocate a linked

465
00:23:06,160 --> 00:23:09,157
列出三个数字1、2和3。
list with three numbers, 1, 2, and 3.

466
00:23:09,156 --> 00:23:10,489
好吧，我该怎么做？
Well, how am I going to do this?

467
00:23:10,490 --> 00:23:13,032
好吧，目前，我的程序中存在的唯一内容
Well, at the moment, the only thing that exists in my program

468
00:23:13,031 --> 00:23:14,799
将被称为list的变量。
is going to be this variable called list.

469
00:23:14,799 --> 00:23:17,259
这个故事没有任何意义。
There's no array in this story.

470
00:23:17,259 --> 00:23:19,076
那是在第二周。
That was in Week 2.

471
00:23:19,076 --> 00:23:20,409
今天是关于链表的全部。
Today is all about linked lists.

472
00:23:20,410 --> 00:23:22,570
那么我如何让自己成为一个木块，
So how do I get myself a wooden block that

473
00:23:22,569 --> 00:23:25,239
代表1，另一个代表2的木块
represents 1, another wooden block that represents 2,

474
00:23:25,240 --> 00:23:27,012
第三个代表3？
and a third that represents 3?

475
00:23:27,011 --> 00:23:29,469
好吧，我们需要使用上周的新朋友malloc。
Well, we need to use our new friend from last week, malloc.

476
00:23:29,470 --> 00:23:32,710
回想一下malloc允许您分配内存，
Recall that malloc allows you to allocate memory,

477
00:23:32,710 --> 00:23:35,110
只要您告诉它就可以拥有尽可能多的内存
as much memory as you might want, so long as you tell it

478
00:23:35,109 --> 00:23:36,399
那东西的大小。
the size of that thing.

479
00:23:36,400 --> 00:23:38,740
坦率地说，我认为我们今天最终能做些什么
So frankly, I think what we could do ultimately today

480
00:23:38,740 --> 00:23:44,020
使用malloc动态分配一个结构并将数字1放入其中，
is use malloc to allocate dynamically one struct and put the number 1 in it,

481
00:23:44,019 --> 00:23:48,009
另一个结构将数字2放在上面，另一个结构将数字3放在上面。
another struct put the number 2 on it, another struct put the number 3 in it.

482
00:23:48,009 --> 00:23:52,159
然后，使用此处的这些俏皮箭头将它们实际缝合在一起，
And then, use these playful arrows here to actually stitch them together,

483
00:23:52,160 --> 00:23:53,930
指向另一点。
having one point to the other.

484
00:23:53,930 --> 00:23:55,810
因此，值得庆幸的是，道具商店
So thankfully, the prop shop has wonderfully

485
00:23:55,809 --> 00:23:57,859
为我们创造了一大堆这些。
created a whole bunch of these for us.

486
00:23:57,859 --> 00:24:04,459
让我继续，并分配一个非常重的节点，该节点可以容纳两个值。
Let me go ahead and malloc a very heavy node that has room for two values.

487
00:24:04,460 --> 00:24:07,795
而且您会看到它有空间容纳数字和下一个指针。
And you'll see it has room for a number and a next pointer.

488
00:24:07,795 --> 00:24:09,670
所以我要首先在这里安装的号码
So the number I'm going to first install here

489
00:24:09,670 --> 00:24:12,760
例如，将是数字1。
is going to be the number 1, for instance.

490
00:24:12,759 --> 00:24:15,639
我将其指针指向地面，
And I'm going to leave its pointer as just pointing at the ground,

491
00:24:15,640 --> 00:24:17,800
指示这是一个空指针。
indicating that this is a null pointer.

492
00:24:17,799 --> 00:24:19,659
它实际上并没有指向其他任何东西。
It's not actually pointing at anything else.

493
00:24:19,660 --> 00:24:22,510
但是现在我开始实例化，
But now that I'm starting to instantiate,

494
00:24:22,509 --> 00:24:25,689
那就是创建这个列表，现在我要做这样的事情
that is create this list, now I'm going to do something like this

495
00:24:25,690 --> 00:24:29,860
并说，好的，我的变量称为“列表”，其生命目的
and say that, all right, my variable called "list," whose purpose in life

496
00:24:29,859 --> 00:24:32,529
是为了跟踪此列表在内存中的位置，
is to keep track of where this list is in memory,

497
00:24:32,529 --> 00:24:34,959
我将通过实际将彼此连接起来
I'm going to connect one to the other by actually having

498
00:24:34,960 --> 00:24:38,080
此变量指向此节点。
this variable point at this node.

499
00:24:38,079 --> 00:24:40,539
然后，要分配另一个节点，
When it comes time, then, to allocate another node,

500
00:24:40,539 --> 00:24:42,352
我想插入此链接列表。
I want to insert into this linked list.

501
00:24:42,353 --> 00:24:45,520
回到数组世界，我可能不得不分配一个新的内存块，
Back in the world of arrays, I might have to allocate a new chunk of memory,

502
00:24:45,519 --> 00:24:48,159
将此值复制到新值中。
copy this value over into the new values.

503
00:24:48,160 --> 00:24:49,300
我不必那样做。
I don't have to do that.

504
00:24:49,299 --> 00:24:52,569
在链接列表的世界中，我第二次调用malloc
In the world of linked lists, I just call malloc for a second time

505
00:24:52,569 --> 00:24:55,959
再说一遍，再给我一块足够大的内存，足以容纳一个节点。
and say, give me another chunk of memory big enough to fit a node.

506
00:24:55,960 --> 00:24:59,170
值得庆幸的是，在道具商店里，我们还有另一个。
Thankfully, from the prop shop, we have another one of these.

507
00:24:59,170 --> 00:25:03,628
我继续在这里分配另一个节点。
Let me go ahead and malloc another node here.

508
00:25:03,627 --> 00:25:05,169
目前，其中没有任何内容。
At the moment, there's nothing in it.

509
00:25:05,170 --> 00:25:06,400
它只是占位符。
It's just the placeholder.

510
00:25:06,400 --> 00:25:08,200
因此，如果可以的话，这是垃圾值。
So it's garbage values, if you will.

511
00:25:08,200 --> 00:25:10,060
我不知道那里到底有什么
I don't know what's there until I actually

512
00:25:10,059 --> 00:25:13,089
说数字应该是2。
say that the number shall be number 2.

513
00:25:13,089 --> 00:25:17,709
然后转到链接列表，其变量名称为“列表”，
And then I go over to my linked list whose variable name is "list,"

514
00:25:17,710 --> 00:25:19,060
我想插入这个东西。
and I want to insert this thing.

515
00:25:19,059 --> 00:25:20,709
所以我跟随箭头。
So I follow the arrow.

516
00:25:20,710 --> 00:25:26,180
然后，我将此节点的下一个字段指向此节点。
I then point the next field of this node at this node here.

517
00:25:26,180 --> 00:25:28,600
所以现在我有了一个尺寸为2的链表。
So now I have a linked list of size 2.

518
00:25:28,599 --> 00:25:31,989
图片中有三件事，但这只是一个简单的变量。
There's three things in the picture, but this is just a simple variable.

519
00:25:31,990 --> 00:25:35,710
这是一个指向实际节点的指针，该节点依次是
This is a pointer that's pointing at the actual node which, in turn, is

520
00:25:35,710 --> 00:25:37,370
指向实际的另一个节点。
pointing at an actual other node.

521
00:25:37,369 --> 00:25:40,989
现在，假设我要将数字3插入此链表中。
Now suppose I want to insert the number 3 into this linked list.

522
00:25:40,990 --> 00:25:43,420
回想一下malloc是强大的，并且它
Recall that malloc is powerful and that it

523
00:25:43,420 --> 00:25:45,550
从可用的地方获取内存，
takes memory from wherever it's available,

524
00:25:45,549 --> 00:25:48,079
您计算机上的所谓“堆”。
the so-called "heap" from your computer.

525
00:25:48,079 --> 00:25:51,339
根据定义，这意味着它可能不是连续的。
And that means, by definition, that it might not be contiguous.

526
00:25:51,339 --> 00:25:54,729
下一个数字可能实际上不是隐喻在这里
The next number might not actually be here metaphorically

527
00:25:54,730 --> 00:25:56,050
在计算机的内存中。
in the computer's memory.

528
00:25:56,049 --> 00:25:57,952
可能在那边。
It might be way over there.

529
00:25:57,952 --> 00:25:59,119
因此，这确实有可能发生。
So that might indeed happen.

530
00:25:59,119 --> 00:26:03,249
现在第三次调用malloc并分配第三个节点，
The third time I call malloc now and allocate a third node,

531
00:26:03,250 --> 00:26:07,000
它可能在计算机内存中的任何地方都不可用，除了，
it might not be available anywhere in the computer's memory except for,

532
00:26:07,000 --> 00:26:09,040
就像，在这边。
like, way over here.

533
00:26:09,039 --> 00:26:10,279
很好。
And that's fine.

534
00:26:10,279 --> 00:26:15,499
它不必像在数组世界中那样是连续的。
It doesn't have to be contiguous as it did in the world of our arrays.

535
00:26:15,500 --> 00:26:18,140
我现在可以将数字3放在它的位置。
I can now put the number 3 in its place.

536
00:26:18,140 --> 00:26:22,683
但是，如果我想保留指向该节点的指针，以便所有这些事情
But if I want to keep a pointer to that node, so that all of these things

537
00:26:22,682 --> 00:26:24,849
缝合在一起，我可以从头开始。
are stitched together, I can start at the beginning.

538
00:26:24,849 --> 00:26:26,199
我跟随箭头。
I follow the arrows.

539
00:26:26,200 --> 00:26:27,350
我跟随箭头。
I follow the arrows.

540
00:26:27,349 --> 00:26:29,589
现在，如果我想记住那个地方，
And now, if I want to remember where that one is,

541
00:26:29,589 --> 00:26:32,119
我将不得不连接这些东西。
I'm going to have to connect these things.

542
00:26:32,119 --> 00:26:38,119
因此，现在，该指针需要指向此处的该块。
And so now, that pointer needs to point at this block here.

543
00:26:38,119 --> 00:26:39,849
而且这种视觉效果是有意为之的。
And this visual is very much deliberate.

544
00:26:39,849 --> 00:26:42,819
这些节点可以在计算机内存中的任何位置。
These nodes can be anywhere in the computer's memory.

545
00:26:42,819 --> 00:26:45,369
它们不一定是连续的。
They're not necessarily going to be contiguous.

546
00:26:45,369 --> 00:26:49,449
缺点是您不能依赖二进制搜索，
The downside of that is that you cannot rely on binary search,

547
00:26:49,450 --> 00:26:51,460
我们从第0周开始的朋友。
our friend from Week 0 onward.

548
00:26:51,460 --> 00:26:55,210
二进制搜索是惊人的，因为它是log n的BigO。
Binary search was amazing in that it's Big O of log n.

549
00:26:55,210 --> 00:26:57,883
您可以比n的Big O更快地找到东西。
You can find stuff way faster than Big O of n.

550
00:26:57,883 --> 00:26:59,800
这就是电话簿的重点
That was the whole point of even the phonebook

551
00:26:59,799 --> 00:27:01,719
在第一周的例子。
example in the very first week.

552
00:27:01,720 --> 00:27:05,080
但是这种方法的好处是
But the upside of this approach is that you

553
00:27:05,079 --> 00:27:09,309
不必实际继续分配和复制更多的内存
don't have to actually keep allocating and copying more memory

554
00:27:09,309 --> 00:27:11,892
并在需要调整大小时随时使用所有值。
and all of your values any time you want to resize this thing.

555
00:27:11,893 --> 00:27:15,102
我有些尴尬地承认我出于某种原因而气喘吁吁，
And I'm a little embarrassed to admit that I'm out of breath for some reason,

556
00:27:15,102 --> 00:27:16,360
只是在这里分配节点。
just mallocing nodes here.

557
00:27:16,359 --> 00:27:18,819
但是重点是使用malloc并进行构建
But the point is using malloc and building out

558
00:27:18,819 --> 00:27:20,799
结构确实要付出一些代价。
the structure does come at some price.

559
00:27:20,799 --> 00:27:22,754
坦白说，这太累了。
It's exhausting, frankly.

560
00:27:22,755 --> 00:27:24,880
但这也将在内存中扩展内容。
But it's also going to spread things out in memory.

561
00:27:24,880 --> 00:27:26,020
但是你有这种活力。
But you have this dynamism.

562
00:27:26,019 --> 00:27:28,269
老实说，如果您是全世界的推特，那么Google
And honestly, if you are the Twitters of the world, the Googles

563
00:27:28,269 --> 00:27:30,394
在世界上，那里有很多数据，
of the world, where you have lots and lots of data,

564
00:27:30,394 --> 00:27:34,359
必须复制所有数据，这会扼杀您的性能
it's going to kill you performance wise to have to copy all of your data

565
00:27:34,359 --> 00:27:36,809
从一个地方到另一个地方，就像圣地亚哥一样
from one location into another as Santiago originally

566
00:27:36,809 --> 00:27:39,449
建议作为阵列的解决方案。
proposed as a solution to the array.

567
00:27:39,450 --> 00:27:43,380
因此，使用这些动态数据结构（例如链表）时，
So using these dynamic data structures, like a linked list, where

568
00:27:43,380 --> 00:27:45,690
您在可用的地方分配更多的空间，
you allocate more space wherever it's available,

569
00:27:45,690 --> 00:27:48,750
而且您以某种方式还记得缝合的位置[？团队？]东西
and you somehow remember where that is by stitching [? team ?] things

570
00:27:48,750 --> 00:27:50,939
就像这些物理指针一样
together, as with these physical pointers,

571
00:27:50,940 --> 00:27:53,160
确实是您最新的技术水平
is really the state of the art in how you

572
00:27:53,160 --> 00:27:56,730
如果对您来说更重要，则可以创建这些更动态的结构
can create these more dynamic structures if it's more important to you

573
00:27:56,730 --> 00:27:59,100
具有那种活力。
to have that dynamism.

574
00:27:59,099 --> 00:28:04,009
好吧，我们现在翻译这些物理块之前的任何问题
All right, any questions before we now translate these physical blocks

575
00:28:04,009 --> 00:28:06,896
一些代码示例？
to some samples of code?

576
00:28:06,896 --> 00:28:08,479
布莱恩：聊天中出现了一个问题。
BRIAN: A question came in in the chat.

577
00:28:08,480 --> 00:28:11,660
在链接列表的整个过程中，什么时候我们实际上在使用malloc？
When in this whole process of linked lists are we actually using malloc?

578
00:28:11,660 --> 00:28:13,220
而malloc的作用是什么？
And what is malloc being used for?

579
00:28:13,220 --> 00:28:14,280
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

580
00:28:14,279 --> 00:28:15,487
那么我们在哪里使用malloc？
So where are we using malloc?

581
00:28:15,488 --> 00:28:17,600
每次我走下舞台，抓住一个
Every time I went off stage and grabbed one

582
00:28:17,599 --> 00:28:23,269
在这些大块中，这是我执行分配节点的过程。
of these big blocks, that was my acting out the process of mallocing a node.

583
00:28:23,269 --> 00:28:25,519
因此，当您调用malloc时，它将返回给您，
So when you call malloc, that returns to you,

584
00:28:25,519 --> 00:28:30,239
每上周，这是一块内存的第一个字节的地址。
per last week, the address of the first byte of a chunk of memory.

585
00:28:30,240 --> 00:28:33,200
而且，如果您调用malloc的1，则将为您提供1个字节的地址。
And if you call malloc of one, that gives you the address of one byte.

586
00:28:33,200 --> 00:28:35,930
如果您将malloc调用为100，则将为您提供第一个地址
If you call malloc of 100, that gives you the first address

587
00:28:35,930 --> 00:28:38,580
100个连续字节。
of 100 bytes that are contiguous.

588
00:28:38,579 --> 00:28:43,109
因此，这些节点中的每一个都代表返回值，如果您愿意的话，
So each of these nodes, then, represents the return value, if you will,

589
00:28:43,109 --> 00:28:45,199
对malloc的单个调用。
of a single call to malloc.

590
00:28:45,200 --> 00:28:47,600
实际上，也许布莱恩是最好的方法
And in fact, perhaps, Brian, the best way

591
00:28:47,599 --> 00:28:50,719
要更详细地回答该问题，请立即翻译
to answer that question in more detail is to translate this now

592
00:28:50,720 --> 00:28:51,627
一些实际的代码。
to some actual code.

593
00:28:51,626 --> 00:28:53,209
因此，让我们不时进行此操作，然后再进行访问。
So let's do that now and then revisit.

594
00:28:53,210 --> 00:28:56,000
例如，这是一行代码，
So here is, for instance, a line of code that

595
00:28:56,000 --> 00:28:58,310
代表我们故事的开始，我们只
represents the beginning of our story, where we only

596
00:28:58,309 --> 00:29:02,959
有一个名为“列表”的变量，该变量最初初始化为空。
had a variable called "list" that was initialized to nothing initially.

597
00:29:02,960 --> 00:29:05,023
这个箭头没有指向任何东西。
This arrow was not pointing at anything.

598
00:29:05,022 --> 00:29:07,189
实际上，如果它只是指向上，下，左
And in fact, if it was just pointing up, down, left,

599
00:29:07,190 --> 00:29:09,650
或正确，它将被视为垃圾值。
or right, it would be considered a garbage value.

600
00:29:09,650 --> 00:29:12,440
这只是内存，这意味着其中包含值
This is just memory, which means there are values inside of it

601
00:29:12,440 --> 00:29:15,240
在我实际输入实际值之前。
before I actually put actual values in it.

602
00:29:15,240 --> 00:29:18,273
所以，如果我不给它赋值，谁知道它指向的是什么？
So if I don't assign it a value, who knows what it's pointing to?

603
00:29:18,272 --> 00:29:19,939
但是，让我继续更改代码。
But let me go ahead and change the code.

604
00:29:19,940 --> 00:29:24,290
默认情况下，此列表变量具有一些垃圾值，除非我对其进行初始化
This list variable, by default, has some garbage value unless I initialize it

605
00:29:24,289 --> 00:29:25,489
到null之类的东西
to something like null.

606
00:29:25,490 --> 00:29:28,940
因此，我仅通过指向地面来形象地表示这一点。
So I'll represent that here figuratively by just pointing at the ground.

607
00:29:28,940 --> 00:29:30,260
现在表示为空。
That now represents null.

608
00:29:30,259 --> 00:29:32,509
这将是相应的代码行
This would be the corresponding line of code that just

609
00:29:32,509 --> 00:29:35,419
为您创建一个空的链表。
creates for you an empty linked list.

610
00:29:35,420 --> 00:29:36,975
那是故事的开始。
That was the beginning of the story.

611
00:29:36,974 --> 00:29:39,349
现在回想一下，我接下来要做的就是离开舞台
Now recall that the next thing I did was I went off stage

612
00:29:39,349 --> 00:29:42,619
我打电话给malloc来带回这些大箱子之一。
and I called malloc to bring back one of these big boxes.

613
00:29:42,619 --> 00:29:45,979
该代码可能看起来像这样。
That code might instead look like this.

614
00:29:45,980 --> 00:29:47,360
节点* n。
Node *n.

615
00:29:47,359 --> 00:29:52,039
因此，我可以将变量命名为malloc，节点大小。
So I could call the variable anything I want, malloc, size of node.

616
00:29:52,039 --> 00:29:55,039
因此，我们的规模可能已经简短地看到了
So size of we might have seen briefly in that it's just

617
00:29:55,039 --> 00:29:59,549
C语言中的运算符，它告诉您任何数据类型的字节数为多少。
an operator in C that tells you how many bytes large any data type is.

618
00:29:59,549 --> 00:30:03,709
所以我可以进行数学计算，然后在Mac或PC或CS50 IDE中弄清楚
So I could do the math and figure out in my Mac or PC or CS50 IDE just how

619
00:30:03,710 --> 00:30:05,690
这些节点应该占用很多字节。
many bytes these nodes are supposed to take up.

620
00:30:05,690 --> 00:30:07,970
大小只是为我回答了这个问题。
Size of just answers that question for me.

621
00:30:07,970 --> 00:30:10,370
因此，malloc再次接受一个参数，即数字
So malloc, again, takes one argument, the number

622
00:30:10,369 --> 00:30:13,009
您要动态分配的字节数，
of bytes you want to allocate dynamically,

623
00:30:13,009 --> 00:30:15,929
然后返回到这些字节中第一个字节的地址。
and it returns to the address of the first of those bytes.

624
00:30:15,930 --> 00:30:18,822
因此，如果您将其视为我以前的黄色幻灯片之一，
So if you think of this as one of my earlier slides in yellow,

625
00:30:18,821 --> 00:30:20,779
它返回给您，例如顶部的地址
it returns to you, like, the address of the top

626
00:30:20,779 --> 00:30:23,669
如果可以的话，此内存块的左字节。
left byte of this chunk of memory, if you will.

627
00:30:23,670 --> 00:30:26,160
我将继续将其分配给变量
And I'm going to go ahead and assign that to a variable

628
00:30:26,160 --> 00:30:28,430
我将调用n表示一个节点。
I'll call n to represent a node.

629
00:30:28,430 --> 00:30:33,410
以及它的节点*，因为malloc同样总是返回一个地址。
And its node * because, again, malloc returns always an address.

630
00:30:33,410 --> 00:30:36,050
以及上周我们看到的用于存储地址的语法
And the syntax we saw last week for storing addresses

631
00:30:36,049 --> 00:30:39,299
是在这里使用这种新的*语法。
is to use this new * syntax here.

632
00:30:39,299 --> 00:30:44,309
因此，这给了我一个最初只有垃圾值的块。
So this gave me a block that initially just had garbage values.

633
00:30:44,309 --> 00:30:48,449
因此没有适当的数字，谁知道箭头所指的位置？
So there was no number in place and who knows where the arrow was pointing at?

634
00:30:48,450 --> 00:30:52,010
因此，如果我现在将其绘制在屏幕上，它看起来像这样。
So it looked a little something like this, if I draw it now on the screen.

635
00:30:52,009 --> 00:30:53,522
列表初始化为空。
List is initialized to null.

636
00:30:53,522 --> 00:30:55,189
现在没有指向任何东西。
It's not pointing at anything right now.

637
00:30:55,190 --> 00:30:59,330
但是我刚刚声明的变量n指向一个节点。
But n, the variable I just declared, is pointing at a node.

638
00:30:59,329 --> 00:31:01,219
但是在那个节点内部，还是谁知道呢？
But inside of that node, or who knows what?

639
00:31:01,220 --> 00:31:02,120
这是垃圾值。
It's garbage values.

640
00:31:02,119 --> 00:31:04,159
Number和next只是垃圾值。
Number and next are just garbage values.

641
00:31:04,160 --> 00:31:07,760
因为默认情况下就是过去的残局。
Because that's what's there by default, remnants of the past.

642
00:31:07,759 --> 00:31:10,309
但是现在，让我建议我们执行此代码。
But now, let me propose that we do this code.

643
00:31:10,309 --> 00:31:12,097
只要n不为空，
So long as n is not null--

644
00:31:12,097 --> 00:31:15,139
这是您现在想要养成的习惯，总是检查一下，
which is something you want to get into the habit always now of checking,

645
00:31:15,140 --> 00:31:19,580
在C中的任何时候，当您调用返回给您指针的函数时，
any time in C, when you call a function that returns to you a pointer,

646
00:31:19,579 --> 00:31:23,029
您几乎应该始终检查它是否为null。
you should almost always check is it null or is it not null.

647
00:31:23,029 --> 00:31:26,149
因为如果它确实为null，则不希望尝试对其进行触摸。
Because you do not want to try touching it if it is indeed null.

648
00:31:26,150 --> 00:31:28,490
因为这意味着这里没有有效的地址。
Because that means there is no valid address here.

649
00:31:28,490 --> 00:31:30,950
这是使用指针时的惯例。
That's the human convention when using pointers.

650
00:31:30,950 --> 00:31:34,578
但是，如果n不等于null，那是一件好事。
But if n does not equal null, that's a good thing.

651
00:31:34,577 --> 00:31:37,369
这意味着它是计算机内存中某个地方的有效地址。
That means it's a valid address somewhere in the computer's memory.

652
00:31:37,369 --> 00:31:43,039
现在让我继续前往该地址，其语法为* n，
Let me go ahead now and go to that address, the syntax for which is *n,

653
00:31:43,039 --> 00:31:44,479
就像上周一样。
just like last week.

654
00:31:44,480 --> 00:31:48,530
然后，运算符意味着进入那里的结构内部
And then the operator means go inside of the structure that's there

655
00:31:48,529 --> 00:31:52,229
然后进入其中的变量（在这种情况下称为数字）。
and go into the variable inside of it, called number in this case.

656
00:31:52,230 --> 00:31:54,680
所以当我继续做这样的事情时，
So when I go ahead and do something like this,

657
00:31:54,680 --> 00:31:58,400
当我有一个最初大小为1的列表时
when I have a list that's initially of size 1,

658
00:31:58,400 --> 00:32:04,070
该变量指向当前唯一的一个节点，
where this variable is pointing at the one and only node at the moment,

659
00:32:04,069 --> 00:32:07,969
一旦执行此行代码，它将立即将数字1包含在其中。
it's going to have the number 1 in it as soon as I execute this line of code.

660
00:32:07,970 --> 00:32:12,710
* n表示从此处包含的地址开始，转到该地址，
*n means start at the address embodied here, go to it,

661
00:32:12,710 --> 00:32:16,560
然后将数字（在这种情况下为1）放置到位。
and then put the number, 1 in this case, in place.

662
00:32:16,559 --> 00:32:18,739
但是我也需要做另一件事。
But I need to do one other thing as well.

663
00:32:18,740 --> 00:32:20,990
我也想去替换垃圾
I want to go ahead, too, and replace the garbage

664
00:32:20,990 --> 00:32:23,570
表示该结构中下一个指针的值
value that represents the next pointer in that structure

665
00:32:23,569 --> 00:32:24,679
并将其替换为null。
and replace it with null.

666
00:32:24,680 --> 00:32:27,020
空[音频不清晰]发现这是列表的末尾。
Null [INAUDIBLE] find that this is the end of the list.

667
00:32:27,019 --> 00:32:27,769
那里什么都没有。
There's nothing there.

668
00:32:27,769 --> 00:32:29,149
我不希望它成为垃圾值。
I don't want it to be garbage value.

669
00:32:29,150 --> 00:32:31,067
因为垃圾值是任意数字
Because a garbage value is an arbitrary number

670
00:32:31,067 --> 00:32:33,380
这可能是这种方式，这种方式的指向。
that could be pointing this way, this way, this way.

671
00:32:33,380 --> 00:32:36,560
隐喻地，我想实际上将其更改为null
Metaphorically, I want to actually change that to be null

672
00:32:36,559 --> 00:32:38,347
所以我可以使用相同的语法
and so I can use the same syntax.

673
00:32:38,347 --> 00:32:39,889
但是现在有一种聪明的方法。
But there's this clever approach now.

674
00:32:39,890 --> 00:32:43,850
如前所述，我不必先用星号然后在该位置上点一下。
I don't have to use star and then dot over the place, as mentioned earlier.

675
00:32:43,849 --> 00:32:47,389
星点带有一些语法糖。
Star and dot comes with some syntactic sugar.

676
00:32:47,390 --> 00:32:50,290
您可以替换星号，括号和点
You can replace the star and the parentheses and the dot

677
00:32:50,289 --> 00:32:54,049
我们刚刚看到的箭头符号表示跟随箭头。
that we just saw with an arrow notation, which means follow the arrow.

678
00:32:54,049 --> 00:32:56,389
然后将其设置为null，即
And then set this thing equal to null, which

679
00:32:56,390 --> 00:32:59,240
我将再次用箭头逐字地表示
I'll represent again by just having the arrow literally points

680
00:32:59,240 --> 00:33:02,040
为了清楚起见，在地板上。
at the floor for clarity.

681
00:33:02,039 --> 00:33:07,489
因此，再次从我们开始的地方倒带* n.number，
So, again, rewinding from where we started, *n.number,

682
00:33:07,490 --> 00:33:11,270
括号中的第一个是与此相同的东西。
with the first of those in parentheses, is the same thing as this.

683
00:33:11,269 --> 00:33:15,269
可以这么说，也是大多数人更喜欢使用箭头符号的原因，
And the reason that most people prefer using the arrow notation, so to speak,

684
00:33:15,269 --> 00:33:18,019
是它确实捕获了这种物理状态。
is that it really does capture this physicality.

685
00:33:18,019 --> 00:33:20,869
您从地址开始，然后去那里，然后
You start at the address, you go there, and then

686
00:33:20,869 --> 00:33:24,049
您分别查看字段，数字或下一个。
you look at the field, number or next, respectively.

687
00:33:24,049 --> 00:33:27,874
但这等同于我们刚才看到的开头和句点的语法
But it's equivalent to the syntax we saw a moment ago with the start and the dot

688
00:33:27,875 --> 00:33:29,090
像之前一样。
as before.

689
00:33:29,089 --> 00:33:30,979
这两个步骤之后，我们是否已初始化
So after these two steps, have we initialized

690
00:33:30,980 --> 00:33:36,760
此节点包含数字1，内部包含null。
this node to containing the number 1 and null inside of it.

691
00:33:36,759 --> 00:33:38,539
但是接下来呢？
But what comes next?

692
00:33:38,539 --> 00:33:39,379
接下来是什么？
What comes next?

693
00:33:39,380 --> 00:33:41,470
好吧，在故事中，在这段代码中，
Well, at point in the story, in this code,

694
00:33:41,470 --> 00:33:43,690
我这里还有其他未显示的变量。
I have some other variable here that's not pictured.

695
00:33:43,690 --> 00:33:47,090
因为我们现在正在从木工世界过渡到实际代码。
Because we're now transitioning from the world of woodwork to actual code.

696
00:33:47,089 --> 00:33:51,129
因此，还有另一个变量n，我也可以代表我自己。
So there's another variable n, which I might as well be representing myself.

697
00:33:51,130 --> 00:33:54,280
如果我是这个临时变量n，我也将指向该值。
If I am this temporary variable n, I, too, am pointing at this value.

698
00:33:54,279 --> 00:33:59,829
直到我实际执行这一行代码list = n ;，
It's not until I actually execute this line of code, list = n;,

699
00:33:59,829 --> 00:34:04,356
我记得该节点在计算机内存中的位置。
that I remember where this node is in the computer's memory.

700
00:34:04,356 --> 00:34:06,939
因此，到目前为止，n确实只是一个临时变量。
So n, up until now, has really just been a temporary variable.

701
00:34:06,940 --> 00:34:09,190
这是我可以用来实际保留的变量
It's a variable that I can use to actually keep

702
00:34:09,190 --> 00:34:10,969
在内存中跟踪此事物。
track of this thing in memory.

703
00:34:10,969 --> 00:34:14,530
但是，如果我想将此节点最终添加到我的链表中，
But if I want to add this node ultimately to my linked list,

704
00:34:14,530 --> 00:34:18,460
列表以null开头，请记住该指针指向
list started out as null, recall that this pointer was pointing

705
00:34:18,460 --> 00:34:20,170
在地面上，表示null。
at the ground, representing null.

706
00:34:20,170 --> 00:34:24,250
但是，当我现在想记住此链表中有一个节点时，
But when I now want to remember that this linked list has a node in it,

707
00:34:24,250 --> 00:34:30,488
我实际上需要执行这样的代码，list = null。
I need to actually execute a line of code like this, list = null.

708
00:34:30,489 --> 00:34:31,900
好吧，我们接下来要做什么？
All right, what did we next do?

709
00:34:31,900 --> 00:34:33,530
让我们再迈出一步。
Let's take one more step further.

710
00:34:33,530 --> 00:34:36,159
所以在故事的这一点上，如果我代表n，
So at this point in the story, if I was representing n,

711
00:34:36,159 --> 00:34:38,650
我也指着同一街区。 n是临时的，
I'm also pointing at the same block. n is temporary,

712
00:34:38,650 --> 00:34:39,969
因此它最终可以消失。
so it can eventually go away.

713
00:34:39,969 --> 00:34:43,018
但是在故事的这一点上，我们有一个大小为1的链表。
But at this point in the story, we have a linked list of size 1.

714
00:34:43,018 --> 00:34:44,560
让我们继续前进。
Let's go ahead and take this further.

715
00:34:44,559 --> 00:34:46,388
假设现在执行这些代码行。
Suppose now I execute these lines of code.

716
00:34:46,389 --> 00:34:48,489
而且我们会更快一点，一次全部完成
And we'll do it a little faster and all at once so

717
00:34:48,489 --> 00:34:50,230
您可以在上下文中看到更多。
that you can see it more in context.

718
00:34:50,230 --> 00:34:52,389
代码的第一行与以前相同。
The first line of code is the same as before.

719
00:34:52,389 --> 00:34:54,722
嘿，malloc，给我一块内存
Hey, malloc, give me a chunk of memory that's

720
00:34:54,722 --> 00:34:56,139
大到足以容纳一个节点的大小。
big enough for the size of a node.

721
00:34:56,139 --> 00:34:59,465
再次，让我们使用这个临时变量n指向该变量。
And, again, let's use this temporary variable n to point to that.

722
00:34:59,465 --> 00:35:02,590
假设这意味着如果我代表这个临时变量，
And suppose that means that I, if I'm representing this temporary variable,

723
00:35:02,590 --> 00:35:04,630
我在这里指向这个新的内存块。
I'm pointing at this new chunk of memory here.

724
00:35:04,630 --> 00:35:08,260
然后我检查，如果n不等于null，那么
I then check, if n does not equal null, then

725
00:35:08,260 --> 00:35:10,870
只有这样我才能继续安装
and only then do I go ahead and install the number

726
00:35:10,869 --> 00:35:16,449
2就像我之前所做的一样，并且我最初初始化了指针
2 as I did physically earlier and do I initialize the pointer originally

727
00:35:16,449 --> 00:35:21,519
指向不是指向尚不存在的其他节点，而是指向
to pointing not at some other node which doesn't yet exist, but pointing at,

728
00:35:21,519 --> 00:35:24,639
让我们将其称为地板，从而代表null。
let's just call it the floor, thereby representing null.

729
00:35:24,639 --> 00:35:26,019
就是这样。
And that's it.

730
00:35:26,019 --> 00:35:28,179
现在已经分配了第二个节点。
That has now allocated the second node.

731
00:35:28,179 --> 00:35:30,759
但是请注意，从字面上看，这是断开的。
But notice, literally, this disconnect.

732
00:35:30,760 --> 00:35:33,010
只是因为我分配了一个新节点并放入
Just because I've allocated a new node and put

733
00:35:33,010 --> 00:35:36,220
我关心的数字，并将其下一个指针初始化为null，
the number I care about and initialized its next pointer to null,

734
00:35:36,219 --> 00:35:38,479
这并不意味着它是数据结构的一部分。
that doesn't mean it's part of the data structure.

735
00:35:38,480 --> 00:35:43,030
链表仍然缺少从旧到新的指针。
The linked list is still missing a pointer from old to new.

736
00:35:43,030 --> 00:35:45,200
所以我们需要执行另一行代码
So we need to execute one other line of code

737
00:35:45,199 --> 00:35:49,149
现在，以便我们可以最终从这张图片到最后一张。
now so that we can get from this picture ultimately to the final one.

738
00:35:49,150 --> 00:35:52,420
在这里，我们可以使用与以前相同的语法。
And here's where we can use the same kind of syntax as before.

739
00:35:52,420 --> 00:35:57,550
如果我从列表变量开始，则按照该代码跟随箭头。
If I start at my list variable, I follow the arrow as per that code.

740
00:35:57,550 --> 00:36:00,280
然后我更新下一个字段以指向
And then I update the next field to point

741
00:36:00,280 --> 00:36:04,940
到n，这是我新分配的节点。
to n, which is my newly allocated node.

742
00:36:04,940 --> 00:36:09,700
现在，在最后一行代码之后，我是否有一个大小为2的链表。
Now, after that final line of code, do I have a linked list of size 2.

743
00:36:09,699 --> 00:36:12,879
因为我不仅分配了节点，还初始化了它的两个
Because I've not only allocated the node, initialized its two

744
00:36:12,880 --> 00:36:17,050
变量，分别是数字和下一个，
variables, a number and next respectively,

745
00:36:17,050 --> 00:36:23,727
我还将其与链表上的现有节点链接在一起。
I've also chained it together with the existing node on the linked list.

746
00:36:23,726 --> 00:36:25,809
让我更快速地执行此操作，
And let me do this one even slightly more quickly,

747
00:36:25,809 --> 00:36:29,319
只是因为这是同一件事，所以我们才能一次看到所有内容。
only because it's the same thing, just so we can see it all together at once.

748
00:36:29,320 --> 00:36:32,660
现在我们有了这张图片，让我们再次执行相同类型的代码。
Now that we have this picture, let's execute the same kind of code again.

749
00:36:32,659 --> 00:36:34,389
此代码块中的唯一区别
The only difference in this chunk of code

750
00:36:34,389 --> 00:36:36,429
我正在将数字初始化为3。
is that I'm initializing number to 3.

751
00:36:36,429 --> 00:36:37,659
那么这对我做了什么呢？
So what has this done for me?

752
00:36:37,659 --> 00:36:40,539
那段代码已经分配了第三个也是最后一个节点。
That chunk of code has malloced a third and final node.

753
00:36:40,539 --> 00:36:42,429
我已经将顶部初始化为数字3。
I've initialized the top to the number 3.

754
00:36:42,429 --> 00:36:44,709
我将底部初始化为null，因为
I've initialized the bottom to null, as I'll

755
00:36:44,710 --> 00:36:46,990
只需将箭头指向地面即可表示。
represent by just pointing the arrow at the ground.

756
00:36:46,989 --> 00:36:49,059
然后，有最后一步。
There's one final step, then.

757
00:36:49,059 --> 00:36:52,269
如果我要继续并将该第三个节点插入此链接列表，
If I want to go ahead and insert that third node into this linked list,

758
00:36:52,269 --> 00:36:55,179
我现在必须继续前进，而不仅仅是指着自己，
I've got to go ahead now and not just point it at myself,

759
00:36:55,179 --> 00:36:59,349
我再次代表临时变量n，我现在需要这样做。
me representing, again, the temporary variable n, I need to now do this.

760
00:36:59,349 --> 00:37:01,269
这是您不会经常使用的语法。
And this is syntax you won't do often.

761
00:37:01,269 --> 00:37:03,829
我们将在稍后的实际程序中看到它。
We'll see it in an actual program in just a moment.

762
00:37:03,829 --> 00:37:07,089
但这仅说明了我们正在处理的基本构建块。
But it just speaks to the basic building blocks we're manipulating.

763
00:37:07,090 --> 00:37:12,250
如果我要继续并将2链接到3，我可以从列表开始。
If I want to go ahead and link the 2 to the 3, I can start here at list.

764
00:37:12,250 --> 00:37:14,139
我可以跟随箭头一次。
I can follow the arrow once.

765
00:37:14,139 --> 00:37:15,849
我可以再次跟随箭头。
I can follow the arrow again.

766
00:37:15,849 --> 00:37:20,139
然后我可以将下一个字段设置为n。
And then I can set that next field equal to n.

767
00:37:20,139 --> 00:37:29,109
同样，因为n是该最近分配的节点的当前地址。
Because, again, n is the current address of that most recently allocated node.

768
00:37:29,110 --> 00:37:34,770
因此，即使语法有了一些新变化，我使用的两个箭头
So even though the syntax is getting a little new, the two arrows I'm using

769
00:37:34,769 --> 00:37:37,739
从字面上看就像是Just的代码体现
are literally just like a code manifestation of just

770
00:37:37,739 --> 00:37:43,949
跟随指针，跟随指针，动臂，为下一个分配一个值。
follow the pointer, follow the pointer, boom, assign one value to the next.

771
00:37:43,949 --> 00:37:47,289
好吧，所以在故事的这一点上，图片现在看起来像这样。
All right, so at this point in the story, the picture now looks like this.

772
00:37:47,289 --> 00:37:49,019
只要我，n，仍然在图片中。
So long as I, n, am still in the picture.

773
00:37:49,019 --> 00:37:50,852
但是如果我摆脱自己，因为我
But if I just get rid of myself, because I'm

774
00:37:50,853 --> 00:37:54,480
临时变量，瞧，我们刚刚逐步建立起来，
a temporary variable, voila, we've just built up, step by step,

775
00:37:54,480 --> 00:38:00,480
大小为3的全新链接列表。
a brand new linked list of size 3.

776
00:38:00,480 --> 00:38:06,973
似乎需要做很多工作，但是它使我们现在可以动态地发展这个东西。
Seems like a lot of work, but it allows us to now grow this thing dynamically.

777
00:38:06,972 --> 00:38:07,889
但是，让我在这里暂停。
But let me pause here.

778
00:38:07,889 --> 00:38:12,459
对链表有任何疑问或困惑吗？
Any questions or confusion on linked lists?

779
00:38:12,460 --> 00:38:15,210
链表上有任何疑问或困惑吗？
Any questions or confusions on linked lists?

780
00:38:15,210 --> 00:38:17,267
布莱恩：聊天中出现了一个问题。
BRIAN: One question just came in the chat.

781
00:38:17,266 --> 00:38:20,099
如果我们试图列出更长的列表，例如，
If we're trying to make a list that's going to be much longer, like,

782
00:38:20,099 --> 00:38:22,474
超过三个元素，难道就没有泰迪乌斯了吗？
more than three elements, wouldn't it get tedius to have,

783
00:38:22,474 --> 00:38:24,629
像，下一个箭头，一遍又一遍的箭头？
like, arrow next, arrow next over and over again?

784
00:38:24,630 --> 00:38:25,050
戴维·马兰：是的。
DAVID MALAN: Yeah.

785
00:38:25,050 --> 00:38:25,990
真的很好观察。
Really good observation.

786
00:38:25,989 --> 00:38:28,469
因此，这就是我说的原因，您通常不会这样写。
And so that's why I said, you won't usually write it like this.

787
00:38:28,469 --> 00:38:31,219
稍后，我们将在功能完善的程序中暂时进行此操作
We'll do it temporarily in a full-fledged program in just a moment

788
00:38:31,219 --> 00:38:32,219
只是为了演示它。
just to demonstrate it.

789
00:38:32,219 --> 00:38:34,919
但通常，您可能会使用类似循环的内容。
But in general, you'll probably use something like a loop.

790
00:38:34,920 --> 00:38:38,190
而您要做的就是使用一个指向该变量的临时变量，
And what you'll do is use a temporary variable that points at this one,

791
00:38:38,190 --> 00:38:40,530
然后再次迭代，然后再次迭代。
then iterates again, then iterates again.

792
00:38:40,530 --> 00:38:43,930
现在让我规定，如果您以正确的方式使用循环，
And let me stipulate for now that if you use a loop in the right way,

793
00:38:43,929 --> 00:38:46,229
最终只用一个箭头就可以写出
you can end up writing just a single arrow by just

794
00:38:46,230 --> 00:38:48,447
不断更新变量。
keep updating the variable again and again.

795
00:38:48,447 --> 00:38:49,780
因此，有一种方法可以避免这种情况。
So there is a way to avoid that.

796
00:38:49,780 --> 00:38:53,430
您可以更加动态地进行操作。
And you do it much more dynamically.

797
00:38:53,429 --> 00:38:56,409
那么，让我继续前进，在这里问您一个我自己的问题。
Let me go ahead then and ask you a question of my own here.

798
00:38:56,409 --> 00:38:58,169
让我继续问这个。
Let me go ahead and ask this one.

799
00:38:58,170 --> 00:39:00,780
如果您想讨论这个问题，
If you'd like to buzz in to this question,

800
00:39:00,780 --> 00:39:05,170
搜索链接列表的运行时间是多少？
what is the running time of searching a linked list?

801
00:39:05,170 --> 00:39:08,800
以Big O表示法搜索链接列表的运行时间是多少？
What's the running time of searching a linked list in Big O notation?

802
00:39:08,800 --> 00:39:12,690
那么什么是上限，最坏的搜索情况
So what's an upper bound, worst case of searching

803
00:39:12,690 --> 00:39:17,460
像这样的一个链表，它是否包含三个元素甚至更多？
a linked list like this one, whether it has three elements or even many more?

804
00:39:17,460 --> 00:39:20,190
就像以前一样，该组中大约有80％
So it looks like, as before, about 80% of the group

805
00:39:20,190 --> 00:39:21,750
建议它是n的大O。
is proposing that it's Big O of n.

806
00:39:21,750 --> 00:39:23,026
这实际上是正确的。
And this is actually correct.

807
00:39:23,027 --> 00:39:24,360
因为考虑最坏的情况。
Because consider the worst case.

808
00:39:24,360 --> 00:39:26,318
假设您要寻找数字3，
Suppose you're looking for the number 3, you're

809
00:39:26,318 --> 00:39:29,400
将必须查看所有三个数字，即n的大O。
going to have to look at all three numbers, Big O of n.

810
00:39:29,400 --> 00:39:31,260
如果您要查找数字10，则表示
If you're looking for the number 10, you're

811
00:39:31,260 --> 00:39:32,670
首先要从这里开始
going to start here at the beginning, you're

812
00:39:32,670 --> 00:39:34,110
要继续寻找，寻找，寻找，寻找。
going to keep looking, looking, looking, looking.

813
00:39:34,110 --> 00:39:37,235
您将最终意识到，哦，数字10甚至不在这里。
You're going to get to the end realize, oh, the number 10 is not even here.

814
00:39:37,235 --> 00:39:39,840
此时，您已经查看了n个元素。
At which point, you've already looked at n elements.

815
00:39:39,840 --> 00:39:42,690
但这又是链表的一种。
But here's one of the trade, again, of linked lists.

816
00:39:42,690 --> 00:39:46,413
使用数组，您可以在恒定时间内跳到列表的末尾。
With arrays, you could jump to the end of the list in constant time.

817
00:39:46,413 --> 00:39:48,330
您可以只使用一点算术。
You could just use a little bit of arithmetic.

818
00:39:48,329 --> 00:39:50,829
您可以跳到中间元素或第一个元素，
You could jump to the middle elements, or the first element,

819
00:39:50,829 --> 00:39:51,839
全部使用固定时间。
all using constant time.

820
00:39:51,840 --> 00:39:55,140
不幸的是，最终显示了一个链表
A linked list, unfortunately, is represented ultimately

821
00:39:55,139 --> 00:39:59,729
仅通过一个地址，即指向第一个节点的地址。
by just a single address, the address that points to the very first node.

822
00:39:59,730 --> 00:40:02,850
因此，即使您在摄像机上的所有人都可以看到该节点和该节点
And so even though you all on camera can see this node and this node

823
00:40:02,849 --> 00:40:05,459
而这一次像人类一样，计算机
and this one as humans all at once, the computer

824
00:40:05,460 --> 00:40:07,350
只能跟随这些面包屑。
can only follow these breadcrumbs.

825
00:40:07,349 --> 00:40:12,299
因此，在这种情况下，搜索链接列表将成为n的BigO。
And so searching a linked list is going to be Big O of n in that case.

826
00:40:12,300 --> 00:40:14,460
但是，让我问一个后续问题。
But let me ask a follow up question.

827
00:40:14,460 --> 00:40:19,930
插入链表的运行时间是多少？
What's the running time of inserting into a linked list?

828
00:40:19,929 --> 00:40:23,219
插入链表的运行时间是多少？
What's the running time of inserting into a linked list?

829
00:40:23,219 --> 00:40:29,879
因此，您有了一些新数字，例如数字4或0或100或负5，
So you've got some new number like the number 4 or 0 or 100 or negative 5,

830
00:40:29,880 --> 00:40:31,350
不管是什么
whatever it may be.

831
00:40:31,349 --> 00:40:34,259
将会涉及到一个malloc，但这是固定的时间。
There's going to be a malloc involved, but that's constant time.

832
00:40:34,260 --> 00:40:36,010
这只是一个函数调用。
It's just one function call.

833
00:40:36,010 --> 00:40:38,010
但是您将不得不将其插入某个位置。
But you're going to have to insert it somewhere.

834
00:40:38,010 --> 00:40:42,720
在这里，您看来有68％的人提议1的大O
And here it looks like 68% of you are proposing Big O of 1,

835
00:40:42,719 --> 00:40:44,819
有趣的是，恒定的时间。
which is interesting, constant time.

836
00:40:44,820 --> 00:40:47,880
你们中有25％的人提议n的大O。
25% of you are proposing Big O of n.

837
00:40:47,880 --> 00:40:51,360
任何人都可以随意在口头或聊天中进行提示
Would anyone be comfortable chiming in verbally or on the chat

838
00:40:51,360 --> 00:40:54,970
至于为什么你觉得是另一种呢？
as to why you feel it's one or the other?

839
00:40:54,969 --> 00:40:57,569
的确是这些答案之一。
It is indeed one of those answers.

840
00:40:57,570 --> 00:41:00,450
听众：可能是n的O。
AUDIENCE: It could be O of n.

841
00:41:00,449 --> 00:41:03,329
因为即使你
Because of the fact that even though you're

842
00:41:03,329 --> 00:41:06,569
本质上，使用malloc创建一个新节点
using malloc to create a new node, essentially,

843
00:41:06,570 --> 00:41:11,820
我认为分配计算机时，所有计算机的工作是[？去 -  ？]
I think all the computer's doing when you assign it is [? going-- ?]

844
00:41:11,820 --> 00:41:14,820
当您引用这些箭头时，就像我们要从一个箭头转到下一个箭头一样
as you cite those arrows, like we're going from one arrow to the next

845
00:41:14,820 --> 00:41:16,750
到下一个。
to the next to the next.

846
00:41:16,750 --> 00:41:19,259
而且我认为这将是n的O。
And I would think it would be O of n.

847
00:41:19,260 --> 00:41:21,300
DAVID MALAN：正如您所描述的，它是n的O。
DAVID MALAN: It is O of n as you described it.

848
00:41:21,300 --> 00:41:27,930
但是您也正在做一个假设，就像其他人中的25％所做的那样。
But you, too, are making an assumption, like 25% of other people are making.

849
00:41:27,929 --> 00:41:31,769
您似乎在假设，如果是一个新数字，假设它是数字4，
You seem to be assuming that if a new number, suppose it's number 4,

850
00:41:31,769 --> 00:41:33,239
必须走到最后。
has to go at the end.

851
00:41:33,239 --> 00:41:35,439
或者，如果它是数字5，则必须在末尾输入。
Or if it's the number 5, it has to go at the end.

852
00:41:35,440 --> 00:41:37,523
我故意用这种方式进行设置。
And I kind of deliberately set things up that way.

853
00:41:37,523 --> 00:41:41,310
我碰巧将它们按从左到右的顺序进行维护，即1、2、3。
I've happened to maintain them in sorted order, 1, 2, 3, from left to right.

854
00:41:41,309 --> 00:41:43,439
但是到现在为止，我还没有做出条件
But up until now, I have not made the condition

855
00:41:43,440 --> 00:41:45,700
甚至必须对链接列表进行排序
that the linked list has to be sorted, even

856
00:41:45,699 --> 00:41:48,449
尽管到目前为止我们看到的示例都是故意的。
though the examples we've seen thus far are deliberately that way.

857
00:41:48,449 --> 00:41:51,586
但是，您知道什么，如果您想花哨并且更有效率，
But you know what, if you want to get fancy and a little more efficient,

858
00:41:51,586 --> 00:41:54,419
并且您想分配数字4，坦率地说，您实际上并没有
and you want to allocate the number 4, and frankly, you don't really

859
00:41:54,420 --> 00:41:57,570
关心保持链表的排序顺序，
care about keeping the linked list in sorted order,

860
00:41:57,570 --> 00:42:00,930
好吧，哎呀，把它拉出来，把你的新节点放到这里。
well, heck, just pull this out, put your new node here.

861
00:42:00,929 --> 00:42:01,949
在这里插入。
Plug it in here.

862
00:42:01,949 --> 00:42:03,419
将另一个插回这里。
Plug the other one back in here.

863
00:42:03,420 --> 00:42:06,870
只需将新元素插入列表的开头即可。
And just insert the new element at the beginning of the list.

864
00:42:06,869 --> 00:42:10,109
对于此后的每个数字，请像以前一样分配malloc。
And for every number thereafter, malloc as before.

865
00:42:10,110 --> 00:42:13,292
但是只要继续将其插入此处，将其插入此处，将其插入此处即可。
But just keep inserting it here, inserting it here, inserting it here.

866
00:42:13,291 --> 00:42:14,999
现在，无需采取任何步骤。
Now it's not going to take a single step.

867
00:42:15,000 --> 00:42:17,189
因为当我口头表达出来时，就有了malloc步骤。
Because as I verbalized it, there's, like, the malloc step.

868
00:42:17,190 --> 00:42:18,180
我必须拔掉它。
I have to unplug this.

869
00:42:18,179 --> 00:42:19,289
我必须重新插入。
I have to plug it back in.

870
00:42:19,289 --> 00:42:21,719
因此，总共需要三到四个步骤。
So it's like three or four steps total.

871
00:42:21,719 --> 00:42:23,639
但是四个步骤也是不变的。
But four steps is also constant.

872
00:42:23,639 --> 00:42:26,529
这是1的大O，因为它的步数是固定的。
That's big O of 1, because it's a fixed number of steps.

873
00:42:26,530 --> 00:42:31,600
因此，如果您能够牺牲此列表的排序顺序，
So if you're able to sacrifice sorted order when it comes to this list,

874
00:42:31,599 --> 00:42:34,619
您可以在固定时间内插入，插入，插入，插入。
you can in constant time insert, insert, insert, insert.

875
00:42:34,619 --> 00:42:39,689
列表会越来越长，但是从一开始
And the list is going to get longer and longer, but from the beginning of it

876
00:42:39,690 --> 00:42:40,680
而不是终点。
rather than the end.

877
00:42:40,679 --> 00:42:41,927
因此，这始终是一个权衡。
So that's always a trade off.

878
00:42:41,927 --> 00:42:44,969
如果您不在乎排序顺序，并且您没有算法或代码
If you don't care about sorted order, and none of your algorithms or code

879
00:42:44,969 --> 00:42:49,259
要求将其排序，然后您就可以继续进行下去了
require that it be sorted, then you can go ahead and cut that corner

880
00:42:49,260 --> 00:42:51,600
并实现恒定时间插入，如果您
and achieve constant time insert, which if you're

881
00:42:51,599 --> 00:42:54,419
Twitter或Google之类的东西，也许实际上
a Twitter or Google or the like, maybe that's actually

882
00:42:54,420 --> 00:42:56,800
净储蓄和一件好事。
a net savings and a good thing.

883
00:42:56,800 --> 00:42:59,350
但是，在这种情况下，您又会牺牲排序顺序。
But, again, you sacrifice the sorted order in that case.

884
00:42:59,349 --> 00:43:00,599
好吧，我想，让我们继续吧。
Well, let's go ahead, I think.

885
00:43:00,599 --> 00:43:03,209
让我们将其翻译为一些实际的代码。
And let's translate this to some actual code.

886
00:43:03,210 --> 00:43:06,118
让我在CS50 IDE中继续。
Let me go ahead here in CS50 IDE.

887
00:43:06,117 --> 00:43:08,159
让我们继续写一些变体
And let's go ahead and write a couple of variants

888
00:43:08,159 --> 00:43:11,699
现在实际上用数字做某事的程序
of a program that now actually do something with numbers

889
00:43:11,699 --> 00:43:14,769
并开始操纵记忆中的事物。
and start to manipulate things in memory.

890
00:43:14,769 --> 00:43:17,909
因此，我将在这里继续创建一个名为list.c的程序。
So I'm going to go ahead here and create a program called list.c.

891
00:43:17,909 --> 00:43:20,159
我的第一个版本将非常简单。
And my first version is going to be very simplistic.

892
00:43:20,159 --> 00:43:22,445
我要继续，包括stdio。
I'm going to go ahead and include stdio.

893
00:43:22,445 --> 00:43:24,359
给自己一个int main（void）。
Give myself an int main(void).

894
00:43:24,360 --> 00:43:27,250
然后在这里，让我继续前进，就像我们开始的那样，
And then inside of here, let me go ahead, like we began,

895
00:43:27,250 --> 00:43:30,450
并给我自己一个大小为3的整数列表。
and give myself a list of integers of size 3.

896
00:43:30,449 --> 00:43:32,856
所以这将是一个大小为3的数组。
So this is going to be an array that's of size 3.

897
00:43:32,856 --> 00:43:35,189
这个大小为3的数组，我要继续努力
And this array of size 3, I'm going to go ahead and hard

898
00:43:35,190 --> 00:43:36,700
向其中编码一些新值。
code some new values into it.

899
00:43:36,699 --> 00:43:38,909
因此，在第一个位置，我将输入数字1。
So at the very first location, I'll put the number 1.

900
00:43:38,909 --> 00:43:41,579
在第二个位置，我将输入数字2。
At the second location, I will put the number 2.

901
00:43:41,579 --> 00:43:44,909
在第三个位置，我将输入数字3。
At the third location, I will put the number 3.

902
00:43:44,909 --> 00:43:48,599
然后，只是为了证明这是按我想的那样工作，
And then, just to demonstrate that this is working as I think I intend,

903
00:43:48,599 --> 00:43:49,989
我将快速进行循环。
I'm going to do a quick for loop.

904
00:43:49,989 --> 00:43:54,299
因此，对于int，我得到0，我小于3，我++。
So for int i get 0, i less than 3, i++.

905
00:43:54,300 --> 00:43:58,200
然后，在此循环中，我将继续打印％i。
And then, inside this loop, I'm going to go ahead and print out %i.

906
00:43:58,199 --> 00:44:01,529
然后我将打印出i的值。
And then I'm going to print out the value of i.

907
00:44:01,530 --> 00:44:04,770
现在，我已经在循环中打印了所有这些值，让
So now that I've printed out all of these values in my loop, let

908
00:44:04,769 --> 00:44:08,229
我继续做清单。
me go ahead and do make list.

909
00:44:08,230 --> 00:44:12,060
然后让我继续执行./list，然后按Enter。
Let me go ahead then and do ./list and hit Enter.

910
00:44:12,059 --> 00:44:15,749
确实，我得到了-哎呀，不是我想要的。
And indeed, I get-- oops, not what I wanted.

911
00:44:15,750 --> 00:44:18,899
诚然，这么好的可教的时刻，不是故意的。
So good teachable moment, not intended, admittedly.

912
00:44:18,900 --> 00:44:21,305
但是我在这里做错了什么？
But what have I done wrong here?

913
00:44:21,304 --> 00:44:22,679
我的目标是我们打印出列表。
My goal is we print out the list.

914
00:44:22,679 --> 00:44:24,389
但是不知何故，我打印了0、1、2。
But somehow, I printed out 0, 1, 2.

915
00:44:24,389 --> 00:44:27,569
这些确实不是此列表中的数字。
And those are indeed not the numbers in this list.

916
00:44:27,570 --> 00:44:28,600
[？格雷格？ ？]
[? Greg? ?]

917
00:44:28,599 --> 00:44:30,329
听众：所以你印了i。
AUDIENCE: So you printed i.

918
00:44:30,329 --> 00:44:32,171
您应该已经打印了i的列表。
You should have printed list of i.

919
00:44:32,172 --> 00:44:32,880
戴维·马兰：是的。
DAVID MALAN: Yes.

920
00:44:32,880 --> 00:44:35,755
因此，我应该已经打印了数组的内容，即list [i]。
So I should have printed the contents of the array, which is list[i].

921
00:44:35,755 --> 00:44:38,430
所以这只是我在这里的新手错误。
So that was just a newbie mistake by me here.

922
00:44:38,429 --> 00:44:39,399
因此，让我修复该问题。
So let me fix that.

923
00:44:39,400 --> 00:44:42,927
让我继续重新编译make list，。/ list。和voila。
Let me go ahead and recompile make list, ./list., and voila.

924
00:44:42,927 --> 00:44:44,010
我现在已经打印了列表。
I've now printed the list.

925
00:44:44,010 --> 00:44:48,600
所以这是第2周的东西，当我们在第2周首次引入阵列时。
So this is sort of Week 2 stuff, when we first introduced arrays in Week 2.

926
00:44:48,599 --> 00:44:51,659
但是，现在让我继续前进，现在过渡到更具活力的事物。
But now let me go ahead and transition now to something more dynamic.

927
00:44:51,659 --> 00:44:56,189
在我不必提前承诺创建数组的情况下，
Where I don't have to commit in advance to creating an array,

928
00:44:56,190 --> 00:44:59,080
我可以使用动态分配的内存块来完成此操作。
I can do this with a dynamically allocated chunk of memory.

929
00:44:59,079 --> 00:45:01,349
因此，让我删除在main内部完成的所有操作。
So let me delete everything I've done inside of main.

930
00:45:01,349 --> 00:45:03,057
让我继续，给我自己。
And let me go ahead and give myself this.

931
00:45:03,057 --> 00:45:06,179
让我继续声明值列表
Let me go ahead and declare a list of values

932
00:45:06,179 --> 00:45:09,599
现在，列表将成为按照star运算符的地址。
where list is now going to be an address as per the star operator.

933
00:45:09,599 --> 00:45:11,529
我将继续进行malloc-
And I'm going to go ahead and malloc--

934
00:45:11,530 --> 00:45:12,030
让我们来看看。
let's see.

935
00:45:12,030 --> 00:45:14,270
我想要三个整数的空间。
I want space for three integers.

936
00:45:14,269 --> 00:45:17,369
所以最简单的方法，如果我要保持简单，
So the simplest way to do this, if I'm just going to keep it simple,

937
00:45:17,369 --> 00:45:21,629
我实际上可以做到这一点，是int大小的3倍。
I can actually do this, 3 times size of int.

938
00:45:21,630 --> 00:45:26,040
所以我程序的这个版本本身不会使用数组。
So this version of my program isn't going to use an array per se.

939
00:45:26,039 --> 00:45:27,419
它将使用malloc。
It's going to use malloc.

940
00:45:27,420 --> 00:45:30,660
但是它将为我动态分配该数组。
But it's going to dynamically allocate that array for me.

941
00:45:30,659 --> 00:45:32,639
我们将看到它的语法是什么。
And we'll see what the syntax for this is.

942
00:45:32,639 --> 00:45:35,099
和现在一样，无论何时您使用malloc，
As always now, any time you use malloc, I

943
00:45:35,099 --> 00:45:39,097
应该检查list equals是否等于null。
should check whether list equals equals null.

944
00:45:39,097 --> 00:45:40,139
如果是这样，您知道吗？
And if so, you know what?

945
00:45:40,139 --> 00:45:41,489
我要返回1。
I'm just going to return 1.

946
00:45:41,489 --> 00:45:44,249
回想一下，您可以返回0或1或其他一些值
Recall that you can return 0 or 1 or some other value

947
00:45:44,250 --> 00:45:46,229
从主要到有效地退出您的程序。
from main to effectively quit your program.

948
00:45:46,230 --> 00:45:49,170
我要继续，如果list为null，则只返回1，
I'm going to go ahead and just return 1 if list is null,

949
00:45:49,170 --> 00:45:52,260
只是假设某件事非常严重地出了错，例如我内存不足
just assuming that something very badly went wrong, like I'm out of memory

950
00:45:52,260 --> 00:45:53,430
共。
altogether.

951
00:45:53,429 --> 00:45:59,189
但是现在我有了这块内存，大小是原来的3倍
But now that I have this chunk of memory that's of size 3 times

952
00:45:59,190 --> 00:46:05,030
一个int的大小，这实际上是给自己一个数组的malloc方法。
the size of an int, this is actually the malloc way to give yourself an array.

953
00:46:05,030 --> 00:46:07,530
到现在为止，每次我们为自己创建数组时，
Up until now, every time we've created arrays for ourselves,

954
00:46:07,530 --> 00:46:09,030
我们使用方括号表示法。
we've used square bracket notation.

955
00:46:09,030 --> 00:46:11,700
你们都在方括号内放了一个数字
And you all have put a number inside the square brackets

956
00:46:11,699 --> 00:46:13,769
给自己一个这样大小的数组。
to give yourself an array of that size.

957
00:46:13,769 --> 00:46:15,989
但坦率地说，如果我们拥有malloc和
But frankly, if we have malloc and the ability

958
00:46:15,989 --> 00:46:18,479
只是问电脑内存，
to just ask the computer for memory, well,

959
00:46:18,480 --> 00:46:21,450
如果我想存储三个整数，为什么不问malloc
if I want to store three integers, why don't I ask malloc

960
00:46:21,449 --> 00:46:23,939
整数大小的三倍？
for three times the size of an integer?

961
00:46:23,940 --> 00:46:25,710
而malloc的工作原理是
And the way malloc works is it's actually

962
00:46:25,710 --> 00:46:29,580
会返回给我这么大的连续内存，
going to return to me a contiguous chunk of memory of that size,

963
00:46:29,579 --> 00:46:31,409
从而使很多字节背靠背。
so that many bytes back to back to back.

964
00:46:31,409 --> 00:46:36,479
这是我们将在短时间内使用的一种技术
And that's a technique that we'll use in just a moment

965
00:46:36,480 --> 00:46:38,130
分配实际节点时。
when allocating actual nodes.

966
00:46:38,130 --> 00:46:41,730
因此，在故事的这一点上，只要list不等于null，
So at this point in the story, so long as list does not equal null,

967
00:46:41,730 --> 00:46:46,470
现在，我的内存块足够大，可以容纳三个int的大小。
I now have a chunk of memory that's big enough to fit the size of three ints.

968
00:46:46,469 --> 00:46:48,959
和以前一样，我可以继续进行初始化。
And as before, I can go ahead and initialize those.

969
00:46:48,960 --> 00:46:50,370
第一个元素将是1。
The first element will be 1.

970
00:46:50,369 --> 00:46:51,959
第二个元素是2。
The second element will be 2.

971
00:46:51,960 --> 00:46:54,090
第三个元素是3。
The third element will be 3.

972
00:46:54,090 --> 00:46:58,290
并注意现在使用数组之间的等效性
And notice the sort of equivalence now between using arrays

973
00:46:58,289 --> 00:46:59,729
并使用指针。
and using pointers.

974
00:46:59,730 --> 00:47:02,520
C以这种方式具有多种用途，如果您
C is kind of versatile in this way and that if you

975
00:47:02,519 --> 00:47:07,019
malloc有一块内存返回给您，您可以在每个星期内，
have a chunk of memory returned to you by malloc, you can, per last week,

976
00:47:07,019 --> 00:47:09,029
使用方括号表示法。
use square bracket notation.

977
00:47:09,030 --> 00:47:12,532
您可以使用方括号表示法并将该内存块视为一个数组。
You can use square bracket notation and treat that chunk of memory as an array.

978
00:47:12,532 --> 00:47:13,990
因为毕竟是什么数组？
Because after all, what's an array?

979
00:47:13,989 --> 00:47:18,359
这是一个连续的内存块，而这正是malloc返回的内容。
It's a contiguous block of memory and that is exactly what malloc returns.

980
00:47:18,360 --> 00:47:22,980
如果您想花哨的话，实际上可以说去那个地址
If you want to be fancy instead, you could actually say go to that address

981
00:47:22,980 --> 00:47:24,360
并把数字1放在那里。
and put the number 1 there.

982
00:47:24,360 --> 00:47:28,170
您可以说去那个地址加1，然后把下一个数字放在那里。
You could say go to that address plus 1 and put the next number there.

983
00:47:28,170 --> 00:47:33,730
您可以说去那个地址加2，然后把第三个数字放在那里。
You could say go to that address plus 2 and put the third number there.

984
00:47:33,730 --> 00:47:36,750
但老实说，这至少很快变得难以理解
But honestly, this just very quickly becomes unreadable, at least

985
00:47:36,750 --> 00:47:37,380
对大多数人来说。
to most people.

986
00:47:37,380 --> 00:47:39,510
这就是所谓的指针算术，
This is that thing called pointer arithmetic,

987
00:47:39,510 --> 00:47:41,580
你在用指针做算术，
you're doing arithmetic with pointers, that

988
00:47:41,579 --> 00:47:45,899
等同于使用我们已经使用了一段时间的语法，即
is equivalent to using the syntax that we've used for a while now, which

989
00:47:45,900 --> 00:47:47,528
是只使用方括号。
is to just use the square brackets.

990
00:47:47,527 --> 00:47:49,319
而方括号的好处是
And the nice thing about square brackets is

991
00:47:49,320 --> 00:47:51,810
电脑会为您找到
that the computer will figure out for you

992
00:47:51,809 --> 00:47:56,789
这些整数中的每一个相距多远，因为它知道int的大小。
how far apart each of those integers are because it knows the size of an int.

993
00:47:56,789 --> 00:47:59,119
但是现在，在故事的这一点上，
But now, at this point in the story, things

994
00:47:59,119 --> 00:48:01,309
变得有趣又烦人。
get interesting and also annoying.

995
00:48:01,309 --> 00:48:04,159
回想一下，圣地亚哥是帮助我们更早解决这一问题的国家。
And Santiago, recall, was the one that helped us solve this earlier.

996
00:48:04,159 --> 00:48:06,019
假设我没有提前计划。
Suppose I didn't plan ahead.

997
00:48:06,019 --> 00:48:10,589
我只在第五行分配了三个整数。
I only allocated three integers on line five there.

998
00:48:10,590 --> 00:48:12,800
但是现在，在第13行，我该死。
But now, at line 13, I'm, like, oh, dammit.

999
00:48:12,800 --> 00:48:15,240
现在，我想在列表中添加第四个整数。
Now I want to add a fourth integer to the list.

1000
00:48:15,239 --> 00:48:17,209
我显然可以重做所有代码。
I could obviously just redo all the code.

1001
00:48:17,210 --> 00:48:19,520
但是，假设这里的故事的一部分是继续
But suppose that part of the story here is to go ahead

1002
00:48:19,519 --> 00:48:21,919
并动态分配更多内存。
and dynamically allocate more memory.

1003
00:48:21,920 --> 00:48:23,222
好吧，我该怎么做？
Well, how can I do this?

1004
00:48:23,222 --> 00:48:26,180
好吧，让我继续并临时分配另一块内存。
Well, let me go ahead and allocate another chunk of memory temporarily.

1005
00:48:26,179 --> 00:48:28,159
因此，按照惯例，我将其称为temp。
So I'll call it temp, by convention.

1006
00:48:28,159 --> 00:48:31,549
这次我将继续分配4倍int的大小。
And this time I'm going to go ahead and allocate 4 times size of int.

1007
00:48:31,550 --> 00:48:34,130
因为，为了这个故事，我又搞砸了
Because, again, for the sake of the story, I messed up

1008
00:48:34,130 --> 00:48:37,523
我现在想为该原件分配足够的空间-
and I want to allocate enough space now for that original--

1009
00:48:37,523 --> 00:48:38,690
我还没搞砸。
I haven't so much messed up.

1010
00:48:38,690 --> 00:48:42,050
现在，我决定要向该数组添加第四个数字。
I have now decided that I want to add a fourth number to this array.

1011
00:48:42,050 --> 00:48:46,057
和往常一样，我应该检查temp equals是否等于null。
As always, I should check if temp equals equals null.

1012
00:48:46,056 --> 00:48:46,639
你知道吗？
You know what?

1013
00:48:46,639 --> 00:48:49,429
我将继续释放已经分配的内存。
I'm going to go ahead and free the memory I already allocated.

1014
00:48:49,429 --> 00:48:51,229
然后我要离开这里，返回1。
And then I'm just going to get out of here, return 1.

1015
00:48:51,230 --> 00:48:52,020
出了些问题。
Something went wrong.

1016
00:48:52,019 --> 00:48:53,311
没有什么可证明的。
There's nothing to demonstrate.

1017
00:48:53,311 --> 00:48:56,299
因此，我将完全退出主要领域。
So I'm going to exit out of main entirely.

1018
00:48:56,300 --> 00:49:00,718
但是，如果malloc没有返回null，并且一切都很好，那我该怎么办？
But if malloc did not return null, and all is well, what am I going to do?

1019
00:49:00,717 --> 00:49:02,509
好吧，让我们先做圣地亚哥的建议
Well, let's first do what Santiago proposed

1020
00:49:02,510 --> 00:49:05,000
当我们第一次开始这个对话时。
when we first began this conversation.

1021
00:49:05,000 --> 00:49:11,540
对于int我得到0，我小于3，我++，让我们继续复制到这个新的，
For int i get 0, i less than 3, i++, let's go ahead and copy into this new,

1022
00:49:11,539 --> 00:49:15,659
临时内存块，无论原始内存块是什么。
temporary chunk of memory whatever is at the original chunk of memory.

1023
00:49:15,659 --> 00:49:17,899
因此，当圣地亚哥提议我们复制1、2
So when Santiago proposed that we copy 1, 2,

1024
00:49:17,900 --> 00:49:20,960
3从旧阵列到新阵列，这里是
3 from the old array into the new array, here's

1025
00:49:20,960 --> 00:49:25,370
第2周，我们如何使用简单的for循环在代码中做到这一点？
how we might do that in code just using a simple for loop, a la Week 2.

1026
00:49:25,369 --> 00:49:30,889
然后让我现在继续添加一个值tmp [3]，
And then let me go ahead now and add one more value, tmp[3],

1027
00:49:30,889 --> 00:49:33,619
如果您从0开始，则是第四个位置。
which is the fourth location if you're starting from 0.

1028
00:49:33,619 --> 00:49:36,529
我要继续把4放在那里。
I'm going to go ahead and put the number 4 there.

1029
00:49:36,530 --> 00:49:39,440
现在，在这一点上，我要继续记住
And now, at this point, I'm going to go ahead and remember

1030
00:49:39,440 --> 00:49:43,513
tmp是我的新列表。
the fact that tmp is my new list.

1031
00:49:43,512 --> 00:49:45,679
因此，我将继续释放原始列表。
So I'm going to go ahead and free the original list.

1032
00:49:45,679 --> 00:49:49,579
我将更新旧列表以指向新列表。
And I'm going to update my old list to point at the new list.

1033
00:49:49,579 --> 00:49:53,479
最后，我要继续使用另一个for循环
And then lastly, I'm going to go ahead and use another for loop just

1034
00:49:53,480 --> 00:49:57,920
证明我认为我正确地做到了，这次最多重复4次
to demonstrate that I think I did this correctly, this time iterating up to 4

1035
00:49:57,920 --> 00:49:59,120
而不是3。
instead of 3.

1036
00:49:59,119 --> 00:50:04,279
我将继续打印并打印出list [i]的内容。
I'm going to go ahead and print out with i the contents of list[i].

1037
00:50:04,280 --> 00:50:06,320
因此，让我们快速倒带。
So let's rewind real quick.

1038
00:50:06,320 --> 00:50:12,350
我们从分配三个整数数组开始了这个故事。
We began the story by allocating an array of three integers.

1039
00:50:12,349 --> 00:50:15,816
但是我们这次是动态进行的，以证明malloc只是
But we did it this time dynamically to demonstrate that malloc just

1040
00:50:15,817 --> 00:50:16,900
返回一块内存。
returns a chunk of memory.

1041
00:50:16,900 --> 00:50:20,510
而且，如果您要将那部分内存视为一个数组，则绝对可以。
And if you want to treat that chunk of memory as an array, you absolutely can.

1042
00:50:20,510 --> 00:50:22,477
这里的东西，如果list等于等于null，
This stuff here, if list equals equals null,

1043
00:50:22,476 --> 00:50:25,309
这只是错误检查，只是为了确保没有出错。
it's just error checking, just to make sure that nothing went wrong.

1044
00:50:25,309 --> 00:50:27,169
有趣的代码在这里恢复。
The interesting code resumes here.

1045
00:50:27,170 --> 00:50:31,640
我将数字1、2和3分别放在位置0、1和2
I'm putting the numbers 1, 2, and 3 at location 0, 1, and 2 respectively

1046
00:50:31,639 --> 00:50:34,789
在那块内存中，我再次将其视为数组。
in that chunk of memory which, again, I'm treating like an array.

1047
00:50:34,789 --> 00:50:38,179
但现在在故事的这一点上，我已规定，请稍等，
But now at this point in the story, I've stipulated that, wait a minute,

1048
00:50:38,179 --> 00:50:39,949
我想继续并添加第四个值。
I want to go ahead and add a fourth value.

1049
00:50:39,949 --> 00:50:40,919
我怎样才能做到这一点？
How can I do that?

1050
00:50:40,920 --> 00:50:43,790
让我们指定我想返回并更改现有程序。
And let's stipulate that I want to go back and change the existing program.

1051
00:50:43,789 --> 00:50:45,789
因为假设出于讨论目的，
Because suppose that for the sake of discussion,

1052
00:50:45,789 --> 00:50:48,499
这是一段时间以来在Google或Twitter上运行的代码
this is code that's running at Google or Twitter over time

1053
00:50:48,500 --> 00:50:52,169
只有在收到另一条推文之后，他们的代码才能意识到，
and it's only after receiving another tweet that their code realizes,

1054
00:50:52,170 --> 00:50:53,730
哦，我们需要更多空间。
oh, we need more space.

1055
00:50:53,730 --> 00:50:54,890
那我该怎么办呢？
So how do I do this here?

1056
00:50:54,889 --> 00:50:59,689
在第15行，这次我为四个整数分配了足够的空间。
On line 15, this time I allocate enough space for four integers.

1057
00:50:59,690 --> 00:51:01,910
然后，我再次进行一些错误检查。
And I, again, do some error checking.

1058
00:51:01,909 --> 00:51:04,819
如果tmp等于null，则发生了一些不好的事情。
If tmp equals null, then something bad happened.

1059
00:51:04,820 --> 00:51:07,010
让我们一起退出吧。
Let's just exit all together.

1060
00:51:07,010 --> 00:51:09,620
但是，如果没有发生任何不好的情况，让我们接受圣地亚哥的建议
But if nothing bad happened, let's take Santiago's suggestion

1061
00:51:09,619 --> 00:51:14,959
并将他的英语建议翻译成C。让我们使用一个从0到3的for循环
and translate his English advice into C. Let's use a for loop from 0 to 3

1062
00:51:14,960 --> 00:51:17,480
并复制到此新的临时内存块中
and copy into this new temporary chunk of memory

1063
00:51:17,480 --> 00:51:20,190
原始内存块的内容。
the contents of the original chunk of memory.

1064
00:51:20,190 --> 00:51:22,160
所以tmp [i] = list [i]。
So tmp[i] = list[i].

1065
00:51:22,159 --> 00:51:24,529
然后在这里，这就是本练习的重点，
And then here, which was the point of this exercise,

1066
00:51:24,530 --> 00:51:29,870
让我在tmp [3]处添加我的第四个数字，如果您在第四个位置，
let me add my fourth number at tmp[3], which is the fourth location if you

1067
00:51:29,869 --> 00:51:31,369
从0开始计数。
start counting from 0.

1068
00:51:31,369 --> 00:51:34,279
但是在故事的这一点上，就像我之前的幻灯片一样，
But at this point in the story, much like my earlier slide,

1069
00:51:34,280 --> 00:51:38,000
我同时拥有大小为3的数组中的1、2、3，
I have both the 1, 2, 3 in an array of size 3,

1070
00:51:38,000 --> 00:51:41,689
我在大小为4的数组中有1，2，3个重复项。
and I have 1, 2, 3 duplicated in the array of size 4.

1071
00:51:41,690 --> 00:51:45,230
让我继续并释放原始列表并退还给计算机
Let me go ahead and free the original list and give back to the computer

1072
00:51:45,230 --> 00:51:46,820
原始的内存块。
that original chunk of memory.

1073
00:51:46,820 --> 00:51:49,340
然后让我记住，用我更好的名字
Let me then remember, using my better names

1074
00:51:49,340 --> 00:51:52,730
变量，这个新的内存块的地址是什么。
variable, what the address of this new chunk of memory is.

1075
00:51:52,730 --> 00:51:55,010
然后，为了炫耀，让我继续前进，
And then, just to show off, let me go ahead,

1076
00:51:55,010 --> 00:51:58,430
加上另一个for循环，这次计数了四次，而不是三遍，
and with another for loop, this time counting four times, not three,

1077
00:51:58,429 --> 00:52:00,719
让我打印出所有这些值。
let me print out all of those values.

1078
00:52:00,719 --> 00:52:04,199
现在，在这里我将尽力而为，编译我的新程序。
Now here's where I'll cross my fingers, compile my new program.

1079
00:52:04,199 --> 00:52:05,899
它不能编译确定。
It does not compile OK.

1080
00:52:05,900 --> 00:52:09,150
因为看起来我那里有太多括号。
Because it looks like I have one too many parentheses there.

1081
00:52:09,150 --> 00:52:11,840
因此，让我们用make list重新编译程序-
So let's recompile the program with make list--

1082
00:52:11,840 --> 00:52:13,440
另一个错误。
another error.

1083
00:52:13,440 --> 00:52:14,810
所以让我向上滚动。
So let me scroll up there.

1084
00:52:14,809 --> 00:52:22,039
哦，很有趣，所以这是一个常见错误，隐式声明了库
And oh, interesting, so this is a common mistake, implicitly declaring library

1085
00:52:22,039 --> 00:52:24,169
函数malloc一些东西。
function malloc something something.

1086
00:52:24,170 --> 00:52:27,140
因此，每当您收到隐式声明的错误时，
So any time you get an implicitly declaring error,

1087
00:52:27,139 --> 00:52:31,009
很有可能这意味着您只是做了一些简单的事情，
odds are it means you just did something simple like this,

1088
00:52:31,010 --> 00:52:35,150
您忘记了在其中定义该功能的必需头文件。
you forgot the requisite header file in which that function is defined.

1089
00:52:35,150 --> 00:52:39,120
确实，回想一下上周，malloc是免费的，位于标准库中。
And indeed, recall from last week, malloc is in standard lib, as is free.

1090
00:52:39,119 --> 00:52:40,219
现在，让我们做一个清单。
So now let's do make list.

1091
00:52:40,219 --> 00:52:42,209
再次交叉手指。
Cross my fingers again.

1092
00:52:42,210 --> 00:52:42,710
ew
Phew.

1093
00:52:42,710 --> 00:52:43,880
那个时候它起作用了。
That time it worked.

1094
00:52:43,880 --> 00:52:47,360
./list，瞧，1，2，3，4。
./list, voila, 1, 2, 3, 4.

1095
00:52:47,360 --> 00:52:50,480
所以现在这是一个完全字面的翻译
So this is now a completely literal translation

1096
00:52:50,480 --> 00:52:53,990
所有这些代码都放入一个工作程序中
of all of that code into a working program

1097
00:52:53,989 --> 00:52:58,869
再一次，它使用大小为3的数组开始，
that, again, starts off by using an array of size 3,

1098
00:52:58,869 --> 00:53:01,269
动态分配了它。
having dynamically allocated it.

1099
00:53:01,269 --> 00:53:05,199
然后通过创建尺寸为4的新尺寸来调整尺寸，将旧尺寸复制为新尺寸，
And then it resizes it by creating a new one of size 4, copying old into new,

1100
00:53:05,199 --> 00:53:08,169
释放旧的，然后像以前一样继续进行。
freeing the old, and then proceeding as before.

1101
00:53:08,170 --> 00:53:11,240
而且我在这里故意两次都使用了malloc，如下所示。
And I've deliberately used malloc both times here as follows.

1102
00:53:11,239 --> 00:53:14,349
如果您使用方括号表示法在C中创建数组，
If you create an array in C using square bracket notation,

1103
00:53:14,349 --> 00:53:16,209
你已经把自己画在一个角落。
you have painted yourself into a corner.

1104
00:53:16,210 --> 00:53:19,210
您不能使用我们已经看到的任何代码行
You can't use any lines of code that we have seen

1105
00:53:19,210 --> 00:53:22,770
并调整使用方括号声明的数组的大小。
and resize an array that you have declared using square brackets.

1106
00:53:22,769 --> 00:53:25,269
从技术上来讲，当您使用方括号时，
More technically speaking, when you use the square brackets,

1107
00:53:25,269 --> 00:53:28,959
您是在堆栈上静态分配数组。
you are statically allocating the array on the stack.

1108
00:53:28,960 --> 00:53:31,750
您将其放入计算机内存的框架中
You're putting it into the frame of the computer's memory

1109
00:53:31,750 --> 00:53:37,929
根据该图，属于该计算机，属于该功能的堆栈框架
that belongs to that computer, to that function's stack frame, per the diagram

1110
00:53:37,929 --> 00:53:38,949
上个星期。
last week.

1111
00:53:38,949 --> 00:53:44,169
但是，如果您使用上周推出的新工具malloc，
If, however, you use malloc, our new tool from last week,

1112
00:53:44,170 --> 00:53:47,170
并说给我一块内存，它来自堆。
and say give me a chunk of memory, that comes from the heap.

1113
00:53:47,170 --> 00:53:49,420
而且您可以调整大小。
And that you can resize.

1114
00:53:49,420 --> 00:53:52,520
这样您就可以回馈并承担更多的往返费用。
That you can give back and take more of and back and forth.

1115
00:53:52,519 --> 00:53:57,049
实际上，相对而言，还有一种更简单的方法可以做到这一点。
And in fact, there's even a more simple way of doing this, relatively speaking.

1116
00:53:57,050 --> 00:54:02,140
如果您想通过重新调整数组大小来重新分配数组，则是一个大块的内存，
If you want to reallocate an array, a chunk of memory, by resizing it,

1117
00:54:02,139 --> 00:54:04,569
您不必做所有我以前做过的事情。
you don't have to do all of this, which I did before.

1118
00:54:04,570 --> 00:54:06,460
您不必两次使用malloc。
You don't have to use malloc twice.

1119
00:54:06,460 --> 00:54:08,710
您一开始可以使用malloc。
You can use malloc once at the beginning.

1120
00:54:08,710 --> 00:54:10,780
然后，您可以使用一个新功能
And then, you can use a new function that's

1121
00:54:10,780 --> 00:54:13,930
在这种情况下，实际上有点帮助，称为realloc。
actually kind of helpful in this case, called realloc.

1122
00:54:13,929 --> 00:54:19,729
您实际上可以执行此操作，将一块大小为4的内存重新分配
And you can actually do this, realloc a chunk of memory of size 4 times

1123
00:54:19,730 --> 00:54:20,500
int的大小。
size of int.

1124
00:54:20,500 --> 00:54:24,790
但具体来说，重新分配称为list的东西。
But specifically, reallocate the thing called list.

1125
00:54:24,789 --> 00:54:27,249
因此，realloc与malloc非常相似。
So realloc is very similar to malloc.

1126
00:54:27,250 --> 00:54:28,790
但这需要两个论点。
But it takes two arguments.

1127
00:54:28,789 --> 00:54:32,139
一个是您想要的内存大小，无论是更大还是更小。
One is the size of the memory you want, whether bigger or smaller.

1128
00:54:32,139 --> 00:54:33,669
但这需要第二个论点。
But it takes a second argument.

1129
00:54:33,670 --> 00:54:38,170
现在，它的第一个参数是一块内存的地址
Its very first argument now is the address of a chunk of memory

1130
00:54:38,170 --> 00:54:41,800
与malloc一样，您已经分配了。
that you have already allocated, as with malloc.

1131
00:54:41,800 --> 00:54:43,660
因此，同样，在同一程序的顶部，
So, again, at the top of the same program,

1132
00:54:43,659 --> 00:54:48,949
回想一下，我使用malloc给自己一个指向大块内存的列表
recall that I used malloc to give myself a list that points at a chunk of memory

1133
00:54:48,949 --> 00:54:50,379
足以容纳三个整数。
big enough for three integers.

1134
00:54:50,380 --> 00:54:55,030
在第16行，我现在将该地址交还给我重新分配，说，等一下，
On line 16, I'm now handing that address back to realloc, saying, wait a minute,

1135
00:54:55,030 --> 00:54:56,800
这是你给我的那个地址。
here is that same address you gave me.

1136
00:54:56,800 --> 00:55:01,090
现在，请调整大小，将其重新分配为大小4。
Please now resize it, reallocate it to be of size 4.

1137
00:55:01,090 --> 00:55:03,760
该功能的作用是，如果一切顺利，
And what the function does is, if all goes well,

1138
00:55:03,760 --> 00:55:10,300
它返回到内存中已经足够大的地址。
it returns to the address in memory that it is now of sufficient size.

1139
00:55:10,300 --> 00:55:13,030
否则，如果发生任何不良情况，则返回null。
Otherwise, it returns null if anything bad happened.

1140
00:55:13,030 --> 00:55:14,570
因此，我将不理会该代码。
So I'll leave that code alone.

1141
00:55:14,570 --> 00:55:16,870
但是，我不必再这样做了。
But what I don't have to do anymore is this.

1142
00:55:16,869 --> 00:55:20,849
Realloc实际上为您复制了旧的到新的。
Realloc actually copies the old into the new for you.

1143
00:55:20,849 --> 00:55:23,739
因此，再次回到今天开始的圣地亚哥的故事，
So, again, coming back to Santiago's story at the beginning of today,

1144
00:55:23,739 --> 00:55:26,259
重新分配不仅会给您更大的块
realloc will not only give you a bigger chunk

1145
00:55:26,260 --> 00:55:29,740
内存（如果您需要的话），方法是将内存的地址交还给您
of memory, if you ask for it, by handing back the address of the memory you

1146
00:55:29,739 --> 00:55:31,149
已经要求。
already requested.

1147
00:55:31,150 --> 00:55:35,020
这将使您获得新的内存块的地址
And it's going to hand you back the address of a new chunk of memory

1148
00:55:35,019 --> 00:55:37,809
足以容纳所有这些新价值。
that is big enough to fit all of those new values.

1149
00:55:37,809 --> 00:55:39,129
而且它也很聪明。
And it's smart, too.

1150
00:55:39,130 --> 00:55:42,880
如果恰好在现有内存块的末尾有空间，
If there happens to be room at the very end of the existing chunk of memory,

1151
00:55:42,880 --> 00:55:45,397
就像我们早些时候在幻灯片上看到的那样，世界没有你好
there's no hello, world, like we saw on my slide earlier,

1152
00:55:45,396 --> 00:55:47,979
那么您实际上将获得完全相同的地址。
then you're actually going to get back the exact same address.

1153
00:55:47,980 --> 00:55:51,100
但是计算机的操作系统是Windows，Mac，OS或Linux，
But the computer's operating system, Windows, Mac, OS, or Linux,

1154
00:55:51,099 --> 00:55:54,159
会记得，好吧，是的，我知道我原来给了你三个字节。
is going to remember, OK, yes, I know I gave you three bytes originally.

1155
00:55:54,159 --> 00:55:56,719
那块内存的末尾恰好有空间。
There happened to be room at the end of that chunk of memory.

1156
00:55:56,719 --> 00:56:00,039
所以现在我要记住，那个相同的地址有
So now I'm going to remember, instead, that that same address has

1157
00:56:00,039 --> 00:56:03,229
可以容纳四个整数或您传入的任何数字的空间。
room for four integers, or whatever number you pass in.

1158
00:56:03,230 --> 00:56:06,070
因此，再次，您不必费心复制自己。
So, again, you don't have to bother copying yourself.

1159
00:56:06,070 --> 00:56:10,880
您可以让计算机实际为您进行重新分配。
You can let the computer actually do the reallocation for you.

1160
00:56:10,880 --> 00:56:18,345
任何问题，然后是关于malloc，关于realloc，关于free或从根本上来说，
Any questions, then on malloc, on realloc, on free, or fundamentally,

1161
00:56:18,344 --> 00:56:22,299
在链表上？
on linked lists?

1162
00:56:22,300 --> 00:56:24,040
请注意，这还不是一个列表。
Notice that this isn't yet a list.

1163
00:56:24,039 --> 00:56:25,779
这仍然是一个数组。
This is still an array.

1164
00:56:25,780 --> 00:56:28,628
因此，我们仍然需要将该程序再进一步一点
So we still need to take this program one step further

1165
00:56:28,628 --> 00:56:30,670
并实际上从这块内存过渡
and actually transition from this chunk of memory

1166
00:56:30,670 --> 00:56:34,120
对这些实际节点使用数组。
using arrays to these actual nodes.

1167
00:56:34,119 --> 00:56:37,309
但是在我们这样做之前，有什么疑问或困惑吗？
But before we do that, any questions or confusion?

1168
00:56:37,309 --> 00:56:37,809
布莱恩：是的。
BRIAN: Yeah.

1169
00:56:37,809 --> 00:56:41,774
出现了一个问题，为什么您不需要在程序结束时释放tmp？
A question came in, why do you not need to free tmp at the end of the program?

1170
00:56:41,775 --> 00:56:44,650
戴维·马兰（DAVID MALAN）：为什么在程序结束时不需要释放tmp？
DAVID MALAN: Why do I not need to free tmp at the end of the program?

1171
00:56:44,650 --> 00:56:48,610
因为我是个白痴，对关键的重要细节一无所知。
Because I'm an idiot and glossed over that key, important detail.

1172
00:56:48,610 --> 00:56:52,200
在这种情况下，您绝对不应该释放tmp而不是列表。
You absolutely should free not tmp in this case, but list.

1173
00:56:52,199 --> 00:56:58,899
因此，在这里的这一行27，我使用了我的list变量，它的名字比较好，
So at this line here, 27, I use my list variable, which just has a better name,

1174
00:56:58,900 --> 00:57:03,520
我将其设置为等于tmp，以便可以将其称为更大的列表。
and I make it equal to tmp so that I can just refer to it as a bigger list.

1175
00:57:03,519 --> 00:57:04,629
但是你说的很对。
But you are quite right.

1176
00:57:04,630 --> 00:57:06,400
那是我的疏忽。
That was an oversight on my part.

1177
00:57:06,400 --> 00:57:07,900
Valgrind不会喜欢的。
Valgrind would not have liked that.

1178
00:57:07,900 --> 00:57:12,850
在该程序结束时，我应该绝对自由列出。
At the very end of this program, I should absolutely free list.

1179
00:57:12,849 --> 00:57:15,789
但是，我本身不需要免费的tmp，
However, I don't need to free tmp, per se,

1180
00:57:15,789 --> 00:57:20,449
因为我只是通过该分配重用了变量名。
because I've simply reused the variable name through that assignment.

1181
00:57:20,449 --> 00:57:22,729
好问题，好捕获。
Good question and good catch.

1182
00:57:22,730 --> 00:57:24,370
意想不到的。
Unintended.

1183
00:57:24,369 --> 00:57:26,194
其他问题或意见，布莱恩？
Other questions or comments, Brian?

1184
00:57:26,195 --> 00:57:28,570
BRIAN：问题来了，为什么链表会改善
BRIAN: Question came in, why does the linked list improve

1185
00:57:28,570 --> 00:57:32,050
这种情况下，如果我们只能使用数组并重新分配和malloc做
this situation if we can just use arrays and realloc and malloc to do

1186
00:57:32,050 --> 00:57:32,900
所有这些东西？
all this stuff?

1187
00:57:32,900 --> 00:57:33,230
戴维·马兰：是的。
DAVID MALAN: Yeah.

1188
00:57:33,230 --> 00:57:34,105
真的很好的问题。
Really good question.

1189
00:57:34,105 --> 00:57:38,410
那么，如果我们只能以这种方式使用数组，我们如何改善这种情况呢？
So how have we improved this situation if we can just use arrays in this way?

1190
00:57:38,409 --> 00:57:40,569
回想一下，这是一种回归。
Recall that this is kind of a regression.

1191
00:57:40,570 --> 00:57:44,920
我刚才所做的只是回归故事的起点，据此
What I just did is a regression to where we started the story, whereby

1192
00:57:44,920 --> 00:57:46,990
在我刚刚编写的任何版本的代码中，
in any of the versions of code I just wrote,

1193
00:57:46,989 --> 00:57:50,269
我为该数组重新分配了更多空间。
I reallocated more space for this array.

1194
00:57:50,269 --> 00:57:54,159
这意味着我手动使用该for循环，或使用自己的realloc
Which means that I, manually with that for loop, or realloc with its own

1195
00:57:54,159 --> 00:57:57,489
对于循环，必须将所有旧值复制到新值中。
for loop, had to copy all of the old values into the new.

1196
00:57:57,489 --> 00:58:00,639
因此，我们在该程序的所有三个版本中采用的方法
So the approach we've taken in all three versions of this program

1197
00:58:00,639 --> 00:58:04,449
到目前为止，我一直在写，他们都是n的大O。
that I've written thus far on the fly, they've all been Big O of n.

1198
00:58:04,449 --> 00:58:10,219
当涉及插入时，他们没有给我们链接列表的活力
When it comes to inserts, they have not given us the dynamism of a linked list

1199
00:58:10,219 --> 00:58:12,402
只需添加而无需重复。
to just add without that duplication.

1200
00:58:12,402 --> 00:58:15,319
而且我们还没有能力进行插入，例如，
And we haven't had the ability yet to just do an insert, for instance,

1201
00:58:15,320 --> 00:58:18,460
1的Big O中的结构开头。
at the beginning of the structure in Big O of 1 time.

1202
00:58:18,460 --> 00:58:20,800
再次，这是代码翻译，真的，
So, again, this is the code translation, really,

1203
00:58:20,800 --> 00:58:23,740
是我们开始时采用的较慢的方法。
of that slower approach from which we began.

1204
00:58:23,739 --> 00:58:26,499
因此，现在的最终目标是更改此代码
So the ultimate goal now is going to be to change this code

1205
00:58:26,500 --> 00:58:29,830
并给我们这种动力并实际上将事物实现为适当的链接
and give us that dynamism and actually implement things as a proper linked

1206
00:58:29,829 --> 00:58:32,904
列表，而不仅仅是一个整数数组。
list, not just as an array of integers.

1207
00:58:32,905 --> 00:58:34,030
但是我们大约一个小时。
But we're about an hour in.

1208
00:58:34,030 --> 00:58:36,405
让我们继续前进，在这里休息第一个五分钟。
Let's go ahead and take our first five minute break here.

1209
00:58:36,405 --> 00:58:40,600
当我们回来时，我们会将节点本身转换为完整的程序。
And when we come back, we'll translate the nodes themselves to a full program.

1210
00:58:40,599 --> 00:58:42,399
好吧，我们回来了。
All right, we are back.

1211
00:58:42,400 --> 00:58:46,930
回想一下，我们今天从回顾数组并指出
And recall that we began today by revisiting arrays and pointing out

1212
00:58:46,929 --> 00:58:49,509
如果您对它们进行排序，那么对数组的搜索非常有用。
that searching is great in arrays if you keep them sorted.

1213
00:58:49,510 --> 00:58:52,990
您从第0周起就得到了我们喜欢的log n的BigO。
You get the Big O of log n that we liked back from Week 0.

1214
00:58:52,989 --> 00:58:56,019
但是，一旦您要开始动态修改数组，
But as soon as you want to start dynamically modifying an array,

1215
00:58:56,019 --> 00:58:58,049
它很快变得非常昂贵。
it gets very expensive quickly.

1216
00:58:58,050 --> 00:59:00,640
复制可能需要您花费n步的大笔费用
It might take you Big O of n steps to copy

1217
00:59:00,639 --> 00:59:03,789
将旧的小型阵列的内容转换为新的较大阵列。
the contents of an old, small array into a new, bigger array.

1218
00:59:03,789 --> 00:59:07,359
老实说，随着时间的流逝，尤其是对于具有大量数据的真实世界的软件而言，
And honestly, over time, especially for real world software with lots of data,

1219
00:59:07,360 --> 00:59:09,440
即使n的大O也很昂贵。
even Big O of n is expensive.

1220
00:59:09,440 --> 00:59:12,640
就像，您不想一直复制和复制
Like, you don't want to be constantly copying and copying and copying

1221
00:59:12,639 --> 00:59:15,169
计算机内存附近的所有数据。
all of your data around the computer's memory.

1222
00:59:15,170 --> 00:59:18,730
因此，我们可以通过使用指针来避免这种情况，
So we can avoid that by using pointers and, in turn,

1223
00:59:18,730 --> 00:59:21,400
将这些称为“链表”的结构拼接在一起，
stitching together these structures called linked lists,

1224
00:59:21,400 --> 00:59:24,010
尽管付出了更多内存的代价。
albeit at a price of spending more memory.

1225
00:59:24,010 --> 00:59:27,693
但是有了额外的内存，就需要增加额外的动力。
But with that additional memory, that additional cost, comes dynamism.

1226
00:59:27,693 --> 00:59:29,860
这样，如果我们愿意，我们甚至可以实现恒定的时间
So that if we want we can even achieve constant time

1227
00:59:29,860 --> 00:59:31,270
当涉及到插入时。
when it comes to inserting.

1228
00:59:31,269 --> 00:59:34,539
但是，当然，我们必须牺牲诸如可分类性之类的东西。
But of course, then we have to sacrifice things like sortability.

1229
00:59:34,539 --> 00:59:36,429
因此，这需要权衡取舍。
So this came with trade offs.

1230
00:59:36,429 --> 00:59:39,399
我们刚刚看了一些实际C程序的例子
We've just seen a few examples of actual C programs

1231
00:59:39,400 --> 00:59:42,070
首先执行旧数组，每个第0周，
that implement first the old school array, per Week 0,

1232
00:59:42,070 --> 00:59:43,820
在这里我们只是硬编码数组的长度。
where we just hardcode the array's length.

1233
00:59:43,820 --> 00:59:46,210
不幸的是，我们把自己画在了一个角落，
And unfortunately, we painted ourselves into a corner,

1234
00:59:46,210 --> 00:59:47,830
单独使用括号符号。
using the bracket notation alone.

1235
00:59:47,829 --> 00:59:51,489
因此，我们改为部署了m，它是一种更具通用性的工具，
So we deployed instead m which is more versatile tool that

1236
00:59:51,489 --> 00:59:53,769
让我们获得尽可能多的内存。
lets us get as much memory as we want.

1237
00:59:53,769 --> 00:59:58,119
然后，我们用它来重新创建将列表实现为数组的想法。
And we used that to recreate the idea of a list implemented as arrays.

1238
00:59:58,119 --> 01:00:00,879
但是即使那样，我们仍然看到我必须使用for循环进行复制
But even then, we saw that I had to copy using a for loop

1239
01:00:00,880 --> 01:00:04,865
否则我们不得不使用旧的，间接的，重新分配的副本复制到新的副本中。
or we had to copy using, indirectly, realloc, old into new.

1240
01:00:04,864 --> 01:00:07,989
同样，对于这些小程序，您甚至都没有注意到它们之间的区别。
And, again, for these small programs, you don't even notice the difference.

1241
01:00:07,989 --> 01:00:09,319
程序像这样运行。
The programs run like that.

1242
01:00:09,320 --> 01:00:12,580
但是对于大型的，现实世界的软件来说，这是n次
But for large, real world software, all of that Big O of n time

1243
01:00:12,579 --> 01:00:14,059
将很快加起来。
is going to add up quickly.

1244
01:00:14,059 --> 01:00:18,019
因此，最好是我们完全避免它并实现动态。
So it's best if we can try to avoid it altogether and achieve dynamism.

1245
01:00:18,019 --> 01:00:22,809
因此，您可以通过其动态添加到链表的代码
So the code via which you can add to linked list dynamically

1246
01:00:22,809 --> 01:00:26,059
实际上，这是下周问题集5面临的挑战的一部分。
is actually part of the challenge for Problem Set 5 this coming week.

1247
01:00:26,059 --> 01:00:30,099
但是让我们看一些可以通过句法构建的构建块
But let's see some of the building blocks via which we can syntactically

1248
01:00:30,099 --> 01:00:33,159
开始分配节点并将它们拼接在一起
start to allocate nodes and stitch them together when

1249
01:00:33,159 --> 01:00:35,162
我们事先知道我们想要多少。
we know in advance how many we want.

1250
01:00:35,163 --> 01:00:37,330
问题集5不会出现这种情况
Which is not going to be the case for Problem Set 5,

1251
01:00:37,329 --> 01:00:40,856
但目前确实如此，因为我只想要其中三件事。
but for now is indeed the case, because I only want three of these things.

1252
01:00:40,856 --> 01:00:42,939
所以我将从以前回到我的程序。
So I'm going to go back to my program from before.

1253
01:00:42,940 --> 01:00:45,520
我将倒退并竞赛main内部的所有内容。
And I'm going to rewind and race everything inside of main.

1254
01:00:45,519 --> 01:00:47,469
我要继续声明自己
And I'm going to go ahead and declare myself

1255
01:00:47,469 --> 01:00:54,489
一个类型为struct节点的类型，该类型的开头带有一个数字，并带有一个struct节点
a type called struct node initially with a number inside of it and a struct node

1256
01:00:54,489 --> 01:00:56,736
*在里面叫下一个。
* called next inside of that.

1257
01:00:56,737 --> 01:00:59,320
然后，我将整个过程称为“节点”。
And then I'm going to call this whole thing quite simply node.

1258
01:00:59,320 --> 01:01:02,110
因此，这与我们对一个人所做的非常相似。
So that's quite similar to what we did with a person.

1259
01:01:02,110 --> 01:01:05,440
但是现在有点幻想，因为我提供的是结构本身
But now it's a little fancier in that I'm giving the structure itself

1260
01:01:05,440 --> 01:01:07,150
临时名称struct节点。
a temporary name, struct node.

1261
01:01:07,150 --> 01:01:10,270
我指的是结构内部的临时名称
I'm referring to that temporary name inside of the structure

1262
01:01:10,269 --> 01:01:12,429
这样我也可以在那里找到一个指针
so that I can have a pointer there, too.

1263
01:01:12,429 --> 01:01:16,309
然后，我将人重命名为现在的节点。
And then I'm renaming what was person to now node.

1264
01:01:16,309 --> 01:01:19,329
现在，让我们继续并在main内部实际使用此东西。
Now let's go ahead and actually use this thing inside of main.

1265
01:01:19,329 --> 01:01:22,839
因此，让我继续创建一个空的链表。
So let me go ahead and create an empty linked list.

1266
01:01:22,840 --> 01:01:27,760
翻译我们今天开始的简单区块的最简单方法就是
The simplest way to translate the simple block with which we began today is just

1267
01:01:27,760 --> 01:01:31,120
正在执行节点* list;。
doing node *list;.

1268
01:01:31,119 --> 01:01:33,969
不幸的是，任何时候您声明一个变量
Unfortunately, any time you declare a variable

1269
01:01:33,969 --> 01:01:36,729
没有分配的值，这是垃圾。
that does not have an assigned value, it's garbage.

1270
01:01:36,730 --> 01:01:38,980
在指针世界中，垃圾是不好的。
And garbage is bad in the world of pointers.

1271
01:01:38,980 --> 01:01:42,430
同样，要明确的是，如果您创建此名为list的变量
Again, to be clear, if you create this variable called list

1272
01:01:42,429 --> 01:01:46,689
并且您没有显式初始化其值
and you do not explicitly initialize its value

1273
01:01:46,690 --> 01:01:49,570
就像零点指向地面一样
to be something like null pointing at the ground,

1274
01:01:49,570 --> 01:01:51,563
而是将其保留为垃圾值，它是
but instead leave it as a garbage value, it's

1275
01:01:51,563 --> 01:01:53,980
该箭头指向的隐喻等效形式
the sort of metaphorical equivalent of this arrow pointing

1276
01:01:53,980 --> 01:01:55,840
这种方式这种方式
this way, this way, this other way.

1277
01:01:55,840 --> 01:01:58,570
也就是说，您可能会意外地使用自己的代码，
That is to say you might accidentally, in your own code,

1278
01:01:58,570 --> 01:02:01,570
跟随此箭头到一个完全伪造的地方。
follow this arrow to a completely bogus place.

1279
01:02:01,570 --> 01:02:05,038
这就是所谓的分段错误所在，
And that's the point at which you have what are called segmentation faults,

1280
01:02:05,038 --> 01:02:08,080
就像你们中的一些人在您完成问题集4时已经经历的那样
as some of you might have experienced already with Problem Set 4 when you

1281
01:02:08,079 --> 01:02:09,879
触摸不应该的记忆。
touch memory that you shouldn't.

1282
01:02:09,880 --> 01:02:12,580
因此，垃圾值在上下文中变得更加糟糕。
So garbage values are bad ever more so in the context

1283
01:02:12,579 --> 01:02:14,239
出于这个原因的指针。
of pointers for that reason.

1284
01:02:14,239 --> 01:02:15,744
因此，您很少想要这样做。
So you rarely want to do this.

1285
01:02:15,744 --> 01:02:19,539
您几乎总是想将指针初始化为某个已知值。
You almost always want to initialize the pointer to some known value.

1286
01:02:19,539 --> 01:02:21,849
在没有实际地址的情况下，我们
In the absence of an actual address, we're

1287
01:02:21,849 --> 01:02:24,839
将使用null来指示那里什么都没有。
going to use null to indicate that there's nothing there.

1288
01:02:24,840 --> 01:02:26,810
但这是我们故意的。
But that's deliberate on our part.

1289
01:02:26,809 --> 01:02:29,599
现在，假设我要插入，就像我在物理上所做的一样
Now, suppose I want to insert, just as I did physically

1290
01:02:29,599 --> 01:02:32,959
通过将第一个块放在舞台上，让我继续前进
by lugging the block number 1 onto stage before, let me go ahead

1291
01:02:32,960 --> 01:02:36,320
并分配一个节点-我们将其暂时称为n-
and allocate a node-- we'll call it n temporarily--

1292
01:02:36,320 --> 01:02:40,410
使用malloc，这一次要求一个节点的大小。
using malloc, this time asking for the size of a node.

1293
01:02:40,409 --> 01:02:41,899
因此，故事现在正在改变。
So the story is now changing.

1294
01:02:41,900 --> 01:02:43,640
我没有分配单个整数。
I'm not allocating individual ints.

1295
01:02:43,639 --> 01:02:49,339
我正在分配单个节点，其中的内部空间足以容纳一个整数
I'm allocating individual nodes inside of which is enough room for an integer

1296
01:02:49,340 --> 01:02:51,410
和另一个指向节点的指针。
and another pointer to a node.

1297
01:02:51,409 --> 01:02:55,099
运营商的规模可以从定义中得出
And this size of operator figures out, from the definition

1298
01:02:55,099 --> 01:02:58,309
上面这个结构的结构，有多少空间
of this structure up here above main, how much space

1299
01:02:58,309 --> 01:03:03,559
需要用于存储整数和指向结构节点的指针。
is needed to store an integer and a pointer to a struct node.

1300
01:03:03,559 --> 01:03:06,109
因此，一如既往，我将始终进行检查。
So as always now, I'm always going to check.

1301
01:03:06,110 --> 01:03:09,860
如果n等于null，我将退出该程序
If n equals equals null, I'm going to get out of this program

1302
01:03:09,860 --> 01:03:11,330
立即返回1。
immediately, and just return 1.

1303
01:03:11,329 --> 01:03:14,129
因为出了点问题，而且没有足够的内存。
Because something went wrong, and there's just not enough memory.

1304
01:03:14,130 --> 01:03:19,010
但是，如果一切顺利，我现在就继续进行，进入该节点n。
But if all went well, I'm going to go ahead now and go into that node n.

1305
01:03:19,010 --> 01:03:23,180
我将进入其数字字段并为其分配值1。
I'm going to go into its number field and assign it the value 1.

1306
01:03:23,179 --> 01:03:27,409
我将进入该节点n并进入其下一个字段，现在，
And I'm going to go into that node n and go into its next field and, for now,

1307
01:03:27,409 --> 01:03:28,949
给它分配空值。
assign it the value null.

1308
01:03:28,949 --> 01:03:32,599
好像我刚给木制积木分配了1
So this is as though I've just allocated the wooden block with a 1 in it

1309
01:03:32,599 --> 01:03:35,699
并且我已经将它的下一个指针初始化为null。
and I have initialized its next pointer to null.

1310
01:03:35,699 --> 01:03:40,439
现在，我将继续更新列表本身以指向该值。
Now I'm going to go ahead and update the list itself to point at that value.

1311
01:03:40,440 --> 01:03:44,270
所以，再次，我的变量叫做list是通过它的变量
So, again, my variable called list is the variable via which

1312
01:03:44,269 --> 01:03:46,639
我代表了整个清单。
I'm representing the whole list.

1313
01:03:46,639 --> 01:03:49,459
现在，我有一个实际的节点要指向，
And now that I have an actual node to point to,

1314
01:03:49,460 --> 01:03:55,260
我正在设置列表，它再次是一个指向节点的指针，等于
I'm setting list which, again, is a pointer, to a node, equal to whatever

1315
01:03:55,260 --> 01:03:58,850
n是实际节点的地址。
n is, the address of an actual node.

1316
01:03:58,849 --> 01:04:01,939
所以在故事的这一点上，我已经连接了一个小木块
So at this point in the story, I have the small wooden block connected

1317
01:04:01,940 --> 01:04:04,330
到包含1的较大块。
to the larger block containing 1.

1318
01:04:04,329 --> 01:04:06,079
为了讨论起见，让我们假设
Let's suppose, for the sake of discussion,

1319
01:04:06,079 --> 01:04:09,799
我现在想将数字2添加到此列表中，这次使用
I now want to add the number 2 to this list, this time using

1320
01:04:09,800 --> 01:04:11,870
一个节点，而不仅仅是一个整数。
a node as well, not just an integer.

1321
01:04:11,869 --> 01:04:15,499
我将继续使用malloc分配n，
I'm going to go ahead and allocate n, using malloc,

1322
01:04:15,500 --> 01:04:17,871
给我自己另一个节点的大小。
giving myself the size of another node.

1323
01:04:17,871 --> 01:04:20,329
我要再次检查那个东西是否相等
I'm going to again just going to check if that thing equals

1324
01:04:20,329 --> 01:04:24,169
null，让我继续并释放列表，以免泄漏内存。
null let me go ahead and free the list so I don't leak memory.

1325
01:04:24,170 --> 01:04:25,618
然后让我继续并返回1。
Then let me go ahead and return 1.

1326
01:04:25,617 --> 01:04:27,409
所以这只是一个快速的理智检查
So that's just a quick sanity check to make

1327
01:04:27,409 --> 01:04:30,769
确保我释放了之前已经分配的所有内存。
sure I free any memory I've already allocated before.

1328
01:04:30,769 --> 01:04:33,259
但是如果一切顺利，那是我所希望的，
But if all goes well, and that's what I'm hoping for,

1329
01:04:33,260 --> 01:04:37,790
我将继续进入该节点n并存储在其number字段中
I'm going to go ahead and go into this node n and store in its number field

1330
01:04:37,789 --> 01:04:39,102
从字面上看是2。
literally the number 2.

1331
01:04:39,103 --> 01:04:40,520
然后现在，因为这件事
And then now, because this thing--

1332
01:04:40,519 --> 01:04:42,769
我现在将其按排序顺序插入-
I'll insert it in sorted order for now--

1333
01:04:42,769 --> 01:04:46,999
我将继续进行下一步，并插入下一个= NULL。
I'm going to go ahead and insert this next = NULL.

1334
01:04:47,000 --> 01:04:52,339
如果我确实想将此2号节点放在1号节点之后，
And if I indeed want to put this number 2 node after the number 1 node,

1335
01:04:52,340 --> 01:04:55,940
我可以从列表的顶部开始，可以转到下一个节点。
I can start at the top of the list, I can go to the next node.

1336
01:04:55,940 --> 01:05:01,170
在其价值内，我可以说n。
And inside of its value, I can say n.

1337
01:05:01,170 --> 01:05:05,700
因此，这行代码从小块开始，跟随箭头，
So this line of code here starts at the little block, follows the arrow,

1338
01:05:05,699 --> 01:05:10,049
然后更新该第一个节点的下一个指针1节点，
and then updates the next pointer of that first node, the 1 node,

1339
01:05:10,050 --> 01:05:14,290
而是存储该新节点的地址n。
to instead store the address of this new node, n.

1340
01:05:14,289 --> 01:05:18,689
最后，让我们再做一个，所以n = malloc（sizeof（node））;
And then lastly, let's do one more of these so n = malloc(sizeof(node));

1341
01:05:18,690 --> 01:05:19,722
最后一次。
one last time.

1342
01:05:19,722 --> 01:05:21,930
让我继续进行一次理智检查。
Let me go ahead and do my sanity check one more time.

1343
01:05:21,929 --> 01:05:24,401
如果n = = NULL，那么会发生不好的情况。
If n = = NULL something bad happened.

1344
01:05:24,402 --> 01:05:27,360
因此，现在我将继续进行操作，不必担心语法。
So now I'm going to go ahead and don't worry about the syntax just yet.

1345
01:05:27,360 --> 01:05:29,730
但是，我将继续进行下一步，然后列出免费列表。
But I'm going to go ahead and free list next.

1346
01:05:29,730 --> 01:05:31,620
我将继续免费（列表）；
And I'm going to go ahead and free(list);

1347
01:05:31,619 --> 01:05:33,452
然后我将继续并返回1。
and then I'm going to go ahead and return 1.

1348
01:05:33,452 --> 01:05:34,829
但是在另一时间。
But more on that another time.

1349
01:05:34,829 --> 01:05:37,439
那只是在发生一些不好的情况的极端情况下。
That's just in the corner case where something bad happened.

1350
01:05:37,440 --> 01:05:41,310
但是，如果没有发生任何问题，我将把number字段更新为3。
But if nothing bad happened, I'm going to update the number field to be 3.

1351
01:05:41,309 --> 01:05:45,449
我将下一个字段更新为NULL。
I'm going to update the next field to be NULL.

1352
01:05:45,449 --> 01:05:49,559
现在我要更新下一个块的列表
And now I'm going to update the list next block

1353
01:05:49,559 --> 01:05:53,339
下一个等于该新n的块。
next block to equal this new one n.

1354
01:05:53,340 --> 01:05:57,570
然后，在此之后，如果需要，我可以继续打印所有这些东西。
And then here, after this, I can proceed to print all of these things if I want.

1355
01:05:57,570 --> 01:06:00,270
实际上，我将继续循环进行此操作。
And in fact, I'll go ahead and do this with a loop.

1356
01:06:00,269 --> 01:06:03,899
在这种情况下，循环看起来与以前有些不同。
The loop is going to look a little different from before in this case.

1357
01:06:03,900 --> 01:06:07,080
但是事实证明，我们在这里也可以非常强大地使用for循环。
But it turns out we can use for loops pretty powerfully here, too.

1358
01:06:07,079 --> 01:06:09,929
但是在故事的这一点上，我的列表指针
But at this point in the story, my list pointer

1359
01:06:09,929 --> 01:06:12,299
指向1节点，它指向2
is pointing at the 1 node, which is pointing at the 2

1360
01:06:12,300 --> 01:06:14,190
节点，它指向3节点。
node, which is pointing at the 3 node.

1361
01:06:14,190 --> 01:06:16,110
而且，正如之前有人观察到的那样，
And, again, as someone observed earlier, it's

1362
01:06:16,110 --> 01:06:19,590
在这种情况下，使用此双箭头符号并不常见。
not common to use this double arrow notation in this case.

1363
01:06:19,590 --> 01:06:22,680
我敢打赌，我实际上可以使用循环来遍历这些东西
I bet I could actually use a loop to iterate over these things

1364
01:06:22,679 --> 01:06:23,279
一次一个。
one at a time.

1365
01:06:23,280 --> 01:06:26,250
当需要打印时，我们可以在这里看到。
And we can see this here when it's time to print.

1366
01:06:26,250 --> 01:06:28,649
让我继续这样做。
Let me go ahead and do this for.

1367
01:06:28,650 --> 01:06:32,310
而不是使用i，因为实际上没有任何数字在讨论中。
And instead of using i, because there really aren't any numbers in question.

1368
01:06:32,309 --> 01:06:36,419
这不再是数组，所以我不能使用方括号符号或指针
This is no longer an array, so I can't use square bracket notation or pointer

1369
01:06:36,420 --> 01:06:37,050
算术。
arithmetic.

1370
01:06:37,050 --> 01:06:38,670
我需要使用指针。
I need to use pointers.

1371
01:06:38,670 --> 01:06:40,590
因此，一开始可能会觉得有些奇怪。
So this might feel a little weird at first.

1372
01:06:40,590 --> 01:06:43,500
但是，并没有阻止我使用for循环执行此操作。
But there's nothing stopping me with a for loop from doing this.

1373
01:06:43,500 --> 01:06:46,919
给我一个临时指针，指向名为tmp的节点
Give me a temporary pointer to a node called tmp

1374
01:06:46,920 --> 01:06:51,600
并将其初始化为列表开头的任何内容。
and initialize it to be whatever is at the beginning of the list.

1375
01:06:51,599 --> 01:06:56,039
只要tmp不等于NULL，就继续执行以下操作。
Keep doing the following so long as tmp does not equal NULL.

1376
01:06:56,039 --> 01:06:59,579
并且在此循环的每次迭代中，请勿执行类似i ++的操作，
And on each iteration of this loop, don't do something like i++ which,

1377
01:06:59,579 --> 01:07:01,319
同样，现在不相关了。
again, is not relevant now.

1378
01:07:01,320 --> 01:07:04,410
但是继续更新我的临时指针
But go ahead and update my temporary pointer

1379
01:07:04,409 --> 01:07:09,299
成为临时指针的下一个字段的值是什么。
to be whatever the value of the temporary pointer's next field is.

1380
01:07:09,300 --> 01:07:12,000
因此，这很可能看起来像是疯狂的神秘事物，尤其是
So this looks crazy cryptic most likely, especially

1381
01:07:12,000 --> 01:07:16,019
如果您像上周一样不熟悉指针，则与大多数人一样。
if you're new to pointers as of last week, as most of you are.

1382
01:07:16,019 --> 01:07:18,329
但是，相同的想法是典型的for循环。
But it's the same idea is a typical for loop.

1383
01:07:18,329 --> 01:07:21,779
您可以在分号之前初始化一些变量。
You initialize some variable before the semicolon.

1384
01:07:21,780 --> 01:07:24,720
您在第一个分号后检查一些条件。
You check some condition after the first semicolon.

1385
01:07:24,719 --> 01:07:28,897
然后在第二个分号之后执行该变量的更新。
And you perform an update of that variable after the second semicolon.

1386
01:07:28,898 --> 01:07:30,690
在这种情况下，它们不是整数。
In this case, they're not integers, though.

1387
01:07:30,690 --> 01:07:33,840
相反，我是说给自己一个暂时的起点
Instead, I'm saying give myself a temporary pointer to the beginning

1388
01:07:33,840 --> 01:07:37,800
列表中的手指，例如我的手指指着泡沫手指，或者，如果您愿意，
of the list, like my finger pointing at, or if you prefer, the foam finger

1389
01:07:37,800 --> 01:07:40,620
指向列表中的某个节点。
pointing at some node in the list.

1390
01:07:40,619 --> 01:07:43,949
继续并调用该临时变量tmp。
Go ahead and call that temporary variable tmp.

1391
01:07:43,949 --> 01:07:45,309
现在执行以下操作。
And now do the following.

1392
01:07:45,309 --> 01:07:48,149
只要tmp不为null，也就是说，只要它为
So long as tmp is not null, that is, so long as it's

1393
01:07:48,150 --> 01:07:51,960
指着一个实际的合法木块，我该怎么办？
pointing at an actual legitimate wooden block, what do I want to do?

1394
01:07:51,960 --> 01:07:57,300
让我继续使用printf和％i进行打印，
Let me go ahead and print out, using printf and %i as always,

1395
01:07:57,300 --> 01:08:04,230
那里那个节点的数字字段中的任何值。
whatever value is in the number field of that node there.

1396
01:08:04,230 --> 01:08:05,190
就是这样。
And that's it.

1397
01:08:05,190 --> 01:08:08,340
有了这个简单的for循环，相对简单的for循环，
With this simple for loop, relatively simple for loop,

1398
01:08:08,340 --> 01:08:11,910
我基本上可以指向列表中的第一个节点
I can essentially point at the very first node in my list

1399
01:08:11,909 --> 01:08:14,849
并继续将其更新到下一个字段，将其更新到下一个字段，
and keep updating it to the next field, updating it to the next field,

1400
01:08:14,849 --> 01:08:16,099
将其更新到下一个字段。
updating it to the next field.

1401
01:08:16,100 --> 01:08:18,720
我一直这样做，直到我的手指掉下来
And I keep doing this until my finger sort of walks off

1402
01:08:18,720 --> 01:08:21,420
木块列表的末尾，从而
the end of the list of wooden blocks, thereby

1403
01:08:21,420 --> 01:08:25,493
指向null，0x0，此时循环停止
pointing at null, 0x0, at which point the loop stops

1404
01:08:25,493 --> 01:08:26,910
没有更多可打印的内容了。
and there's nothing more to print.

1405
01:08:26,909 --> 01:08:29,994
因此，为了更早地回答该问题，我们
So in answer to that question earlier, do we

1406
01:08:29,994 --> 01:08:31,619
需要使用这个双箭头符号吗？
need to use this double arrow notation?

1407
01:08:31,619 --> 01:08:35,009
简短的回答，不，这是这里的秘密成分。
Short answer, no, this is kind of the secret ingredient here.

1408
01:08:35,010 --> 01:08:38,520
for循环中的这种语法可以接受您所指的任何内容，
This syntax inside of the for loop takes whatever you're pointing at,

1409
01:08:38,520 --> 01:08:41,939
跟随一个箭头，然后立即更新临时变量
follows one arrow, and then updates the temporary variable now

1410
01:08:41,939 --> 01:08:43,710
指向那个结构。
to point at that structure instead.

1411
01:08:43,710 --> 01:08:47,189
因此，这在指针和链接列表的世界中是等效的
So this is kind of the equivalent in the world of pointers and linked lists

1412
01:08:47,189 --> 01:08:48,450
做我++。
of doing i++.

1413
01:08:48,449 --> 01:08:49,769
但这并不像i ++那样简单。
But it's not as simple as i++.

1414
01:08:49,770 --> 01:08:52,170
您不能只向右或向左看一个字节。
You can't just look one byte to the right or to the left.

1415
01:08:52,170 --> 01:08:55,380
相反，您必须跟随箭头，然后跟随箭头。
Instead, you have to follow an arrow, follow an arrow.

1416
01:08:55,380 --> 01:08:59,609
但是通过将这个临时变量重新分配给您刚刚关注的任何地方，
But by reassigning this temporary variable to wherever you just followed,

1417
01:08:59,609 --> 01:09:02,790
这是跟随每个橙色箭头的方式
it's a way of following each of these orange arrows

1418
01:09:02,789 --> 01:09:06,419
就像我们刚才所做的一样。
as we did physically a moment ago.

1419
01:09:06,420 --> 01:09:10,350
在此之后，我应该采取充分的措施，继续释放整个清单。
After this, I should, for good measure, go ahead and free the whole list.

1420
01:09:10,350 --> 01:09:13,217
而且，让我提供释放链表的常用方法。
And let me just offer up a common way of freeing a linked list.

1421
01:09:13,216 --> 01:09:14,799
我实际上可以做这样的事情。
I can actually do something like this.

1422
01:09:14,800 --> 01:09:19,470
虽然list！= NULL，所以虽然整个列表本身不等于null，
While list != NULL, so while the whole list itself does not equal null,

1423
01:09:19,470 --> 01:09:23,970
继续，并获得一个指向下一个字段的临时指针，这样我
go ahead and get a temporary pointer like this to the next field so I

1424
01:09:23,970 --> 01:09:27,689
记住在列表的当前标题之后是什么。
remember what comes after the current head of the list.

1425
01:09:27,689 --> 01:09:29,460
释放列表节点本身。
Free the list node itself.

1426
01:09:29,460 --> 01:09:32,010
然后更新列表为tmp。
And then update list to be tmp.

1427
01:09:32,010 --> 01:09:35,040
因此，再次，这可能看起来是疯狂的神秘的，当然在未来
So, again, this probably looks crazy cryptic and certainly in the coming

1428
01:09:35,039 --> 01:09:36,898
天，尤其是问题集5，您将
days, especially with Problem Set 5, you'll

1429
01:09:36,899 --> 01:09:40,439
在逻辑上多一点地处理这种逻辑
work through this kind of logic a little more logically, a little more

1430
01:09:40,439 --> 01:09:41,830
也许是图片上的。
pictorially, perhaps.

1431
01:09:41,829 --> 01:09:43,079
但是我在这里做什么？
But what am I doing here?

1432
01:09:43,079 --> 01:09:46,478
首先，只要链接列表不为空，我就将执行以下操作。
First, I'm going to do the following, so long as my linked list is not null.

1433
01:09:46,479 --> 01:09:48,479
如果我有三个节点，按照定义
And if I've got three nodes in it, by definition

1434
01:09:48,479 --> 01:09:49,854
从一开始就不为空。
it's not null from the beginning.

1435
01:09:49,854 --> 01:09:52,590
但是我现在的目标是释放我分配的所有内存
But my goal now is to free all of the memory I have allocated

1436
01:09:52,590 --> 01:09:54,430
从左到右，可以这么说。
from left to right, so to speak.

1437
01:09:54,430 --> 01:09:55,390
那我该怎么做呢？
So how do I do that?

1438
01:09:55,390 --> 01:09:58,950
好吧，如果我面前有一个木块，
Well, if I've got a wooden block in front of me,

1439
01:09:58,949 --> 01:10:02,179
释放那个木块还不安全。
it's not safe to free that wooden block yet.

1440
01:10:02,180 --> 01:10:06,630
因为回想起那个木块，所以包含指向下一个节点的指针。
Because that wooden block, recall, contains the pointer to the next node.

1441
01:10:06,630 --> 01:10:09,740
因此，如果我过早地释放了内存，
So if I free this memory prematurely, I've

1442
01:10:09,739 --> 01:10:12,229
然后搁浅所有后续节点。
then stranded all subsequent nodes.

1443
01:10:12,229 --> 01:10:15,019
因为一旦我告诉计算机，就无法再访问它们
Because they are no longer accessible once I've told the computer

1444
01:10:15,020 --> 01:10:17,660
您可以为第一个节点取回这块内存。
you can take back this chunk of memory for the first node.

1445
01:10:17,659 --> 01:10:22,249
因此，这行代码（第52行）只是暂时说
So this line of code here, on line 52, is just saying temporarily

1446
01:10:22,250 --> 01:10:24,020
给我一个叫tmp的变量。
give me a variable call tmp.

1447
01:10:24,020 --> 01:10:28,740
并且不要将其指向列表本身（第一个节点），而是指向下一个节点。
And point it not at the list itself, the first node, point at the next node.

1448
01:10:28,739 --> 01:10:32,059
所以就像用我的右手指向当前节点，我的左手
So it's like using my right hand to point at the current node, my left hand

1449
01:10:32,060 --> 01:10:37,140
指向下一个节点，这样我就可以在第53行上释放列表本身，
to point at the next node, so that I can then, on line 53, free the list itself,

1450
01:10:37,140 --> 01:10:38,750
这不应该从字面上看。
which should not be taken literally.

1451
01:10:38,750 --> 01:10:43,259
列表表示链接列表中的第一个节点，而不是整个对象。
List represents the first node in the linked list, not the whole thing.

1452
01:10:43,260 --> 01:10:46,460
因此，当您说空闲列表时，就像仅释放当前节点一样。
So when you say free list, that's, like, freeing just the current node.

1453
01:10:46,460 --> 01:10:47,270
但是没关系。
But that's OK.

1454
01:10:47,270 --> 01:10:49,580
即使现在，这个记忆已经归还了，
Even now this memory has been given back,

1455
01:10:49,579 --> 01:10:52,609
我的左手仍然指向每个后续节点
I still have my left hand pointing at every subsequent node

1456
01:10:52,609 --> 01:10:54,239
通过下一个。
by way of the next one.

1457
01:10:54,239 --> 01:10:58,249
所以现在我可以将列表更新为等于该临时变量
So now I can update list to equal that temporary variable

1458
01:10:58,250 --> 01:10:59,820
并继续此循环。
and just continue this loop.

1459
01:10:59,819 --> 01:11:01,699
因此，这是一种Pacman风格的方式，例如，
So it's a way of sort of Pacman style, like,

1460
01:11:01,699 --> 01:11:04,249
从左侧吞噬整个链表
gobbling up the entire linked list from left

1461
01:11:04,250 --> 01:11:07,970
向右移动第一个节点，第二个节点，第三个节点，然后
to right by freeing the first node, the second node, the third node, and then

1462
01:11:07,970 --> 01:11:08,490
你完成了。
you're done.

1463
01:11:08,489 --> 01:11:12,169
但是通过使用临时变量来向前看一步，以确保
But by using a temporary variable to look one step ahead to make sure

1464
01:11:12,170 --> 01:11:15,230
你不吃力，过早释放内存
you don't chomp, free the memory too soon

1465
01:11:15,229 --> 01:11:20,249
因此，将失去对所有这些后续节点的访问权限。
and, therefore, lose access to all of those subsequent nodes.

1466
01:11:20,250 --> 01:11:21,419
好吧，
All right, phew.

1467
01:11:21,420 --> 01:11:22,560
那是一个很大的程序。
That was a big program.

1468
01:11:22,560 --> 01:11:25,860
但这本来应该是连续的，从数组开始，
But it was meant to be in succession, starting with an array,

1469
01:11:25,859 --> 01:11:29,909
过渡到动态分配的数组，最后是
transitioning into a dynamically allocated array, followed by, finally,

1470
01:11:29,909 --> 01:11:32,399
使用链表的实现，尽管是硬编码的
an implementation using linked list, albeit hardcoded

1471
01:11:32,399 --> 01:11:33,999
仅支持三个节点。
to support only three nodes.

1472
01:11:34,000 --> 01:11:37,200
但是在该示例中，您是否看到了一些示例语法，通过这些示例语法
But in that example, do you see some sample syntax via which you

1473
01:11:37,199 --> 01:11:39,929
可以操纵这些类型的节点？
can manipulate these kinds of nodes?

1474
01:11:39,930 --> 01:11:44,950
我可以帮助解决的问题或困惑？
Questions or confusion that I can help address?

1475
01:11:44,949 --> 01:11:45,449
布莱恩：是的。
BRIAN: Yes.

1476
01:11:45,449 --> 01:11:48,059
有人问，就像您之前做过的一个例子一样，
Someone asked, similar to one of the examples you did before,

1477
01:11:48,060 --> 01:11:51,780
为什么我们不能刚刚完成三倍于节点大小的malloc
why could we not have just done malloc three times size of node

1478
01:11:51,779 --> 01:11:53,879
得到三个节点，并这样做吗？
to get three nodes and do it that way?

1479
01:11:53,880 --> 01:11:54,760
大卫·马兰（David MALAN）：很好的问题。
DAVID MALAN: Really good question.

1480
01:11:54,760 --> 01:11:56,910
我不能只使用malloc并一次分配所有三个吗？
Could I not just use malloc and allocate all three at once?

1481
01:11:56,909 --> 01:11:57,429
绝对地。
Absolutely.

1482
01:11:57,430 --> 01:11:57,930
是的。
Yes.

1483
01:11:57,930 --> 01:11:59,430
那完全是你的特权。
That is completely your prerogative.

1484
01:11:59,430 --> 01:12:01,770
我做得更勤快一点，一次一次。
I did it a little more pedantically, one at a time.

1485
01:12:01,770 --> 01:12:05,550
但是您绝对可以一次全部完成这三个操作。
But you could absolutely do it all three at once.

1486
01:12:05,550 --> 01:12:09,150
然后，您将需要使用一些指针算法，
You would then need to use some pointer arithmetic though,

1487
01:12:09,149 --> 01:12:11,369
否则您将需要使用方括号符号
or you would need to square bracket notation

1488
01:12:11,369 --> 01:12:16,049
将更大的内存块视为本质上是节点数组，
to treat that bigger chunk of memory as essentially an array of nodes,

1489
01:12:16,050 --> 01:12:17,570
然后将它们缝在一起。
and then stitch them together.

1490
01:12:17,569 --> 01:12:19,822
因此，我假设出于演示目的，
So I am assuming, for demonstration purposes,

1491
01:12:19,823 --> 01:12:22,740
即使我们有这些简单的例子来说明
that even though we have these little simple examples that demonstrate

1492
01:12:22,739 --> 01:12:26,669
语法，在现实世界的系统中，您不会插入1，
the syntax, in a real world system, you're not going to be inserting 1,

1493
01:12:26,670 --> 01:12:28,110
然后2，然后3。
then 2, then 3.

1494
01:12:28,109 --> 01:12:29,909
奇怪的是，您将要插入1。
Odds are you're going to be inserting 1.

1495
01:12:29,909 --> 01:12:31,169
一段时间过去了。
Some time passes.

1496
01:12:31,170 --> 01:12:33,750
然后，您想插入2，以便分配更多的内存。
Then you want to insert 2, so you allocate more memory.

1497
01:12:33,750 --> 01:12:35,189
然后再经过一些时间。
Then some more time passes.

1498
01:12:35,189 --> 01:12:36,939
然后您要插入3。
Then you want to insert 3.

1499
01:12:36,939 --> 01:12:42,149
因此，在现实世界中，这些代码块之间存在差距。
And so there's gaps in between these chunks of code in the real world.

1500
01:12:42,149 --> 01:12:43,529
还有其他疑问或困惑吗？
Other questions or confusion?

1501
01:12:43,529 --> 01:12:43,799
布莱恩：是的。
BRIAN: Yeah.

1502
01:12:43,800 --> 01:12:44,850
另一个问题出现了。
Another question came in.

1503
01:12:44,850 --> 01:12:47,113
为什么malloc永远无法分配内存？
Why would malloc ever fail to allocate memory?

1504
01:12:47,113 --> 01:12:48,780
DAVID MALAN：为什么malloc会失败？
DAVID MALAN: Why would malloc ever fail?

1505
01:12:48,779 --> 01:12:52,659
它很少会失败，但是如果计算机内存不足。
It's rarely going to fail, but if the computer is out of memory.

1506
01:12:52,659 --> 01:12:56,639
所以本质上，如果您正在编写这样的内存需求大的程序
So essentially, if you're writing such a memory hungry program

1507
01:12:56,640 --> 01:13:00,000
具有如此多的变量，大型数组，大型结构，大量数据，
with so many variables, big arrays, big structures, lots of data,

1508
01:13:00,000 --> 01:13:01,870
您可能会耗尽内存。
you may very well run out of memory.

1509
01:13:01,869 --> 01:13:04,679
也许是2 GB，也许是4 GB或更多。
Maybe that's two gigabytes, maybe it's four gigabytes or more.

1510
01:13:04,680 --> 01:13:07,080
但是malloc可能很容易向您返回null。
But malloc may very well return null to you.

1511
01:13:07,079 --> 01:13:09,489
因此，您应该始终对其进行检查。
And so you should always check for it.

1512
01:13:09,489 --> 01:13:11,969
实际上，我敢说，在Mac和PC上，
In fact, I dare say, on Macs and PCs, one

1513
01:13:11,970 --> 01:13:15,780
直到今天，最常见的原因是程序被冻结，
of the most common reasons, to this day, for programs to freeze,

1514
01:13:15,779 --> 01:13:17,909
崩溃，您的家用计算机重新启动，
to crash, for your home computer to reboot,

1515
01:13:17,909 --> 01:13:20,249
确实是因为有人做了一些愚蠢的事情，例如我
is truly because someone did something stupid, like I've

1516
01:13:20,250 --> 01:13:22,919
现在已经在今天和上周进行了多次，
done multiple times now already today and last week,

1517
01:13:22,920 --> 01:13:25,080
触摸您不应该拥有的记忆。
by touching memory that you shouldn't have.

1518
01:13:25,079 --> 01:13:27,839
因此，在问题集4和现在的问题5中，
So in Problem Set 4 and now 5, any time you

1519
01:13:27,840 --> 01:13:30,210
经历那些细分错误之一
experience one of those segmentation faults

1520
01:13:30,210 --> 01:13:35,910
因此您的程序崩溃了，这就是问题所在
whereby your program just crashes, that is the problem set

1521
01:13:35,909 --> 01:13:38,759
整个Mac或PC崩溃的版本，
version of, like, your whole Mac or PC crashing,

1522
01:13:38,760 --> 01:13:40,530
因为有人比你经验丰富
because someone more experienced than you

1523
01:13:40,529 --> 01:13:43,739
在他们的代码中犯了同样的错误。
made that same mistake in their code.

1524
01:13:43,739 --> 01:13:46,709
为了加强这一点，让我们以一个快速的最终示例为例
Just to reinforce this, let's take a quick final example

1525
01:13:46,710 --> 01:13:50,550
涉及链表，这又是一维结构，
involving linked lists which, again, are this very one dimensional structure,

1526
01:13:50,550 --> 01:13:51,153
左到右。
left to right.

1527
01:13:51,153 --> 01:13:53,820
然后，我们将添加第二个维度，看看能为我们带来什么。
And then we'll add a second dimension and see what that buys us.

1528
01:13:53,819 --> 01:13:55,299
但是我们已经更改了此处的数字。
But we've changed the numbers around here.

1529
01:13:55,300 --> 01:13:56,580
现在我们仍然有清单。
Now we still have our list.

1530
01:13:56,579 --> 01:13:58,769
但这首先指向这里的第二位。
But it's first pointing at the number two here.

1531
01:13:58,770 --> 01:14:01,770
然后第二个指向其他的内存块
And then the number two is pointing to some other chunk of memory that's

1532
01:14:01,770 --> 01:14:03,570
被分配到这里。
been malloced way over here.

1533
01:14:03,569 --> 01:14:05,189
那么，这就是数字4。
And this, then, is the number 4.

1534
01:14:05,189 --> 01:14:06,819
那么，这就是数字5。
And this, then, is the number 5.

1535
01:14:06,819 --> 01:14:08,699
因此，我们有一个大小为3的链表。
So we have a linked list of size 3.

1536
01:14:08,699 --> 01:14:12,059
但是这次我故意将数字分配给2、4、5。
But I've deliberately spread the numbers out this time, 2, 4, 5.

1537
01:14:12,060 --> 01:14:15,000
因为假设我们确实希望在此列表中插入更多数字，
Because suppose that we do want to insert more numbers into this list,

1538
01:14:15,000 --> 01:14:17,729
但是按照排序的顺序，事实证明我们
but in sorted order, it turns out that we

1539
01:14:17,729 --> 01:14:19,769
当什么时候必须有所不同
have to think a little bit differently when

1540
01:14:19,770 --> 01:14:23,280
我们不是在节点的末尾添加节点，
we're adding nodes not to the end and not to the beginning,

1541
01:14:23,279 --> 01:14:24,246
但在中间。
but in the middle.

1542
01:14:24,247 --> 01:14:26,580
例如，当我们想在中间分配更多的节点时，
Like, when we want to allocate more nodes in the middle,

1543
01:14:26,579 --> 01:14:29,559
实际上还有更多工作要做。
there's a bit more work that actually has to happen.

1544
01:14:29,560 --> 01:14:31,140
那么我们该怎么做呢？
So how might we go about doing this?

1545
01:14:31,140 --> 01:14:34,260
假设我们要分配数字1。
Suppose that we want to allocate, for instance, the number 1.

1546
01:14:34,260 --> 01:14:35,820
我想添加数字1。
And I want to add the number 1.

1547
01:14:35,819 --> 01:14:37,289
好吧，我们可以使用这样的代码。
Well, we could use code like this.

1548
01:14:37,289 --> 01:14:39,059
这与我们之前使用的代码相同。
This is the same code as we used before.

1549
01:14:39,060 --> 01:14:40,770
我们分配一个节点的大小。
We allocate the size of a node.

1550
01:14:40,770 --> 01:14:43,080
我们检查它是否等于null，然后将其初始化
We check whether it equals null, we initialize it

1551
01:14:43,079 --> 01:14:46,411
具有我们关心的值，并且默认情况下，我们坐在下一个等于null的位置。
with a value we care about, and by default, we sit next equal to null.

1552
01:14:46,412 --> 01:14:48,120
从图片上看，它可能看起来像这样。
And pictorially, it might look like this.

1553
01:14:48,119 --> 01:14:50,494
有点像漂浮在计算机内存中的某个地方。
It's kind of floating somewhere in the computer's memory.

1554
01:14:50,494 --> 01:14:53,129
我有了这个临时变量n，不再显示了，
I have this temporary variable n, no longer pictured,

1555
01:14:53,130 --> 01:14:55,470
我在分配数字1时所指的就是
that I'm just pointing at when I allocate the number 1.

1556
01:14:55,470 --> 01:14:56,820
那么这是什么样的呢？
So what does this look like?

1557
01:14:56,819 --> 01:15:01,509
这就像可能在此处某处有数字1。
This is like having the number 1 maybe somewhere over here.

1558
01:15:01,510 --> 01:15:02,760
我将其放置到位。
And I'll just put it in place.

1559
01:15:02,760 --> 01:15:05,410
我们很幸运，那里有很多记忆。
We got lucky, and there was a chunk of memory right there.

1560
01:15:05,409 --> 01:15:07,139
那我现在想做什么？
So what do I want to now do?

1561
01:15:07,140 --> 01:15:08,920
好吧，我想继续进行连接。
Well, I want to go ahead and connect this.

1562
01:15:08,920 --> 01:15:12,720
所以我可以做的，只是凭直觉，如果1应该排在2之前
So what I could do, just intuitively, if 1 should go before 2,

1563
01:15:12,720 --> 01:15:14,220
我可以拔掉它。
I can unplug this.

1564
01:15:14,220 --> 01:15:17,980
我可以将其插入此处，这很有意义。
And I can plug this into here, which makes sense.

1565
01:15:17,979 --> 01:15:19,559
但是已经有问题了。
But there's already a problem.

1566
01:15:19,560 --> 01:15:22,290
如果到目前为止我什么也没做，
If I have done nothing else up until this point,

1567
01:15:22,289 --> 01:15:26,579
我只是孤立了三个节点2、4、5。
I have just orphaned three nodes, 2, 4, and 5.

1568
01:15:26,579 --> 01:15:29,369
孤立一个节点意味着忘记它在哪里。
To orphan a node means to forget where it is.

1569
01:15:29,369 --> 01:15:32,069
如果我的代码中没有其他变量，
And if I don't have another variable in my code,

1570
01:15:32,069 --> 01:15:34,079
或者如果我没有用一只手表演
or if I'm not acting out with one of my hands

1571
01:15:34,079 --> 01:15:36,959
指向列表的原始开头，
pointing at the original beginning of the list,

1572
01:15:36,960 --> 01:15:39,330
我实际上已经孤立了列表的其余部分。
I have literally orphaned the rest of the list.

1573
01:15:39,329 --> 01:15:41,969
而且，从技术上讲，每星期，
And the technical implication of that, per last week,

1574
01:15:41,970 --> 01:15:44,010
就是现在我有大量的内存泄漏。
is that now I have a massive memory leak.

1575
01:15:44,010 --> 01:15:46,560
您刚刚泄漏了三个节点的大小
You have just leaked the size of three nodes

1576
01:15:46,560 --> 01:15:49,320
在记忆中，你几乎永远都不会回来
in memory that you can literally never get back

1577
01:15:49,319 --> 01:15:51,309
例如，直到重新启动计算机，
until you reboot the computer, for instance,

1578
01:15:51,310 --> 01:15:54,742
否则程序将退出，操作系统将为您清除内容。
or the program quits and the operating system cleans things up for you.

1579
01:15:54,742 --> 01:15:55,950
所以你不想这样做。
So you don't want to do this.

1580
01:15:55,949 --> 01:15:58,569
操作顺序实际上很重要。
Order of operations actually matters.

1581
01:15:58,569 --> 01:16:01,139
所以我可能应该做的是。
So what I should probably do is this.

1582
01:16:01,140 --> 01:16:04,340
当我首先插入数字1时，我可能应该
When I insert the number 1 first, I should probably

1583
01:16:04,340 --> 01:16:07,090
认识到，那是从列表的开头开始的。
recognize that, well, the one begins at the beginning of the list.

1584
01:16:07,090 --> 01:16:10,980
因此，我真正应该做的就是将此箭头也指向同一节点。
So what I should really do is point this arrow also at the same node.

1585
01:16:10,979 --> 01:16:13,629
我们会像这样有点草率地做到这一点。
And we'll sort of do it a little sloppily like that.

1586
01:16:13,630 --> 01:16:16,720
但是让我规定它们都指向同一节点。
But let me stipulate those are both pointing at the same node.

1587
01:16:16,720 --> 01:16:21,990
现在，我的新节点AKA n和我显示的代码就是针对这个问题的，
Now that my new node, AKA n and the code I showed is pointing at this thing,

1588
01:16:21,989 --> 01:16:23,819
现在，我可以做一个switcheroo。
now I can do kind of a switcheroo.

1589
01:16:23,819 --> 01:16:27,749
因为我已经指向那里的最终目的地了。
Because I'm already pointing at the final destination there.

1590
01:16:27,750 --> 01:16:30,720
现在，我可以安全地删除它了，因为这是我的列表。
And now I can remove this safely, because this is my list.

1591
01:16:30,720 --> 01:16:31,710
这是n。
This is n.

1592
01:16:31,710 --> 01:16:33,625
因此，我有两个变量都指向
Therefore, I have variables pointing to both

1593
01:16:33,625 --> 01:16:35,500
我可以继续并正确插入。
and I can go ahead and insert that correctly.

1594
01:16:35,500 --> 01:16:38,279
长话短说，操作顺序很重要。
So long story short, order of operations matters.

1595
01:16:38,279 --> 01:16:43,799
因此，以图形方式，如果我像以前一样这样做，只需说list等于n，
So graphically, if I were to do this as before, just by saying list equals n,

1596
01:16:43,800 --> 01:16:48,950
如果这是n，这是列表，并且我先调整此箭头，
if this is n, and this is list, and I adjust this arrow first,

1597
01:16:48,949 --> 01:16:50,419
坏事将会发生。
bad things are going to happen.

1598
01:16:50,420 --> 01:16:54,890
确实，我们最终孤立了2、4和5，从而泄漏了大量
Indeed, we end up orphaning 2, 4, and 5, thereby leaking a significant amount

1599
01:16:54,890 --> 01:16:55,850
潜在的内存。
of memory potentially.

1600
01:16:55,850 --> 01:16:57,645
通常，泄漏任何内存都是不好的。
And leaking any memory, typically, is bad.

1601
01:16:57,645 --> 01:16:58,770
所以我不想那样做。
So I don't want to do that.

1602
01:16:58,770 --> 01:17:00,200
因此，让我们看一下正确的代码。
So let's look at the correct code.

1603
01:17:00,199 --> 01:17:03,349
正确的代码将从n开始
The correct code is going to be to start at n

1604
01:17:03,350 --> 01:17:08,210
并更新其下一个字段（这里的箭头）指向同一件事
and update its next field, this arrow here, to point at the same thing

1605
01:17:08,210 --> 01:17:10,550
就像列表最初指向的一样。
as the list was originally pointing at.

1606
01:17:10,550 --> 01:17:14,600
然后继续更新列表，这样他们两个
And then go ahead and update the list, such that both of them

1607
01:17:14,600 --> 01:17:16,220
当前指向重复。
are currently pointing in duplicate.

1608
01:17:16,220 --> 01:17:18,750
然后更新列表以指向新节点。
Then update the list to point to the new node.

1609
01:17:18,750 --> 01:17:21,410
因此，这次的代码与以前有些不同。
So, again, the code's a little different this time from before.

1610
01:17:21,409 --> 01:17:23,242
因为在我们将其添加到末尾之前，
Because before we kept adding it to the end,

1611
01:17:23,243 --> 01:17:26,390
或者我口头建议我们只是将其添加到开头。
or I proposed verbally that we just add it to the beginning.

1612
01:17:26,390 --> 01:17:28,530
实际上，我们确实在开始时就添加了它。
Here, we're adding it, indeed, at the beginning.

1613
01:17:28,529 --> 01:17:31,791
因此，实际步骤，实际代码略有不同。
And so the actual steps, the actual code, are a little bit different.

1614
01:17:31,792 --> 01:17:34,250
好吧，如果要分配3，让我们做一个最后的例子。
Well, let's do one final example, if we want to allocate 3.

1615
01:17:34,250 --> 01:17:37,459
好吧，我必须分配另一个节点3。
Well, I've got to malloc another node, the number 3.

1616
01:17:37,460 --> 01:17:42,090
假设最终出现在计算机内存中的某个位置。
Suppose that ends up somewhere in the computer's memory.

1617
01:17:42,090 --> 01:17:45,330
让我们继续前进，把这一个放在这里。
Let's go ahead and plop this one over here.

1618
01:17:45,329 --> 01:17:46,849
所以现在3就位了。
So now 3 is in place.

1619
01:17:46,850 --> 01:17:48,630
我现在该如何插入这个东西？
How do I now insert this thing?

1620
01:17:48,630 --> 01:17:52,460
好吧，类似于之前，我不想更新此指针
Well, similar to before, I'm not going to want to update this pointer

1621
01:17:52,460 --> 01:17:56,060
像这样去，然后把这个家伙插在这里。
and go like this and then plug this guy in over here.

1622
01:17:56,060 --> 01:17:57,830
因为现在我孤立了这两个节点。
Because now I've orphaned those two nodes.

1623
01:17:57,829 --> 01:17:59,869
因此，这又是错误的步骤。
So that, again is the wrong step.

1624
01:17:59,869 --> 01:18:03,051
当您位于链接列表的中间时，任何代码
When you're inside the middle of a linked list, any code

1625
01:18:03,051 --> 01:18:04,759
您写的要插入中间的内容，
that you write to insert into the middle,

1626
01:18:04,760 --> 01:18:09,260
如果您关心按排序顺序插入，则应首先进行更新。
if you care about inserting in sorted order, this should be updated first.

1627
01:18:09,260 --> 01:18:12,500
而且我应该作弊并指出同一件事，
And odds are I should kind of cheat and point this at the same thing,

1628
01:18:12,500 --> 01:18:14,930
即使目前只有一个物理插头。
even though there's only one physical plug at the moment.

1629
01:18:14,930 --> 01:18:18,300
因此，我们只是假装这是可行的。
So we'll just pretend that this is working.

1630
01:18:18,300 --> 01:18:19,140
好了
There we go.

1631
01:18:19,140 --> 01:18:23,430
现在我可以安全地说n和上一个节点
And now I can go ahead and safely say that n and the previous node

1632
01:18:23,430 --> 01:18:25,200
已经指出了他们应该去的地方。
are already pointing where they should be.

1633
01:18:25,199 --> 01:18:28,489
因此，现在我可以安全地拔下该插头了
So now it's safe for me to unplug this one

1634
01:18:28,489 --> 01:18:31,819
并继续更新此最终箭头以指向
and go ahead and update this final arrow to point

1635
01:18:31,819 --> 01:18:35,819
在正确位置的新节点上。
at the new node in the correct location.

1636
01:18:35,819 --> 01:18:37,249
因此，让我们再次在代码中看到它。
So let's see that in code again.

1637
01:18:37,250 --> 01:18:41,480
如果我去这里，我会以图形方式看到节点3在太空中的漂浮情况。
If I go here, I've got graphically the node 3 kind of floating in space.

1638
01:18:41,479 --> 01:18:45,829
我首先更新其下一个字段，使其也指向一式两份的4。
I first update its next field to point also at the 4 in duplicate.

1639
01:18:45,829 --> 01:18:48,619
然后，我将2更新为指向3。
Then, I update the 2 to point to the 3.

1640
01:18:48,619 --> 01:18:53,629
再次的目标是避免任何内存泄漏或孤立
The goal being, again, to avoid any leaking of memory or orphaning

1641
01:18:53,630 --> 01:18:55,250
的节点。
of nodes.

1642
01:18:55,250 --> 01:18:59,339
好吧，我们将把链表留在后面。
All right , we are about to leave linked lists behind.

1643
01:18:59,340 --> 01:19:02,760
因为你们当中有许多人已经注意到或可能想到过，
Because as multiple of you have noted or probably thought,

1644
01:19:02,760 --> 01:19:05,300
他们很好，但也许不是很好。
they're good, but maybe not great.

1645
01:19:05,300 --> 01:19:08,160
它们的优势在于它们是动态的，我可以添加到它们中，例如
They're good in that they are dynamic and I can add to them, as

1646
01:19:08,159 --> 01:19:10,589
如果我真的想在开头插入
by inserting at the beginning if I really want

1647
01:19:10,590 --> 01:19:12,030
并且不在乎排序顺序。
and don't care about sorted order.

1648
01:19:12,029 --> 01:19:13,979
但是他们仍然要做很多工作
But they're still a good amount of work to do

1649
01:19:13,979 --> 01:19:16,769
如果我想让它们保持排序并插入它们
if I want to keep them in sorted order and I insert them

1650
01:19:16,770 --> 01:19:17,940
在中间或最后。
in the middle or the end.

1651
01:19:17,939 --> 01:19:19,829
因为那就像，如果我保持n的大O
Because that's, like, Big O of n if I keep

1652
01:19:19,829 --> 01:19:22,089
遍历所有这些织补箭头。
traversing all of these darn arrows.

1653
01:19:22,090 --> 01:19:24,600
这样我们就具有了活力，但是我们不一定
So we get the dynamism, but we don't necessarily

1654
01:19:24,600 --> 01:19:26,250
获得性能提升。
get the performance increase.

1655
01:19:26,250 --> 01:19:29,580
但是我们从根本上为自己打开了一个全新的世界。
But we fundamentally have opened up a whole new world to ourselves.

1656
01:19:29,579 --> 01:19:32,669
现在，我们可以将这些数据结构拼接在一起
We can now stitch together these data structures

1657
01:19:32,670 --> 01:19:35,910
在内存中使用指针作为我们的线程（如果可以的话）。
in memory using pointers as our thread, if you will.

1658
01:19:35,909 --> 01:19:39,689
我们可以将内存用作画布，在其上绘制所需的任何值。
We can just use memory as a canvas, painting on it any values we want.

1659
01:19:39,689 --> 01:19:42,509
我们可以记住所有这些值在哪里。
And we can sort of remember where all of those values are.

1660
01:19:42,510 --> 01:19:47,010
但这确实是从左到右的非常单一的一维。
But this is indeed very single, one dimensional, left to right.

1661
01:19:47,010 --> 01:19:49,763
如果我们给自己第二个维度怎么办？
What if we give ourselves a second dimension?

1662
01:19:49,762 --> 01:19:51,929
如果我们开始思考不是从左到右，
What if we start thinking sort of not left to right,

1663
01:19:51,930 --> 01:19:53,632
而且从左到右，上，下。
but also left to right, up, down.

1664
01:19:53,631 --> 01:19:55,589
因此，这对计算机毫无意义。
So, again, this is meaningless to the computer.

1665
01:19:55,590 --> 01:19:59,100
计算机只是认为内存是字节0、1、2、3。
The computer just thinks of memory as being byte 0, 1, 2, 3.

1666
01:19:59,100 --> 01:20:01,680
但是我们人类可以想到这些数据结构
But we humans can kind of think of these data structures

1667
01:20:01,680 --> 01:20:04,620
更抽象一点，更简单一点。
a little more abstractly, a little more simply.

1668
01:20:04,619 --> 01:20:06,779
我们可以以熟悉的方式考虑它们，
And we can think about them in a way familiar,

1669
01:20:06,779 --> 01:20:08,169
也许对我们在现实世界中。
perhaps, to us in the real world.

1670
01:20:08,170 --> 01:20:10,630
树木，不是从地上生长的那么多的树木，
Trees, not the ones so much that grow from the ground,

1671
01:20:10,630 --> 01:20:12,412
但是如果您熟悉家谱。
but if you're familiar with family trees.

1672
01:20:12,412 --> 01:20:14,370
你可能有一个女家长或族长
Where you might have a matriarch or a patriarch

1673
01:20:14,369 --> 01:20:16,869
然后以图形方式将这些后代悬挂下来
and then sort of descendants hanging off of them graphically

1674
01:20:16,869 --> 01:20:19,661
在一张纸上，你可能在小学时做过的东西，
on a piece of paper, something you might have made in grade school,

1675
01:20:19,662 --> 01:20:20,470
例如。
for instance.

1676
01:20:20,470 --> 01:20:22,860
我们可以利用树形结构的想法
We can leverage this idea of a tree structure

1677
01:20:22,859 --> 01:20:26,729
根源是那种分支机构，分支机构和分支机构
that has a root that kind of branches and branches and branches

1678
01:20:26,729 --> 01:20:28,389
并从上到下生长。
and grows top to bottom.

1679
01:20:28,390 --> 01:20:32,610
因此，再一次，它更像是一棵家谱，而不是土壤中的一棵真实的树。
So, again, more like a family tree than an actual tree in the soil.

1680
01:20:32,609 --> 01:20:36,719
因此，对于树木，事实证明，关于树木的想法
So with trees, it turns out, this idea of a tree,

1681
01:20:36,720 --> 01:20:40,410
我们可以借鉴从链接列表中学到的一些经验教训。
we can take some of the lessons learned from linked lists.

1682
01:20:40,409 --> 01:20:43,799
但是我们可以重新获得数组的某些功能。
But we can gain back some of the features of arrays.

1683
01:20:43,800 --> 01:20:45,220
我们可以按照以下步骤进行操作。
And we can do that as follows.

1684
01:20:45,220 --> 01:20:48,420
考虑以下关于我们的定义
Consider the following definition of what we're

1685
01:20:48,420 --> 01:20:50,400
即将调用二叉搜索树。
about to call a binary search tree.

1686
01:20:50,399 --> 01:20:54,359
从第一周（第0周）开始，二进制搜索是一件非常好的事情。
Binary search being a very good thing from the first, Week 0.

1687
01:20:54,359 --> 01:20:57,029
现在，一棵树已成为新主意。
And a tree now being the new idea.

1688
01:20:57,029 --> 01:21:00,749
无论何时，这都是第0周，第1周，第2周的数组。
Here's an array from Week 0, Week 1, Week 2, whenever.

1689
01:21:00,750 --> 01:21:02,159
它的大小为7。
And it's of size 7.

1690
01:21:02,159 --> 01:21:05,801
并回想一下，如果已排序，我们可以对该数组应用二进制搜索。
And recall that if it's sorted, we can apply binary search to this array.

1691
01:21:05,801 --> 01:21:06,509
那太好了。
And that's great.

1692
01:21:06,510 --> 01:21:08,218
因为如果我们要搜索一个值，
Because if we want to search for a value,

1693
01:21:08,217 --> 01:21:09,779
我们可以开始在中间寻找。
we can start looking in the middle.

1694
01:21:09,779 --> 01:21:13,079
然后，我们可以在两者之间的中间位置向左或向右走。
Then we can go either left or right, halfway between each.

1695
01:21:13,079 --> 01:21:15,839
然后我们可以类似地向左或向右走。
And then we can similarly go left or right.

1696
01:21:15,840 --> 01:21:20,460
所以对排序数组进行二进制搜索是如此强大
So binary search on a sorted array was so powerful

1697
01:21:20,460 --> 01:21:23,010
因为它是log n的Big O，所以我们得出结论，
because it was Big O of log n, we've concluded,

1698
01:21:23,010 --> 01:21:27,330
一次又一次地遇到问题，
by just having and having and having the problem again and again,

1699
01:21:27,329 --> 01:21:30,299
一次又一次地将电话簿撕成两半。
tearing the phone book in half again and again and again.

1700
01:21:30,300 --> 01:21:33,300
但是二进制搜索的问题在于
But the problem with binary search is that it

1701
01:21:33,300 --> 01:21:38,010
要求您使用数组，以便您具有随机访问权限。
requires that you use an array so that you have random access.

1702
01:21:38,010 --> 01:21:42,240
您必须能够在恒定时间内索引数组
You have to be able to index into the array in constant time

1703
01:21:42,239 --> 01:21:46,829
使用简单的算术运算，例如括号0，括号n减1，括号n减1
using simple arithmetic, like bracket 0, bracket n minus 1, bracket n minus 1

1704
01:21:46,829 --> 01:21:48,719
除以2，得到中点。
divided by 2, to get the halfway point.

1705
01:21:48,720 --> 01:21:52,470
您必须能够对数据结构进行算术运算。
You have to be able to do arithmetic on the data structure.

1706
01:21:52,470 --> 01:21:56,280
我们只是建议摆脱这种随机访问
And we've just proposed getting rid of that random access

1707
01:21:56,279 --> 01:21:59,069
通过过渡到动态数据结构
by transitioning to a dynamic data structure

1708
01:21:59,069 --> 01:22:01,529
像是链表而不是数组。
like a linked list instead of an array.

1709
01:22:01,529 --> 01:22:02,739
但是，如果我们这样做呢？
But what if we do this?

1710
01:22:02,739 --> 01:22:07,139
如果您和我开始不在一个维度上思考，而是在两个维度上思考，该怎么办？
What if you and I start thinking not on one dimension, but on two dimensions?

1711
01:22:07,140 --> 01:22:10,270
如果我们改变思维方式像这样呢？
And what if we alter our thinking to be like this?

1712
01:22:10,270 --> 01:22:13,710
因此，可以将数组视为二维数组
So think of an array, perhaps, as being a two dimensional

1713
01:22:13,710 --> 01:22:18,000
不仅具有长度或长度，而且具有高度的结构。
structure that has not only with or length, but also height.

1714
01:22:18,000 --> 01:22:21,750
因此，我们似乎在视觉上保持了这种关系
And so we maintain, it seems, visually this relationship

1715
01:22:21,750 --> 01:22:23,469
所有这些值之间。
between all of these values.

1716
01:22:23,470 --> 01:22:24,240
但是你知道吗？
But you know what?

1717
01:22:24,239 --> 01:22:28,829
我们可以使用什么将所有这些值缝合在一起？
We can stitch all of these values together using what?

1718
01:22:28,829 --> 01:22:29,699
好吧，指针。
Well, pointers.

1719
01:22:29,699 --> 01:22:32,129
指针是我们可以使用的新的构建基块
Pointers are this new building block that we can use

1720
01:22:32,130 --> 01:22:34,410
将内存中的东西缝合在一起。
to stitch together things in memory.

1721
01:22:34,409 --> 01:22:36,479
如果内存中的内容是数字，那很好。
If the things in memory are numbers, that's fine.

1722
01:22:36,479 --> 01:22:37,229
它们是整数。
They're integers.

1723
01:22:37,229 --> 01:22:40,439
但是如果我们给它们多一点的内存，如果我们使用一个节点，
But if we throw a little more memory at them, if we use a node,

1724
01:22:40,439 --> 01:22:42,839
我们将整数包装在这样的节点中
and we kind of wrap the integer in a node such

1725
01:22:42,840 --> 01:22:46,200
该节点不仅包含数字，还包含指针，
that that node contains not only numbers but pointers,

1726
01:22:46,199 --> 01:22:48,419
我们可能会这样画一幅画，而不是
we could probably draw a picture like this, not

1727
01:22:48,420 --> 01:22:51,510
不像家谱，那里有根
unlike a family tree, where there's a root

1728
01:22:51,510 --> 01:22:54,960
可以这么说，在这种情况下，节点是最顶层，然后是子节点。
node, at the very top in this case, and then children, so to speak.

1729
01:22:54,960 --> 01:22:59,670
左孩子和右孩子，该定义一次又一次地重复。
Left child and right child, and that definition repeats again and again.

1730
01:22:59,670 --> 01:23:04,170
事实证明，计算机科学家确实按顺序使用了此数据结构
And it turns out the computer scientists do use this data structure in order

1731
01:23:04,170 --> 01:23:07,320
具有链接列表的动态性，其中
to have the dynamism of a linked list, where

1732
01:23:07,319 --> 01:23:10,679
您可以向树中添加越来越多的节点
you can add more and more nodes to the tree

1733
01:23:10,680 --> 01:23:13,740
只是增加越来越小的正方形
by just adding more and more squares even lower

1734
01:23:13,739 --> 01:23:15,389
比1、3、5和7。
than the 1, the 3, the 5, and the 7.

1735
01:23:15,390 --> 01:23:18,307
只需使用更多的指针就可以将它们缝合在一起，
And just use more pointers to kind of stitch them together, to sort of

1736
01:23:18,306 --> 01:23:22,019
如果可以的话，垂直，向下，向下，向下生长树。
grow the tree vertically, down, down, down, if you will.

1737
01:23:22,020 --> 01:23:25,530
但是优秀的计算机科学家会认识到，您不应该只是
But a good computer scientist would recognize that you shouldn't just

1738
01:23:25,529 --> 01:23:27,779
将这些数字放在随机的位置，否则，
put these numbers in random locations, otherwise,

1739
01:23:27,779 --> 01:23:29,489
你真的只是在浪费时间。
you're really just wasting your time.

1740
01:23:29,489 --> 01:23:30,829
您应该使用一些算法。
You should use some algorithm.

1741
01:23:30,829 --> 01:23:31,329
并注意。
And notice.

1742
01:23:31,329 --> 01:23:36,639
有人注意到这个树的图案吗？
Does anyone notice the pattern to this tree?

1743
01:23:36,640 --> 01:23:39,850
任何人都可以在聊天中进行口头表达或文字化吗
Can anyone verbalize or textualize in the chat

1744
01:23:39,850 --> 01:23:44,410
这棵树中的这七个节点显示了什么模式？
what pattern is manifest by these seven nodes in this tree?

1745
01:23:44,409 --> 01:23:46,129
它们不是随机排列的。
They're not randomly ordered.

1746
01:23:46,130 --> 01:23:50,230
他们是故意从左到右，从上到下订购的，
They're very deliberately ordered left to right, top to bottom,

1747
01:23:50,229 --> 01:23:51,039
以某种方式。
in a certain way.

1748
01:23:51,039 --> 01:23:55,359
任何人都可以指望这个东西的定义是什么？
Can anyone put their finger on what the definition of this thing is?

1749
01:23:55,359 --> 01:23:57,699
除此以外最重要的特征是什么
What is the most important characteristic besides it

1750
01:23:57,699 --> 01:24:00,819
像家谱一样被吸引？
just being drawn like a family tree?

1751
01:24:00,819 --> 01:24:02,049
[？格雷格？ ？]
[? Greg? ?]

1752
01:24:02,050 --> 01:24:05,353
听众：您把它们放在中间，
AUDIENCE: You have put in the middle of them,

1753
01:24:05,353 --> 01:24:07,270
在它们之上，您已经放置了中间数字。
on top of them you have put the middle number.

1754
01:24:07,270 --> 01:24:09,550
例如，在1到3之间，您放了2。
For example, between 1 and 3, you have put 2.

1755
01:24:09,550 --> 01:24:13,240
在5到7之间，您放置了6。
Between 5 and 7, you have put 6.

1756
01:24:13,239 --> 01:24:15,604
因此，在它们之上，您已放置了中间数字。
So on top of them, you have put the middle number.

1757
01:24:15,604 --> 01:24:16,479
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

1758
01:24:16,479 --> 01:24:18,271
所有数字都有这种模式。
There's this pattern to all of the numbers.

1759
01:24:18,271 --> 01:24:19,329
在1和3之间是2。
Between 1 and 3 is 2.

1760
01:24:19,329 --> 01:24:20,739
在5到7之间是6。
Between 5 and 7 is 6.

1761
01:24:20,739 --> 01:24:22,594
2到6之间是4。
Between 2 and 6 is 4.

1762
01:24:22,595 --> 01:24:24,970
本质上，它甚至不必是中间数字。
And it doesn't even have to be the middle number, per se.

1763
01:24:24,970 --> 01:24:27,310
我可以概括一下并发表评论
I can generalize it a little bit and comment

1764
01:24:27,310 --> 01:24:30,760
也就是说，如果您在树中选择任何节点，可以这么说，
that, if you pick any node in this tree, so to speak,

1765
01:24:30,760 --> 01:24:33,700
它的左孩子将小于其价值，
its left child will be less than its value,

1766
01:24:33,699 --> 01:24:36,609
它的正确孩子的价值将大于其价值。
and its right child's will be greater than its value.

1767
01:24:36,609 --> 01:24:38,289
我们可以一次又一次地做到这一点。
And we can do that again and again.

1768
01:24:38,289 --> 01:24:39,099
所以这里是4。
So here's 4.

1769
01:24:39,100 --> 01:24:40,270
它的左孩子是2。
Its left child is 2.

1770
01:24:40,270 --> 01:24:41,050
小于。
That's less than.

1771
01:24:41,050 --> 01:24:41,650
这是4。
Here's 4.

1772
01:24:41,649 --> 01:24:42,759
对6岁的孩子来说是正确的。
It's right child to 6.

1773
01:24:42,760 --> 01:24:43,750
大于。
That's greater than.

1774
01:24:43,750 --> 01:24:44,750
我们可以再做一次。
We can do this again.

1775
01:24:44,750 --> 01:24:45,489
我们去2。
Let's go to 2.

1776
01:24:45,489 --> 01:24:47,349
它的左子项为1，该子项较小。
Its left child is 1, which is less.

1777
01:24:47,350 --> 01:24:49,480
它的正确孩子是3，甚至更多。
Its right child is 3, which is more.

1778
01:24:49,479 --> 01:24:51,849
6，其左子项为5，该子项更少。
6, its left child is 5, which is less.

1779
01:24:51,850 --> 01:24:54,660
6，它的正确的孩子是7，更多。
6, its right child is 7, which is more.

1780
01:24:54,659 --> 01:24:56,409
所以这实际上是，如果您不介意的话
And so this is actually, if you don't mind

1781
01:24:56,409 --> 01:25:00,729
上周的回顾性递归，这是一个递归定义。
the revisiting recursion from last week, this is a recursive definition.

1782
01:25:00,729 --> 01:25:03,139
这是一个递归数据结构。
This is a recursive data structure.

1783
01:25:03,140 --> 01:25:05,230
因此，不仅算法或函数
So it's not only algorithms or functions that

1784
01:25:05,229 --> 01:25:07,329
可以通过调用自己来递归。
can be recursive by calling themselves.

1785
01:25:07,329 --> 01:25:10,299
数据结构也可以是递归的。
A data structure can also be recursive.

1786
01:25:10,300 --> 01:25:12,440
毕竟这是什么东西？
After all, what is this thing?

1787
01:25:12,439 --> 01:25:13,569
这是一棵树，是的。
This is a tree, yes.

1788
01:25:13,569 --> 01:25:14,589
我会规定。
I'll stipulate.

1789
01:25:14,590 --> 01:25:18,520
但是从技术上讲，它是一棵有两棵树的树。
But it's technically a tree with two trees.

1790
01:25:18,520 --> 01:25:19,120
正确的？
Right?

1791
01:25:19,119 --> 01:25:23,139
这个第四个节点在技术上有两个孩子。
This node here, number four, technically has two children.

1792
01:25:23,140 --> 01:25:25,750
每个孩子本身就是一棵树。
And each of those children is itself a tree.

1793
01:25:25,750 --> 01:25:27,070
它是一棵较小的树。
It's a smaller tree.

1794
01:25:27,069 --> 01:25:29,829
但这是一次又一次的完全相同的定义。
But it's the same exact definition again and again.

1795
01:25:29,829 --> 01:25:32,709
每当我们看到递归数据结构时，
And any time we see a recursive data structure,

1796
01:25:32,710 --> 01:25:35,350
这实际上将是使用递归代码的机会，
it's actually going to be an opportunity to use recursive code,

1797
01:25:35,350 --> 01:25:37,183
我们待会儿会介绍。
which we'll take a look at in just a moment.

1798
01:25:37,182 --> 01:25:39,289
但是现在，请注意我们再次取得的成就，
But for now, notice what we've achieved again,

1799
01:25:39,289 --> 01:25:42,699
使用指针的动力，以便我们可以（如果需要），
the dynamism of using pointer so that we can, if we want,

1800
01:25:42,699 --> 01:25:45,489
向该树添加更多节点，例如通过将它们串起来
add more nodes to this tree, as by stringing them

1801
01:25:45,489 --> 01:25:47,709
沿着底部以正确的顺序排列。
along the bottom in the correct order.

1802
01:25:47,710 --> 01:25:51,970
但是，我们保留了二进制搜索的重要顺序，
And yet, we've preserved an important order for binary search,

1803
01:25:51,970 --> 01:25:55,960
也就是这种数据结构的正式名称，二进制搜索树，
AKA, the formal name of this data structure, binary search tree,

1804
01:25:55,960 --> 01:26:00,190
通过确保左孩子总是更少，右孩子总是更多。
by making sure that left child is always less, right child is always more.

1805
01:26:00,189 --> 01:26:03,789
因为现在，我们可以更有效地搜索此内容。
Because now, we can go about searching this thing more efficiently.

1806
01:26:03,789 --> 01:26:04,299
如何？
How?

1807
01:26:04,300 --> 01:26:06,800
好吧，如果我想搜索数字3，该怎么办？
Well, if I want to search for the number 3, what do I do?

1808
01:26:06,800 --> 01:26:08,592
好吧，我从树的开头开始。
Well, I start at the beginning of the tree.

1809
01:26:08,591 --> 01:26:13,027
就像链接列表一样，您从链接列表的开头开始。
Just like with a linked list, you start at the beginning of the linked list.

1810
01:26:13,028 --> 01:26:15,820
因此，从树的根部开始，树[[？总是。 ？]
So with the tree, you start with the root of the tree [? always. ?]

1811
01:26:15,819 --> 01:26:17,409
假设我要搜索3。
Suppose I want to search for 3.

1812
01:26:17,409 --> 01:26:18,799
好吧，我该怎么办？
Well, what do I do?

1813
01:26:18,800 --> 01:26:21,220
好吧，3明显小于4。
Well, 3 is obviously less than 4.

1814
01:26:21,220 --> 01:26:23,980
因此，就像在第0周将电话簿撕成两半一样，
So just like in Week 0 where I tore the phone book in half,

1815
01:26:23,979 --> 01:26:27,339
您现在可以将其砍倒一半。
you can now think of this as chopping down half of the tree.

1816
01:26:27,340 --> 01:26:30,130
因为您知道3（如果存在）绝对不是
Because you know 3, if it's present, is definitely not

1817
01:26:30,130 --> 01:26:33,790
将会在这里的任何地方，因此我们可以将注意力集中在这里。
going to be anywhere over here, so we can focus our attention down here.

1818
01:26:33,789 --> 01:26:34,834
这是数字2。
Here's the number 2.

1819
01:26:34,835 --> 01:26:35,710
这是另一棵树。
This is another tree.

1820
01:26:35,710 --> 01:26:37,780
如果愿意的话，它只是一个较小的子树。
It's just a smaller subtree, if you will.

1821
01:26:37,779 --> 01:26:39,009
我如何找到数字3？
How do I find the number 3?

1822
01:26:39,010 --> 01:26:41,290
好吧，我向右看，因为它大于。
Well, I look to the right because it's greater than.

1823
01:26:41,289 --> 01:26:43,369
繁荣，我找到了。
And boom, I found it.

1824
01:26:43,369 --> 01:26:46,329
但是相比之下，假设我正在搜索数字8。
But by contrast, suppose I were searching for the number 8.

1825
01:26:46,329 --> 01:26:47,349
我将从这里开始。
I would start here.

1826
01:26:47,350 --> 01:26:48,130
我会看这里。
I would look here.

1827
01:26:48,130 --> 01:26:48,880
我会看这里。
I would look here.

1828
01:26:48,880 --> 01:26:51,560
然后得出结论，不，它不存在。
And then conclude, no, it's not there.

1829
01:26:51,560 --> 01:26:53,680
但是，每次我搜索那个8时，
But, again, every time I search for that 8,

1830
01:26:53,680 --> 01:26:58,400
我忽略了树的一半，子树的一半，依此类推。
I'm ignoring this half of the tree, this half of the subtree, and so forth.

1831
01:26:58,399 --> 01:27:00,219
这样看来，您将要实现，
So you're going to achieve, it would seem,

1832
01:27:00,220 --> 01:27:03,730
从第0周开始，我们便看到了同样的力量和表现。
the same kind of power, the same kind of performance as we saw from Week 0.

1833
01:27:03,729 --> 01:27:06,249
那么，我们如何将这个想法转化为代码呢？
So how do we translate this idea now into code?

1834
01:27:06,250 --> 01:27:08,110
我们已经有了所有的构建基块。
We have all the building blocks already.

1835
01:27:08,109 --> 01:27:11,019
让我继续提议，而不是节点
Let me go ahead and propose that, instead of the node

1836
01:27:11,020 --> 01:27:15,130
我们以前使用过的链表，看起来像这样，有一个数字和一个
we used before for a linked list, which looked like this, with a number and one

1837
01:27:15,130 --> 01:27:16,480
称为下一个的指针
pointer called next--

1838
01:27:16,479 --> 01:27:19,437
但是，同样，我们可以将这些东西称为“任何东西”-让我们继续
but, again, we could have called those things anything-- let's go ahead

1839
01:27:19,438 --> 01:27:24,580
不仅为数字腾出空间，而且为两个指针腾出空间，一个
and make room for not just a number, but also two pointers, one

1840
01:27:24,579 --> 01:27:27,369
我叫左，我叫右。
that I'll call left, one that I'll call right.

1841
01:27:27,369 --> 01:27:30,729
这些都仍然是指向结构节点的指针。
Both of those is still a pointer to a struct node.

1842
01:27:30,729 --> 01:27:35,169
和以前一样，但现在我有两个指针，而不是一个
So same terminology as before, but now I have two pointers instead of one

1843
01:27:35,170 --> 01:27:38,560
这样一来，您可以从概念上指向左侧并指向较小的
so that one can conceptually point to the left and point to a smaller

1844
01:27:38,560 --> 01:27:39,190
子树。
subtree.

1845
01:27:39,189 --> 01:27:43,119
可以指向右边并指向更大的子树。
One can point to the right and point to a larger subtree.

1846
01:27:43,119 --> 01:27:46,101
那么，我们如何实现类似于二进制搜索的东西呢？
So how do we go about implementing something like binary search?

1847
01:27:46,101 --> 01:27:47,559
好吧，让我们实际看一些代码。
Well, let's actually see some code.

1848
01:27:47,560 --> 01:27:50,140
这就是递归真正变得很酷的地方。
And this is where recursion really gets kind of cool.

1849
01:27:50,140 --> 01:27:53,560
我们在构建[时会强制使用它吗？ Maro的？]金字塔与递归。
We kind of forced it when building [? Maro's ?] pyramid with recursion.

1850
01:27:53,560 --> 01:27:55,180
就像，是的，您可以做到。
Like, yeah, you can do it.

1851
01:27:55,180 --> 01:27:59,110
是的，我声称金字塔是递归的物理结构
And yes, the pyramid was, I claimed, a recursive physical structure

1852
01:27:59,109 --> 01:28:00,879
或游戏中的虚拟结构。
or virtual structure in the game.

1853
01:28:00,880 --> 01:28:05,680
但是有了数据结构和指针，现在递归确实开始崭露头角了。
But with data structures and pointers, now recursion really starts to shine.

1854
01:28:05,680 --> 01:28:06,970
因此，让我们考虑一下。
So let's consider this.

1855
01:28:06,970 --> 01:28:10,060
如果我用C声明一个函数，其作用是生命
If I declare a function in C whose purpose in life

1856
01:28:10,060 --> 01:28:13,660
是在树上搜索数字，按照定义，
is to search a tree for a number, it's going to, by definition,

1857
01:28:13,659 --> 01:28:15,579
从根向下搜索。
search from the root on down.

1858
01:28:15,579 --> 01:28:16,819
我们如何实现呢？
How do we implement this?

1859
01:28:16,819 --> 01:28:19,277
好吧，我将建议的功能是返回布尔值。
Well, my function, I'll propose, is going to return a bool.

1860
01:28:19,278 --> 01:28:22,180
对或错，数字在树中，是或否。
True or false, the number is in the tree, yes or no.

1861
01:28:22,180 --> 01:28:27,070
它需要两个参数，一个指向节点的指针，即AKA树。
It's going to take two arguments, a pointer to a node, AKA tree.

1862
01:28:27,069 --> 01:28:29,441
我可以称其为root或其他名称。
I could call it root or anything else.

1863
01:28:29,442 --> 01:28:31,150
这将需要一个数字，这是
And it's going to take a number, which is

1864
01:28:31,149 --> 01:28:36,019
我关心的数字，无论是4还是6或8或其他任何数字。
the number I care about, whether it's four or six or eight or anything else.

1865
01:28:36,020 --> 01:28:38,450
那么，我的第一段代码将是什么？
So what's going to be my first chunk of code?

1866
01:28:38,449 --> 01:28:41,759
好吧，让我做我不断讲道的最佳实践。
Well, let me do the best practice that I keep preaching.

1867
01:28:41,760 --> 01:28:44,860
每当您处理指针时，请检查是否为空
Any time you're dealing with pointers, check for null

1868
01:28:44,859 --> 01:28:47,709
这样您的程序就不会冻结或崩溃，也不会发生坏事。
so that your program doesn't freeze or crash or bad thing happens.

1869
01:28:47,710 --> 01:28:48,460
因为谁知道？
Because who knows?

1870
01:28:48,460 --> 01:28:51,190
也许您会偶然或故意
Maybe you will accidentally or maybe intentionally

1871
01:28:51,189 --> 01:28:53,829
在空指针上传递此函数，因为没有树。
pass this function on null pointer, because there's no tree.

1872
01:28:53,829 --> 01:28:54,999
也许你会搞砸。
Maybe you'll screw up.

1873
01:28:55,000 --> 01:28:57,879
只要您的代码是自卫的，就可以了。
And that's OK, so long as your code is self-defensive.

1874
01:28:57,880 --> 01:28:59,740
因此，请务必检查指针是否为空。
So always check pointers for null.

1875
01:28:59,739 --> 01:29:02,709
如果是这样，如果树为空，即那里没有树，
If so, if the tree is null, that is, there is no tree there,

1876
01:29:02,710 --> 01:29:04,610
显然，这个数字不存在。
obviously, the number is not present.

1877
01:29:04,609 --> 01:29:06,109
因此，您只需返回false。
So you just return false.

1878
01:29:06,109 --> 01:29:08,409
可以这么说，这是我们的基本情况之一。
So that's one of our base cases, so to speak.

1879
01:29:08,409 --> 01:29:14,869
否则，如果您要查找的数字小于树的自身数字，
Else, if the number you're looking for is less than the tree's own number--

1880
01:29:14,869 --> 01:29:19,389
因此，同样，此箭头符号表示作为树的树，它是一个节点*，
so, again, this arrow notation means take tree, which is a node *,

1881
01:29:19,390 --> 01:29:20,740
所以拿这个指针。
so take this pointer.

1882
01:29:20,739 --> 01:29:22,959
转到实际节点。
Go there to the actual node.

1883
01:29:22,960 --> 01:29:25,450
并查看其自己的数字字段。
And look in its own number field.

1884
01:29:25,449 --> 01:29:28,389
如果您要从参数中寻找数字
If the number you're looking for from the argument

1885
01:29:28,390 --> 01:29:32,010
小于树自己的数字字段中的数字，
is less than the number in the tree's own number field,

1886
01:29:32,010 --> 01:29:33,760
好吧，这意味着您想离开。
well, that means that you want to go left.

1887
01:29:33,760 --> 01:29:36,593
而在电话簿中，我走到电话簿的左侧，
And whereas in the phone book, I went to the left of the phone book,

1888
01:29:36,592 --> 01:29:39,129
在这里，我们将转到左侧的子树。
here we're going to go to the left subtree.

1889
01:29:39,130 --> 01:29:40,630
但是，如何搜索子树？
But how do I search a subtree?

1890
01:29:40,630 --> 01:29:45,430
在这里，树是递归数据结构很重要。
Here's where it's important that a tree is a recursive data structure.

1891
01:29:45,430 --> 01:29:50,000
与以前一样，树是具有新根节点的两个子树。
A tree is two subtrees with a new root node, as before.

1892
01:29:50,000 --> 01:29:54,339
因此，我已经有了可以搜索较小树的代码。
So I already have code via which I can search a smaller tree.

1893
01:29:54,340 --> 01:29:57,730
所以我可以说搜索左侧的子树，
So I can just say search the left subtree,

1894
01:29:57,729 --> 01:30:00,579
如此处所示，这意味着从当前节点开始
as expressed here, which means start at the current node

1895
01:30:00,579 --> 01:30:04,339
并转到左孩子并传递相同的数字。
and go to the left child and pass in the same number.

1896
01:30:04,340 --> 01:30:05,530
人数没有变化。
The number is not changing.

1897
01:30:05,529 --> 01:30:06,939
但是树越来越小。
But the tree is getting smaller.

1898
01:30:06,939 --> 01:30:09,789
我已经用代码有效地将树切成了两半。
I've effectively, in code, chopped the tree in half.

1899
01:30:09,789 --> 01:30:11,319
我忽略了右边的那一半。
And I'm ignoring the right half.

1900
01:30:11,319 --> 01:30:13,989
我将返回任何答案。
And I'm returning whatever that answer is.

1901
01:30:13,989 --> 01:30:16,389
否则，如果我关心的数字更大
Otherwise, if the number I care about is greater

1902
01:30:16,390 --> 01:30:18,760
比当前节点中的数字多，请执行相反的操作。
than the number in the current node, do the opposite.

1903
01:30:18,760 --> 01:30:22,132
搜索正确的子树，并输入相同的数字。
Search the right subtree, passing in the same number.

1904
01:30:22,131 --> 01:30:23,839
因此，就像电话簿一样，
So, again, just like with the phone book,

1905
01:30:23,840 --> 01:30:25,340
它越来越小？
it kept getting smaller and smaller?

1906
01:30:25,340 --> 01:30:28,750
在这里，我继续搜索越来越小的子树。
Here I keep searching a smaller and smaller subtree.

1907
01:30:28,750 --> 01:30:31,810
因为我不断砍掉左或右的分支
Because I keep chopping off branches left or right as

1908
01:30:31,810 --> 01:30:33,710
我从上到下。
I go from top to bottom.

1909
01:30:33,710 --> 01:30:35,530
最后一种情况。
There's one final case.

1910
01:30:35,529 --> 01:30:38,719
让我把这个扔给小组。
And let me toss this out to the group.

1911
01:30:38,720 --> 01:30:41,110
还有第四种情况。
There's a fourth case.

1912
01:30:41,109 --> 01:30:45,849
无论是文字还是文字方式，在这里我还要检查什么？
Verbally or textually, what else should I be checking for and doing here?

1913
01:30:45,850 --> 01:30:48,370
我为最后一种情况留了余地。
I've left room for one final case.

1914
01:30:48,369 --> 01:30:51,832
布莱恩：有人建议树本身就是数字。
BRIAN: A few people are suggesting if the tree itself is the number.

1915
01:30:51,832 --> 01:30:54,249
DAVID MALAN：如果树本身包含数字，是的。
DAVID MALAN: If the tree itself contains the number, yeah.

1916
01:30:54,250 --> 01:30:57,850
因此，如果树中的数字等于
So if the number in the tree equals equals

1917
01:30:57,850 --> 01:31:02,300
我要查找的数字，继续，只有在这种情况下，才返回true。
the number I'm looking for, go ahead and, only in this case, return true.

1918
01:31:02,300 --> 01:31:04,840
这就是代码再次出现的地方-
And so this is where the code, again, gets kind of--

1919
01:31:04,840 --> 01:31:07,570
相反，递归会有点儿弯腰。
recursion, rather, gets a little mind-bending.

1920
01:31:07,569 --> 01:31:11,119
我在这里只有虚假的东西，在这里是真实的。
I only have false up here, true here.

1921
01:31:11,119 --> 01:31:16,039
但不要在这两个中间的两个分支中的任何一个中使用双关语（如果您愿意的话）。
But not in either of these middle two branches, no pun intended, if you will.

1922
01:31:16,039 --> 01:31:17,169
但是没关系。
But that's OK.

1923
01:31:17,170 --> 01:31:21,220
因为我的代码以这样的方式设计：如果我搜索左子树
Because my code is designed in such a way that if I search the left subtree

1924
01:31:21,220 --> 01:31:24,580
那里什么也没有，就像我在树的叶子上，
and there's nothing there, like, literally I'm at the leaf of the tree,

1925
01:31:24,579 --> 01:31:26,534
可以这么说，那么它将返回false。
so to speak, then it's going to return false.

1926
01:31:26,534 --> 01:31:27,159
这样很好
So that's fine.

1927
01:31:27,159 --> 01:31:28,689
就像，如果我搜索数字8。
That's, like, if I search for the number 8.

1928
01:31:28,689 --> 01:31:29,889
它甚至不在树上。
It's not even in the tree.

1929
01:31:29,890 --> 01:31:32,640
我只会意识到，一旦我跌落到树的尽头
I'm only going to realize that once I fall off the end of the tree

1930
01:31:32,640 --> 01:31:33,740
看看，哎呀，null
and see, oops, null.

1931
01:31:33,739 --> 01:31:35,179
我将返回false。
I'll just return false.

1932
01:31:35,180 --> 01:31:38,750
但是，如果我一路上看到数字，我将返回true。
But if I ever see the number along the way, I will return true.

1933
01:31:38,750 --> 01:31:43,144
还有这两个内部搜索请求，这两个递归搜索请求，
And these two inner calls to search, these two recursive calls to search,

1934
01:31:43,145 --> 01:31:44,770
就像在推卸责任。
are just kind of like passing the buck.

1935
01:31:44,770 --> 01:31:47,590
除了自己回答是非，
Instead of answering true or false themselves,

1936
01:31:47,590 --> 01:31:51,070
他们将返回较小问题的答案
they're returning whatever the answer to a smaller question

1937
01:31:51,069 --> 01:31:55,669
是分别搜索左或右树。
is by searching the left or right tree instead respectively.

1938
01:31:55,670 --> 01:31:57,520
所以，这又是递归开始的地方
So, again, this is where recursion starts

1939
01:31:57,520 --> 01:32:02,620
变得不是真正地被迫甚至不一定被迫地被迫，
to get not really forced or even necessarily really as forced,

1940
01:32:02,619 --> 01:32:04,329
但确实是适当的。
but really as appropriate.

1941
01:32:04,329 --> 01:32:08,499
当您的数据本身是递归的时，则将递归作为一种编码技术
When your data is itself recursive, then recursion in as a coding technique

1942
01:32:08,500 --> 01:32:10,600
真的很闪耀。
really rather shines.

1943
01:32:10,600 --> 01:32:14,020
所以，如果最终，我们有-哦[？ ？]次优化。
So if ultimately, we have-- oh, [? an ?] minor optimization.

1944
01:32:14,020 --> 01:32:15,975
正如我们可能在第0周注意到Scratch一样，
As we might have noted in Week 0 with Scratch,

1945
01:32:15,975 --> 01:32:18,850
当然，我们不需要显式检查数量是否相等。
we, of course, don't need to explicitly check if the number is equal.

1946
01:32:18,850 --> 01:32:22,695
我们可以摆脱最后一个条件，并假设它不为null
We can get rid of that last condition and just assume that if it's not null

1947
01:32:22,694 --> 01:32:24,819
它不在左边，也不在右边，
and it's not to the left and it's not to the right,

1948
01:32:24,819 --> 01:32:27,259
我们必须站在它上面。
we must be standing right on top of it.

1949
01:32:27,260 --> 01:32:29,230
因此，我们在那里才返回true。
And so we just return true there.

1950
01:32:29,229 --> 01:32:31,839
好吧，让我在这里总结一下图片。
Well, let me summarize the picture here.

1951
01:32:31,840 --> 01:32:33,940
现在这是一个二维数据结构。
This is now a two dimensional data structure.

1952
01:32:33,939 --> 01:32:38,019
它比二维链表更好，因为它现在是二维的。
And it's sort of better than a linked list in that now it's two dimensions.

1953
01:32:38,020 --> 01:32:40,750
我获得了二进制搜索，这非常了不起，所以
I gain back binary search, which is amazing, so

1954
01:32:40,750 --> 01:32:45,459
只要我按照此二叉搜索树定义将数据按排序顺序保留即可。
long as I keep my data in sorted order per this binary search tree definition.

1955
01:32:45,460 --> 01:32:47,480
但是我肯定已经付出了代价。
But I've surely paid a price.

1956
01:32:47,479 --> 01:32:47,979
正确的？
Right?

1957
01:32:47,979 --> 01:32:52,989
到目前为止，没有什么绝对比我们的故事中的其他任何事情更好。
Nothing is absolutely better than anything else in our story thus far.

1958
01:32:52,989 --> 01:32:56,079
那么，一棵树的缺点是什么？
So what is the downside of a tree?

1959
01:32:56,079 --> 01:32:59,589
我在这里秘密或不秘密地支付了什么价格，
What price have I secretly or not so secretly paid here,

1960
01:32:59,590 --> 01:33:02,710
在宣扬树木的优点时？
while preaching the upsides of trees?

1961
01:33:02,710 --> 01:33:06,700
而且，答案通常是在这种情况下的空间或时间，
And, again, the answer is often in this context sort of space, or time,

1962
01:33:06,699 --> 01:33:13,139
或开发人员的时间，金钱或个人或实物的某些资源，
or developer time, or money, or some resource, personal, or physical,

1963
01:33:13,140 --> 01:33:14,800
或真实世界。
or real world.

1964
01:33:14,800 --> 01:33:15,300
是的。
Yeah.

1965
01:33:15,300 --> 01:33:17,970
怎么过[听不清]？
How about over to [INAUDIBLE]?

1966
01:33:17,970 --> 01:33:24,000
听众：所以我认为插入不再是固定的时间。
AUDIENCE: So I think that inserting is no longer constant time.

1967
01:33:24,000 --> 01:33:25,649
而且我想我们需要更多的内存。
And I guess we need more memory.

1968
01:33:25,649 --> 01:33:28,679
您需要记忆来[？排序？]两个指针，而不是一次。
You need memory to [? sort ?] two pointers instead of one this time.

1969
01:33:28,680 --> 01:33:29,430
戴维·马兰：是的。
DAVID MALAN: Yeah.

1970
01:33:29,430 --> 01:33:32,220
似乎插入不再是固定时间。
It seems insertion is no longer constant time.

1971
01:33:32,220 --> 01:33:35,940
因为如果我需要保留排序的顺序，就不能仅将其放在最前面。
Because if I need to preserve sorted order, I can't just put it at the top.

1972
01:33:35,939 --> 01:33:37,979
我不能一直压低其他一切
I can't just keep pushing everything else down

1973
01:33:37,979 --> 01:33:39,562
因为事情可能会变得混乱。
because things might get out of order.

1974
01:33:39,563 --> 01:33:43,110
在这种情况下，它会[？似乎。 ？]或者，即使我维持订单，
In that case, it would [? seem. ?] Or rather, even if I maintain the order,

1975
01:33:43,109 --> 01:33:45,179
它可能会变得很长且很刺耳。
it might kind of get very long and stringy.

1976
01:33:45,180 --> 01:33:48,507
例如，如果我加上另一个数字，另一个数字，
If I add, for instance, another number, another number,

1977
01:33:48,506 --> 01:33:50,339
我一直把它塞在顶部
and I keep jamming it at the top, I probably

1978
01:33:50,340 --> 01:33:52,890
如果可以的话，需要保持平衡。
need to kind of keep things balanced, if you will.

1979
01:33:52,890 --> 01:33:55,590
是的，更重要的是，我立刻
And yeah, the bigger point, too, is that immediately I'm

1980
01:33:55,590 --> 01:33:57,660
使用两倍多的指针。
using twice as many pointers.

1981
01:33:57,659 --> 01:34:00,719
所以现在我的节点变得比这些东西还要大。
So now my node is getting even bigger than these things.

1982
01:34:00,720 --> 01:34:03,360
现在，我不仅有空间容纳数字和指针，
I now have room for not only a number and a pointer,

1983
01:34:03,359 --> 01:34:06,779
但是还有另一个指针，这当然会花费我更多的空间。
but another pointer, which is, of course, going to cost me more space.

1984
01:34:06,779 --> 01:34:08,029
同样，在那儿进行权衡。
Again, so a trade off there.

1985
01:34:08,029 --> 01:34:09,779
让我们继续问这里的小组，
And let's go ahead and ask the group here,

1986
01:34:09,779 --> 01:34:13,079
当涉及插入时，为什么我们暂时不考虑
when it comes to insertion, why don't we consider for a moment what

1987
01:34:13,079 --> 01:34:17,499
插入的运行时间可能是插入二进制搜索时的时间
the running time of insertion might be when inserting into a binary search

1988
01:34:17,500 --> 01:34:18,000
树。
tree.

1989
01:34:18,000 --> 01:34:20,458
如果您想像往常一样提取网址，请让我继续
If you'd like to pull up the URL as always, let me go ahead

1990
01:34:20,457 --> 01:34:22,449
并提出这一点。
and present this one.

1991
01:34:22,449 --> 01:34:26,649
插入二叉搜索树的运行时间是多少？
What's the running time of inserting into a binary search tree?

1992
01:34:26,649 --> 01:34:29,369
因此，如果您要将数字0插入该树，
So if you want to insert the number 0 into that tree,

1993
01:34:29,369 --> 01:34:36,389
如果您想插入数字8，或者介于两者之间或更大的数字
if you want to insert the number 8, or anything in between or bigger

1994
01:34:36,390 --> 01:34:39,580
或更小，这里的答案是什么？
or smaller, what are the answers here?

1995
01:34:39,579 --> 01:34:42,539
因此，获得最高酒吧的胜利并不算太大。
So not quite as big of a victory for the tallest bar.

1996
01:34:42,539 --> 01:34:44,679
大约60％的人认为log n。
About 60% of you think log n.

1997
01:34:44,680 --> 01:34:46,680
坦率地说，那里的良好本能是如此
And the good instincts there, frankly, are so

1998
01:34:46,680 --> 01:34:47,970
那将是正确的答案。
that is going to be the right answer.

1999
01:34:47,970 --> 01:34:49,553
这是正确的本能。
And that's kind of the right instinct.

2000
01:34:49,552 --> 01:34:52,919
每当您进行二分查找时，您说的都是对数的几率。
Anytime you have binary search, odds are you're talking something logarithmic.

2001
01:34:52,920 --> 01:34:56,730
但是我们也看到了用n log n进行分治和合并排序，
But we've also seen divide and conquer and merge sort with n log n,

2002
01:34:56,729 --> 01:34:59,384
因此约有10％的人也这么认为。
so not unreasonable that about 10% of you think that, too.

2003
01:34:59,385 --> 01:35:01,230
n平方实际上是不好的。
n squared would actually be bad.

2004
01:35:01,229 --> 01:35:04,829
因此，n平方是迄今为止我们所见过的最糟糕的时期。
So n squared is, like, the worst of the times we've seen thus far.

2005
01:35:04,829 --> 01:35:08,342
这表明一棵树比一个链表还要糟，
And that would suggest that a tree is even worse than a linked list,

2006
01:35:08,342 --> 01:35:09,509
比数组还差
is even worse than an array.

2007
01:35:09,510 --> 01:35:11,340
值得庆幸的是，我们还没有到那时。
And thankfully, we're not at that point.

2008
01:35:11,340 --> 01:35:14,790
但是根据某些假设，它的确是log n。
But it's indeed log n, based on certain assumptions.

2009
01:35:14,789 --> 01:35:16,359
那为什么呢？
So why is that?

2010
01:35:16,359 --> 01:35:19,349
因此，如果我们考虑一下刚才的那棵树，
So if we consider the tree from a moment ago,

2011
01:35:19,350 --> 01:35:21,430
看起来有点像这样。
it looked a little something like this.

2012
01:35:21,430 --> 01:35:25,740
插入树中涉及什么？
And what is involved in inserting into a tree?

2013
01:35:25,739 --> 01:35:27,779
好吧，假设我要插入数字8。
Well, suppose I want to insert the number 8.

2014
01:35:27,779 --> 01:35:28,829
好吧，我从这里开始。
Well, I start here.

2015
01:35:28,829 --> 01:35:31,409
它显然属于右图，因为8更大。
And it obviously belongs to the right because 8 is bigger.

2016
01:35:31,409 --> 01:35:32,156
我去这里
I go here.

2017
01:35:32,157 --> 01:35:33,990
它属于右边，因为8更大。
It belongs to the right because 8 is bigger.

2018
01:35:33,989 --> 01:35:34,569
我去这里
I go here.

2019
01:35:34,569 --> 01:35:36,249
它属于右边，因为8更大。
It belongs to the right, because 8 is bigger.

2020
01:35:36,250 --> 01:35:38,790
因此，将在此处某处创建一个新节点。
And so a new node is going to be created somewhere down here.

2021
01:35:38,789 --> 01:35:41,519
即使它不能显示在屏幕上，我也可以绝对调用malloc。
And even though it doesn't fit on the screen, I could absolutely call malloc.

2022
01:35:41,520 --> 01:35:43,020
我可以更新几个指针。
I could update a couple of pointers.

2023
01:35:43,020 --> 01:35:46,120
繁荣时期，我们在树上添加了第八个节点。
And boom, we've added an eighth node to the tree.

2024
01:35:46,119 --> 01:35:51,719
因此，如果我花了很多步骤，从根目录1、2、3开始，
So if it took me that many steps, starting at the root, 1, 2, 3,

2025
01:35:51,720 --> 01:35:55,660
如何将其概括为Big O表示法？
how do I generalize this into Big O notation?

2026
01:35:55,659 --> 01:36:00,359
好吧，二叉搜索树，如果您像这样很好地布置它们，
Well, a binary search tree, if you lay it out nice and prettily like this,

2027
01:36:00,359 --> 01:36:04,289
如果您愿意的话，该二叉搜索树的高度会很好并且平衡，
nice and balanced if you will, the height of that binary search tree,

2028
01:36:04,289 --> 01:36:06,809
事实证明，它将是n的对数。
it turns out, is going to be log of n.

2029
01:36:06,810 --> 01:36:11,310
如果n是故事中的总节点数（现在为7或8），则
If n is the number of total nodes, 7 or 8 now in the story, then

2030
01:36:11,310 --> 01:36:14,770
n的对数底数2将是树的高度。
log base 2 of n is going to be the height of the tree.

2031
01:36:14,770 --> 01:36:18,060
因此，如果采用n个节点，n个数字，并且
So if you take n nodes, n numbers, and you kind of

2032
01:36:18,060 --> 01:36:22,770
以一种很好的排序方式平衡它们，总高度将为log n。
balance them in this nice sorted way, the total height is going to be log n.

2033
01:36:22,770 --> 01:36:24,690
那么插入的运行时间是多少？
So what is the running time of insert?

2034
01:36:24,689 --> 01:36:27,659
好了，insert的运行时间等于多少
Well, the running time of insert is equivalent to how many

2035
01:36:27,659 --> 01:36:30,959
您是否需要执行以下步骤才能找到其中的位置
steps does it take you to find the location into which

2036
01:36:30,960 --> 01:36:32,010
新号码属于？
the new number belongs?

2037
01:36:32,010 --> 01:36:33,480
好吧，那是1,2,3。
Well, that's 1, 2, 3.

2038
01:36:33,479 --> 01:36:36,719
事实证明，以2为底的对数确实是3。
And as it turns out, log base 2 of 8 is indeed 3.

2039
01:36:36,720 --> 01:36:39,300
因此，在这种情况下，数学运算实际上是完美的。
So the math actually works out perfectly in this case.

2040
01:36:39,300 --> 01:36:41,383
有时，可能会有一些舍入错误。
Sometimes, there might be a little rounding error.

2041
01:36:41,382 --> 01:36:45,989
但总的来说，这确实将是log n的大O。
But in general it's going to indeed be Big O of log n.

2042
01:36:45,989 --> 01:36:48,419
但是，如果我们有点草率呢？
But what if we get a little sloppy?

2043
01:36:48,420 --> 01:36:50,550
如果我们有点草率并且开始
What if we get a little sloppy and we start

2044
01:36:50,550 --> 01:36:56,710
插入使我们有些倒霉的节点，如果愿意的话？
inserting nodes that are giving us a bit of bad luck, if you will?

2045
01:36:56,710 --> 01:37:00,090
举例来说，假设我继续进行-让
So for instance, suppose that I go ahead-- and let

2046
01:37:00,090 --> 01:37:02,430
我在这里忙着做一些事。
me do something on the fly here.

2047
01:37:02,430 --> 01:37:09,570
假设我继续插入数字1，数字2，
Suppose that I go ahead and insert the number 1, the number 2,

2048
01:37:09,569 --> 01:37:13,589
和数字3，这样逻辑上就会发生这种情况。
and the number 3 such that this is what logically happens.

2049
01:37:13,590 --> 01:37:16,230
这符合二叉搜索树的定义。
This adheres to the definition of a binary search tree.

2050
01:37:16,229 --> 01:37:18,209
如果这是根源，则为1。
If this is the roots, it's 1.

2051
01:37:18,210 --> 01:37:21,462
它没有左子树，这绝对不是问题，
It has no left subtree, and that's not strictly a problem,

2052
01:37:21,462 --> 01:37:24,420
因为这里没有什么违反搜索树的定义的。
because there's nothing violating the definition of a search tree here.

2053
01:37:24,420 --> 01:37:25,560
那里什么都没有。
There's just nothing there.

2054
01:37:25,560 --> 01:37:26,850
2在正确的位置。
2 is in the right place.

2055
01:37:26,850 --> 01:37:28,690
3在正确的位置。
3 is in the right place.

2056
01:37:28,689 --> 01:37:32,459
因此，从技术上讲，这也是二叉搜索树。
So this, too, technically is a binary search tree.

2057
01:37:32,460 --> 01:37:35,890
但这是一个极端的情况，一个反常的情况，如果您愿意的话，
But it's a bit of a corner case, a perverse case, if you will,

2058
01:37:35,890 --> 01:37:40,410
您插入事物的方式最终在二进制搜索树中最终到达的位置
where the way you inserted things ended up in the binary search tree actually

2059
01:37:40,409 --> 01:37:44,789
如果要在聊天中发出声音，您会说类似什么？
resembling more of a what, would you say, if you want to chime in the chat?

2060
01:37:44,789 --> 01:37:46,711
还有Brian，如果您想中继一下？
And Brian, if you might want to relay?

2061
01:37:46,712 --> 01:37:49,170
布莱恩：一些人说它看起来像一个链表。
BRIAN: A few people are saying it looks like a linked list.

2062
01:37:49,170 --> 01:37:49,920
戴维·马兰：是的。
DAVID MALAN: Yeah.

2063
01:37:49,920 --> 01:37:52,050
因此，即使我已将其自上而下绘制，
So even though I've drawn it sort of top down,

2064
01:37:52,050 --> 01:37:53,820
所以在第二维上，那就是
so in the sort of second dimension, that's

2065
01:37:53,819 --> 01:37:55,589
真的只是艺术家的表演。
really just an artist's rendition.

2066
01:37:55,590 --> 01:37:58,800
该树是二进制搜索树。
This tree is a binary search tree.

2067
01:37:58,800 --> 01:38:00,960
但这也是一种链表。
But it's kind of sort of also a linked list.

2068
01:38:00,960 --> 01:38:03,450
因此，即使是意图最明确的数据
And so even the most well-intentioned data

2069
01:38:03,449 --> 01:38:08,489
输入不幸的东西，运气不好或设计不好的结构，
structures, given unfortunate inputs or some bad luck or some bad design,

2070
01:38:08,489 --> 01:38:12,789
可能只是偶然地演变成不同的数据结构。
could devolve into a different data structure just by chance.

2071
01:38:12,789 --> 01:38:18,039
因此，即使有这些值，也有解决此问题的方法。
So there's a way to solve this though, even with these values.

2072
01:38:18,039 --> 01:38:23,819
当我插入1、2、3时，我可以考虑这种不正常的情况
When I insert 1, 2, 3, I could allow for this perverse situation

2073
01:38:23,819 --> 01:38:27,059
在这里它变得又长又弦，这时一切都是n的大O。
where it just gets long and stringy, at which point everything is Big O of n.

2074
01:38:27,060 --> 01:38:28,140
这只是一个链表。
It's just a linked list.

2075
01:38:28,140 --> 01:38:30,900
它恰好是对角绘制的，而不是左右绘制的。
It just happens to be drawn diagonally instead of left right.

2076
01:38:30,899 --> 01:38:33,509
但是，有人能直观地看到解决方案吗？
But does anyone see a solution intuitively?

2077
01:38:33,510 --> 01:38:36,480
没有代码，没有正式语言，
Not in terms of code, no formal language,

2078
01:38:36,479 --> 01:38:40,499
但是这里有一个解决方案，以确保该树具有1、2、3
but there is a solution here to make sure that this tree with 1, 2, 3

2079
01:38:40,500 --> 01:38:43,500
首先不会变得冗长而紧张。
does not get long and stringy in the first place.

2080
01:38:43,500 --> 01:38:46,083
您可以怎么做才能解决这个问题？
What might you do instead to solve this?

2081
01:38:46,082 --> 01:38:47,999
布莱恩：聊天中有几个人在暗示
BRIAN: A few people in the chat are suggesting

2082
01:38:48,000 --> 01:38:51,100
您应该在树的顶部将2设为新的根节点。
you should make 2 the new root node at the top of the tree.

2083
01:38:51,100 --> 01:38:54,390
DAVID MALAN：因此，如果我改为将2设为新的根节点，让我继续
DAVID MALAN: So if I instead make 2 the new root node, let me go ahead

2084
01:38:54,390 --> 01:38:57,030
并迅速进行模拟。
and mock this up real quickly.

2085
01:38:57,029 --> 01:39:00,179
一会儿，我会透露我认为你刚刚说过的话。
And in a moment, I'll reveal what I think you've just verbalized.

2086
01:39:00,180 --> 01:39:02,808
如果相反，我可以确保在插入这些节点时
What if instead, I make sure that when inserting these nodes

2087
01:39:02,807 --> 01:39:05,849
我不是天真地一直走到右边，右边，右边吗？
I don't naively just keep going to the right, to the right, to the right?

2088
01:39:05,850 --> 01:39:07,420
我行使一些判断力。
I exercise some judgment.

2089
01:39:07,420 --> 01:39:09,930
如果我注意到，也许是我的数据结构，我的树
And if I notice, maybe, that my data structure, my tree

2090
01:39:09,930 --> 01:39:11,820
变得有点长而刺鼻，也许我
is getting kind of long and stringy, maybe I

2091
01:39:11,819 --> 01:39:15,599
应该有点旋转，使用第二个维度
should kind of rotate it around, using that second dimension for real

2092
01:39:15,600 --> 01:39:17,370
这样我就改变了根源。
so that I change what the root is.

2093
01:39:17,369 --> 01:39:19,469
而且，我们不会遍历执行此操作的代码。
And we won't go through the code for doing this.

2094
01:39:19,470 --> 01:39:21,240
但是事实证明这是解决方案。
But it turns out this is the solution.

2095
01:39:21,239 --> 01:39:22,979
这是正确的直觉。
That is exactly the right intuition.

2096
01:39:22,979 --> 01:39:25,319
如果您在数据结构上参加更高级别的课程
If you take a higher level class on data structures

2097
01:39:25,319 --> 01:39:27,389
和专门用于计算机科学的算法，
and algorithms specifically in computer science,

2098
01:39:27,390 --> 01:39:30,960
您将学习诸如AVL树或红色，黑色树之类的树，
you'll study trees like AVL trees, or red, black trees,

2099
01:39:30,960 --> 01:39:33,510
这是不同类型的树数据结构。
which are different types of tree data structures.

2100
01:39:33,510 --> 01:39:37,080
他们在其中内置了用于转移事物的算法
They kind of have built into them the algorithms for kind of shifting things

2101
01:39:37,079 --> 01:39:40,529
根据需要确保在插入或删除时
as needed to make sure that as you insert, or maybe as you delete,

2102
01:39:40,529 --> 01:39:42,839
您会不断地重新平衡树。
you constantly rebalance the tree.

2103
01:39:42,840 --> 01:39:46,870
长话短说，这样做可能会花费您一些额外的时间。
And long story short, doing so might cost you a little extra time.

2104
01:39:46,869 --> 01:39:50,969
但是，如果您有很多数据，请保持平衡和对数
But if you've got a lot of data, keeping that thing balanced and logarithmic

2105
01:39:50,970 --> 01:39:54,750
可以这么说，在高度上线性不长而严格，
in height, so to speak, and not long and stringy in the linear in height,

2106
01:39:54,750 --> 01:39:58,290
根据您的应用程序，可能会节省您的时间
it's probably, depending on your application, going to save you

2107
01:39:58,289 --> 01:40:01,169
总的来说，时间很多。
quite a bit of time overall.

2108
01:40:01,170 --> 01:40:05,250
因此，我们可以说将其插入平衡的二进制搜索树中
So we might say that insert into a balanced binary search tree

2109
01:40:05,250 --> 01:40:07,500
确实是log n的BigO。
is indeed Big O of log n.

2110
01:40:07,500 --> 01:40:11,100
但这是确保您保持平衡的条件。
But that is conditional on you making sure that you keep it balanced.

2111
01:40:11,100 --> 01:40:13,620
这将是比我们今天要讨论的更多的代码，
And that's going to be more code than we'll go into today,

2112
01:40:13,619 --> 01:40:17,789
但确实是一个可能的设计决策。
but indeed, a possible design decision.

2113
01:40:17,789 --> 01:40:24,039
好吧，那么现在关于树和二进制搜索树的任何问题，
All right, any questions then on now trees and binary search trees,

2114
01:40:24,039 --> 01:40:25,149
特别是？
in particular?

2115
01:40:25,149 --> 01:40:27,339
几周前，我们开始使用阵列。
We started with arrays a few weeks ago.

2116
01:40:27,340 --> 01:40:30,940
现在，我们有了链表，这些链表很好，更好，但不是很好。
We've now got linked lists, which are good, better, but not great.

2117
01:40:30,939 --> 01:40:34,899
对于树木来说，这似乎很棒，但是，这始终是一个权衡。
To trees, which seemed maybe to be great but, again, it's always a trade off.

2118
01:40:34,899 --> 01:40:36,999
他们给我们增加了空间。
They're costing us more space.

2119
01:40:37,000 --> 01:40:39,490
但我敢打赌，我们可以继续缝合其中的一些想法
But I bet we can continue to stitch some of these ideas

2120
01:40:39,489 --> 01:40:41,859
一起用于其他结构。
together for other structures still.

2121
01:40:41,859 --> 01:40:44,509
布莱恩，什么出色的？
Brian, anything outstanding?

2122
01:40:44,510 --> 01:40:45,010
布莱恩：是的。
BRIAN: Yeah.

2123
01:40:45,010 --> 01:40:48,070
一个问题来了，如果有的话为什么会成问题，
One question came in as to why it's a problem if you have,

2124
01:40:48,069 --> 01:40:51,277
像是1、2和3都在右侧按一个顺序排列？
like, the 1, and the 2, and the 3 all in just one sequence on the right side?

2125
01:40:51,278 --> 01:40:53,028
大卫·马兰（David MALAN）：是的，这是一个非常好的问题。
DAVID MALAN: Yeah, a really good question.

2126
01:40:53,028 --> 01:40:54,070
为什么会出问题呢？
Why is it a problem?

2127
01:40:54,069 --> 01:40:55,149
也许不是。
Maybe it isn't.

2128
01:40:55,149 --> 01:40:57,819
如果您没有非常大的数据集，而您
If you don't have a very large data set and you

2129
01:40:57,819 --> 01:41:00,549
老实说，结构中没有太多价值，谁在乎？
don't have many values in the structure, honestly, who cares?

2130
01:41:00,550 --> 01:41:02,607
如果这是三个要素，那么绝对不在乎。
If it's three elements, definitely don't care.

2131
01:41:02,606 --> 01:41:05,689
如果是10个元素，如果是1000个元素，那么，如果您的计算机足够快，
If it's 10 elements, if it's 1,000, heck, if your computer is fast enough,

2132
01:41:05,689 --> 01:41:08,147
可能有上百万个元素，但这没什么大不了的。
there might be a million elements, and it's not a big deal.

2133
01:41:08,148 --> 01:41:10,510
但是如果是200万或10亿个元素，
But if it's two million elements or a billion elements,

2134
01:41:10,510 --> 01:41:13,655
那么这完全取决于您正在建立的业务是什么？
then it totally depends, again, on what is the business you're building?

2135
01:41:13,654 --> 01:41:15,279
您正在编写什么应用程序？
What is the application you're writing?

2136
01:41:15,279 --> 01:41:16,269
您的数据有多大？
How big is your data?

2137
01:41:16,270 --> 01:41:18,220
您的计算机有多快或多慢？
How fast or how slow is your computer?

2138
01:41:18,220 --> 01:41:20,187
最终可能很重要。
It might very well matter ultimately.

2139
01:41:20,186 --> 01:41:23,019
确实，当我们几个星期看到一些算法时
And indeed, when we've seen some of our algorithms a couple of weeks

2140
01:41:23,020 --> 01:41:26,470
以前，当我们比较气泡排序和选择排序以及合并排序时，
ago, when we compared bubble sort and selection sort and merge sort,

2141
01:41:26,470 --> 01:41:29,200
即使这些时间属于不同的运行时间类别，
even though those were in a different category of running times,

2142
01:41:29,199 --> 01:41:33,639
n记录n和n的平方，只需回想一下明显的差异即可。
n log n and n squared, just recall the appreciable difference.

2143
01:41:33,640 --> 01:41:38,500
在搜索上下文中，n的对数比n更好。
Log of n in the context of searching is way better than n.

2144
01:41:38,500 --> 01:41:41,709
因此，如果您的数据结构演变成冗长而冗长的内容，
So if your data structure is devolving into something long and stringy,

2145
01:41:41,710 --> 01:41:46,120
回想一下，就像搜索一本电话簿共一千页。
recall that's, like, searching a phone book a thousand total pages.

2146
01:41:46,119 --> 01:41:49,959
但是二进制搜索并不让它变得冗长而冗长
But binary search and not letting it get long and stringy

2147
01:41:49,960 --> 01:41:53,170
给您10个步骤，而不是1,000个步骤
gives you, like, 10 steps instead of 1,000

2148
01:41:53,170 --> 01:41:55,510
步骤以搜索相同的页面。
steps in order to search those same pages.

2149
01:41:55,510 --> 01:41:58,900
因此，即使在第0周，我们也看到了明显的差异
So, again, even in Week 0 we saw the appreciable difference

2150
01:41:58,899 --> 01:42:04,009
在这些不同类别的运行时间之间。
between these different categories of running times.

2151
01:42:04,010 --> 01:42:06,248
好吧，让我们看看我们是否可能
All right, well, let's see if we can't maybe

2152
01:42:06,247 --> 01:42:07,789
兼顾两全其美。
take some of the best of both worlds.

2153
01:42:07,789 --> 01:42:09,259
到目前为止，我们再次看到了数组。
Thus far, again, we've seen arrays.

2154
01:42:09,260 --> 01:42:10,370
我们已经看到了链表。
We've seen linked lists.

2155
01:42:10,369 --> 01:42:11,779
我们看过树木。
We've seen trees.

2156
01:42:11,779 --> 01:42:15,109
如果我们在这里有点弗兰肯斯坦，把东西捣碎怎么办
What if we kind of get a little Frankenstein here and mash things

2157
01:42:15,109 --> 01:42:18,527
在一起，并采取这些东西的最好的功能
together and take sort of the best features of these things

2158
01:42:18,528 --> 01:42:19,820
并建立更大的东西。
and build up something grander.

2159
01:42:19,819 --> 01:42:22,579
实际上，我感觉像是数据结构的圣杯
In fact, I feel like the Holy Grail of a data structure

2160
01:42:22,579 --> 01:42:27,139
证明和插入不是n，n的Big O的东西，
would be something for which cert and insertion aren't n, Big O of n,

2161
01:42:27,140 --> 01:42:28,340
不是log n的BigO。
aren't Big O of log n.

2162
01:42:28,340 --> 01:42:30,590
但是，如果有数据结构，那会不会令人惊讶
But wouldn't it be amazing if there's a data structure

2163
01:42:30,590 --> 01:42:33,950
那里的运行时间就像恒定时间，Big O为1。
out there where the running time is like constant time, Big O of 1.

2164
01:42:33,949 --> 01:42:35,089
那是圣杯。
That's the Holy Grail.

2165
01:42:35,090 --> 01:42:37,957
如果您可以通过这种方式巧妙地布置计算机的内存
If you can cleverly lay out your computer's memory in such a way

2166
01:42:37,957 --> 01:42:40,790
如果您要搜索或插入一个值，繁荣，就可以了。
that if you want to search for or insert a value, boom, you're done.

2167
01:42:40,789 --> 01:42:44,739
动臂，您已完成，并且没有任何线性或对数运行时间。
Boom, you're done, and none of this linear or logarithmic running time.

2168
01:42:44,739 --> 01:42:46,819
因此，让我们看看我们是否无法实现这一目标。
So let's see if we can't pursue that goal.

2169
01:42:46,819 --> 01:42:50,359
让我建议我们介绍一个称为哈希表的主题。
Let me propose that we introduce this topic called hash tables.

2170
01:42:50,359 --> 01:42:53,389
哈希表是另一种数据结构
Hash table is another data structure that's

2171
01:42:53,390 --> 01:42:56,010
本质上是链表的数组。
essentially an array of linked lists.

2172
01:42:56,010 --> 01:42:57,980
再说一次，这是科学怪人怪物
So, again, it's this Frankenstein monster,

2173
01:42:57,979 --> 01:43:01,199
从而我们最终将数组与链表结合在一起。
whereby we've combined arrays ultimately with linked list.

2174
01:43:01,199 --> 01:43:02,539
让我们看看这是如何完成的。
Let's see how this is done.

2175
01:43:02,539 --> 01:43:05,346
让我建议我们首先从大小为26的数组开始。
Let me propose that we first start with an array of size 26.

2176
01:43:05,346 --> 01:43:08,179
我将开始垂直绘制数组，只是因为它
And I'm going to start drawing my arrays vertically, just because it

2177
01:43:08,180 --> 01:43:09,890
可以通过图片更好地完成工作。
sort of works out better pictorially.

2178
01:43:09,890 --> 01:43:11,840
但是，无论如何，这些都是艺术家的作品。
But, again, these are all artist's renditions, anyway.

2179
01:43:11,840 --> 01:43:15,048
即使我们总是从左到右绘制数组，这完全是任意的。
Even though we always draw arrays left to right, that's completely arbitrary.

2180
01:43:15,047 --> 01:43:17,779
因此，现在我要开始，将我的数组从上到下绘制。
So I'm going to start, for now, drawing my array top to bottom.

2181
01:43:17,779 --> 01:43:20,509
并假设我现在关心的数据结构
And suppose that the data structure I care about now

2182
01:43:20,510 --> 01:43:22,620
这些数字将变得更加有趣。
is going to be even more interesting the numbers.

2183
01:43:22,619 --> 01:43:26,449
假设我要存储诸如名称之类的东西，如字典或名称
Suppose I want to store things like names, like dictionaries, or names

2184
01:43:26,449 --> 01:43:28,411
就像手机中的联系人一样。
like contacts in your phone.

2185
01:43:28,412 --> 01:43:30,620
如果您想跟踪所有认识的人，
If you want to keep track of all the people you know,

2186
01:43:30,619 --> 01:43:33,619
如果它不需要线性时间或对数时间，那将很棒
it would be great if it doesn't take linear time or logarithmic time

2187
01:43:33,619 --> 01:43:34,639
找人。
to find people.

2188
01:43:34,640 --> 01:43:37,980
相反，恒定的时间似乎会更好。
Instead, constant time would seem to be even better.

2189
01:43:37,979 --> 01:43:40,944
因此，这是一个数组，例如，大小为26。
So here's an array, for instance, size 26.

2190
01:43:40,944 --> 01:43:42,319
我是故意提出的。
And I proposed that deliberately.

2191
01:43:42,319 --> 01:43:44,719
在英语中，有26个字母，从A到Z。
In English, there's 26 letters, A through Z. So

2192
01:43:44,720 --> 01:43:48,590
让我们考虑位置0是A。位置25是Z。
let's consider location 0 is A. Location 25 is Z.

2193
01:43:48,590 --> 01:43:53,270
如果我现在开始将所有朋友插入新手机，
And if I now go and start inserting all of my friends into my new phone,

2194
01:43:53,270 --> 01:43:56,210
放入通讯录应用程序中，我可以将它们放在哪里？
into the contacts application, where might I put them?

2195
01:43:56,210 --> 01:43:57,650
好吧，让我继续执行此操作。
Well, let me go ahead and do this.

2196
01:43:57,649 --> 01:44:01,399
让我继续考虑一下这些元素，分别是0到25，
Let me go ahead and think of each of these elements as, again, 0 through 25,

2197
01:44:01,399 --> 01:44:03,169
或实际上是A到Z。
or really A through Z.

2198
01:44:03,170 --> 01:44:07,670
然后，在我将新朋友或联系人插入手机后，
And let me, upon inserting a new friend or contact into my phone,

2199
01:44:07,670 --> 01:44:12,260
让我将其放置在与名称本身有一定关系的位置。
let me put them into a location that has some relationship with the name itself.

2200
01:44:12,260 --> 01:44:15,120
我们不仅要一开始就把它们放在首位。
Let's not just start putting them at the very beginning.

2201
01:44:15,119 --> 01:44:17,809
我们不必将它们本身按字母顺序排列。
Let's not necessarily put them alphabetically per se.

2202
01:44:17,810 --> 01:44:22,310
我们实际上将它们放置在此数组中的特定位置，而不仅仅是顶部
Let's actually put them at a specific location in this array, not just top

2203
01:44:22,310 --> 01:44:24,980
到底部，但在特定条目处。
to bottom, but at a specific entry.

2204
01:44:24,979 --> 01:44:28,309
因此，假设我要添加到我的联系人中的第一个人是Albus。
So suppose the first person I want to add to my contacts is Albus.

2205
01:44:28,310 --> 01:44:31,820
好吧，我提议，因为阿不思以A开头，
Well, I'm going to propose that because Albus starts with an A,

2206
01:44:31,819 --> 01:44:37,879
他将要进入A位置，因此是该数组中的第一个条目。
he is going to go into the A location, so the very first entry in this array.

2207
01:44:37,880 --> 01:44:40,160
假设我接下来要添加Zacharias。
Suppose I next want to add Zacharias.

2208
01:44:40,159 --> 01:44:43,699
好吧，他的名字以Z开头。所以他要去的最后一个位置。
Well, his name starts with Z. So he's going to go in the very last location.

2209
01:44:43,699 --> 01:44:45,349
所以，我再次跳来跳去。
So, again, I'm jumping around.

2210
01:44:45,350 --> 01:44:46,970
我从0降到25。
I went from 0 to 25.

2211
01:44:46,970 --> 01:44:50,030
但这是一个数组，我可以在恒定时间内做到这一点。
But it's an array, and I can do that in constant time.

2212
01:44:50,029 --> 01:44:53,399
您可以使用方括号随机索引到任何元素。
You can randomly index to any element using square brackets.

2213
01:44:53,399 --> 01:44:54,671
所以这都是恒定的时间。
So this is both constant time.

2214
01:44:54,671 --> 01:44:56,629
我不必只是把他放在阿不思之后。
I don't have to just put him right after Albus.

2215
01:44:56,630 --> 01:44:57,980
我可以把他放在我想要的任何地方。
I can put him wherever I want.

2216
01:44:57,979 --> 01:44:59,929
假设第三人称赫敏。
Suppose the third person is Hermione.

2217
01:44:59,930 --> 01:45:02,360
好吧，我要把她放在位置H。为什么？
Well, I'm going to put her at location H. Why?

2218
01:45:02,359 --> 01:45:04,609
因为我可以进行数学运算，并且可以算出H。好吧，
Because I can do the math, and I can figure out H. OK,

2219
01:45:04,609 --> 01:45:07,579
我可以立即跳到那个字母。
I can just jump immediately to that letter of the alphabet.

2220
01:45:07,579 --> 01:45:10,759
反过来，多亏了ASCII并做了一些算术运算，
And in turn, thanks to ASCII and doing a bit of arithmetic,

2221
01:45:10,760 --> 01:45:13,110
我也将其转换为数字。
I convert that to a number as well.

2222
01:45:13,109 --> 01:45:16,309
所以她以0、1、2、3、4、5、6、7结束
So she ends up at 0, 1, 2, 3, 4, 5, 6, 7,

2223
01:45:16,310 --> 01:45:21,570
因为H最终映射到第八个字符或位置7。
because H ends up mapping to the eighth character, or location 7.

2224
01:45:21,569 --> 01:45:22,819
好的。
All right.

2225
01:45:22,819 --> 01:45:23,629
还有谁？
Who else?

2226
01:45:23,630 --> 01:45:25,950
所有这些其他人最终都出现在我的通讯录中。
All these other people end up in my address book.

2227
01:45:25,949 --> 01:45:27,209
因此，它们都散布了。
And so they're all spread out.

2228
01:45:27,210 --> 01:45:28,670
我没有多达26个朋友。
I don't have as many as 26 friends.

2229
01:45:28,670 --> 01:45:30,360
因此，那里的数据存在一些差距。
So there's some gaps in the data there.

2230
01:45:30,359 --> 01:45:32,179
但是我适合所有人。
But I fit everyone here.

2231
01:45:32,180 --> 01:45:33,750
但是可能有问题。
But there might be a problem.

2232
01:45:33,750 --> 01:45:35,479
您也许可以看到这种情况的到来。
And you can perhaps see this coming.

2233
01:45:35,479 --> 01:45:37,009
到目前为止，我有点幸运。
Thus far, I've kind of gotten lucky.

2234
01:45:37,010 --> 01:45:40,790
而且我只知道名字以唯一的字母开头的人。
And I've only know people whose names are-- uniquely start with a letter.

2235
01:45:40,789 --> 01:45:45,709
但是当我在学校遇到一个人并将他们添加到我的联系人中后，
But as soon as I meet someone at school and I add them to my contacts,

2236
01:45:45,710 --> 01:45:49,560
好吧，例如，现在哈利必须去同一地点。
well, now Harry, for instance, has to go in the same location.

2237
01:45:49,560 --> 01:45:52,850
如果我要同时存储赫敏和哈利，那么这是一个问题，
Now this is a problem if I want to store both Hermione and Harry,

2238
01:45:52,850 --> 01:45:54,680
因为它们的名称都以H开头。
because their names both start with H.

2239
01:45:54,680 --> 01:45:57,770
但是，再说一次，如果它是一个数组，那绝对是一个破坏交易的事情。
But, again if it's an array, it's absolutely a deal breaker.

2240
01:45:57,770 --> 01:45:59,840
到那时，一切都崩溃了。
At that point, all things break down.

2241
01:45:59,840 --> 01:46:01,880
因为可以，所以我可以增加阵列。
Because I could, yes, grow the array.

2242
01:46:01,880 --> 01:46:04,880
但是，如果我增加数组，那么它的大小为27。
But if I grow the array, then it's size 27.

2243
01:46:04,880 --> 01:46:08,120
然后，就像，我怎么知道那时候什么字母是什么数字？
And then it's, like, how do I know what number is what letter at that point?

2244
01:46:08,119 --> 01:46:09,949
它只是变成了一个烂摊子。
It just devolves into a complete mess.

2245
01:46:09,949 --> 01:46:12,529
但是如果我借用链表的想法，如果我
But if I borrow the idea of a linked list, what if I

2246
01:46:12,529 --> 01:46:15,859
使我的数组为链接列表的数组？
make my array an array of linked lists?

2247
01:46:15,859 --> 01:46:17,899
所以是的，即使有碰撞
So yes, even though there's this collision

2248
01:46:17,899 --> 01:46:22,399
赫敏和哈利都在阵列中的同一位置，
where both Hermione and Harry belong at the same location in the array,

2249
01:46:22,399 --> 01:46:23,179
没关系。
that's fine.

2250
01:46:23,180 --> 01:46:26,570
万一发生这种情况，我只是将它们缝合在一起
In the event this happens, I'm just going to kind of stitch them together

2251
01:46:26,569 --> 01:46:28,829
从左到右进入一个链表。
into a linked list from left to right.

2252
01:46:28,829 --> 01:46:29,689
所以这不是理想的。
So it's not ideal.

2253
01:46:29,689 --> 01:46:32,569
因为现在我要走两步才能到达哈利，而不是1，
Because now it takes me two steps to get to Harry instead of 1,

2254
01:46:32,569 --> 01:46:35,059
使用简单的算术和方括号表示法。
using simple arithmetic and square bracket notation.

2255
01:46:35,060 --> 01:46:37,880
但是，至少我仍然可以将他放入我的通讯录中。
But heck, at least I can still fit him in my address book.

2256
01:46:37,880 --> 01:46:40,220
因此，需要权衡取舍，但感觉是合理的。
So a bit of a trade off, but feels reasonable.

2257
01:46:40,220 --> 01:46:41,630
好吧，其他人，海格-
Well, someone else, Hagrid--

2258
01:46:41,630 --> 01:46:43,970
好吧，现在需要我是不理想的
all right, it's not ideal that now it takes me

2259
01:46:43,970 --> 01:46:46,370
在我的地址簿中到达海格的三个步骤。
three steps to get to Hagrid in my address book.

2260
01:46:46,369 --> 01:46:50,279
但是三个总比根本不让他在那里更好。
But three is way better than not having him in there at all.

2261
01:46:50,279 --> 01:46:52,999
因此，我们再次在这里看到了折衷的体现。
So, again, we see a manifestation of a trade off here, too.

2262
01:46:53,000 --> 01:46:54,709
但是我们已经解决了这个问题。
But we've solved the problem.

2263
01:46:54,710 --> 01:46:57,680
哈希表确实就是这种数据结构。
And a hash table is, indeed, exactly this data structure.

2264
01:46:57,680 --> 01:47:02,000
它是一个链表的数组，至少可以这样实现。
It is an array of linked lists, at least it can be implemented as such.

2265
01:47:02,000 --> 01:47:05,708
它基于引入哈希函数的概念。
And it is predicated on introducing the notion of a hash function.

2266
01:47:05,707 --> 01:47:08,499
这实际上是我们不久之后将在其他环境中看到的东西。
This is actually something we'll see in other contexts before long.

2267
01:47:08,500 --> 01:47:12,759
但是散列函数将使我们不仅可以映射Hermione，Harry，
But a hash function is going to allow us to map not only Hermione, Harry,

2268
01:47:12,760 --> 01:47:15,880
和海格，还有罗恩和雷穆斯，西弗勒斯和小天狼星
and Hagrid, but also Ron and Remus, Severus and Sirius

2269
01:47:15,880 --> 01:47:19,180
确定地移动到其各自的位置。
to their respective locations deterministically.

2270
01:47:19,180 --> 01:47:21,910
也就是说，这里不涉及随机性。
That is, there's no randomness involved here.

2271
01:47:21,909 --> 01:47:24,099
每当我看到这些人的名字时，
Every time I look at these people's names,

2272
01:47:24,100 --> 01:47:27,760
我要弄清楚它们所属的位置
I'm going to figure out the location at which they belong

2273
01:47:27,760 --> 01:47:30,170
而且位置永远不会改变。
and that location is never going to change.

2274
01:47:30,170 --> 01:47:31,190
那么我该怎么做呢？
So how do I do this?

2275
01:47:31,189 --> 01:47:34,211
好吧，事实证明我们可以回想一下自己解决问题的方法
Well, it turns out we can think back to problem solving itself

2276
01:47:34,212 --> 01:47:35,170
以及什么功能。
and what functions are.

2277
01:47:35,170 --> 01:47:37,003
因此，这就是我们定义的问题解决方法。
So this is problem solving as we defined it.

2278
01:47:37,002 --> 01:47:41,139
这也是使用输入和输出的任何语言的功能。
This is also a function in any language that takes inputs and outputs.

2279
01:47:41,140 --> 01:47:43,720
哈希函数将是一种秘密
A hash function is going to be sort of a secret sauce

2280
01:47:43,720 --> 01:47:45,600
现在在此黑匣子内部。
inside of this black box for now.

2281
01:47:45,600 --> 01:47:47,050
那么什么是哈希函数？
And so what is a hash function?

2282
01:47:47,050 --> 01:47:50,620
嗯，哈希函数实际上是一个函数，无论从数学上还是
Well, a hash function is literally a function, either mathematically

2283
01:47:50,619 --> 01:47:55,149
或在编程中以某种字符串作为输入，在这种情况下，
or in programming, that takes as input some string, in this case,

2284
01:47:55,149 --> 01:47:58,429
例如Hermione或Harry，它会返回一些输出。
like Hermione or Harry, and it returns some output.

2285
01:47:58,430 --> 01:48:01,480
哈希函数的输出通常是一个数字。
And the output of a hash function is usually a number.

2286
01:48:01,479 --> 01:48:06,169
在这种情况下，我想要的数字将在0到25之间。
In this case, the number I want is going to be between 0 and 25.

2287
01:48:06,170 --> 01:48:09,040
因此，为了实现哈希表的这一概念，
So in order to implement this notion of a hash table,

2288
01:48:09,039 --> 01:48:11,739
不仅以图形方式显示在屏幕上，而且以实际代码显示，
not just pictorially on the screen, but in actual code,

2289
01:48:11,739 --> 01:48:15,129
实际上，我将不得不编写一个需要字符串的函数，
I'm literally going to have to write a function that takes a string,

2290
01:48:15,130 --> 01:48:20,800
或者，如果愿意，可以将char *作为输入，并返回一个介于0到25之间的int，以便
or if you will, char*, as input and returns an int between 0 and 25 so that

2291
01:48:20,800 --> 01:48:27,380
在这种情况下，我知道如何将Hermione或Harry或Hagrid转换为7。
I know how to convert Hermione or Harry or Hagrid to the number 7 in this case.

2292
01:48:27,380 --> 01:48:29,080
那么这个散列函数做什么呢？
So what does this hash function do?

2293
01:48:29,079 --> 01:48:32,049
它采用像Albus这样的输入作为输入，并且输出0。
It takes as input something like Albus and it outputs 0.

2294
01:48:32,050 --> 01:48:35,110
它需要像Zacharias这样的人，并且输出25。
It takes someone like Zacharias, and it outputs 25.

2295
01:48:35,109 --> 01:48:37,219
您可能会在这里看到该模式。
And you can probably see the pattern here.

2296
01:48:37,220 --> 01:48:40,120
我将编写以实现此类代码的代码是
The code I would write in order to implement something like this is

2297
01:48:40,119 --> 01:48:43,119
可能要看用户的输入，即char *。
probably going to look at the user's input, that char*.

2298
01:48:43,119 --> 01:48:45,879
然后要看第一个字符
And it's going to look at the first character, which

2299
01:48:45,880 --> 01:48:48,763
这两个分别为A或Z。
is A or Z, respectively, for these two.

2300
01:48:48,762 --> 01:48:50,679
然后要做一点数学
And it's then going to do a little bit of math

2301
01:48:50,680 --> 01:48:53,660
然后减去65之类的
and subtract off, like, 65 or whatnot.

2302
01:48:53,659 --> 01:48:57,039
这将使我得到一个介于0到25之间的数字，
And it's going to get me a number between 0 and 25,

2303
01:48:57,039 --> 01:49:01,909
就像凯撒（Caesar）或我们过去对字符串的某些处理一样。
just like with Caesar or some of our past manipulations of strings.

2304
01:49:01,909 --> 01:49:06,789
因此，从这里开始，我们现在可以采用此构建块，也许
So from here, we can now take this building block, though, and perhaps

2305
01:49:06,789 --> 01:49:09,009
更有效地解决我们的问题。
solve our problems a little more effectively.

2306
01:49:09,010 --> 01:49:11,710
就像，我不喜欢这样的事实，即使是的，我已经
Like, I don't love the fact that even though, yes, I've

2307
01:49:11,710 --> 01:49:15,010
为哈利，赫敏和海格腾出了空间，
made room for Harry, and Hermione, and Hagrid,

2308
01:49:15,010 --> 01:49:19,510
现在是Luna，Lily，Lucius和Lavender，其中一些链接列表
and now Luna, and Lily, and Lucius, and Lavender, some of these linked lists

2309
01:49:19,510 --> 01:49:20,620
越来越长了。
are getting a little long.

2310
01:49:20,619 --> 01:49:22,089
您可以在这里使用另一个术语。
And there's another term you can use here.

2311
01:49:22,090 --> 01:49:23,882
这些有点像链子，如果您愿意的话，
These are kind of like chains, if you will,

2312
01:49:23,881 --> 01:49:28,389
因为它们看起来像链节围栏或链条中的小链接。
because they look like chain link fences or little links in a chain.

2313
01:49:28,390 --> 01:49:29,860
这些是链或链表。
These are chains or linked lists.

2314
01:49:29,859 --> 01:49:31,609
但是其中一些已经开始变长了。
But some of them are starting to get long.

2315
01:49:31,609 --> 01:49:35,619
我试图达到恒定的时间有点愚蠢，Big O为1
And it's a little stupid that I'm trying to achieve constant time, Big O of 1,

2316
01:49:35,619 --> 01:49:39,579
但是从技术上讲，即使其中一些名称从字面上迈出了一步，
but technically, even though some of the names literally take one step,

2317
01:49:39,579 --> 01:49:42,399
他们中的一些人正在采取两个或三个或四个步骤。
some of them are taking two or three or four steps.

2318
01:49:42,399 --> 01:49:44,079
因此，它开始发展。
So it's starting to devolve.

2319
01:49:44,079 --> 01:49:45,761
那么，这里的优化是什么？
So what would be an optimization here?

2320
01:49:45,761 --> 01:49:48,219
如果因为如此受欢迎而开始感到不适
If you start to get uncomfortable because you're so popular

2321
01:49:48,220 --> 01:49:50,890
并且您的联系人中有很多名字，以至于
and you've got so many names in your contacts that looking up

2322
01:49:50,890 --> 01:49:56,790
H，查找L比其他花费更多的时间，
the H's, looking up the L's is taking more time than the others,

2323
01:49:56,789 --> 01:50:01,199
我们可以做些什么来改善这种情况，并且仍然使用哈希表，
what could we do to improve the situation and still use a hash table,

2324
01:50:01,199 --> 01:50:03,299
还在使用哈希函数吗？
still use a hash function?

2325
01:50:03,300 --> 01:50:05,790
但是，合理的解决方案可能是什么
But what would maybe the logical solution

2326
01:50:05,789 --> 01:50:08,879
当你有太多的碰撞时，你
be when you have too many collisions, you

2327
01:50:08,880 --> 01:50:12,150
有太多的名字彼此冲突？
have too many names colliding with one another?

2328
01:50:12,149 --> 01:50:15,569
我们又如何才能提高绩效并到达目标位置，
How could we improve our performance and get at locations, again,

2329
01:50:15,569 --> 01:50:18,629
接近一步，不是两个，不是三个，不是四个？
closer to one step, not two, not three, not four?

2330
01:50:18,630 --> 01:50:23,327
所以实际上是一步，因为这是我们这里的圣杯。
So literally one step, because that's our Holy Grail here.

2331
01:50:23,327 --> 01:50:26,160
布莱恩：一些人建议您不仅仅应该看
BRIAN: A few people have suggested you should look at more than just

2332
01:50:26,159 --> 01:50:26,879
第一个字母。
the first letter.

2333
01:50:26,880 --> 01:50:28,710
例如，您可以查看第二个字母。
Like, you could look at the second letter, for example.

2334
01:50:28,710 --> 01:50:29,160
戴维·马兰：是的。
DAVID MALAN: Yeah.

2335
01:50:29,159 --> 01:50:29,659
好的。
Nice.

2336
01:50:29,659 --> 01:50:32,219
因此，如果看一个人名字的字母
So if looking at one letter of the person's name

2337
01:50:32,220 --> 01:50:33,420
显然是不够的。
is obviously insufficient.

2338
01:50:33,420 --> 01:50:37,530
因为我们所有人的名字都以H或A开头
Because a whole bunch of us have names that start with H or A

2339
01:50:37,529 --> 01:50:40,679
或Z之类的东西，那么，为什么我们不看两个字母
or Z or the like, well, why don't we look at two letters

2340
01:50:40,680 --> 01:50:42,930
因此降低了我们
and therefore decrease the probability that we're

2341
01:50:42,930 --> 01:50:44,320
会发生这些碰撞？
going to have these collisions?

2342
01:50:44,319 --> 01:50:46,139
因此，让我继续进行重组。
So let me go ahead and restructure this.

2343
01:50:46,140 --> 01:50:48,840
并着眼于赫敏，哈里和海格的问题，
And focusing on the Hermione, Harry, and Hagrid problem,

2344
01:50:48,840 --> 01:50:52,830
我们为什么不继续将我们的数组放在哈希表中，垂直的东西
why don't we go ahead and take our array in the hash table, the vertical thing

2345
01:50:52,829 --> 01:50:56,566
在这里，让我们想一想，可能不只是在那个位置是H。
here, and let's think of it as maybe not just being H at that location.

2346
01:50:56,567 --> 01:50:58,650
但是，如果我们特别想到那个位置呢？
But what if we think of that location specifically

2347
01:50:58,649 --> 01:51:05,009
首先是HA，然后是HB，HC，HD，HE，HF，直到HZ。
as being HA, and then HB, HC, HD, HE, HF, all the way down to HZ.

2348
01:51:05,010 --> 01:51:09,390
然后是IA，IB，IC等，所以我们现在
And then IA, IB, IC, and so forth, so we now

2349
01:51:09,390 --> 01:51:16,060
枚举从AA到ZZ的所有可能的字母对？
enumerate all possible pairs of letters from AA to ZZ?

2350
01:51:16,060 --> 01:51:18,060
但这似乎使事情散布开了，对吗？
But this would seem to spread things out, right?

2351
01:51:18,060 --> 01:51:21,850
因为现在赫敏进入阵列中的HE位置。
Because now Hermione goes in the HE location in the array.

2352
01:51:21,850 --> 01:51:23,340
现在，哈利进入房委会。
Now Harry goes in the HA.

2353
01:51:23,340 --> 01:51:24,870
现在，哈格-噢，该死。
And now Hag-- oh, dammit.

2354
01:51:24,869 --> 01:51:28,119
就像，海格仍在同一地点。
Like, Hagrid still goes in the same location.

2355
01:51:28,119 --> 01:51:30,059
那么，什么会是更好的解决方法呢？
So what would maybe be a better fix?

2356
01:51:30,060 --> 01:51:33,640
再说一次，这并不可怕，就像两个步骤没什么大不了的，
Again, this isn't horrible, like two steps is not a big deal,

2357
01:51:33,640 --> 01:51:34,890
特别是在快速计算机上。
especially on fast computers.

2358
01:51:34,890 --> 01:51:37,153
但是，同样，如果有足够大的数据集，
But, again, with large enough data sets, and if we're

2359
01:51:37,153 --> 01:51:39,570
不再谈论您联系人中的人，但也许
no longer talking about people in your contacts, but maybe

2360
01:51:39,569 --> 01:51:43,772
世界上所有拥有Google帐户或Twitter帐户的人，
all the people in the world who have Google accounts, or Twitter accounts,

2361
01:51:43,773 --> 01:51:46,440
等等，您想在其中快速搜索此信息，
and the like, where you want to search this information quickly,

2362
01:51:46,439 --> 01:51:49,409
您将有很多人的名字以H和A开头
you're going to have a lot of people whose names start with H and A

2363
01:51:49,409 --> 01:51:50,759
和Z以及其他所有内容。
and Z and everything else.

2364
01:51:50,760 --> 01:51:52,877
最好将它们进一步传播出去。
It would be nice to spread them out further.

2365
01:51:52,877 --> 01:51:53,710
那我们该怎么办？
So what could we do?

2366
01:51:53,710 --> 01:51:55,740
好吧，与其使用前两个字母，
Well, instead of using the first two letters,

2367
01:51:55,739 --> 01:51:59,589
坦率地说，我认为这的逻辑扩展是使用前三个字母。
frankly I think the logical extension of this is to use the first three letters.

2368
01:51:59,590 --> 01:52:01,740
因此，也许这就是HAA存储桶。
So maybe this is the HAA bucket.

2369
01:52:01,739 --> 01:52:07,559
这就是HAB，HAC，HAD，HAE，点，点，点，一直到HZZ，
This is the HAB, HAC, HAD, HAE, dot, dot, dot, all the way down to HZZ,

2370
01:52:07,560 --> 01:52:08,630
然后是IAA。
and then IAA.

2371
01:52:08,630 --> 01:52:13,320
但是现在当我们哈希我们的三个朋友时，赫敏
But now when we hash our three friends, Hermione

2372
01:52:13,319 --> 01:52:17,399
可以说是数组的元素。
goes in the HER bucket so to speak, the elements of the array.

2373
01:52:17,399 --> 01:52:19,529
哈利，哈利，进了那个水桶。
Harry, HAR, goes in that bucket.

2374
01:52:19,529 --> 01:52:24,359
现在，海格和其他所有人一样，都拥有自己的水桶HAG。
And Hagrid now gets his own bucket, HAG, as would everyone else.

2375
01:52:24,359 --> 01:52:26,621
这样看来已经解决了这个特定问题。
So it seems to have solved this specific problem.

2376
01:52:26,622 --> 01:52:29,580
您仍然可以想象，而我不得不更加努力地思考，也许是谷歌
You could still imagine, and I have to think harder and probably Google

2377
01:52:29,579 --> 01:52:33,401
看看是否还有其他以HAG或HAR开头的哈利波特名称
to see if there's other Harry Potter names that start with HAG or HAR

2378
01:52:33,402 --> 01:52:35,880
或HER寻找另一个碰撞。
or HER to find another collision.

2379
01:52:35,880 --> 01:52:39,420
因为您可以想象使用四个字母来代替。
Because you could imagine using four letters instead.

2380
01:52:39,420 --> 01:52:41,460
但是我们要付出什么代价呢？
But what price are we paying?

2381
01:52:41,460 --> 01:52:44,190
就像，我一次又一次地解决这个问题。
Like, I'm solving this problem again and again.

2382
01:52:44,189 --> 01:52:48,029
而且我正在使自己的查字时间更快，
And I'm getting myself literally faster look up time,

2383
01:52:48,029 --> 01:52:49,589
因为它给了我一步。
because it's giving me one step.

2384
01:52:49,590 --> 01:52:51,690
我可以从数学上算出
I can mathematically figure out by just doing

2385
01:52:51,689 --> 01:52:55,704
一点点的ASCII数学，索引的数量是多少
a bit of ASCII math, what the number of the index

2386
01:52:55,704 --> 01:52:58,079
是我应该跳入这个越来越大的阵营。
is that I should jump to in this bigger and bigger array.

2387
01:52:58,079 --> 01:53:00,994
但是我要付出什么代价？
But what price am I paying?

2388
01:53:00,994 --> 01:53:03,469
Brian，您有什么想传达的想法吗？
Brian, any thoughts you'd like to relay?

2389
01:53:03,470 --> 01:53:03,970
布莱恩：是的。
BRIAN: Yeah.

2390
01:53:03,970 --> 01:53:06,180
少数人说这将占用大量内存。
A few people are saying it's going to take a lot of memory.

2391
01:53:06,180 --> 01:53:06,930
戴维·马兰：是的。
DAVID MALAN: Yeah.

2392
01:53:06,930 --> 01:53:09,690
就像我的上帝，这现在需要大量的记忆。
My God, like, this is taking a huge amount of memory now.

2393
01:53:09,689 --> 01:53:11,659
以前，它需要多少内存？
Previously, how much memory did it take?

2394
01:53:11,659 --> 01:53:15,419
好吧，让我在这里拉起一个小计算器，然后做一些快速数学运算。
Well, let me pull up a little calculator here and do some quick math.

2395
01:53:15,420 --> 01:53:21,327
因此，如果我们最初有26个存储桶（可以说是数组中的元素），
So if we had originally 26 buckets, so to speak, elements in the array, that,

2396
01:53:21,327 --> 01:53:22,410
当然，还不错。
of course, isn't that bad.

2397
01:53:22,409 --> 01:53:24,269
感觉很合理，有26个插槽。
That feels pretty reasonable, 26 slots.

2398
01:53:24,270 --> 01:53:26,280
但不利的一面是，连锁店可能
But the downside was that the chains might

2399
01:53:26,279 --> 01:53:28,989
得到一种长名称，三个名称，四个名称，甚至更多。
get kind of long, three names, four names, maybe even more.

2400
01:53:28,989 --> 01:53:35,099
但是，如果我们有AA到ZZ，而不是A到Z，那就是26乘以26，
But if we have AA through ZZ, instead of A through Z, that's 26 times 26,

2401
01:53:35,100 --> 01:53:36,845
那是676个桶
that's 676 buckets.

2402
01:53:36,845 --> 01:53:39,720
听起来不算什么，尽管这比大多数事情都大
Doesn't sound like a huge deal, though that's bigger than most things

2403
01:53:39,720 --> 01:53:41,950
到目前为止，我们已经在内存中完成了很多任务。
we've done in memory thus far, not a huge deal.

2404
01:53:41,949 --> 01:53:46,439
但是如果我们有三个，那就是26种可能性乘以26乘以26，
But if we have three, that's 26 possibilities times 26 times 26,

2405
01:53:46,439 --> 01:53:48,599
通过ZZZ的AAA。
for AAA through ZZZ.

2406
01:53:48,600 --> 01:53:54,540
现在，我的阵列中有17,576个存储桶。
Now we have 17,576 buckets in my array.

2407
01:53:54,539 --> 01:53:57,059
问题不仅仅在于我们正在使用该内存。
And the problem isn't so much that we're using that memory.

2408
01:53:57,060 --> 01:53:58,840
老实说，如果您需要内存，请使用它。
Because honestly, if you need the memory, use it.

2409
01:53:58,840 --> 01:53:59,460
没关系。
That's fine.

2410
01:53:59,460 --> 01:54:01,050
只是把硬件扔在问题上。
Just throw hardware at the problem.

2411
01:54:01,050 --> 01:54:02,940
购买并升级更多内存。
Buy and upgrade more memory.

2412
01:54:02,939 --> 01:54:05,609
但问题是我可能不知道
But the problem is that I probably don't know

2413
01:54:05,609 --> 01:54:11,309
有很多名字以HAA或AZZ开头的人
that many people whose names start with HAA or AZZ

2414
01:54:11,310 --> 01:54:14,700
或字母的这些组合中的任何数量。
or any number of these combinations of letters of the alphabet.

2415
01:54:14,699 --> 01:54:16,764
这些水桶很多都将是空的。
A lot of those buckets are going to be empty.

2416
01:54:16,765 --> 01:54:18,390
但是，它们是否为空并不重要。
But it doesn't matter if they're empty.

2417
01:54:18,390 --> 01:54:22,870
如果您想要一个数组并且想要随机访问，则必须存在它们
If you want an array and you want random access, they have to be present

2418
01:54:22,869 --> 01:54:25,979
这样您的算术就可以每个星期2进行一次计算
so that your arithmetic works out, per Week 2,

2419
01:54:25,979 --> 01:54:27,749
您只使用方括号表示法的地方
where you just use square bracket notation

2420
01:54:27,750 --> 01:54:32,160
并跳转到您关心的内存中的任何位置。
and jump to any of the locations in memory that you care about.

2421
01:54:32,159 --> 01:54:36,059
因此，需要权衡利弊，或者找到与这些交易有关的拐点
So finding that trade off, or finding the inflection point with those trade

2422
01:54:36,060 --> 01:54:39,330
是一种艺术和/或科学，
offs, is kind of an art and/or a science, figuring out

2423
01:54:39,329 --> 01:54:42,329
对于您的特定数据，您的特定应用程序，
for your particular data, your particular application, which

2424
01:54:42,329 --> 01:54:46,989
更重要的是两者之间的时间或空间或某种快乐的媒介。
is more important, time or space or some happy medium in between the two.

2425
01:54:46,989 --> 01:54:49,109
正如问题5所示，您将
And with Problem Set 5, as you'll see, you'll

2426
01:54:49,109 --> 01:54:51,269
实际上必须部分弄清这种平衡
actually have to figure out this balance in part

2427
01:54:51,270 --> 01:54:54,300
通过尝试最终减少您自己的内存使用量
by trying to minimize, ultimately, your own use of memory

2428
01:54:54,300 --> 01:54:56,792
和您自己使用计算机的时间。
and your own use of computers' time.

2429
01:54:56,792 --> 01:54:58,500
但是，实际上，让我指出一点。
But let me point something out, actually.

2430
01:54:58,500 --> 01:55:00,540
直到现在，哈希表的概念
This notion of hash table, which up until now,

2431
01:55:00,539 --> 01:55:03,456
绝对是我们研究过的最复杂的数据结构，
definitely the most sophisticated data structure that we've looked at,

2432
01:55:03,457 --> 01:55:06,380
在某种程度上您已经很熟悉了。
it's kind of familiar to you in some way already.

2433
01:55:06,380 --> 01:55:09,130
这些可能比您在家中拥有的扑克牌还要大。
These are probably larger than the playing cards you have at home.

2434
01:55:09,130 --> 01:55:11,088
但是，如果您曾经玩过一副纸牌，
But if you've ever played with a deck of cards,

2435
01:55:11,087 --> 01:55:14,399
纸牌随机开始，在某些时候您很有可能，
and the cards start out randomly, odds are you've, at some point,

2436
01:55:14,399 --> 01:55:16,439
需要将它们分类以进行一场或另一场比赛。
needed to sort them for one game or another.

2437
01:55:16,439 --> 01:55:18,329
有时您需要彻底洗牌。
Sometimes you need to shuffle them entirely.

2438
01:55:18,329 --> 01:55:20,537
如果您想变得整洁一些，可以对它们进行排序，
If you want to be a little neat, you might sort them,

2439
01:55:20,537 --> 01:55:22,439
不仅是数量，而且是西装。
not just by number, but also by suit.

2440
01:55:22,439 --> 01:55:27,819
因此，心，黑桃，球杆和钻石分为不同的类别。
So hearts and spades and clubs and diamonds into separate categories.

2441
01:55:27,819 --> 01:55:31,049
坦白说，我只是为了隐喻而在此使用此字词。
So honestly, I have this literally here just for the sake of the metaphor.

2442
01:55:31,050 --> 01:55:32,550
我们这里有四个水桶。
We have four buckets here.

2443
01:55:32,550 --> 01:55:36,430
我们已经继续前进，并在那儿预先用铁锹标记它们。
And we've gone ahead and labeled them in advance with spade there.

2444
01:55:36,430 --> 01:55:37,740
这就是一个桶。
So that's one bucket.

2445
01:55:37,739 --> 01:55:41,879
在这里，我们有菱形。
Here we have diamond shape here.

2446
01:55:41,880 --> 01:55:43,920
在这里，我们有-
And here we have--

2447
01:55:43,920 --> 01:55:45,510
[咕RUN]
[GRUNTING]

2448
01:55:45,510 --> 01:55:50,230
-在这里我们有心，然后在这里有俱乐部。
--here we have hearts here and then clubs here.

2449
01:55:50,229 --> 01:55:52,374
因此，如果您曾经整理过一副纸牌，
So if you've ever sorted a deck of cards,

2450
01:55:52,375 --> 01:55:54,750
很有可能您还没有真正考虑过这个问题。
odds are you haven't really thought about this very hard.

2451
01:55:54,750 --> 01:55:55,860
因为它没那么有趣。
Because it's not that interesting.

2452
01:55:55,859 --> 01:55:58,442
您可能会无意识地开始对它们进行布局和排序
You probably mindlessly start laying them out and sorting them

2453
01:55:58,443 --> 01:56:01,140
穿西装，然后按数字。
by suits and then maybe by number.

2454
01:56:01,140 --> 01:56:04,798
但是，如果您这样做了，那么您之前就有了哈希值。
But if you've done that, you have hashed values before.

2455
01:56:04,797 --> 01:56:06,839
如果您看第一张卡片，就会发现，
If you take a look at the first card and you see,

2456
01:56:06,840 --> 01:56:09,540
哦，那是钻石的王牌。
that, oh, it's the ace of diamonds.

2457
01:56:09,539 --> 01:56:12,929
您知道，是的，您最终可能会关心它是钻石，是王牌。
You know, yes, you might care ultimately that it's a diamond, that it's an ace.

2458
01:56:12,930 --> 01:56:18,240
但是现在，我只是将其放入钻石桶中。
But for now, I'm just going to put it, for instance, into the diamond bucket.

2459
01:56:18,239 --> 01:56:19,622
这是这里的两颗钻石。
Here's the two of diamonds here.

2460
01:56:19,622 --> 01:56:21,539
我将其放入钻石桶中。
I'm going to put that into the diamond bucket.

2461
01:56:21,539 --> 01:56:23,649
这是俱乐部的王牌。
Here's the ace of clubs.

2462
01:56:23,649 --> 01:56:25,379
所以我要把它放在这里。
So I'm going to put that over here.

2463
01:56:25,380 --> 01:56:29,970
您可以逐步将一张卡散列在另一张卡上。
And you can just progressively hash one card after the other.

2464
01:56:29,970 --> 01:56:34,260
而且，实际上，散列实际上只是意味着要看一些输入和产生，
And, indeed, hashing really just means to look at some input and produce,

2465
01:56:34,260 --> 01:56:38,070
在这种情况下，一些数字输出会输出类似存储桶0、1、2
in this case, some numeric output that outputs the like bucket 0, 1, 2,

2466
01:56:38,069 --> 01:56:41,009
或3根据该输入的某些特征，
or 3 based on some characteristic of that input,

2467
01:56:41,010 --> 01:56:43,950
像我在这里一样，实际上是否是西装上的西装，
whether it's actually the suit on the card like I'm doing here,

2468
01:56:43,949 --> 01:56:46,949
还是基于这里的字母。
or maybe it's based on the letter of the alphabet here.

2469
01:56:46,949 --> 01:56:48,009
我为什么要这样做呢？
And why am I doing this?

2470
01:56:48,010 --> 01:56:48,510
正确的？
Right?

2471
01:56:48,510 --> 01:56:49,410
我不会做整个事情。
I'm not going to do the whole thing.

2472
01:56:49,409 --> 01:56:52,529
因为52个步骤需要一段时间并且很快就会变得无聊
Because 52 steps is going to take a while and get boring quickly, if not

2473
01:56:52,529 --> 01:56:53,519
已经。
already.

2474
01:56:53,520 --> 01:56:54,750
但是我为什么要这样做呢？
But why am I doing this?

2475
01:56:54,750 --> 01:56:56,189
因为很可能您已经做到了。
Because odds are you've probably done this.

2476
01:56:56,189 --> 01:56:59,369
与实际水桶的戏剧性不同，您可能只是将它们铺好了
Not with the drama of actual buckets, you've probably just kind of laid them

2477
01:56:59,369 --> 01:57:00,202
在你面前
out in front of you.

2478
01:57:00,203 --> 01:57:05,560
但是，如果您确实做到了，那您为什么要这样做呢？
But why have you done that, if that's indeed something you have done?

2479
01:57:05,560 --> 01:57:06,060
是的。
Yeah.

2480
01:57:06,060 --> 01:57:08,340
到索菲亚？
Over to Sophia?

2481
01:57:08,340 --> 01:57:11,520
听众：实际上，我们可能会更快地处理问题，
AUDIENCE: There's a possibility that we could actually get to things faster,

2482
01:57:11,520 --> 01:57:12,990
就像，如果我们知道它是什么桶。
like, if we know what bucket it is.

2483
01:57:12,989 --> 01:57:16,529
我们甚至可以搜索0、1或更少的东西。
We might be able to even search things for, like, 0, 1, or less.

2484
01:57:16,529 --> 01:57:17,759
戴维·马兰：是的。
DAVID MALAN: Yeah.

2485
01:57:17,760 --> 01:57:18,150
听众：类似的东西。
AUDIENCE: Something like that.

2486
01:57:18,149 --> 01:57:18,449
戴维·马兰：是的。
DAVID MALAN: Yeah.

2487
01:57:18,449 --> 01:57:20,324
您开始获得这些优化，对吗？
You start to gain these optimizations, right?

2488
01:57:20,324 --> 01:57:24,359
至少，作为一个人类，老实说，我可以处理四个较小的问题
At least, as a human, honestly, I can process four smaller problems

2489
01:57:24,359 --> 01:57:27,539
比一个更大的问题（即52号问题）容易得多。
just much easier than one bigger problem, that's size 52.

2490
01:57:27,539 --> 01:57:32,237
我可以更快地解决四个13卡问题
I can solve four 13 card problems a little faster, especially

2491
01:57:32,238 --> 01:57:33,780
如果我正在寻找特定的卡片。
if I'm looking for a particular card.

2492
01:57:33,779 --> 01:57:36,369
现在我可以在13张牌中找到它，而不是52张。
Now I can find it among 13 cards instead of 52.

2493
01:57:36,369 --> 01:57:38,309
因此，这里只是一种优化。
So there's just kind of an optimization here.

2494
01:57:38,310 --> 01:57:41,790
因此，您可以将这些卡作为输入，将它们散列到特定的存储桶中，
So you might take as input these cards, hash them into a particular bucket,

2495
01:57:41,789 --> 01:57:43,889
然后继续解决较小的问题。
and then proceed to solve the smaller problem.

2496
01:57:43,890 --> 01:57:46,500
现在，这不是哈希表本身的全部内容。
Now that's not what a hash table itself is all about.

2497
01:57:46,500 --> 01:57:50,580
哈希表是关于存储信息，但存储信息
A hash table is about storing information, but storing information

2498
01:57:50,579 --> 01:57:52,329
以便更快地到达它。
so as to get to it more quickly.

2499
01:57:52,329 --> 01:58:00,389
因此，索菲亚（Sophia）的观点是，如果确实她只是想像钻石般地寻找自己，
So to Sophia's point, if indeed she just wants to find like the ace of diamonds,

2500
01:58:00,390 --> 01:58:03,900
她现在只需要查看一个13大小的问题，
she now only has to look through a 13 sized problem, a linked

2501
01:58:03,899 --> 01:58:09,479
大小为13的列表，而不是数组或大小为52的链表。
list of size 13, if you will, instead of an array or a linked list of size 52.

2502
01:58:09,479 --> 01:58:12,869
因此，哈希表允许您对输入进行存储，如果可以的话，
So a hash table allows you to bucketize your inputs, if you will,

2503
01:58:12,869 --> 01:58:15,479
口语化，并更快地访问数据。
colloquially, and get access to data more quickly.

2504
01:58:15,479 --> 01:58:20,261
不一定要一次完成，一步就可以是两个。
Not necessarily in time one, in one step, it might be two.

2505
01:58:20,261 --> 01:58:20,969
可能是四个。
It might be four.

2506
01:58:20,970 --> 01:58:22,560
这可能是13个步骤。
It might be 13 steps.

2507
01:58:22,560 --> 01:58:25,530
但是通常比您减少步骤
But it's generally fewer steps than if you

2508
01:58:25,529 --> 01:58:29,969
纯粹是线性地，甚至是对数地做某事。
were doing something purely linearly, or even logarithmically.

2509
01:58:29,970 --> 01:58:32,850
理想情况下，您尝试以这种方式选择哈希函数
Ideally, you're trying to pick your hash function in such a way

2510
01:58:32,850 --> 01:58:38,790
通过不使用A到Z来最大程度地减少发生碰撞的元素的数量，
that you minimize the number of elements that collide by using not A through Z,

2511
01:58:38,789 --> 01:58:41,289
但是AA到ZZ等。
but AA through ZZ and so forth.

2512
01:58:41,289 --> 01:58:43,439
因此，让我继续在这里提出一个问题。
So let me go ahead here and ask a question.

2513
01:58:43,439 --> 01:58:45,719
那么，什么是运行时间
What, then, is the running time when it comes

2514
01:58:45,720 --> 01:58:48,180
哈希表的这种数据结构？
to this data structure of a hash table?

2515
01:58:48,180 --> 01:58:52,860
如果要继续在哈希表中搜索，则所有数据
If you want to go ahead and search in a hash table, once all of the data

2516
01:58:52,859 --> 01:58:55,559
在那里，一旦我所有的联系人都在那里，
is in there, once all of my contacts are there,

2517
01:58:55,560 --> 01:59:00,240
给定手机中的n个联系人，您的手机必须执行多少步骤，
how many steps does your phone have to take, given n contacts in your phone,

2518
01:59:00,239 --> 01:59:06,439
找到赫敏，海格或其他人？
to find Hermione or Hagrid or anyone else?

2519
01:59:06,439 --> 01:59:10,569
因此，我再次看到，你们80％的人说的是固定时间，即1的大O。
So I see, again, 80% of you are saying constant time, Big O of 1.

2520
01:59:10,569 --> 01:59:13,479
同样，恒定时间可能意味着一个步骤，两个步骤，四个步骤，
And, again, constant time might mean one step, two steps, four steps,

2521
01:59:13,479 --> 01:59:16,389
但是一些固定的数字，不依赖于n。
but some fixed number, not dependent on n.

2522
01:59:16,390 --> 01:59:19,900
大约有18％的人说线性时间。
18% of you or so are saying linear time.

2523
01:59:19,899 --> 01:59:22,569
我必须承认，你们中的20％
And I have to admit, the 20% of you or so that

2524
01:59:22,569 --> 01:59:29,059
所说的线性时间在技术上，渐近上，数学上都是正确的。
said linear time are technically, asymptotically, mathematically correct.

2525
01:59:29,060 --> 01:59:33,010
在这里，我们开始看到现实世界之间的某种区别
And here we begin to see sort of a distinction between the real world

2526
01:59:33,010 --> 01:59:33,820
和学术界。
and academia.

2527
01:59:33,819 --> 01:59:40,509
所以这里的学者，或者这里的真实世界，真实的程序员
So the academic here, or rather the real world here, the real world programmer

2528
01:59:40,510 --> 01:59:44,590
会说，就像索菲亚所做的那样，很明显，里面有13张卡的水桶
would say, just like Sophia did, obviously, a bucket with 13 cards in it

2529
01:59:44,590 --> 01:59:48,227
绝对比拥有52张卡的更大水桶更好。
is strictly better than one bigger bucket with 52 cards.

2530
01:59:48,226 --> 01:59:49,059
那只是更快。
That is just faster.

2531
01:59:49,060 --> 01:59:52,480
实际上，查找或翻转的速度是它的四倍
It's literally four times as fast to find or to flip

2532
01:59:52,479 --> 01:59:54,819
通过这13张牌，而不是52张。
through those 13 cards instead of 52.

2533
01:59:54,819 --> 01:59:56,769
从客观上讲，这是更快的。
That is objectively faster.

2534
01:59:56,770 --> 02:00:00,670
但是学者会说是的，但是渐近地-渐近地
But the academic would say yes, but asymptotically-- and asymptotically

2535
02:00:00,670 --> 02:00:03,310
这只是一种幻想的说法，因为n变得非常大，
is just a fancy way of saying as n gets really large,

2536
02:00:03,310 --> 02:00:07,510
我不断描述的手形，渐近地
the sort of wave of the hand that I keep describing, asymptotically taking

2537
02:00:07,510 --> 02:00:11,170
13个步骤在技术上是n的大O。
13 steps is technically big O of n.

2538
02:00:11,170 --> 02:00:11,800
为什么？
Why?

2539
02:00:11,800 --> 02:00:15,520
好吧，对于这里的卡片，从技术上来说，它是n除以4。
Well, in the case of the cards here, it's technically n divided by 4.

2540
02:00:15,520 --> 02:00:16,360
是的，那是13岁。
Yes, it's 13.

2541
02:00:16,359 --> 02:00:19,629
但是，如果总共有n张牌，从技术上讲，这个存储桶的大小
But if there's n cards total, technically, the size of this bucket

2542
02:00:19,630 --> 02:00:21,400
最终将被m除以4。
is going to end up being m divided by 4.

2543
02:00:21,399 --> 02:00:24,279
当我们谈论大O和欧米茄时，我们谈论了什么？
And what did we talk about when we talked about Big O and omega?

2544
02:00:24,279 --> 02:00:26,449
好吧，您放弃了低阶条款。
Well, you throw away the lower order terms.

2545
02:00:26,449 --> 02:00:28,809
您摆脱了常数，例如除以4，
You get rid of the constants, like the divide by 4,

2546
02:00:28,810 --> 02:00:31,613
或其他优点。
or the plus something else.

2547
02:00:31,613 --> 02:00:32,530
因此，我们摆脱了这一点。
So we get rid of that.

2548
02:00:32,529 --> 02:00:35,859
从技术上讲，这是一个哈希表搜索。
And it's technically a hash table searching.

2549
02:00:35,859 --> 02:00:38,049
它仍在n的Big O中。
It is still in Big O of n.

2550
02:00:38,050 --> 02:00:41,260
但是在这里，我们再次看到了现实世界之间的对比
But here, again, we see a contrast between the real world

2551
02:00:41,260 --> 02:00:42,640
和理论世界。
and the theoretical world.

2552
02:00:42,640 --> 02:00:44,920
就像，是的，如果您想参加学术辩论，
Like, yes, if you want to get into an academic debate,

2553
02:00:44,920 --> 02:00:46,920
是的，它在技术上仍然与链接相同
yes, it's still technically the same as a linked

2554
02:00:46,920 --> 02:00:49,630
列表或数组，此时您最好只搜索
list or an array, at which point you might as well just search

2555
02:00:49,630 --> 02:00:52,672
从左到右线性变化的东西，无论是数组还是链表。
the thing left to right linearly, whether it's an array or a linked list.

2556
02:00:52,671 --> 02:00:53,289
但是，来吧。
But come on.

2557
02:00:53,289 --> 02:00:55,779
例如，如果您实际上预先对这些值进行哈希处理，
Like, if you actually hash these values in advance,

2558
02:00:55,779 --> 02:01:00,369
并将它们分散到4或26或576个桶中，
and spread them out into 4, or 26, or 576 buckets,

2559
02:01:00,369 --> 02:01:04,352
实际上，挂钟时间会更快。
that is actually going to be faster when it comes to wall clock time.

2560
02:01:04,353 --> 02:01:06,520
因此，当您从字面上看墙上的时钟时，
So when you literally look at the clock on the wall,

2561
02:01:06,520 --> 02:01:09,610
采取索菲娅的方法所花的时间少于采取的时间
less time will pass taking Sophia's approach than taking

2562
02:01:09,609 --> 02:01:12,019
数组或链表方法。
an array or linked list approach.

2563
02:01:12,020 --> 02:01:16,030
所以在这里，那些说n大O的人是正确的。
So here, those of you who said Big O of n are correct.

2564
02:01:16,029 --> 02:01:18,279
但是当涉及到现实世界的编程时，
But when it comes to the real world programming,

2565
02:01:18,279 --> 02:01:21,759
老实说，如果它比实际的n步快，
honestly, if it's faster than actual n steps,

2566
02:01:21,760 --> 02:01:23,950
这很可能是一个净积极的方面。
that may very well be a net positive.

2567
02:01:23,949 --> 02:01:28,429
因此，也许我们应该将重点更多地放在实践上，而有时却要少一些，
And so perhaps we should be focusing more on practice and less, sometimes,

2568
02:01:28,430 --> 02:01:29,680
这些东西的理论。
on the theory of these things.

2569
02:01:29,680 --> 02:01:31,513
确实，这将是挑战。
And indeed that's going to be the challenge.

2570
02:01:31,512 --> 02:01:33,519
我不断提到的问题集5
The Problem Set 5 to which I keep alluding

2571
02:01:33,520 --> 02:01:35,860
会挑战你去实现一个
is going to challenge you to implement one

2572
02:01:35,859 --> 02:01:40,629
这些数据结构中的一个哈希表，包含100,000个英文单词。
of these data structures, a hash table, with 100,000 plus English words.

2573
02:01:40,630 --> 02:01:43,780
简而言之，我们将为您提供一个大文本文件，其中包含
We're going to, in a nutshell, give you a big text file containing

2574
02:01:43,779 --> 02:01:45,259
每行一个英文单词。
one English word per line.

2575
02:01:45,260 --> 02:01:50,140
您的目标之一就是将所有这140,000多个单词加载
And among your goals is going to be to load all of those 140,000 plus words

2576
02:01:50,140 --> 02:01:53,380
使用哈希表进入计算机的内存。
into your computer's memory using a hash table.

2577
02:01:53,380 --> 02:01:56,500
现在，如果您对此简单化，并且您
Now if you are simplistic about it, and you

2578
02:01:56,500 --> 02:01:59,712
使用具有26个存储区（从A到Z）的哈希表，
use a hash table with 26 buckets, A through Z,

2579
02:01:59,712 --> 02:02:01,420
您将发生很多碰撞。
you're going to have a lot of collisions.

2580
02:02:01,420 --> 02:02:04,510
如果有140,000多个英文单词，那么里面有很多单词
If there's 140,000 plus English words, there's a lot of words in there

2581
02:02:04,510 --> 02:02:08,080
以A或B或Z或介于两者之间的任何内容开头。
that start with A, or B, or Z, or anything in between.

2582
02:02:08,079 --> 02:02:11,559
如果您可能随后通过ZZ选择AA，那也许更好，
If you maybe then go with AA through ZZ, maybe that's better,

2583
02:02:11,560 --> 02:02:13,562
或通过ZZZ AAA认证，也许更好。
or AAA through ZZZ, maybe that's better.

2584
02:02:13,561 --> 02:02:15,519
但是到某个时候，您将开始使用
But at some point, you're going to start to use

2585
02:02:15,520 --> 02:02:17,630
太多的内存对您自己没有好处。
too much memory for your own good.

2586
02:02:17,630 --> 02:02:20,260
问题5的挑战之一（可选）
And one of the challenges, optionally, of Problem Set 5,

2587
02:02:20,260 --> 02:02:23,148
将会是一个好玩的挑战您的同学的方式，
is going to be to playfully challenge your classmates whereby,

2588
02:02:23,148 --> 02:02:25,690
如果您选择这样做，则可以运行一个命令，该命令将使您
if you opt into this, you can run a command that will put you

2589
02:02:25,689 --> 02:02:29,649
在大板上，这将在课程的网站上确切显示多少
on the big board which will show on the course's website exactly how much

2590
02:02:29,649 --> 02:02:33,759
或您正在使用多少RAM或内存，以及
or how little RAM or memory you're using, and how little

2591
02:02:33,760 --> 02:02:36,740
或您的代码需要花费多少时间才能运行。
or how much time your code is taking to run.

2592
02:02:36,739 --> 02:02:40,999
因此，我们只是搁置了一些学术上的挥霍之手，说：
And so we just put aside the sort of academic waves of the hand saying,

2593
02:02:41,000 --> 02:02:43,419
好吧，是的，您所有的代码都是n的BigO。
well, yes, all of your code is Big O of n.

2594
02:02:43,420 --> 02:02:49,450
但是n除以4，Sophia的方法在实践中要比n好得多
But n divided by 4, Sophia's approach, is way better in practice than n

2595
02:02:49,449 --> 02:02:50,019
本身。
itself.

2596
02:02:50,020 --> 02:02:51,910
我们将开始梳理二分法
And we'll begin to tease apart the dichotomy

2597
02:02:51,909 --> 02:02:54,309
在这里理论与实践之间。
between theory here and practice.

2598
02:02:54,310 --> 02:02:57,040
但是，这些并不是在内存中分配内容的唯一方法。
But these aren't the only ways to lay things out in memory.

2599
02:02:57,039 --> 02:03:00,729
我们只想向您展示一些其他想法
And we wanted to show you just a few other ideas that come out now

2600
02:03:00,729 --> 02:03:02,559
我们拥有所有这些构件。
that we have all of these building blocks.

2601
02:03:02,560 --> 02:03:06,400
其中之一就是我们要称为特里的数据结构。
One of which is the data structure that we're going to call a trie.

2602
02:03:06,399 --> 02:03:08,409
Trie实际上是单词检索的缩写，
Trie is actually short for the word retrieval,

2603
02:03:08,409 --> 02:03:10,367
即使发音不尽相同。
even though it's not quite pronounced the same.

2604
02:03:10,368 --> 02:03:11,770
也称为前缀树。
It's also known as a prefix tree.

2605
02:03:11,770 --> 02:03:14,170
这是另一种类型的树，通常
And it's a different type of tree that is typically

2606
02:03:14,170 --> 02:03:17,470
用于存储单词或其他更复杂的数据
used to store words, or other more sophisticated pieces of data

2607
02:03:17,470 --> 02:03:19,630
而不只是数字。
instead of just numbers alone.

2608
02:03:19,630 --> 02:03:24,497
因此，特里树实际上是由数组组成的树。
So a trie is actually a tree made up of arrays.

2609
02:03:24,497 --> 02:03:26,080
因此，您可以在此处看到某种模式。
So you can kind of see a pattern here.

2610
02:03:26,079 --> 02:03:29,289
哈希表是链接列表的数组。
A hash table was an array of linked lists.

2611
02:03:29,289 --> 02:03:33,591
特里是一棵树，其每个节点都是一个数组。
A trie is a tree, each of whose nodes is an array.

2612
02:03:33,591 --> 02:03:36,549
因此，在某个时候，计算机科学家开始变得有点创意
So at some point, computer scientists started getting a little creative

2613
02:03:36,550 --> 02:03:38,620
并开始像砸碎一样
and started just, like, literally smashing together

2614
02:03:38,619 --> 02:03:41,619
似乎可以看到不同的数据结构。
different data structures to see what they could come up with, it seems.

2615
02:03:41,619 --> 02:03:44,229
因此，特里开始看起来像这样。
And so a trie begins to look like this.

2616
02:03:44,229 --> 02:03:48,129
但是它具有这种惊人的特性，比理论上的任何东西都要好
But it has this amazing property that's better than anything in theory

2617
02:03:48,130 --> 02:03:49,300
我们以前见过。
we've seen before.

2618
02:03:49,300 --> 02:03:52,300
这是一个尝试中的节点。
Here is one node in a try.

2619
02:03:52,300 --> 02:03:55,540
从某种意义上来说，这是一个节点，就像矩形或正方形一样。
And it's a node in the sense that this would be like a rectangle or square.

2620
02:03:55,539 --> 02:03:59,919
但是在这种情况下，该节点的内部实际上是一个大小为26的数组。
But inside of that node is literally an array of size 26 in this case.

2621
02:03:59,920 --> 02:04:05,640
如果您要表示A到Z，则表示这些位置或存储桶中的每一个。
And each of those locations or buckets, if you will represent A through Z.

2622
02:04:05,640 --> 02:04:09,840
而且我们要做的就是每当我们插入一个单词（例如名称）时，
And what we're going to do is any time we insert a word, like a name,

2623
02:04:09,840 --> 02:04:12,690
像哈利（Harry）或海格（Hagrid）或赫敏（Hermione）或其他任何人，
like Harry, or Hagrid, or Hermione, or anyone else,

2624
02:04:12,689 --> 02:04:17,489
我们将逐步浏览其名称的字母，例如HAGRID，
we are going to walk through the letters of their name, like, H-A-G-R-I-D,

2625
02:04:17,489 --> 02:04:23,339
我们将遵循一系列从一个节点到另一个节点的指针
and we are going to follow a series of pointers from one node to another

2626
02:04:23,340 --> 02:04:23,980
如下。
as follows.

2627
02:04:23,979 --> 02:04:28,559
因此，例如，如果这是A到Z或0到25，则这里是位置H。
So for instance, if this is A through Z, or 0 through 25, here is location H.

2628
02:04:28,560 --> 02:04:33,570
因此，如果目前的目标是插入我们的第一个联系人，
So if the goal at the moment is to insert the first of our contacts,

2629
02:04:33,569 --> 02:04:36,539
例如，哈里，我将首先看
for instance, Harry, I'm going to start by looking

2630
02:04:36,539 --> 02:04:40,289
在第一个节点（树的根）处，查找H位置。
at the first node, the root of the tree, looking up the H location.

2631
02:04:40,289 --> 02:04:43,169
我会想起哈利从这里开始的想法，
And I'm going to kind of make mental note that Harry starts there,

2632
02:04:43,170 --> 02:04:45,000
哈里的H从那里开始。
the H in Harry starts there.

2633
02:04:45,000 --> 02:04:48,120
然后，如果我想在哈里插入A，我是
Then if I want to insert the A in Harry, I'm

2634
02:04:48,119 --> 02:04:53,669
接下来，添加一个代表26个字母的新节点。
going to go ahead and add a new node, representing 26 letters.

2635
02:04:53,670 --> 02:04:57,280
但我要跟踪一个事实，好的，A在这里。
But I'm going to keep track of the fact that, OK, A is here.

2636
02:04:57,279 --> 02:04:59,169
所以现在我将有另一个指针-
So now I'm going to have another pointer--

2637
02:04:59,170 --> 02:05:07,410
哦，很抱歉-不是哈里，首先是海格，是海格。那我刚刚做了什么？
oh, I'm sorry-- not Harry, Hagrid first, H-A-G-R-I-D. So what have I just done?

2638
02:05:07,409 --> 02:05:11,519
特里树又是一棵树，每个树的节点都是一个数组。
A trie, again, is a tree, each of whose nodes is an array.

2639
02:05:11,520 --> 02:05:17,140
这些数组中的每一个都是指向其他节点的指针的数组。
And each of those arrays is an array of pointers to other nodes.

2640
02:05:17,140 --> 02:05:19,920
因此，再次，我们实际上只是在这里将所有内容融合在一起。
So, again, we're really just mashing up everything together here.

2641
02:05:19,920 --> 02:05:21,930
但这是和以前一样的构建基块。
But it's the same building blocks as before.

2642
02:05:21,930 --> 02:05:27,630
该树中的每个节点（从上到下）都是指向其他节点的指针的数组。
Each node in this tree, top to bottom, is an array of pointers to other nodes.

2643
02:05:27,630 --> 02:05:32,370
因此，如果我想检查海格是否在我的联系人中，
And so, if I wanted to check if Hagrid is in my contacts,

2644
02:05:32,369 --> 02:05:35,909
我实际上从第一个节点开始，然后跟随H指针。
I literally start at the first node, and I follow the H pointer.

2645
02:05:35,909 --> 02:05:37,499
然后，我跟随A指针。
I then follow the A pointer.

2646
02:05:37,500 --> 02:05:40,649
然后，我跟随G指针，R指针，I指针。
I then follow the G pointer, the R pointer, the I pointer.

2647
02:05:40,649 --> 02:05:42,479
然后我检查D指针。
And then I check at the D pointer.

2648
02:05:42,479 --> 02:05:46,929
该结构内部是否存在布尔值-下次再说一次，
Is there a Boolean value inside of that structure-- more on that another time,

2649
02:05:46,930 --> 02:05:47,850
可能 -
perhaps--

2650
02:05:47,850 --> 02:05:53,070
只是说，是或否，有人叫HAGRID
that just says, yes or no, there is someone named H-A-G-R-I-D

2651
02:05:53,069 --> 02:05:54,449
在我的联系人中。
in my contacts.

2652
02:05:54,449 --> 02:05:57,214
请注意，目前没有其他字母要注意。
Notice there's no other letters noted at the moment.

2653
02:05:57,215 --> 02:05:58,590
而且没有其他绿色盒子了。
And there's no other green boxes.

2654
02:05:58,590 --> 02:06:01,290
就我们的目的而言，绿色仅表示布尔值。
Green just denotes a Boolean value for our purposes now.

2655
02:06:01,289 --> 02:06:08,189
因此，这意味着没有人叫HAGRIA，RIB或RIC。
So that means there's no one whose name is H-A-G-R-I-A, or R-I-B, or R-I-C.

2656
02:06:08,189 --> 02:06:13,411
我的联系人中只有HAGRID。
It's only H-A-G-R-I-D that exists in my contacts.

2657
02:06:13,412 --> 02:06:14,620
但是请注意接下来会发生什么。
But notice what happens next.

2658
02:06:14,619 --> 02:06:16,979
现在，如果我继续插入哈利，请注意
Now if I go ahead and insert Harry, notice

2659
02:06:16,979 --> 02:06:21,839
哈里和海格里德共享H，A，然后是第三个节点。
that Harry and Hagrid share the H, the A, and then this third node.

2660
02:06:21,840 --> 02:06:24,510
但随后哈利需要遵循不同的指针
But then Harry needs to follow a different pointer

2661
02:06:24,510 --> 02:06:27,120
存放R和Y。注意那里的绿色。
to store the R and the Y. And notice the green there.

2662
02:06:27,119 --> 02:06:29,519
这是数据结构中的一个复选标记，一个布尔值，即
It's sort of a checkmark in the data structure, a Boolean value, that's

2663
02:06:29,520 --> 02:06:30,120
说是。
saying yes.

2664
02:06:30,119 --> 02:06:32,639
在我的上下文中，我有一个叫HARRY的人。
I have someone in my context named H-A-R-R-Y.

2665
02:06:32,640 --> 02:06:37,740
然后，如果我们添加Hermione，则她共享H，然后共享第二个节点。
And then, if we add Hermione, she shares the H, and then also the second node.

2666
02:06:37,739 --> 02:06:42,279
但是Hermione一起需要一些新节点。
But Hermione requires some new nodes all together.

2667
02:06:42,279 --> 02:06:46,949
但是请注意这个关键属性，这种复杂性的原因，
But notice this key property, the reason for this sort of complexity,

2668
02:06:46,949 --> 02:06:50,099
因为这可能是迄今为止我们所见过的最奇怪的结构，
because this is probably the weirdest structure we've seen thus far,

2669
02:06:50,100 --> 02:06:54,060
即使我的电话簿中有十亿个名字，
is that even if I have a billion names in my phone book,

2670
02:06:54,060 --> 02:06:57,930
从根本上讲，我找到海格要走几步？
how many steps literally does it take me to find Hagrid?

2671
02:06:57,930 --> 02:06:58,620
有人吗
Someone?

2672
02:06:58,619 --> 02:07:01,679
随意发短信，如果您喜欢聊天窗口？
Feel free to chime in the text, the chat window if you like?

2673
02:07:01,680 --> 02:07:04,530
即使我的联系人中有十亿个名字，
Even if I have a billion names in my contacts,

2674
02:07:04,529 --> 02:07:07,319
我要检查并检查多少个步骤
how many steps does it take for me to look up and check

2675
02:07:07,319 --> 02:07:09,231
海格在其中吗？
if Hagrid is among them?

2676
02:07:09,231 --> 02:07:10,439
布莱恩：人们说的是六个。
BRIAN: People are saying six.

2677
02:07:10,439 --> 02:07:15,809
戴维·马兰（David MALAN）：六，哈格里德（HAGRID）。如果我有20亿个名字，40亿个名字，
DAVID MALAN: Six, H-A-G-R-I-D. If I have 2 billion names, 4 billion names,

2678
02:07:15,810 --> 02:07:17,130
它需要执行几个步骤？
how many steps does it take?

2679
02:07:17,130 --> 02:07:21,930
6，这就是我们所说的恒定时间，至少恒定时间
6, and this is what we mean by constant time, constant time at least

2680
02:07:21,930 --> 02:07:25,510
数据结构中人类名字的长度。
in the length of the humans' names in the data structure.

2681
02:07:25,510 --> 02:07:26,760
那么这是什么意思？
So what does this mean?

2682
02:07:26,760 --> 02:07:30,450
无论您将多少个名称塞入一个trie数据
No matter how many names you cram into a trie data

2683
02:07:30,449 --> 02:07:34,019
结构，其他名称的数量不
structure, the number of other names does not

2684
02:07:34,020 --> 02:07:38,040
影响我找到Harry，Hagrid或Hermione所需的步骤
impact how many steps it takes for me to find Harry or Hagrid or Hermione

2685
02:07:38,039 --> 02:07:39,359
或其他任何人。
or anyone else.

2686
02:07:39,359 --> 02:07:41,792
它仅取决于其名称的长度。
It is only dependent on the length of their name.

2687
02:07:41,792 --> 02:07:43,709
这是我们可以学到一点的地方。
And here's where we can get a little academic.

2688
02:07:43,710 --> 02:07:46,043
如果您假设字符数有限
If you assume that there's a finite number of characters

2689
02:07:46,042 --> 02:07:50,369
以任何人类，真实或虚构的名字命名，可能是20或100，或者其他。
in any human, real or imaginary's name, maybe it's 20, or 100, or whatever.

2690
02:07:50,369 --> 02:07:52,929
它大于6，但可能少于数百。
It's more than 6, but it's probably fewer than hundreds.

2691
02:07:52,930 --> 02:07:55,030
然后您可以假设那是恒定的。
And then you can assume that that's constant.

2692
02:07:55,029 --> 02:07:57,419
大概是200个字符
So it might be Big O of, like, 200 characters

2693
02:07:57,420 --> 02:07:59,190
对于拥有超长名字的人。
for someone with a super long name.

2694
02:07:59,189 --> 02:08:00,599
但这是不变的。
But that's constant.

2695
02:08:00,600 --> 02:08:05,100
因此，从技术上来说，尝试可以使您获得圣杯
And so technically a try gives you that Holy Grail

2696
02:08:05,100 --> 02:08:09,360
1的Big O的查找时间和插入时间
of look up times and insertion times of Big O of 1.

2697
02:08:09,359 --> 02:08:12,359
因为它不依赖于n，即n
Because it is not dependent on n, which is the number

2698
02:08:12,359 --> 02:08:14,849
数据结构中其他名称的名称。
of other names in the data structure.

2699
02:08:14,850 --> 02:08:18,300
它仅取决于您输入的名称的长度。
It is dependent only on the length of the name you're inputting.

2700
02:08:18,300 --> 02:08:21,630
而且，如果您假设世界上的所有名称都有合理的联系，
And if you assume that all names in the world are reasonably linked,

2701
02:08:21,630 --> 02:08:24,780
小于某个有限值，例如6或200，或任何其他值
less than some finite value, like 6, or 200, or whatever

2702
02:08:24,779 --> 02:08:26,609
是的，那么你可以打电话给它。
it is, then you can call that.

2703
02:08:26,609 --> 02:08:29,579
从技术上讲，它是1的大O。
And it technically is Big O of 1.

2704
02:08:29,579 --> 02:08:32,139
那是恒定的时间。
That is constant time.

2705
02:08:32,140 --> 02:08:36,633
因此，这就是整天的目标，例如，努力达到固定的时间。
So here is the goal of this whole day, like, trying to get to constant time.

2706
02:08:36,632 --> 02:08:38,549
因为固定时间比固定时间好，所以
Because constant time is better than, it would

2707
02:08:38,550 --> 02:08:42,240
似乎是线性时间，还是对数时间，或者我们看到的其他任何时间。
seem, linear time, or logarithmic time, or anything else we've seen.

2708
02:08:42,239 --> 02:08:45,539
但是，但是，但是，再次，总会有一个权衡。
But-- but-- but-- again, there's always a trade off.

2709
02:08:45,539 --> 02:08:49,709
如果您看到了，我们刚刚支付了什么价格？
What price have we just paid if you see it?

2710
02:08:49,710 --> 02:08:55,630
为什么尝试不一定全部如此？
Why are tries not necessarily all that?

2711
02:08:55,630 --> 02:08:57,850
还有一个陷阱。
There's still a catch.

2712
02:08:57,850 --> 02:08:59,230
丹尼尔？
Daniel?

2713
02:08:59,229 --> 02:09:03,009
听众：例如，假设您的联系人列表中有两个人。
AUDIENCE: For example, if let's say you have two people in your contact list.

2714
02:09:03,010 --> 02:09:07,120
一个人叫丹尼尔，一个人叫丹妮尔。
One person was named Daniel and one person was named Danielle.

2715
02:09:07,119 --> 02:09:09,869
而且您知道Daniel在您的清单中。
And you know that Daniel is in your list.

2716
02:09:09,869 --> 02:09:13,359
因此，L的布尔运算符为true。
So the L would have this Boolean operator of true.

2717
02:09:13,359 --> 02:09:17,499
但是，如果您的L是运算符，您将如何前往Danielle
But then, how would you get to Danielle, if your L was an operator

2718
02:09:17,500 --> 02:09:19,629
而且它并没有指向Danielle的另一个L？
and it didn't point to another L for Danielle?

2719
02:09:19,630 --> 02:09:22,213
戴维·马兰（DAVID MALAN）：真的很好的问题，如果可以的话，可以提供一个特例。
DAVID MALAN: Really good question, a corner case, if you will.

2720
02:09:22,212 --> 02:09:26,109
如果某人的名字是另一人的名字的子串怎么办？
What if someone's name is a substring of another person's name?

2721
02:09:26,109 --> 02:09:29,949
Daniel，DANIEL，我想你是说Danielle，
So Daniel, D-A-N-I-E-L, and I think you're saying Danielle,

2722
02:09:29,949 --> 02:09:35,409
丹妮尔所以第二个名字要长一些。
D-A-N-I-E-L-L-E. So the second name is a little longer.

2723
02:09:35,409 --> 02:09:37,209
让我规定我们可以解决这个问题。
Let me stipulate that we can solve that.

2724
02:09:37,210 --> 02:09:40,960
我没有显示代表此树中每个节点的代码。
I have not shown code that represents each of the nodes in this tree.

2725
02:09:40,960 --> 02:09:44,180
让我建议，我们甚至可以在下面继续使用箭头。
Let me propose that we could continue having arrows even below.

2726
02:09:44,180 --> 02:09:46,540
所以如果我们要把丹尼尔放在这棵树上，
So if we were to have Daniel in this tree,

2727
02:09:46,539 --> 02:09:48,579
我们也可以拥有丹妮尔
we could also have Danielle by just having

2728
02:09:48,579 --> 02:09:52,539
Daniel下方还有几个节点，并且还有另一个绿色对勾。
a couple of more nodes below Daniel and just having another green checkmark.

2729
02:09:52,539 --> 02:09:54,849
因此它在代码中是可解决的，即使它不是
So it is solvable in code, even though it's not

2730
02:09:54,850 --> 02:09:57,790
从图形表示中显而易见，但绝对
obvious from the graphical representation, but absolutely

2731
02:09:57,789 --> 02:09:58,509
拐角处的情况。
a corner case.

2732
02:09:58,510 --> 02:10:01,210
但值得庆幸的是，它可以通过尝试解决。
But thankfully, it is solvable in tries.

2733
02:10:01,210 --> 02:10:04,000
但是，另一个缺点是什么呢？
What might another downside be, though, of a trie?

2734
02:10:04,000 --> 02:10:05,739
就像，您确实获得1次BigO。
Like, you do get Big O of 1 time.

2735
02:10:05,739 --> 02:10:08,449
您可以解决Daniel-Danielle问题。
You can solve the Daniel-Danielle problem.

2736
02:10:08,449 --> 02:10:10,194
但是仍然有代价。
But there's still a price being paid.

2737
02:10:13,289 --> 02:10:15,949
有什么想法吗？
Any thoughts?

2738
02:10:15,949 --> 02:10:16,449
是的。
Yeah.

2739
02:10:16,449 --> 02:10:20,284
如果我说对了，那到Ethan怎么样？
How about over to Ethan, if I'm saying it right?

2740
02:10:20,284 --> 02:10:20,909
听众：是的。
AUDIENCE: Yeah.

2741
02:10:20,909 --> 02:10:21,689
我是伊桑
I'm Ethan.

2742
02:10:21,689 --> 02:10:22,481
戴维·马兰（David MALAN）：伊桑。
DAVID MALAN: Ethan.

2743
02:10:22,481 --> 02:10:25,199
听众：我认为这是因为这只会占用大量内存
AUDIENCE: I think it's because it would just take a lot of memory

2744
02:10:25,199 --> 02:10:26,579
容纳所有这些。
to house all of that.

2745
02:10:26,579 --> 02:10:28,409
这可能会花费很多时间。
And that could take a lot of time.

2746
02:10:28,409 --> 02:10:29,789
这可能会减慢系统速度。
It could slow down the system.

2747
02:10:29,789 --> 02:10:30,819
戴维·马兰（David MALAN）：好的。
DAVID MALAN: Exactly.

2748
02:10:30,819 --> 02:10:31,319
是的。
Yeah.

2749
02:10:31,319 --> 02:10:33,194
您可以单从我的照片中看到它。
You can kind of see it from my picture alone.

2750
02:10:33,194 --> 02:10:35,409
我们仅在此数据结构中添加了三个名称。
We only added three names to this data structure.

2751
02:10:35,409 --> 02:10:39,389
但是我的上帝，就像有几十个，也许有一百多个指针
But my God, like, there's dozens, maybe 100 plus pointers

2752
02:10:39,390 --> 02:10:41,830
如图所示，即使它们都可能为null。
pictured here, even though they might all be null.

2753
02:10:41,829 --> 02:10:42,329
正确的？
Right?

2754
02:10:42,329 --> 02:10:46,199
如果此处没有箭头表明它们为空，则为0x0，但即使
If the absence of an arrow here suggests that they're null, 0x0, but even

2755
02:10:46,199 --> 02:10:49,179
存储空值0x0是8 0位。
storing null, 0x0, is 8 0 bits.

2756
02:10:49,180 --> 02:10:52,710
因此，实际的内存使用情况并不缺乏，
So this is not lacking for actual memory usage,

2757
02:10:52,710 --> 02:10:54,960
我们只是没有非常有效地使用它。
we're just not using it very efficiently.

2758
02:10:54,960 --> 02:10:58,650
我们花费了大量的位或字节，
We have spent a huge number of bits, or bytes,

2759
02:10:58,649 --> 02:11:00,569
还是您要测量它。
or however you want to measure it.

2760
02:11:00,569 --> 02:11:04,439
因为看起来，即使使用H，我也使用26中的一个指针。
Because look, even with the H's, I'm using one pointer out of 26.

2761
02:11:04,439 --> 02:11:06,779
25个指针可能已初始化为null，
25 pointers are probably initialized to null,

2762
02:11:06,779 --> 02:11:08,909
这意味着我在浪费25个指针。
which means I'm wasting 25 pointers.

2763
02:11:08,909 --> 02:11:11,549
您可以想像您在这棵树中得到的越低，
And you can imagine the lower and lower you get in this tree,

2764
02:11:11,550 --> 02:11:16,560
甚至以HAGRID开头的名称的可能性也较小。
the less likely there is to be a name that even starts with H-A-G-R-I-D.

2765
02:11:16,560 --> 02:11:18,990
丹尼尔为丹妮尔提出了一个很好的榜样。
Daniel came up with a good example with Danielle.

2766
02:11:18,989 --> 02:11:20,849
但这很少发生。
But that's not going to often happen.

2767
02:11:20,850 --> 02:11:22,940
当然，您在这棵树中的排名较低。
Certainly, the lower you get in this tree.

2768
02:11:22,939 --> 02:11:26,329
因此，正如Ethan所说，您正在浪费大量内存。
So as Ethan says, you're wasting a huge amount of memory.

2769
02:11:26,329 --> 02:11:30,899
所以，是的，您的时间不断增加，但天哪，以什么价格？
So yes, you're gaining constant time look ups, but my God, at what price?

2770
02:11:30,899 --> 02:11:34,679
您可能正在使用兆字节，千兆字节的存储空间。
You might be using megabytes, gigabytes of storage space.

2771
02:11:34,680 --> 02:11:37,200
同样，因为数组最重要的属性
Because, again, the most important property of an array

2772
02:11:37,199 --> 02:11:38,699
都是连续的。
is that it's all contiguous.

2773
02:11:38,699 --> 02:11:40,299
因此，您具有随机访问权限。
And therefore, you have random access.

2774
02:11:40,300 --> 02:11:42,330
但是如果您必须让每个节点都包含
But if you have to have every node containing

2775
02:11:42,329 --> 02:11:45,659
大小为26或其他任何值的数组，您
an array of size 26 or anything else, you

2776
02:11:45,659 --> 02:11:49,959
必须一遍又一遍地花费内存。
have to spend the memory over and over again.

2777
02:11:49,960 --> 02:11:51,210
因此，这也是一个折衷方案。
So there, too, is a trade off.

2778
02:11:51,210 --> 02:11:53,760
虽然这在理论上可能是理想的，但理论上
While this might be theoretically ideal, theory

2779
02:11:53,760 --> 02:11:55,680
不一定意味着练习。
does not necessarily mean practice.

2780
02:11:55,680 --> 02:11:59,400
有时，设计一些效率较低的教科书，
And sometimes, designing something that is textbook less efficient,

2781
02:11:59,399 --> 02:12:01,979
在现实世界中可能实际上更有效。
might actually be more efficient in the real world.

2782
02:12:01,979 --> 02:12:05,732
在问题集5中，在您自己的拼写检查器中，
And in Problem Set 5, in your own spellchecker,

2783
02:12:05,733 --> 02:12:07,650
当您建立这本字典时，我们
when you build up this dictionary that we then

2784
02:12:07,649 --> 02:12:10,439
用于对非常大的文本语料进行拼写检查，
use to spell check very large corpuses of text,

2785
02:12:10,439 --> 02:12:14,309
您将开始自己体验一些现实世界中的权衡吗？
will you begin to experience some of those real world trade offs yourself.

2786
02:12:14,310 --> 02:12:17,400
好吧，我们今天想结束于其他内容
Well, we wanted to end today with a look at what else

2787
02:12:17,399 --> 02:12:19,379
您可以使用这类数据结构
you can do with these kinds of data structures,

2788
02:12:19,380 --> 02:12:21,990
只是让您了解可以在其他地方使用
just to give you a taste of where else you can go with this

2789
02:12:21,989 --> 02:12:23,759
以及您可以解决什么其他类型的问题。
and what other kinds of problems you can solve.

2790
02:12:23,760 --> 02:12:26,135
再一次，到目前为止，我们已经研究了数组，这些数组实际上是
Again, thus far, we've looked at arrays, which are really

2791
02:12:26,135 --> 02:12:27,468
最简单的数据结构。
the simplest of data structures.

2792
02:12:27,467 --> 02:12:29,092
它们本身甚至都不是结构。
And they're not even structures per se.

2793
02:12:29,092 --> 02:12:30,939
这只是连续的内存块。
It's just contiguous blocks of memory.

2794
02:12:30,939 --> 02:12:33,089
然后，我们引入了链表，当然，
We then introduced linked lists, of course,

2795
02:12:33,090 --> 02:12:35,640
你有一个一维数据结构
where you have this one dimensional data structure that

2796
02:12:35,640 --> 02:12:39,120
使您可以将节点和内存拼接在一起，从而实现动态分配。
allows you to stitch together nodes and memory, giving you dynamic allocation.

2797
02:12:39,119 --> 02:12:42,569
如果要取消分配，可以根据需要插入和删除节点，
And if you want deallocation, inserting and deleting nodes if you want,

2798
02:12:42,569 --> 02:12:46,379
然后我们有了树木，这让我们两全其美，
then we had trees, which kind of gives us the best of both worlds,

2799
02:12:46,380 --> 02:12:48,090
数组和链表。
arrays and linked lists.

2800
02:12:48,090 --> 02:12:51,113
但是我们必须花费更多的空间并使用更多的指针。
But we have to spend more space and use more pointers.

2801
02:12:51,113 --> 02:12:53,280
然后，当然，哈希表会合并在一起
Then, of course, hash tables kind of merged together

2802
02:12:53,279 --> 02:12:56,429
其中两个想法，数组和链表。
two of those ideas, arrays and the linked lists.

2803
02:12:56,430 --> 02:12:57,790
那开始运作良好。
And that starts to work well.

2804
02:12:57,789 --> 02:13:00,479
确实，这就是您将使用自己的拼写检查器进行实验的地方。
And indeed, that's what you'll experiment with your own spellchecker.

2805
02:13:00,479 --> 02:13:02,854
但是，当然，这里有尝试，乍一看
But then, of course, there's tries, which at first glance

2806
02:13:02,854 --> 02:13:07,679
似乎比Ethan更好，但并非没有高昂的代价。
seem better, but not without great cost, as Ethan says.

2807
02:13:07,680 --> 02:13:11,220
事实证明，所有这些构建基块都可供您使用，
So it turns out, with all of those building blocks at your disposal,

2808
02:13:11,220 --> 02:13:14,820
您实际上可以将它们用作较低级别的实施细节
you can actually use them as lower level implementation details

2809
02:13:14,819 --> 02:13:16,739
解决更高层次的问题。
to solve higher level problems.

2810
02:13:16,739 --> 02:13:20,399
这就是所谓的抽象数据结构或抽象数据
And this is what are known as abstract data structures, or abstract data

2811
02:13:20,399 --> 02:13:21,059
类型。
types.

2812
02:13:21,060 --> 02:13:24,122
抽象数据结构是一种心理结构
An abstract data structure is kind of a mental structure

2813
02:13:24,122 --> 02:13:26,580
您可以想象，实现一些现实世界中的问题，
that you can imagine, implementing some real world problem,

2814
02:13:26,579 --> 02:13:30,134
通常，这是通过其他一些数据结构实现的。
typically, that's implemented with some other data structure.

2815
02:13:30,135 --> 02:13:32,010
因此，您有点像在此级别上编写代码。
So you're sort of writing code at this level.

2816
02:13:32,010 --> 02:13:34,885
但是您正在考虑最终在此级别上构建的内容。
But you're thinking about what you've built ultimately at this level.

2817
02:13:34,885 --> 02:13:37,710
那是抽象，需要较低级别的实现
And that's abstraction, taking lower level implementation

2818
02:13:37,710 --> 02:13:40,830
细节，为了讨论或问题而简化它们
details, simplifying them for the sake of discussion or problem

2819
02:13:40,829 --> 02:13:42,599
解决更高。
solving higher up.

2820
02:13:42,600 --> 02:13:44,670
那么，这样的数据结构是一种什么呢？
So what's one such data structure?

2821
02:13:44,670 --> 02:13:48,180
队列是一种非常常见的抽象数据结构。
A queue is a very common abstract data structure.

2822
02:13:48,180 --> 02:13:48,855
什么是队列？
What is a queue?

2823
02:13:48,854 --> 02:13:50,812
好吧，那些在英国长大的人
Well, those of you who grew up, say, in Britain

2824
02:13:50,813 --> 02:13:53,040
在存储区外将一条线称为队列。
call a line outside of a store a queue.

2825
02:13:53,039 --> 02:13:54,839
实际上，它就是它得名的地方。
And that's, indeed, where it gets its name.

2826
02:13:54,840 --> 02:13:58,465
队列是具有某些属性的数据结构。
A queue is a data structure that has certain properties.

2827
02:13:58,465 --> 02:14:00,840
因此，如果您站在商店或餐厅外面，
So if you're standing outside of a store or a restaurant,

2828
02:14:00,840 --> 02:14:04,005
在更健康的时期，等待进入的时间通常会排在队列中。
in healthier times, waiting to get in, you're generally in a queue.

2829
02:14:04,005 --> 02:14:05,880
但是队列有一个重要的属性。
But there's an important property of a queue.

2830
02:14:05,880 --> 02:14:08,550
至少，如果您生活在一个公平的社会中，
At least, if you live in a fair society, you'd

2831
02:14:08,550 --> 02:14:11,760
想想如果您是第一个排队的人，
like to think that if you are the first one in line,

2832
02:14:11,760 --> 02:14:13,920
您是第一个脱颖而出的人。
you are the first one to get out of line.

2833
02:14:13,920 --> 02:14:15,750
先进先出。
First in, first out.

2834
02:14:15,750 --> 02:14:18,149
如果您排在第一位，那将有点令人讨厌
It would be kind of obnoxious if you're first in line

2835
02:14:18,149 --> 02:14:21,179
然后他们开始让那些在您后面的人进入您的队列。
and then they start letting people in who are behind you in that queue.

2836
02:14:21,180 --> 02:14:23,880
因此，如果队列实施正确，
So a queue, if it's implemented correctly,

2837
02:14:23,880 --> 02:14:27,630
具有称为先进先出的先进先出属性。
has a property known as FIFO, first in, first out.

2838
02:14:27,630 --> 02:14:30,180
我们人类会认为这只是一个公平的财产。
And we humans would think of that as just a fair property.

2839
02:14:30,180 --> 02:14:33,870
队列通常至少具有两个与之关联的操作，
And a queue generally has two operations associated with it at least,

2840
02:14:33,869 --> 02:14:35,744
入队和出队。
enqueue and dequeue.

2841
02:14:35,744 --> 02:14:36,869
这些只是约定。
Those are just conventions.

2842
02:14:36,869 --> 02:14:40,019
您可以将其称为添加和删除，或插入，删除任何内容。
You could call it add and remove, or insert, delete, whatever.

2843
02:14:40,020 --> 02:14:43,170
但是入队和出队是比较常见的说法。
But enqueue and dequeue are sort of the more common ones to say.

2844
02:14:43,170 --> 02:14:45,120
因此排队意味着您可以走到商店
So enqueuing means you walk up to the store

2845
02:14:45,119 --> 02:14:47,036
然后排队，因为您必须等待。
and you get in line, because you have to wait.

2846
02:14:47,037 --> 02:14:49,755
出队意味着他们已经准备好为您服务或拥有您。
Dequeue means they're ready to serve you or have you.

2847
02:14:49,755 --> 02:14:50,880
这样您就脱颖而出了。
And so you get out of line.

2848
02:14:50,880 --> 02:14:51,780
那是出队。
That's dequeue.

2849
02:14:51,779 --> 02:14:54,119
再说一次，FIFO只是一个花哨的缩写，
And again, FIFO is just a fancy acronym that

2850
02:14:54,119 --> 02:14:59,099
描述了它的关键属性，即先进先出。
describes a key property of that, which is that it's first in, first out.

2851
02:14:59,100 --> 02:15:03,390
那么，您如何实现队列呢？
So how could you implement a queue then?

2852
02:15:03,390 --> 02:15:07,150
好吧，关于该数据结构的有趣之处在于它是抽象的。
Well, what's interesting about that data structure is that it's abstract.

2853
02:15:07,149 --> 02:15:07,649
正确的？
Right?

2854
02:15:07,649 --> 02:15:10,739
它比代码中的实际更多的是想法。
It's more of an idea than an actual thing in code.

2855
02:15:10,739 --> 02:15:14,019
您想实现某种公平的排队系统。
You want to implement some kind of fair queuing system.

2856
02:15:14,020 --> 02:15:15,450
因此，您将其视为一个队列。
And so you think of it as a queue.

2857
02:15:15,449 --> 02:15:18,769
但坦率地说，如果我们要将该示例转换为代码，
But frankly, if we're going to translate that example to code,

2858
02:15:18,770 --> 02:15:21,590
您可以想象使用一系列人员。
you could imagine using an array of persons.

2859
02:15:21,590 --> 02:15:23,450
那可以实现一个队列。
That could implement a queue.

2860
02:15:23,449 --> 02:15:25,174
您可以使用个人的链接列表。
You could use a linked list of persons.

2861
02:15:25,175 --> 02:15:27,050
坦白说，这些方法中的任何一个都将有效。
Frankly, either of those would actually work.

2862
02:15:27,050 --> 02:15:30,470
底层是较低层的实现细节。
Underneath the hood is the lower level implementation details.

2863
02:15:30,470 --> 02:15:33,860
但是，如果我们翻译这个现实世界，那将会是一个问题
But what would be a problem, if we translate this real world

2864
02:15:33,859 --> 02:15:38,809
类比就像在商店外排队进入代码
analogy like queuing up outside of a store to get in, into code

2865
02:15:38,810 --> 02:15:39,830
而您使用了数组？
and you used an array?

2866
02:15:39,829 --> 02:15:42,979
使用数组的缺点是什么
What would a downside be of using an array

2867
02:15:42,979 --> 02:15:48,379
通常来说，代表一个队列，即使我们做出了一些飞跃
to represent a queue, in general, even though we're making a bit of a leap

2868
02:15:48,380 --> 02:15:50,060
从现实世界突然变成代码？
from real world to code suddenly?

2869
02:15:50,060 --> 02:15:52,760
但是可能还有一个缺点。
But there's probably a downside.

2870
02:15:52,760 --> 02:15:56,720
使用数组来实现队列的不利之处是什么，Ryan？
What might a downside be of using an array to implement a queue, Ryan?

2871
02:15:56,720 --> 02:15:59,690
听众：如果您使用数组，则不能
AUDIENCE: If you're using an array, you can't really

2872
02:15:59,689 --> 02:16:03,326
只是拿出现有的价值。
just take out the existing values.

2873
02:16:03,327 --> 02:16:05,660
因为如果您正在考虑这样做，
Because if you were thinking about doing this in a line,

2874
02:16:05,659 --> 02:16:09,499
您将必须取出第一个人，取出第二个人。
you would have to take out the first person, take out the second person.

2875
02:16:09,500 --> 02:16:13,129
但是之后，您将无法真正动态地更改内存。
But you can't really dynamically sort of change the memory after that.

2876
02:16:13,130 --> 02:16:13,910
戴维·马兰：是的。
DAVID MALAN: Yeah.

2877
02:16:13,909 --> 02:16:14,269
是的。
Yeah.

2878
02:16:14,270 --> 02:16:15,180
这是一个很好的观点。
That's a really good point.

2879
02:16:15,180 --> 02:16:15,972
考虑一条线。
Think about a line.

2880
02:16:15,971 --> 02:16:19,327
假设有一条线可以容纳10位苹果商店外的人。
Suppose that there's a line that can fit 10 people outside the Apple store.

2881
02:16:19,328 --> 02:16:22,370
因为苹果现在在健康危机中的表现相当不错
Because Apple's pretty good right now during the health crisis of letting

2882
02:16:22,369 --> 02:16:24,209
一次只能有很多人。
people in only so many at a time.

2883
02:16:24,210 --> 02:16:26,840
因此，假设他们可以容纳10个人，相距六英尺。
So suppose they have room for 10 people, six feet apart.

2884
02:16:26,840 --> 02:16:30,000
这实际上是一个非常恰当的比喻，今年比以往任何时候都多。
That's actually a pretty apt analogy, this year more than ever.

2885
02:16:30,000 --> 02:16:35,480
但正如瑞安（Ryan）所说，如果您想让某人出队，那么第一个排队的人
But as Ryan says, if you want to dequeue someone, then the first person in line

2886
02:16:35,479 --> 02:16:36,769
要去商店。
is going to go into the store.

2887
02:16:36,770 --> 02:16:38,600
然后第二个人，您将使他们出队。
And then the second person, you're going to dequeue them.

2888
02:16:38,600 --> 02:16:40,049
他们走进商店。
They go into the store.

2889
02:16:40,049 --> 02:16:41,840
数组的问题似乎
The problem with an array, it would seem,

2890
02:16:41,840 --> 02:16:44,976
就是说，您现在在行首处基本上有空白。
is that now you have essentially empty spaces at the beginning of the line.

2891
02:16:44,976 --> 02:16:47,809
但是您仍然没有机会在新朋友的行列中腾出空间。
But you still don't have room at the end of the line for new people.

2892
02:16:47,808 --> 02:16:49,850
现在那里有一个显而易见的现实世界解决方案。
Now there's an obvious real world solution there.

2893
02:16:49,851 --> 02:16:52,879
您只是说，嘿，大家，您介意向前迈出几步吗？
You just say, hey, everyone, would you mind taking a few steps forward?

2894
02:16:52,879 --> 02:16:54,139
但这效率低下。
But that's inefficient.

2895
02:16:54,138 --> 02:16:56,846
在人类世界中没有那么多，您必须进入商店。
Not so much in the human world, you've got to get into the store.

2896
02:16:56,846 --> 02:16:58,939
但是在代码中，这就是价值的复制。
But in code, that's copying of values.

2897
02:16:58,940 --> 02:17:03,410
如果两个人只是，您必须将八个值移动两个位置
You have to move, like, eight values two places over if two people were just

2898
02:17:03,409 --> 02:17:04,439
让它进入商店。
let into the store.

2899
02:17:04,440 --> 02:17:07,520
因此，现在您的出队操作为n的BigO。
So now your dequeue operation is Big O of n.

2900
02:17:07,520 --> 02:17:08,990
这并不十分理想。
And that doesn't feel quite ideal.

2901
02:17:08,989 --> 02:17:10,458
如果我们有一点点，我们可以做得更好
And we can do better than that if we're a little

2902
02:17:10,459 --> 02:17:12,440
巧妙地使用一些局部变量等。
clever with some local variables and such.

2903
02:17:12,440 --> 02:17:14,870
但这将是队列的挑战，
But that would be one challenge of a queue,

2904
02:17:14,870 --> 02:17:19,722
当然，这是我们可以使用数组实现的程度。
certainly, is just how well we could implement it using an array.

2905
02:17:19,721 --> 02:17:21,888
因此，您可能也想像到数组也是有限的。
So you might imagine, too, an array is limited, too.

2906
02:17:21,888 --> 02:17:24,589
因为如果您去Apple Store商店，那会有点令人讨厌。
Because it would kind of be obnoxious if you get to the Apple store.

2907
02:17:24,590 --> 02:17:26,100
已经有10个人在排队。
There's already 10 people in line.

2908
02:17:26,100 --> 02:17:27,559
而且他们不允许您排队。
And they don't let you get in line.

2909
02:17:27,558 --> 02:17:30,649
他们说，对不起，我们今天很忙，而显然他们没有。
They say, sorry, we're all full for today, when they're obviously not.

2910
02:17:30,649 --> 02:17:32,899
因为最终队列中会有更多空间。
Because eventually there'll be more room in the queue.

2911
02:17:32,899 --> 02:17:36,208
链接列表将使您能够继续添加越来越多的人。
A linked list would allow you to keep appending more and more people.

2912
02:17:36,209 --> 02:17:38,510
即使店外的电话线变得疯狂了很长时间，
And even if the line outside the store gets crazy long,

2913
02:17:38,510 --> 02:17:41,059
至少链表允许您服务
at least the linked list allows you to service

2914
02:17:41,058 --> 02:17:43,789
随着时间的流逝出现的所有客户。
all of the customers who are showing up over time.

2915
02:17:43,790 --> 02:17:46,400
固定大小的数组将使处理起来更加困难。
An array of fixed size would make that harder.

2916
02:17:46,399 --> 02:17:48,378
同样，您可以分配更大的数组。
And, again, you could allocate a bigger array.

2917
02:17:48,379 --> 02:17:50,090
但是然后您将不得不问所有的顾客，嘿，
But then you're going to have to ask all the customers, hey,

2918
02:17:50,090 --> 02:17:51,340
大家可以过来吗？
could everyone come over here?

2919
02:17:51,340 --> 02:17:51,840
不。
No.

2920
02:17:51,840 --> 02:17:52,730
回到那边。
Go back over there.

2921
02:17:52,729 --> 02:17:57,689
我的意思是，您正在不断地来回移动人类或价值观和记忆。
I mean, you're constantly moving humans, or values and memory, back and forth.

2922
02:17:57,690 --> 02:18:00,320
所以这只是说要实现这个现实世界
So that is only to say that to implement this real world

2923
02:18:00,319 --> 02:18:03,558
队列的概念，即使在计算机中也很常用
notion of a queue, which is very commonly used even in the computer

2924
02:18:03,558 --> 02:18:09,138
代表某些想法的世界，例如打印机队列，当您
world to represent certain ideas, for instance, the printer queue, when you

2925
02:18:09,138 --> 02:18:12,229
向打印机发送一些东西，尤其是在校园或公司中，
send something to the printer, especially on a campus or in a company,

2926
02:18:12,229 --> 02:18:12,951
有一个队列。
there's a queue.

2927
02:18:12,951 --> 02:18:14,659
理想情况下，第一个人
And ideally, the first person who printed

2928
02:18:14,659 --> 02:18:17,239
是第一个获得打印输出的人。
is the first one who gets their printouts thereafter.

2929
02:18:17,239 --> 02:18:19,099
队列也用于软件中。
Queues are also used in software.

2930
02:18:19,100 --> 02:18:22,760
但是除了队列之外，还有其他抽象数据类型。
But there's other abstract data types out there besides queues.

2931
02:18:22,760 --> 02:18:24,379
其中之一称为堆栈。
One of them is called a stack.

2932
02:18:24,379 --> 02:18:27,230
因此，堆栈是一种数据结构，它也可以
So a stack is a data structure that can also

2933
02:18:27,229 --> 02:18:31,458
可以在内部使用数组或链表实现，或者
be implemented underneath the hood using arrays or linked lists or,

2934
02:18:31,459 --> 02:18:32,870
哎呀，也许还有别的。
heck, maybe something else.

2935
02:18:32,870 --> 02:18:35,090
但是堆栈具有不同的属性。
But stacks have a different property.

2936
02:18:35,090 --> 02:18:37,910
它是后进先出。
It's last in, first out.

2937
02:18:37,909 --> 02:18:39,468
后进先出。
Last in, first out.

2938
02:18:39,468 --> 02:18:41,929
因此，如果您考虑自助餐厅中的托盘，
So if you think about the trays in the cafeteria,

2939
02:18:41,930 --> 02:18:46,070
在更健康的时代，每个人都在校园里使用自助餐厅的托盘，
in healthier times when everyone was on campus using trays from a cafeteria,

2940
02:18:46,069 --> 02:18:48,949
您当然会记得，托盘通常会像这样堆叠。
you'll recall, of course, that trays tend to get stacked like this.

2941
02:18:48,950 --> 02:18:56,930
最后一个放在纸叠顶部的纸盘是第一个出来的纸盘。
And the last tray to go on top of the stack is the first one to come out.

2942
02:18:56,930 --> 02:18:59,000
如果你去服装店，你自己的壁橱，
If you go to a clothing store, your own closet,

2943
02:18:59,000 --> 02:19:01,040
如果您不将东西挂在衣架上或放在抽屉里，
if you don't hang things on hangers or put them in drawers,

2944
02:19:01,040 --> 02:19:03,920
但是有点像在这里像所有这些毛衣一样堆放它们，
but kind of stack them, like here, like all of these sweaters,

2945
02:19:03,920 --> 02:19:05,540
这是一堆毛衣。
this is a stack of sweaters.

2946
02:19:05,540 --> 02:19:07,459
我该如何获得一件想要的毛衣？
And how do I get at a sweater I want?

2947
02:19:07,459 --> 02:19:10,879
好吧，最简单的方法是先入先出。
Well, the easiest way to do it is with last in, first out.

2948
02:19:10,879 --> 02:19:13,879
所以我不断拿黑色毛衣，黑色毛衣。
So I constantly take the black sweater, the black sweater.

2949
02:19:13,879 --> 02:19:16,100
但是，如果我将所有毛衣都存储在此堆栈中，
But if I've stored all of my sweaters in this stack,

2950
02:19:16,100 --> 02:19:18,709
您可能永远也不会接触到较低级别的产品，
you may never get to the sort of lower level ones,

2951
02:19:18,709 --> 02:19:22,379
就像红色或蓝色的毛衣一样，这又是因为这种数据结构。
like the red or the blue sweater because, again, of this data structure.

2952
02:19:22,379 --> 02:19:26,660
所以后进先出实际上是财产
So LIFO, last in, first out, is in fact, the property

2953
02:19:26,659 --> 02:19:28,939
用于表征堆栈。
used to characterize stacks.

2954
02:19:28,940 --> 02:19:33,379
根据实际环境，堆栈是有用的还是无效的。
And stacks are useful or not useful, depending on the real world context.

2955
02:19:33,379 --> 02:19:36,170
但是，即使在计算领域，随着时间的流逝，我们也会看到应用程序
But even within computing, we'll see applications over time

2956
02:19:36,170 --> 02:19:38,480
堆栈确实发挥作用的地方。
where stacks indeed come into play.

2957
02:19:38,479 --> 02:19:41,449
这些东西支持的那两个操作通常称为
And those two operations that those things support are generally called

2958
02:19:41,450 --> 02:19:42,740
推和弹出。
push and pop.

2959
02:19:42,739 --> 02:19:46,399
与添加或删除或插入或删除相同，但是使用条款
It's the same thing as add or remove or insert or delete, but the terms of art

2960
02:19:46,399 --> 02:19:51,229
通常是推入和弹出，这是我从堆栈中弹出一个值。
are generally push and pop, where this is me popping a value off of the stack.

2961
02:19:51,229 --> 02:19:54,259
这是我将一个值压入堆栈。
This is me pushing a value onto the stack.

2962
02:19:54,260 --> 02:19:58,520
但是，它又是后进先出，也就是后进先出。
But, again, it's last in, first out, otherwise known as LIFO.

2963
02:19:58,520 --> 02:20:00,410
还有另一种数据结构
And then there's this other data structure

2964
02:20:00,409 --> 02:20:04,739
实际上有一个非常真实的类比，称为字典。
that actually has a very real world analog, known as a dictionary.

2965
02:20:04,739 --> 02:20:07,369
字典是一种抽象的数据类型，
A dictionary is an abstract data type, which

2966
02:20:07,370 --> 02:20:10,370
意味着您可以使用数组，链接列表或哈希表来实现它，
means you can implement it with arrays, or linked lists, or hash tables,

2967
02:20:10,370 --> 02:20:13,280
或尝试，或任何其他方式，抽象数据类型
or tries, or whatever else, an abstract data type

2968
02:20:13,280 --> 02:20:16,130
使您可以将键与值相关联。
that allows you to associate keys with values.

2969
02:20:16,129 --> 02:20:18,559
最好的模拟确实是在现实世界中。
And the best analog here is indeed in the real world.

2970
02:20:18,559 --> 02:20:20,719
什么是字典，就像旧式字典一样
What is a dictionary, like an old school dictionary

2971
02:20:20,719 --> 02:20:23,329
那实际上是以书本形式印在纸上的？
that's actually printed on paper in book form?

2972
02:20:23,329 --> 02:20:25,549
那本书里面有什么？
What is inside that book?

2973
02:20:25,549 --> 02:20:30,379
一堆钥匙，一堆黑体字，例如苹果和香蕉
A whole bunch of keys, a whole bunch of boldfaced words, like apple and banana

2974
02:20:30,379 --> 02:20:35,179
等等，每个都有定义，也称为值。
and so forth, each of which have definitions, otherwise known as values.

2975
02:20:35,180 --> 02:20:37,548
而且通常将它们按字母顺序排列以使其更容易
And they're often alphabetized to make it easier

2976
02:20:37,548 --> 02:20:40,340
为您找到事物，以便您可以更快地查找事物。
for you to find things so that you can look things up more quickly.

2977
02:20:40,340 --> 02:20:45,560
但是字典是将键与值相关联的抽象数据类型。
But a dictionary is an abstract data type that associates keys with values.

2978
02:20:45,559 --> 02:20:48,319
然后，您可以通过它们的键来查找值，
And you look up the values by way of their keys,

2979
02:20:48,319 --> 02:20:53,069
就像您通过单词本身查询单词的定义一样。
just like you look up a word's definition by way of the word itself.

2980
02:20:53,069 --> 02:20:57,317
词典实际上也属于我们所有人。
And dictionaries are actually kind of all around us, too.

2981
02:20:57,317 --> 02:20:59,359
您可能不会在这些方面考虑它们。
You don't think of them in these terms, probably.

2982
02:20:59,360 --> 02:21:02,330
但是，如果您去过例如New Haven的Sweet Green，
But if you've ever been to Sweet Green, for instance, in New Haven

2983
02:21:02,329 --> 02:21:05,059
或在剑桥或其他地方，这是一个沙拉的地方
or in Cambridge or elsewhere, this is a salad place

2984
02:21:05,059 --> 02:21:08,839
尤其是在如今的地方，您可以在线或通过应用程序提前订购
where nowadays, especially, you can order in advance online or on an app

2985
02:21:08,840 --> 02:21:12,920
然后进入商店，从架子上拿起食物。
and then go into the store and pick up your food from a shelf.

2986
02:21:12,920 --> 02:21:16,580
但是架子，他们在剑桥和其他城市在这里做的方式，
But the shelf, the way they do it here in Cambridge and in other cities,

2987
02:21:16,579 --> 02:21:20,764
他们实际上在架子上有字母A，B，C，D，E，
is they actually have letters of the alphabet on the shelves, A, B, C, D, E,

2988
02:21:20,764 --> 02:21:24,499
F，一直到Z。想法是，如果我进去拿沙拉，
F, all the way through Z. The idea being that if I go in to pick up my salad,

2989
02:21:24,500 --> 02:21:27,709
如果布莱恩进去接他，那可能是在D部分
it's probably on the D section, if Brian goes in to pick up his,

2990
02:21:27,709 --> 02:21:30,209
在B部分，依此类推。
it's in the B section, and so forth.

2991
02:21:30,209 --> 02:21:33,679
现在在这里，您也可以想象异常的拐角案例
Now here, too, you can imagine perverse corner cases

2992
02:21:33,680 --> 02:21:37,100
这个数据结构在哪里，这个字典在哪里
where this data structure, this dictionary whereby

2993
02:21:37,100 --> 02:21:40,910
字母映射到值，即人们的沙拉，
letters of the alphabet map to values, which are people's salad,

2994
02:21:40,909 --> 02:21:42,919
不一定是失败的证明。
is not necessarily fail proof.

2995
02:21:42,920 --> 02:21:45,440
你能想到一个反常的情况吗
Can you think of a perverse corner case where

2996
02:21:45,440 --> 02:21:50,060
Sweet Green的极好的，系统的系统实际上崩溃了吗？
Sweet Green's very wonderful, methodical system actually breaks down?

2997
02:21:50,059 --> 02:21:54,639
即使您从未去过Sweet Green，您能想到这里的限制吗？
Can you think of a limitation here, even if you've never been to Sweet Green

2998
02:21:54,639 --> 02:21:58,209
或从未吃过沙拉，这个系统可能会分解
or never eaten a salad, what could break down with this system

2999
02:21:58,209 --> 02:22:02,889
是否要去商店根据您的名字取东西？
if going into a store and picking something up based on your name?

3000
02:22:02,889 --> 02:22:04,069
有什么想法吗？
Any thoughts?

3001
02:22:04,069 --> 02:22:06,069
布莱恩：有人说可能有问题
BRIAN: A few people say there might be a problem

3002
02:22:06,069 --> 02:22:07,729
如果两个人的名字相同。
if two people have the same name.

3003
02:22:07,729 --> 02:22:08,479
戴维·马兰：是的。
DAVID MALAN: Yeah.

3004
02:22:08,479 --> 02:22:11,499
如果两个人的名字相同，那么您就开始堆叠东西。
If two people have the same names, you start to stack things up.

3005
02:22:11,500 --> 02:22:14,666
因此，从字面上看，Sweet Green将开始在另一种沙拉上堆叠另一种沙拉。
So literally, Sweet Green will start stacking one salad on top of the other.

3006
02:22:14,666 --> 02:22:16,624
所以实际上有一个有趣的化身
So there is actually an interesting incarnation

3007
02:22:16,625 --> 02:22:19,220
一种数据类型构建在另一种数据类型之上。
of one data type being built on top of yet another data type.

3008
02:22:19,219 --> 02:22:22,592
因此，所有这些都有点像自定义的Scratch作品，如果您愿意的话，
So, again, all of these are sort of like custom Scratch pieces, if you will,

3009
02:22:22,593 --> 02:22:24,760
我们不断地重组到更多
that we're constantly sort of reassembling into more

3010
02:22:24,760 --> 02:22:26,380
有趣而有力的想法。
interesting and powerful ideas.

3011
02:22:26,379 --> 02:22:29,469
但是在某个时候，如果有很多B名或D名，
But at some point, if there's a lot of B names, or D names,

3012
02:22:29,469 --> 02:22:33,669
或任何字母，我肯定会在这个架子上看到一个有限的高度。
or any letter of the alphabet, I surely see a finite height to this shelf.

3013
02:22:33,670 --> 02:22:37,270
因此，就好像Sweet Green已实施了他们的字典
So it's kind of as though Sweet Green has implemented their dictionary

3014
02:22:37,270 --> 02:22:39,920
使用带有数组的堆栈。
using stacks with arrays.

3015
02:22:39,920 --> 02:22:41,300
因为数组是固定大小的。
Because arrays are fixed size.

3016
02:22:41,299 --> 02:22:45,039
因此，垂直方向肯定只有这么多英寸的空间。
So there's surely only so many inches of space here vertically.

3017
02:22:45,040 --> 02:22:47,000
因此，您可以看到现实世界中的限制。
So you can see a real world limitation.

3018
02:22:47,000 --> 02:22:48,832
那么，如果发生这种情况，Sweet Green会做什么？
So what does Sweet Green do if that happens?

3019
02:22:48,833 --> 02:22:51,880
他们可能只是作弊，将D放在C部分，
They probably just kind of cheat and put the D's in the C section,

3020
02:22:51,879 --> 02:22:53,091
或E部分中的D。
or the D's in the E section.

3021
02:22:53,092 --> 02:22:54,800
像，谁真的在乎现实世界？
Like, who really cares in the real world?

3022
02:22:54,799 --> 02:22:56,966
您的眼睛可能左右左右掠过。
Your eyes are probably going to skim left and right.

3023
02:22:56,967 --> 02:22:59,530
但是从算法上讲，这会使事情变慢。
But algorithmically, that is slowing things down.

3024
02:22:59,530 --> 02:23:02,732
在最坏的情况下，如果您真的迟到拿起沙拉，
And in the worst case, if you're really late to pick up your salad,

3025
02:23:02,731 --> 02:23:04,689
或者，如果Sweet Green真的很受欢迎，并且有
or if Sweet Green is really popular and there's

3026
02:23:04,690 --> 02:23:08,050
架子上有很多沙拉，你的名字叫阿不思，
a huge number of salads on the shelf, your name might be Albus,

3027
02:23:08,049 --> 02:23:11,529
但是您的沙拉可能会在Z部分结束
but your salad might end up way over here in the Z section

3028
02:23:11,530 --> 02:23:12,820
如果他们刚好不在房间里。
if they're just out of room.

3029
02:23:12,819 --> 02:23:16,149
因此，这也是有效的算法决策，
And so that, too, is a valid algorithmic decision,

3030
02:23:16,149 --> 02:23:17,929
在其他地方腾出空间。
to just make room somewhere else.

3031
02:23:17,930 --> 02:23:21,650
但是，同样，在时间和空间之间进行权衡。
But, again, trade offs between time and space.

3032
02:23:21,649 --> 02:23:24,846
因此，由于我们的一些朋友，我们认为我们将以一个音符结尾
And so we thought we'd end on a note, thanks to some friends of ours

3033
02:23:24,846 --> 02:23:27,429
在另一个机构进行了出色的可视化
at another institution who made a wonderful visualization that

3034
02:23:27,430 --> 02:23:31,480
区分了堆栈和队列的这些概念。
distinguished these notions of stacks versus queues.

3035
02:23:31,479 --> 02:23:34,447
这些抽象数据类型（包括堆栈和队列）
Stack and, again, a queue are these abstract data types that

3036
02:23:34,448 --> 02:23:35,990
可以以不同的方式实现。
can be implemented in different ways.

3037
02:23:35,989 --> 02:23:40,419
它们具有不同的属性，每个属性分别为FIFO或LIFO。
They have different properties, each of them respectively FIFO or LIFO.

3038
02:23:40,420 --> 02:23:43,210
例如，这是我们最后时刻的最后一眼
And here, for instance, is a final look in our final moments

3039
02:23:43,209 --> 02:23:47,439
今天在这里一起讨论这些想法如何体现出来，也许
together here today about how these ideas manifest themselves, perhaps

3040
02:23:47,440 --> 02:23:50,170
在现实世界中，与这里的这堆毛衣没什么两样。
in the real world, not unlike this stack of sweaters here.

3041
02:23:50,170 --> 02:23:50,837
[视频回放]
[VIDEO PLAYBACK]

3042
02:23:50,836 --> 02:23:55,219
[音乐播放]
[MUSIC PLAYING]

3043
02:23:55,219 --> 02:23:58,129
-从前，有个叫杰克的家伙。
- Once upon a time, there was a guy named Jack.

3044
02:23:58,129 --> 02:24:01,549
当结交朋友时，杰克没有诀窍。
When it came to making friends, Jack did not have the knack.

3045
02:24:01,549 --> 02:24:04,459
于是杰克去和他认识的最受欢迎的人交谈。
So Jack went to talk to the most popular guy he knew.

3046
02:24:04,459 --> 02:24:07,069
他走到楼，问：“我该怎么办？”
He went up to Lou and asked, "What do I do?"

3047
02:24:07,069 --> 02:24:09,619
楼看到他的朋友真的很沮丧。
Lou saw that his friend was really distressed.

3048
02:24:09,620 --> 02:24:12,180
“好吧，”娄开始道，“只要看看你的衣着如何。
"Well," Lou began, "just look how you're dressed.

3049
02:24:12,180 --> 02:24:14,900
难道你没有别样的衣服吗？”
Don't you have any clothes with a different look?"

3050
02:24:14,899 --> 02:24:15,899
“是的。”杰克说。
"Yes," said Jack.

3051
02:24:15,899 --> 02:24:17,329
“我肯定会的。
"I sure do.

3052
02:24:17,329 --> 02:24:19,589
到我家来，我给你看。”
Come to my house, and I'll show them to you."

3053
02:24:19,590 --> 02:24:20,720
所以他们去了杰克的。
So they went off to Jack's.

3054
02:24:20,719 --> 02:24:23,749
杰克把盒子放到娄的盒子里。
And Jack showed Lou the box where he kept all his shirts

3055
02:24:23,750 --> 02:24:25,489
还有他的裤子和袜子。
and his pants and his socks.

3056
02:24:25,489 --> 02:24:28,519
楼说：“我看你一堆衣服都放了。
Lou said, "I see you have all your clothes in a pile.

3057
02:24:28,520 --> 02:24:31,070
您为什么不偶尔穿一些其他衣服？”
Why don't you wear some others once in a While?"

3058
02:24:31,069 --> 02:24:34,189
杰克说：“好吧，当我脱下衣服和袜子时，
Jack said, "Well, when I remove clothes and socks,

3059
02:24:34,190 --> 02:24:36,980
我洗净并将它们放在盒子里。
I wash them and put them away in the box.

3060
02:24:36,979 --> 02:24:39,409
然后第二天早晨来了，我跳了起来。
Then comes the next morning, and up I hop.

3061
02:24:39,409 --> 02:24:42,619
我去箱子把衣服脱掉。”
I go to the box and get my clothes off the top."

3062
02:24:42,620 --> 02:24:45,320
娄很快意识到杰克的问题。
Lou quickly realized the problem with Jack.

3063
02:24:45,319 --> 02:24:48,289
他把衣服，CDS和书堆放在一堆中。
He kept clothes, CDS, and books in the stack.

3064
02:24:48,290 --> 02:24:50,690
当他伸手去读书或穿衣服时，
When he reached for something to read or to wear,

3065
02:24:50,690 --> 02:24:53,330
他选择了高级书籍或内衣。
he chose top book or underwear.

3066
02:24:53,329 --> 02:24:55,699
然后，当他完成后，他会把它放回原处。
Then, when he was done, he would put it right back.

3067
02:24:55,700 --> 02:24:58,160
它将返回，位于堆栈的顶部。
Back it would go, on top of the stack.

3068
02:24:58,159 --> 02:25:00,679
“我知道解决方法！”娄凯旋说。
"I know the solution!" said a triumphant Lou.

3069
02:25:00,680 --> 02:25:03,290
“您需要学习开始使用队列。”
"You need to learn to start using a queue."

3070
02:25:03,290 --> 02:25:06,050
娄拿起杰克的衣服，把它们挂在壁橱里。
Lou took Jack's clothes and hung them in a closet.

3071
02:25:06,049 --> 02:25:08,899
当他清空箱子时，他就把它扔了。
And when he had emptied the box, he just tossed it.

3072
02:25:08,899 --> 02:25:12,709
然后他说：“现在，杰克，在一天结束时，把衣服放在左边
Then he said, "Now, Jack, at the end of the day, put your clothes on the left

3073
02:25:12,709 --> 02:25:14,249
当你把它们收起来的时候
when you put them away.

3074
02:25:14,250 --> 02:25:16,879
然后明天早晨看到阳光时，
Then tomorrow morning when you see the sunshine, get

3075
02:25:16,879 --> 02:25:19,639
您的衣服从右边开始，从行尾开始。
your clothes from the right, from the end of the line.

3076
02:25:19,639 --> 02:25:22,549
你看不到吗？”楼说，“那太好了。
Don't you see?" said Lou, "it will be so nice.

3077
02:25:22,549 --> 02:25:25,939
在穿两次之前，你会穿一次。”
You'll wear everything once before you wear something twice."

3078
02:25:25,940 --> 02:25:28,850
一切都在他的壁橱和架子上，
And with everything in queues in his closet and shelf,

3079
02:25:28,850 --> 02:25:31,910
杰克开始对自己很确定，谢谢
Jack started to feel quite sure of himself, all thanks

3080
02:25:31,909 --> 02:25:34,236
到娄和他美妙的队列。
to Lou and his wonderful queue.

3081
02:25:34,236 --> 02:25:34,819
[结束播放]
[END PLAYBACK]

3082
02:25:34,819 --> 02:25:35,359
戴维·马兰：好的。
DAVID MALAN: All right.

3083
02:25:35,360 --> 02:25:36,470
CS50就是这样。
That's it for CS50.

3084
02:25:36,469 --> 02:25:38,089
下次见。
We will see you next time.

3085
02:25:38,090 --> 02:25:41,440
[音乐播放]
[MUSIC PLAYING]

